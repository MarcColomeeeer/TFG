[
    {
        "title": "Bottom-up rewriting for words and terms",
        "authors": [
            "Irene Durand",
            "Geraud Senizergues"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  For the whole class of linear term rewriting systems, we define\n\\emph{bottom-up rewriting} which is a restriction of the usual notion of\nrewriting. We show that bottom-up rewriting effectively inverse-preserves\nrecognizability and analyze the complexity of the underlying construction. The\nBottom-Up class (BU) is, by definition, the set of linear systems for which\nevery derivation can be replaced by a bottom-up derivation. Membership to BU\nturns out to be undecidable, we are thus lead to define more restricted\nclasses: the classes SBU(k), k in N of Strongly Bottom-Up(k) systems for which\nwe show that membership is decidable. We define the class of Strongly Bottom-Up\nsystems by SBU = U_{k in \\} SBU(k). We give a polynomial sufficient condition\nfor a system to be in $\\SBU$. The class SBU contains (strictly) several classes\nof systems which were already known to inverse preserve recognizability: the\ninverse left-basic semi-Thue systems (viewed as unary term rewriting systems),\nthe linear growing term rewriting systems, the inverse\nLinear-Finite-Path-Ordering systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0903.2554v2"
    },
    {
        "title": "Fuzzy Chemical Abstract Machines",
        "authors": [
            "Apostolos Syropoulos"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Fuzzy set theory opens new vistas in computability theory and here I show\nthis by defining a new computational metaphor--the fuzzy chemical metaphor.\nThis metaphor is an extension of the chemical metaphor. In particular, I\nintroduce the idea of a state of a system as a solution of fuzzy molecules,\nthat is molecules that are not just different but rather similar, that react\naccording to a set of fuzzy reaction rules. These notions become precise by\nintroducing fuzzy labeled transition systems. Solutions of fuzzy molecules and\nfuzzy reaction rules are used to define the general notion of a fuzzy chemical\nabstract machine, which is a {\\em realization} of the fuzzy chemical metaphor.\nBased on the idea that these machines can be used to describe the operational\nsemantics of process calculi and algebras that include fuzziness as a\nfundamental property, I present a toy calculus that is a fuzzy equivalent of\nthe $\\pi$-calculus.\n",
        "pdf_link": "http://arxiv.org/pdf/0903.3513v1"
    },
    {
        "title": "The equality problem for infinite words generated by primitive morphisms",
        "authors": [
            "Juha Honkala"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study the equality problem for infinite words obtained by iterating\nmorphisms. In particular, we give a practical algorithm to decide whether or\nnot two words generated by primitive morphisms are equal.\n",
        "pdf_link": "http://arxiv.org/pdf/0904.2257v1"
    },
    {
        "title": "State complexity of orthogonal catenation",
        "authors": [
            "Mark Daley",
            "Michael Domaratzki",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A language $L$ is the orthogonal catenation of languages $L_1$ and $L_2$ if\nevery word of $L$ can be written in a unique way as a catenation of a word in\n$L_1$ and a word in $L_2$. We establish a tight bound for the state complexity\nof orthogonal catenation of regular languages. The bound is smaller than the\nbound for arbitrary catenation.\n",
        "pdf_link": "http://arxiv.org/pdf/0904.3366v1"
    },
    {
        "title": "Linear-Space Computation of the Edit-Distance between a String and a\n  Finite Automaton",
        "authors": [
            "Cyril Allauzen",
            "Mehryar Mohri"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The problem of computing the edit-distance between a string and a finite\nautomaton arises in a variety of applications in computational biology, text\nprocessing, and speech recognition. This paper presents linear-space algorithms\nfor computing the edit-distance between a string and an arbitrary weighted\nautomaton over the tropical semiring, or an unambiguous weighted automaton over\nan arbitrary semiring. It also gives an efficient linear-space algorithm for\nfinding an optimal alignment of a string and such a weighted automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/0904.4686v1"
    },
    {
        "title": "Descriptional complexity of bounded context-free languages",
        "authors": [
            "Andreas Malcher",
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Finite-turn pushdown automata (PDA) are investigated concerning their\ndescriptional complexity. It is known that they accept exactly the class of\nultralinear context-free languages. Furthermore, the increase in size when\nconverting arbitrary PDAs accepting ultralinear languages to finite-turn PDAs\ncannot be bounded by any recursive function. The latter phenomenon is known as\nnon-recursive trade-off. In this paper, finite-turn PDAs accepting bounded\nlanguages are considered. First, letter-bounded languages are studied. We prove\nthat in this case the non-recursive trade-off is reduced to a recursive\ntrade-off, more precisely, to an exponential trade-off. A conversion algorithm\nis presented and the optimality of the construction is shown by proving tight\nlower bounds. Furthermore, the question of reducing the number of turns of a\ngiven finite-turn PDA is studied. Again, a conversion algorithm is provided\nwhich shows that in this case the trade-off is at most polynomial. Finally, the\nmore general case of word-bounded languages is investigated. We show how the\nresults obtained for letter-bounded languages can be extended to word-bounded\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/0905.1045v2"
    },
    {
        "title": "Deterministic pushdown automata and unary languages",
        "authors": [
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The simulation of deterministic pushdown automata defined over a one-letter\nalphabet by finite state automata is investigated from a descriptional\ncomplexity point of view. We show that each unary deterministic pushdown\nautomaton of size s can be simulated by a deterministic finite automaton with a\nnumber of states that is exponential in s. We prove that this simulation is\ntight. Furthermore, its cost cannot be reduced even if it is performed by a\ntwo-way nondeterministic automaton. We also prove that there are unary\nlanguages for which deterministic pushdown automata cannot be exponentially\nmore succinct than finite automata. In order to state this result, we\ninvestigate the conversion of deterministic pushdown automata into context-free\ngrammars. We prove that in the unary case the number of variables in the\nresulting grammar is strictly smaller than the number of variables needed in\nthe case of nonunary alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/0905.1248v1"
    },
    {
        "title": "Answers to Questions Formulated in the Paper \"On States Observability in\n  Deterministic Finite Automata\"",
        "authors": [
            "Tomas Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  This paper gives answers to questions formulated as open in the paper \"On\nState Observability in Deterministic Finite Automata\" by A. Mateescu and Gh.\nPaun. Specifically, it demonstrates that for all k >= 2, the families of\nregular languages acceptable by deterministic finite automata with no more than\nk semi-observable states, denoted by Tk, are anti-AFL's, and that the family T1\ndiffers in the closure property under Kleene +.\n",
        "pdf_link": "http://arxiv.org/pdf/0905.4193v1"
    },
    {
        "title": "The cost of being co-Buchi is nonlinear",
        "authors": [
            "Jerzy Marcinkowski",
            "Jakub Michaliszyn"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  It is well known, and easy to see, that not each nondeterministic Buchi\nautomaton on infinite words can be simulated by a nondeterministic co-Buchi\nautomaton. We show that in the cases when such a simulation is possible, the\nnumber of states needed for it can grow nonlinearly. More precisely, we show a\nsequence of - as we believe, simple and elegant - languages which witness the\nexistence of a nondeterministic Buchi automaton with n states, which can be\nsimulated by a nondeterministic co-Buchi automaton, but cannot be simulated by\nany nondeterministic co-Buchi automaton with less than c*n^{7/6} states for\nsome constant c. This improves on the best previously known lower bound of\n3(n-1)/2.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.0072v2"
    },
    {
        "title": "2D cellular automata: dynamics and undecidability",
        "authors": [
            "Enrico Formenti",
            "Alberto Dennunzio",
            "Michael Weiss"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper we introduce the notion of quasi-expansivity for 2D CA and we\nshow that it shares many properties with expansivity (that holds only for 1D\nCA). Similarly, we introduce the notions of quasi-sensitivity and prove that\nthe classical dichotomy theorem holds in this new setting. Moreover, we show a\ntight relation between closingness and openness for 2D CA. Finally, the\nundecidability of closingness property for 2D CA is proved.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.0857v2"
    },
    {
        "title": "On the Representation of Finite Automata",
        "authors": [
            "Rogério Reis",
            "Nelma Moreira",
            "Marco Almeida"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We give an unique string representation, up to isomorphism, for initially\nconnected deterministic finite automata (ICDFAs) with n states over an alphabet\nof k symbols. We show how to generate all these strings for each n and k, and\nhow its enumeration provides an alternative way to obtain the exact number of\nICDFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.2477v1"
    },
    {
        "title": "Detecting patterns in finite regular and context-free languages",
        "authors": [
            "Narad Rampersad",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We consider variations on the following problem: given an NFA M and a pattern\np, does there exist an x in L(M) such that p matches x? We consider the\nrestricted problem where M only accepts a finite language. We also consider the\nvariation where the pattern p is required only to match a factor of x. We show\nthat both of these problems are NP-complete. We also consider the same problems\nfor context-free grammars; in this case the problems become PSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.3220v1"
    },
    {
        "title": "Aspects of enumeration and generation with a string automata\n  representation",
        "authors": [
            "Marco Almeida",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In general, the representation of combinatorial objects is decisive for the\nfeasibility of several enumerative tasks. In this work, we show how a (unique)\nstring representation for (complete) initially-connected deterministic automata\n(ICDFAs) with n states over an alphabet of k symbols can be used for counting,\nexact enumeration, sampling and optimal coding, not only the set of ICDFAs but,\nto some extent, the set of regular languages. An exact generation algorithm can\nbe used to partition the set of ICDFAs in order to parallelize the counting of\nminimal automata (and thus of regular languages). We present also a uniform\nrandom generator for ICDFAs that uses a table of pre-calculated values. Based\non the same table it is also possible to obtain an optimal coding for ICDFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.3853v1"
    },
    {
        "title": "A note on syndeticity, recognizable sets and Cobham's theorem",
        "authors": [
            "M. Rigo",
            "L. Waxweiler"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this note, we give an alternative proof of the following result. Let p, q\n>= 2 be two multiplicatively independent integers. If an infinite set of\nintegers is both p- and q-recognizable, then it is syndetic. Notice that this\nresult is needed in the classical proof of the celebrated Cobham?s theorem.\nTherefore the aim of this paper is to complete [13] and [1] to obtain an\naccessible proof of Cobham?s theorem.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.0624v1"
    },
    {
        "title": "Representing Real Numbers in a Generalized Numeration Systems",
        "authors": [
            "Charlier Emilie",
            "Le Gonidec Marion",
            "Rigo Michel"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We show how to represent an interval of real numbers in an abstract\nnumeration system built on a language that is not necessarily regular. As an\napplication, we consider representations of real numbers using the Dyck\nlanguage. We also show that our framework can be applied to the rational base\nnumeration systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.0942v1"
    },
    {
        "title": "Algebraic properties of structured context-free languages: old\n  approaches and novel developments",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Dino Mandrioli"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The historical research line on the algebraic properties of structured CF\nlanguages initiated by McNaughton's Parenthesis Languages has recently\nattracted much renewed interest with the Balanced Languages, the Visibly\nPushdown Automata languages (VPDA), the Synchronized Languages, and the\nHeight-deterministic ones. Such families preserve to a varying degree the basic\nalgebraic properties of Regular languages: boolean closure, closure under\nreversal, under concatenation, and Kleene star. We prove that the VPDA family\nis strictly contained within the Floyd Grammars (FG) family historically known\nas operator precedence. Languages over the same precedence matrix are known to\nbe closed under boolean operations, and are recognized by a machine whose pop\nor push operations on the stack are purely determined by terminal letters. We\ncharacterize VPDA's as the subclass of FG having a peculiarly structured set of\nprecedence relations, and balanced grammars as a further restricted case. The\nnon-counting invariance property of FG has a direct implication for VPDA too.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.2130v1"
    },
    {
        "title": "Algorithms for Glushkov K-graphs",
        "authors": [
            "Pascal Caron",
            "Marianne Flouret"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The automata arising from the well known conversion of regular expression to\nnon deterministic automata have rather particular transition graphs. We refer\nto them as the Glushkov graphs, to honour his nice expression-to-automaton\nalgorithmic short cut (On a synthesis algorithm for abstract automata, Ukr.\nMatem. Zhurnal, 12(2):147-156, 1960, In Russian). The Glushkov graphs have been\ncharacterized (P. Caron and D. Ziadi, Characterization of Glushkov automata.\nTheoret. Comput. Sci., 233(1-2):75-90, 2000) in terms of simple graph\ntheoretical properties and certain reduction rules. We show how to carry, under\ncertain restrictions, this characterization over to the weighted Glushkov\ngraphs. With the weights in a semiring K, they are defined as the transition\nGlushkov K-graphs of the Weighted Finite Automata (WFA) obtained by the\ngeneralized Glushkov construction (P. Caron and M. Flouret, Glushkov\nconstruction for series: the non commutative case, Internat. J. Comput. Math.,\n80(4):457-472, 2003) from the K-expressions. It works provided that the\nsemiring K is factorial and the K-expressions are in the so called star normal\nform (SNF) of Bruggeman-Klein (Regular expressions into finite automata,\nTheoret. Comput. Sci., 120(2):197-213, 1993) The restriction to the factorial\nsemiring ensures to obtain algorithms. The restriction to the SNF would not be\nnecessary if every K-expressions were equivalent to some with the same litteral\nlength, as it is the case for the boolean semiring B but remains an open\nquestion for a general K.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4296v2"
    },
    {
        "title": "Quotient Complexity of Regular Languages",
        "authors": [
            "Janusz Brzozowski"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The past research on the state complexity of operations on regular languages\nis examined, and a new approach based on an old method (derivatives of regular\nexpressions) is presented. Since state complexity is a property of a language,\nit is appropriate to define it in formal-language terms as the number of\ndistinct quotients of the language, and to call it \"quotient complexity\". The\nproblem of finding the quotient complexity of a language f(K,L) is considered,\nwhere K and L are regular languages and f is a regular operation, for example,\nunion or concatenation. Since quotients can be represented by derivatives, one\ncan find a formula for the typical quotient of f(K,L) in terms of the quotients\nof K and L. To obtain an upper bound on the number of quotients of f(K,L) all\none has to do is count how many such quotients are possible, and this makes\nautomaton constructions unnecessary. The advantages of this point of view are\nillustrated by many examples. Moreover, new general observations are presented\nto help in the estimation of the upper bounds on quotient complexity of regular\noperations.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4547v1"
    },
    {
        "title": "Slowly synchronizing automata with zero and incomplete sets",
        "authors": [
            "E. V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Using combinatorial properties of incomplete sets in a free monoid we\nconstruct a series of n-state deterministic automata with zero whose shortest\nsynchronizing word has length n^2/4+n/2-1.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4576v1"
    },
    {
        "title": "Probabilistic Automata over Infinite Words: Expressiveness, Efficiency,\n  and Decidability",
        "authors": [
            "Christel Baier",
            "Nathalie Bertrand",
            "Marcus Größer"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Probabilistic omega-automata are variants of nondeterministic automata for\ninfinite words where all choices are resolved by probabilistic distributions.\nAcceptance of an infinite input word can be defined in different ways: by\nrequiring that (i) the probability for the accepting runs is positive (probable\nsemantics), or (ii) almost all runs are accepting (almost-sure semantics), or\n(iii) the probability measure of the accepting runs is greater than a certain\nthreshold (threshold semantics). The underlying notion of an accepting run can\nbe defined as for standard omega-automata by means of a Buechi condition or\nother acceptance conditions, e.g., Rabin or Streett conditions. In this paper,\nwe put the main focus on the probable semantics and provide a summary of the\nfundamental properties of probabilistic omega-automata concerning\nexpressiveness, efficiency, and decision problems.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4760v1"
    },
    {
        "title": "Mutation of Directed Graphs -- Corresponding Regular Expressions and\n  Complexity of Their Generation",
        "authors": [
            "Fevzi Belli",
            "Mutlu Beyazit"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Directed graphs (DG), interpreted as state transition diagrams, are\ntraditionally used to represent finite-state automata (FSA). In the context of\nformal languages, both FSA and regular expressions (RE) are equivalent in that\nthey accept and generate, respectively, type-3 (regular) languages. Based on\nour previous work, this paper analyzes effects of graph manipulations on\ncorresponding RE. In this present, starting stage we assume that the DG under\nconsideration contains no cycles. Graph manipulation is performed by deleting\nor inserting of nodes or arcs. Combined and/or multiple application of these\nbasic operators enable a great variety of transformations of DG (and\ncorresponding RE) that can be seen as mutants of the original DG (and\ncorresponding RE). DG are popular for modeling complex systems; however they\neasily become intractable if the system under consideration is complex and/or\nlarge. In such situations, we propose to switch to corresponding RE in order to\nbenefit from their compact format for modeling and algebraic operations for\nanalysis. The results of the study are of great potential interest to mutation\ntesting.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5055v1"
    },
    {
        "title": "Testing the Equivalence of Regular Languages",
        "authors": [
            "Marco Almeida",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The minimal deterministic finite automaton is generally used to determine\nregular languages equality. Antimirov and Mosses proposed a rewrite system for\ndeciding regular expressions equivalence of which Almeida et al. presented an\nimproved variant. Hopcroft and Karp proposed an almost linear algorithm for\ntesting the equivalence of two deterministic finite automata that avoids\nminimisation. In this paper we improve the best-case running time, present an\nextension of this algorithm to non-deterministic finite automata, and establish\na relationship between this algorithm and the one proposed in Almeida et al. We\nalso present some experimental comparative results. All these algorithms are\nclosely related with the recent coalgebraic approach to automata proposed by\nRutten.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5058v1"
    },
    {
        "title": "Nondeterministic State Complexity of Positional Addition",
        "authors": [
            "Galina Jirásková",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Consider nondeterministic finite automata recognizing base-k positional\nnotation of numbers. Assume that numbers are read starting from their least\nsignificant digits. It is proved that if two sets of numbers S and T are\nrepresented by nondeterministic automata of m and n states, respectively, then\ntheir sum {s+t | s in S, t in T} is represented by a nondeterministic automaton\nwith 2mn+2m+2n+1 states. Moreover, this number of states is necessary in the\nworst case for all k>=9.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5072v1"
    },
    {
        "title": "On the Number of Membranes in Unary P Systems",
        "authors": [
            "Rudolf Freund",
            "Andreas Klein",
            "Martin Kutrib"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We consider P systems with a linear membrane structure working on objects\nover a unary alphabet using sets of rules resembling homomorphisms. Such a\nrestricted variant of P systems allows for a unique minimal representation of\nthe generated unary language and in that way for an effective solution of the\nequivalence problem. Moreover, we examine the descriptional complexity of unary\nP systems with respect to the number of membranes.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5120v1"
    },
    {
        "title": "On Languages Accepted by P/T Systems Composed of joins",
        "authors": [
            "Pierluigi Frisco",
            "Oscar H. Ibarra"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Recently, some studies linked the computational power of abstract computing\nsystems based on multiset rewriting to models of Petri nets and the computation\npower of these nets to their topology. In turn, the computational power of\nthese abstract computing devices can be understood by just looking at their\ntopology, that is, information flow.\n  Here we continue this line of research introducing J languages and proving\nthat they can be accepted by place/transition systems whose underlying net is\ncomposed only of joins. Moreover, we investigate how J languages relate to\nother families of formal languages. In particular, we show that every J\nlanguage can be accepted by a log n space-bounded non-deterministic Turing\nmachine with a one-way read-only input. We also show that every J language has\na semilinear Parikh map and that J languages and context-free languages (CFLs)\nare incomparable.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5121v1"
    },
    {
        "title": "State Complexity Approximation",
        "authors": [
            "Yuan Gao",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper, we introduce the new concept of state complexity\napproximation, which is a further development of state complexity estimation.\nWe show that this new concept is useful in both of the following two cases: the\nexact state complexities are not known and the state complexities have been\nobtained but are in incomprehensible form.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5124v1"
    },
    {
        "title": "Translation from Classical Two-Way Automata to Pebble Two-Way Automata",
        "authors": [
            "Viliam Geffert",
            "Lubomíra Ištoňová"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study the relation between the standard two-way automata and more powerful\ndevices, namely, two-way finite automata with an additional \"pebble\" movable\nalong the input tape. Similarly as in the case of the classical two-way\nmachines, it is not known whether there exists a polynomial trade-off, in the\nnumber of states, between the nondeterministic and deterministic pebble two-way\nautomata. However, we show that these two machine models are not independent:\nif there exists a polynomial trade-off for the classical two-way automata, then\nthere must also exist a polynomial trade-off for the pebble two-way automata.\nThus, we have an upward collapse (or a downward separation) from the classical\ntwo-way automata to more powerful pebble automata, still staying within the\nclass of regular languages. The same upward collapse holds for complementation\nof nondeterministic two-way machines.\n  These results are obtained by showing that each pebble machine can be, by\nusing suitable inputs, simulated by a classical two-way automaton with a linear\nnumber of states (and vice versa), despite the existing exponential blow-up\nbetween the classical and pebble two-way machines.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5127v1"
    },
    {
        "title": "Descriptional Complexity of Three-Nonterminal Scattered Context\n  Grammars: An Improvement",
        "authors": [
            "Tomáš Masopust",
            "Alexander Meduna"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Recently, it has been shown that every recursively enumerable language can be\ngenerated by a scattered context grammar with no more than three nonterminals.\nHowever, in that construction, the maximal number of nonterminals\nsimultaneously rewritten during a derivation step depends on many factors, such\nas the cardinality of the alphabet of the generated language and the structure\nof the generated language itself. This paper improves the result by showing\nthat the maximal number of nonterminals simultaneously rewritten during any\nderivation step can be limited by a small constant regardless of other factors.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5132v1"
    },
    {
        "title": "Capacity Bounded Grammars and Petri Nets",
        "authors": [
            "Ralf Stiebe",
            "Sherzod Turaev"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A capacity bounded grammar is a grammar whose derivations are restricted by\nassigning a bound to the number of every nonterminal symbol in the sentential\nforms. In the paper the generative power and closure properties of capacity\nbounded grammars and their Petri net controlled counterparts are investigated.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5136v1"
    },
    {
        "title": "Localization dynamics in a binary two-dimensional cellular automaton:\n  the Diffusion Rule",
        "authors": [
            "Genaro J. Martinez",
            "Andrew Adamatzky",
            "Harold V. McIntosh"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study a two-dimensional cellular automaton (CA), called Diffusion Rule\n(DR), which exhibits diffusion-like dynamics of propagating patterns. In\ncomputational experiments we discover a wide range of mobile and stationary\nlocalizations (gliders, oscillators, glider guns, puffer trains, etc), analyze\nspatio-temporal dynamics of collisions between localizations, and discuss\npossible applications in unconventional computing.\n",
        "pdf_link": "http://arxiv.org/pdf/0908.0828v1"
    },
    {
        "title": "Operating binary strings using gliders and eaters in reaction-diffusion\n  cellular automaton",
        "authors": [
            "Andrew Adamatzky",
            "Genaro Martinez",
            "Liang Zhang",
            "Andrew Wuensche"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study transformations of 2-, 4- and 6-bit numbers in interactions between\ntraveling and stationary localizations in the Spiral Rule reaction-diffusion\ncellular automaton. The Spiral Rule automaton is a hexagonal ternary-state\ntwo-dimensional cellular automaton -- a finite-state machine imitation of an\nactivator-inhibitor reaction-diffusion system. The activator is self-inhibited\nin certain concentrations. The inhibitor dissociates in the absence of the\nactivator. The Spiral Rule cellular automaton has rich spatio-temporal dynamics\nof traveling (glider) and stationary (eater) patterns. When a glider brushes an\neater the eater may slightly change its configuration, which is updated once\nmore every next hit. We encode binary strings in the states of eaters and\nsequences of gliders. We study what types of binary compositions of binary\nstrings are implementable by sequences of gliders brushing an eater. The models\ndeveloped will be used in future laboratory designs of reaction-diffusion\nchemical computers.\n",
        "pdf_link": "http://arxiv.org/pdf/0908.0853v1"
    },
    {
        "title": "Quotient complexity of ideal languages",
        "authors": [
            "J. Brzozowski",
            "G. Jirásková",
            "B. Li"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study the state complexity of regular operations in the class of ideal\nlanguages. A language L over an alphabet Sigma is a right (left) ideal if it\nsatisfies L = L Sigma* (L = Sigma* L). It is a two-sided ideal if L = Sigma* L\nSigma *, and an all-sided ideal if it is the shuffle of Sigma* with L. We\nprefer the term \"quotient complexity\" instead of \"state complexity\", and we use\nderivatives to calculate upper bounds on quotient complexity, whenever it is\nconvenient. We find tight upper bounds on the quotient complexity of each type\nof ideal language in terms of the complexity of an arbitrary generator and of\nits minimal generator, the complexity of the minimal generator, and also on the\noperations union, intersection, set difference, symmetric difference,\nconcatenation, star and reversal of ideal languages.\n",
        "pdf_link": "http://arxiv.org/pdf/0908.2083v1"
    },
    {
        "title": "Exact generation of acyclic deterministic finite automata",
        "authors": [
            "Marco Almeida",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We give a canonical representation for trim acyclic deterministic finite\nautomata (Adfa) with n states over an alphabet of k symbols. Using this normal\nform, we present a backtracking algorithm for the exact generation of Adfas.\nThis algorithm is a non trivial adaptation of the algorithm for the exact\ngeneration of minimal acyclic deterministic finite automata, presented by\nAlmeida et al.\n",
        "pdf_link": "http://arxiv.org/pdf/0908.3315v1"
    },
    {
        "title": "On Continuous Weighted Finite Automata",
        "authors": [
            "Jarkko Kari",
            "Alexandr Kazda",
            "Paula Steinby"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We investigate the continuity of the \\omega-functions and real functions\ndefined by weighted finite automata (WFA). We concentrate on the case of\naverage preserving WFA. We show that every continuous \\omega-function definable\nby some WFA can be defined by an average preserving WFA and then characterize\nminimal average preserving WFA whose \\omega-function or \\omega-function and\nreal function are continuous.\n  We obtain several algorithmic reductions for WFA-related decision problems.\nIn particular, we show that deciding whether the \\omega-function and real\nfunction of an average preserving WFA are both continuous is computationally\nequivalent to deciding stability of a set of matrices.\n  We also present a method for constructing WFA that compute continuous real\nfunctions.\n",
        "pdf_link": "http://arxiv.org/pdf/0908.3784v1"
    },
    {
        "title": "On Carpi and Alessandro conjecture",
        "authors": [
            "M. V. Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The well known open \\v{C}ern\\'y conjecture states that each \\san with $n$\nstates has a \\sw of length at most $(n-1)^2$. On the other hand, the best known\nupper bound is cubic of $n$. Recently, in the paper \\cite{CARPI1} of Alessandro\nand Carpi, the authors introduced the new notion of strongly transitivity for\nautomata and conjectured that this property with a help of \\emph{Extension}\nmethod allows to get a quadratic upper bound for the length of the shortest\n\\sws. They also confirmed this conjecture for circular automata. We disprove\nthis conjecture and the long-standing \\emph{Extension} conjecture too. We also\nconsider the widely used Extension method and its perspectives.\n",
        "pdf_link": "http://arxiv.org/pdf/0909.3790v2"
    },
    {
        "title": "The averaging trick and the Cerny conjecture",
        "authors": [
            "Benjamin Steinberg"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The results of several papers concerning the \\v{C}ern\\'y conjecture are\ndeduced as consequences of a simple idea that I call the averaging trick. This\nidea is implicitly used in the literature, but no attempt was made to formalize\nthe proof scheme axiomatically. Instead, authors axiomatized classes of\nautomata to which it applies.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.0410v3"
    },
    {
        "title": "Length of the Shortest Word in the Intersection of Regular Languages",
        "authors": [
            "Thomas Ang",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this note, we give a construction that provides a tight lower bound of\nmn-1 for the length of the shortest word in the intersection of two regular\nlanguages with state complexities m and n.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.1528v1"
    },
    {
        "title": "A unifying approach to picture grammars",
        "authors": [
            "Matteo Pradella",
            "Alessandra Cherubini",
            "Stefano Crespi Reghizzi"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Several old and recent classes of picture grammars, that variously extend\ncontext-free string grammars in two dimensions, are based on rules that rewrite\narrays of pixels. Such grammars can be unified and extended using a tiling\nbased approach, whereby the right part of a rule is formalized by means of a\nfinite set of permitted tiles. We focus on a simple type of tiling,named\nregional, and define the corresponding regional tile grammars. They include\nboth Siromoney's (or Matz's) Kolam grammars and their generalization by Prusa,\nas well as Drewes's grid grammars. Regionally defined pictures can be\nrecognized with polynomial-time complexity by an algorithm extending the CKY\none for strings. Regional tile grammars and languages are strictly included\ninto our previous tile grammars and languages, and are incomparable with\nGiammarresi-Restivo tiling systems (or Wang systems).\n",
        "pdf_link": "http://arxiv.org/pdf/0910.2829v3"
    },
    {
        "title": "Automata and Reduced Words in the Free Group",
        "authors": [
            "Thomas Ang",
            "Giovanni Pighizzini",
            "Narad Rampersad",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We consider some questions about formal languages that arise when inverses of\nletters, words and languages are defined. The reduced representation of a\nlanguage over the free monoid is its unique equivalent representation in the\nfree group. We show that the class of regular languages is closed under taking\nthe reduced representation, while the class of context-free languages is not.\nWe also give an upper bound on the state complexity of the reduced\nrepresentation of a regular language, and prove upper and lower bounds on the\nlength of the shortest reducible string in a regular language. Finally we show\nthat the set of all words which are equivalent to the words in a regular\nlanguage can be nonregular, and that regular languages are not closed under\ntaking a generalized form of the reduced representation.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.4555v1"
    },
    {
        "title": "On Pebble Automata for Data Languages with Decidable Emptiness Problem",
        "authors": [
            "Tony Tan"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper we study a subclass of pebble automata (PA) for data languages\nfor which the emptiness problem is decidable. Namely, we introduce the\nso-called top view weak PA. Roughly speaking, top view weak PA are weak PA\nwhere the equality test is performed only between the data values seen by the\ntwo most recently placed pebbles. The emptiness problem for this model is\ndecidable. We also show that it is robust: alternating, nondeterministic and\ndeterministic top view weak PA have the same recognition power. Moreover, this\nmodel is strong enough to accept all data languages expressible in Linear\nTemporal Logic with the future-time operators, augmented with one register\nfreeze quantifier.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.5844v1"
    },
    {
        "title": "Circular Languages Generated by Complete Splicing Systems and Pure\n  Unitary Languages",
        "authors": [
            "Paola Bonizzoni",
            "Clelia De Felice",
            "Rosalba Zizza"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Circular splicing systems are a formal model of a generative mechanism of\ncircular words, inspired by a recombinant behaviour of circular DNA. Some\nunanswered questions are related to the computational power of such systems,\nand finding a characterization of the class of circular languages generated by\ncircular splicing systems is still an open problem. In this paper we solve this\nproblem for complete systems, which are special finite circular splicing\nsystems. We show that a circular language L is generated by a complete system\nif and only if the set Lin(L) of all words corresponding to L is a pure unitary\nlanguage generated by a set closed under the conjugacy relation. The class of\npure unitary languages was introduced by A. Ehrenfeucht, D. Haussler, G.\nRozenberg in 1983, as a subclass of the class of context-free languages,\ntogether with a characterization of regular pure unitary languages by means of\na decidable property. As a direct consequence, we characterize (regular)\ncircular languages generated by complete systems. We can also decide whether\nthe language generated by a complete system is regular. Finally, we point out\nthat complete systems have the same computational power as finite simple\nsystems, an easy type of circular splicing system defined in the literature\nfrom the very beginning, when only one rule is allowed. From our results on\ncomplete systems, it follows that finite simple systems generate a class of\ncontext-free languages containing non-regular languages, showing the\nincorrectness of a longstanding result on simple systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0911.2320v1"
    },
    {
        "title": "Quotient Complexity of Closed Languages",
        "authors": [
            "J. Brzozowski",
            "G. Jirásková",
            "C. Zou"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A language L is prefix-closed if, whenever a word w is in L, then every\nprefix of w is also in L. We define suffix-, factor-, and subword-closed\nlanguages in the same way, where by subword we mean subsequence. We study the\nquotient complexity (usually called state complexity) of operations on prefix-,\nsuffix-, factor-, and subword-closed languages. We find tight upper bounds on\nthe complexity of the prefix-, suffix-, factor-, and subword-closure of\narbitrary languages, and on the complexity of boolean operations,\nconcatenation, star and reversal in each of the four classes of closed\nlanguages. We show that repeated application of positive closure and complement\nto a closed language results in at most four distinct languages, while Kleene\nclosure and complement gives at most eight languages.\n",
        "pdf_link": "http://arxiv.org/pdf/0912.1034v1"
    },
    {
        "title": "Integer Reset Timed Automata: Clock Reduction and Determinizability",
        "authors": [
            "Lakshmi Manasa",
            "Krishna. S"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we propose a procedure that given an integer reset timed\nautomaton (IRTA) ${\\cal A}$, produces a language equivalent deterministic one\nclock IRTA ${\\cal B}$ whose size is at most doubly exponential in the size of\n${\\cal A}$. We prove that this bound on the number of locations is tight.\nFurther, if integer resets are used in stopwatch automata, a subclass of\nstopwatch automata which is closed under all boolean operations and for which\nreachability is decidable is obtained.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.1215v1"
    },
    {
        "title": "Toward a Compositional Theory of Leftist Grammars and Transformations",
        "authors": [
            "Pierre Chambart",
            "Philippe Schnoebelen"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Leftist grammars [Motwani et al., STOC 2000] are special semi-Thue systems\nwhere symbols can only insert or erase to their left. We develop a theory of\nleftist grammars seen as word transformers as a tool toward rigorous analyses\nof their computational power. Our main contributions in this first paper are\n(1) constructions proving that leftist transformations are closed under\ncompositions and transitive closures, and (2) a proof that bounded reachability\nis NP-complete even for leftist grammars with acyclic rules.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.5047v1"
    },
    {
        "title": "Bulking II: Classifications of Cellular Automata",
        "authors": [
            "Marianne Delorme",
            "Jacques Mazoyer",
            "Nicolas Ollinger",
            "Guillaume Theyssier"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper is the second part of a series of two papers dealing with bulking:\na way to define quasi-order on cellular automata by comparing space-time\ndiagrams up to rescaling. In the present paper, we introduce three notions of\nsimulation between cellular automata and study the quasi-order structures\ninduced by these simulation relations on the whole set of cellular automata.\nVarious aspects of these quasi-orders are considered (induced equivalence\nrelations, maximum elements, induced orders, etc) providing several formal\ntools allowing to classify cellular automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.5471v2"
    },
    {
        "title": "On Functionality of Visibly Pushdown Transducers",
        "authors": [
            "Emmanuel Filiot",
            "Jean-François Raskin",
            "Pierre-Alain Reynier",
            "Frédéric Servais",
            "Jean-Marc Talbot"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Visibly pushdown transducers form a subclass of pushdown transducers that\n(strictly) extends finite state transducers with a stack. Like visibly pushdown\nautomata, the input symbols determine the stack operations. In this paper, we\nprove that functionality is decidable in PSpace for visibly pushdown\ntransducers. The proof is done via a pumping argument: if a word with two\noutputs has a sufficiently large nesting depth, there exists a nested word with\ntwo outputs whose nesting depth is strictly smaller. The proof uses technics of\nword combinatorics. As a consequence of decidability of functionality, we also\nshow that equivalence of functional visibly pushdown transducers is\nExptime-Complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.1443v1"
    },
    {
        "title": "Algebraic Linear Orderings",
        "authors": [
            "Stephen L. Bloom",
            "Zoltan Esik"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  An algebraic linear ordering is a component of the initial solution of a\nfirst-order recursion scheme over the continuous categorical algebra of\ncountable linear orderings equipped with the sum operation and the constant 1.\nDue to a general Mezei-Wright type result, algebraic linear orderings are\nexactly those isomorphic to the linear ordering of the leaves of an algebraic\ntree. Using Courcelle's characterization of algebraic trees, we obtain the fact\nthat a linear ordering is algebraic if and only if it can be represented as the\nlexicographic ordering of a deterministic context-free language. When the\nalgebraic linear ordering is a well-ordering, its order type is an algebraic\nordinal. We prove that the Hausdorff rank of any scattered algebraic linear\nordering is less than $\\omega^\\omega$. It follows that the algebraic ordinals\nare exactly those less than $\\omega^{\\omega^\\omega}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.1624v2"
    },
    {
        "title": "On the Minimal Uncompletable Word Problem",
        "authors": [
            "Gabriele Fici",
            "Elena V. Pribavkina",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Let S be a finite set of words over an alphabet Sigma. The set S is said to\nbe complete if every word w over the alphabet Sigma is a factor of some element\nof S*, i.e. w belongs to Fact(S*). Otherwise if S is not complete, we are\ninterested in finding bounds on the minimal length of words in Sigma* which are\nnot elements of Fact(S*) in terms of the maximal length of words in S.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.1928v2"
    },
    {
        "title": "A proof Procedure for Testing Membership in Regular Expressions",
        "authors": [
            "Keehang Kwon",
            "Hong Pyo Ha",
            "Jiseung Kim"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We propose an algorithm that test membership for regular expressions and show\nthat the algorithm is correct. This algorithm is written in the style of a\nsequent proof system. The advantage of this algorithm over traditional ones is\nthat the complex conversion process from regular expressions to finite automata\nis not needed. As a consequence, our algorithm is simple and extends easily to\nvarious extensions to regular expressions such as timed regular expressions or\nregular languages with the intersection.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.2203v1"
    },
    {
        "title": "State machine models of timing and circuit design",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper illustrates a technique for specifying the detailed timing,\nlogical operation, and compositional circuit design of digital circuits in\nterms of ordinary state machines with output (transducers). The method is\nillustrated here with specifications of gates, latches, and other simple\ncircuits and via the construction of devices starting with a SR latch built\nfrom gates and then moving on to more complex devices. Circuit timing and\ntransients are treated in some detail. The method is based on \"classical\"\nautomata and recursive functions on strings. No formal methods, extended state\nmachines, or process algebras are involved but a reference is made to potential\napplications of the Krohn-Rhodes theorem and other group/monoid based algebraic\ntechniques.\n",
        "pdf_link": "http://arxiv.org/pdf/1003.0522v1"
    },
    {
        "title": "Zigzags in Turing machines",
        "authors": [
            "Anahi Gajardo",
            "Pierre Guillon"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We study one-head machines through symbolic and topological dynamics. In\nparticular, a subshift is associated to the subshift, and we are interested in\nits complexity in terms of realtime recognition. We emphasize the class of\none-head machines whose subshift can be recognized by a deterministic pushdown\nautomaton. We prove that this class corresponds to particular restrictions on\nthe head movement, and to equicontinuity in associated dynamical systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1003.0588v2"
    },
    {
        "title": "Complexity of Problems for Commutative Grammars",
        "authors": [
            "Eryk Kopczyński"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider Parikh images of languages accepted by non-deterministic finite\nautomata and context-free grammars; in other words, we treat the languages in a\ncommutative way --- we do not care about the order of letters in the accepted\nword, but rather how many times each one of them appears. In most cases we\nassume that the alphabet is of fixed size. We show tight complexity bounds for\nproblems like membership, equivalence, and disjointness. In particular, we show\npolynomial algorithms for membership and disjointness for Parikh images of\nnon-deterministic finite automata over fixed alphabet, and we show that\nequivalence is Pi2P complete for context-free grammars over fixed terminal\nalphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/1003.4105v1"
    },
    {
        "title": "A note on decidability of cellularity",
        "authors": [
            "Udayan B. Darji",
            "Steve W. Seif"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  A regular language L is said to be cellular if there exists a 1-dimensional\ncellular automaton CA such that L is the language consisting of the finite\nblocks associated with CA. It is shown that cellularity of a regular language\nis decidable using a new characterization of cellular languages formulated by\nFreiling, Goldstein and Moews and implied by a deep result of Boyle in symbolic\ndynamics.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.1946v1"
    },
    {
        "title": "Simulation vs. Equivalence",
        "authors": [
            "Zoltan Esik",
            "Andreas Maletti"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  For several semirings S, two weighted finite automata with multiplicities in\nS are equivalent if and only if they can be connected by a chain of\nsimulations. Such a semiring S is called \"proper\". It is known that the Boolean\nsemiring, the semiring of natural numbers, the ring of integers, all finite\ncommutative positively ordered semirings and all fields are proper. The\nsemiring S is Noetherian if every subsemimodule of a finitely generated\nS-semimodule is finitely generated. First, it is shown that all Noetherian\nsemirings and thus all commutative rings and all finite semirings are proper.\nSecond, the tropical semiring is shown not to be proper. So far there has not\nbeen any example of a semiring that is not proper.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.2426v1"
    },
    {
        "title": "The Complexity of Codiagnosability for Discrete Event and Timed Systems",
        "authors": [
            "Franck Cassez"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper we study the fault codiagnosis problem for discrete event\nsystems given by finite automata (FA) and timed systems given by timed automata\n(TA). We provide a uniform characterization of codiagnosability for FA and TA\nwhich extends the necessary and sufficient condition that characterizes\ndiagnosability. We also settle the complexity of the codiagnosability problems\nboth for FA and TA and show that codiagnosability is PSPACE-complete in both\ncases. For FA this improves on the previously known bound (EXPTIME) and for TA\nit is a new result. Finally we address the codiagnosis problem for TA under\nbounded resources and show it is 2EXPTIME-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.2550v1"
    },
    {
        "title": "Fault Diagnosis with Dynamic Observers",
        "authors": [
            "Franck Cassez",
            "Stavros Tripakis"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we review some recent results about the use of dynamic\nobservers for fault diagnosis of discrete event systems. Fault diagnosis\nconsists in synthesizing a diagnoser that observes a given plant and identifies\nfaults in the plant as soon as possible after their occurrence. Existing\nliterature on this problem has considered the case of fixed static observers,\nwhere the set of observable events is fixed and does not change during\nexecution of the system. In this paper, we consider dynamic observers: an\nobserver can \"switch\" sensors on or off, thus dynamically changing the set of\nevents it wishes to observe. It is known that checking diagnosability (i.e.,\nwhether a given observer is capable of identifying faults) can be solved in\npolynomial time for static observers, and we show that the same is true for\ndynamic ones. We also solve the problem of dynamic observers' synthesis and\nprove that a most permissive observer can be computed in doubly exponential\ntime, using a game-theoretic approach. We further investigate optimization\nproblems for dynamic observers and define a notion of cost of an observer.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.2810v1"
    },
    {
        "title": "Comparison of Two Context-Free Rewriting Systems with Simple\n  Context-Checking Mechanisms",
        "authors": [
            "Tomas Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper solves an open problem concerning the generative power of\nnonerasing context-free rewriting systems using a simple mechanism for checking\nfor context dependencies, in the literature known as semi-conditional grammars\nof degree (1,1). In these grammars, two nonterminal symbols are attached to\neach context-free production, and such a production is applicable if one of the\ntwo attached symbols occurs in the current sentential form, while the other\ndoes not. Specifically, this paper demonstrates that the family of languages\ngenerated by semi-conditional grammars of degree (1,1) coincides with the\nfamily of random context languages. In addition, it shows that the normal form\nproved by Mayer for random context grammars with erasing productions holds for\nrandom context grammars without erasing productions, too. It also discusses two\npossible definitions of the relation of the direct derivation step used in the\nliterature.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.3635v1"
    },
    {
        "title": "Finite Optimal Control for Time-Bounded Reachability in CTMDPs and\n  Continuous-Time Markov Games",
        "authors": [
            "Markus Rabe",
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We establish the existence of optimal scheduling strategies for time-bounded\nreachability in continuous-time Markov decision processes, and of co-optimal\nstrategies for continuous-time Markov games. Furthermore, we show that optimal\ncontrol does not only exist, but has a surprisingly simple structure: The\noptimal schedulers from our proofs are deterministic and timed-positional, and\nthe bounded time can be divided into a finite number of intervals, in which the\noptimal strategies are positional. That is, we demonstrate the existence of\nfinite optimal control. Finally, we show that these pleasant properties of\nMarkov decision processes extend to the more general class of continuous-time\nMarkov games, and that both early and late schedulers show this behaviour.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.4005v2"
    },
    {
        "title": "Simulations of Weighted Tree Automata",
        "authors": [
            "Zoltán Ésik",
            "Andreas Maletti"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Simulations of weighted tree automata (wta) are considered. It is shown how\nsuch simulations can be decomposed into simpler functional and dual functional\nsimulations also called forward and backward simulations. In addition, it is\nshown in several cases (fields, commutative rings, Noetherian semirings,\nsemiring of natural numbers) that all equivalent wta M and N can be joined by a\nfinite chain of simulations. More precisely, in all mentioned cases there\nexists a single wta that simulates both M and N. Those results immediately\nyield decidability of equivalence provided that the semiring is finitely (and\neffectively) presented.\n",
        "pdf_link": "http://arxiv.org/pdf/1005.2079v1"
    },
    {
        "title": "A Note on Ordinal DFAs",
        "authors": [
            "Stephen L. Bloom",
            "YiDi Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We prove the following theorem. Suppose that $M$ is a trim DFA on the Boolean\nalphabet $0,1$. The language $\\L(M)$ is well-ordered by the lexicographic order\n$\\slex$ iff whenever the non sink states $q,q.0$ are in the same strong\ncomponent, then $q.1$ is a sink. It is easy to see that this property is\nsufficient. In order to show the necessity, we analyze the behavior of a\n$\\slex$-descending sequence of words. This property is used to obtain a\npolynomial time algorithm to determine, given a DFA $M$, whether $\\L(M)$ is\nwell-ordered by the lexicographic order. Last, we apply an argument in\n\\cite{BE,BEa} to give a proof that the least nonregular ordinal is\n$\\omega^\\omega $.\n",
        "pdf_link": "http://arxiv.org/pdf/1005.2329v1"
    },
    {
        "title": "A new weakly universal cellular automaton in the 3D hyperbolic space\n  with two states",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we show a construction of a weakly universal cellular\nautomaton in the 3D hyperbolic space with two states. The cellular automaton is\nrotation invariant and, moreover, based on a new implementation of a railway\ncircuit in the dodecagrid,the construction is a truly 3D-one.\n",
        "pdf_link": "http://arxiv.org/pdf/1005.4826v1"
    },
    {
        "title": "The Morphisms With Unstackable Image Words",
        "authors": [
            "C. Robinson Tompkins"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In an attempt to classify all of the overlap-free morphisms constructively\nusing the Latin-square morphism, we came across an interesting counterexample,\nthe Leech square-free morphism. We generalize the combinatorial properties of\nthe Leech square-free morphism to gain insights on a larger class of both\noverlap-free morphisms and square-free morphisms.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.1273v1"
    },
    {
        "title": "An upper bound on the number of states for a strongly universal\n  hyperbolic cellular automaton on the pentagrid",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, following the way opened by a previous paper deposited on\narXiv, we give an upper bound to the number of states for a hyperbolic cellular\nautomaton in the pentagrid. Indeed, we prove that there is a hyperbolic\ncellular automaton which is rotation invariant and whose halting problem is\nundecidable and which has 9~states.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.3451v1"
    },
    {
        "title": "Monitorability of $ω$-regular languages",
        "authors": [
            "Andreas Bauer"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Arguably, omega-regular languages play an important role as a specification\nformalism in many approaches to systems monitoring via runtime verification.\nHowever, since their elements are infinite words, not every omega-regular\nlanguage can sensibly be monitored at runtime when only a finite prefix of a\nword, modelling the observed system behaviour so far, is available. The\nmonitorability of an omega-regular language, L, is thus a property that holds,\nif for any finite word u, observed so far, it is possible to add another finite\nword v, such that uv becomes a \"finite witness\" wrt. L; that is, for any\ninfinite word w, we have that uvw \\in L, or for any infinite word w, we have\nthat uvw \\not\\in L. This notion has been studied in the past by several\nauthors, and it is known that the class of monitorable languages is strictly\nmore expressive than, e.g., the commonly used class of so-called safety\nlanguages. But an exact categorisation of monitorable languages has, so far,\nbeen missing. Motivated by the use of linear-time temporal logic (LTL) in many\napproaches to runtime verification, this paper first determines the complexity\nof the monitorability problem when L is given by an LTL formula. Further, it\nthen shows that this result, in fact, transfers to omega-regular languages in\ngeneral, i.e., whether they are given by an LTL formula, a nondeterministic\nBuechi automaton, or even by an omega-regular expression.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.3638v1"
    },
    {
        "title": "State complexity of union and intersection combined with star and\n  reversal",
        "authors": [
            "Yuan Gao",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we study the state complexities of union and intersection\ncombined with star and reversal, respectively. We obtain the state complexities\nof these combined operations on regular languages and show that they are less\nthan the mathematical composition of the state complexities of their individual\nparticipating operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.3755v1"
    },
    {
        "title": "Parikh's Theorem: A simple and direct automaton construction",
        "authors": [
            "Javier Esparza",
            "Pierre Ganty",
            "Stefan Kiefer",
            "Michael Luttenberger"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Parikh's theorem states that the Parikh image of a context-free language is\nsemilinear or, equivalently, that every context-free language has the same\nParikh image as some regular language. We present a very simple construction\nthat, given a context-free grammar, produces a finite automaton recognizing\nsuch a regular language.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.3825v3"
    },
    {
        "title": "Abelian Primitive Words",
        "authors": [
            "Michael Domaratzki",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We investigate Abelian primitive words, which are words that are not Abelian\npowers. We show that unlike classical primitive words, the set of Abelian\nprimitive words is not context-free. We can determine whether a word is Abelian\nprimitive in linear time. Also different from classical primitive words, we\nfind that a word may have more than one Abelian root. We also consider\nenumeration problems and the relation to the theory of codes.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.4104v2"
    },
    {
        "title": "State Complexity of Two Combined Operations: Reversal-Catenation and\n  Star-Catenation",
        "authors": [
            "Bo Cui",
            "Yuan Gao",
            "Lila Kari",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we show that, due to the structural properties of the\nresulting automaton obtained from a prior operation, the state complexity of a\ncombined operation may not be equal but close to the mathematical composition\nof the state complexities of its component operations. In particular, we\nprovide two witness combined operations: reversal combined with catenation and\nstar combined with catenation.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.4646v1"
    },
    {
        "title": "Dynamic Observers for Fault Diagnosis of Timed Systems",
        "authors": [
            "Franck Cassez"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper we extend the work on \\emph{dynamic ob\\-servers} for fault\ndiagnosis to timed automata. We study sensor minimization problems with static\nobservers and then address the problem of computing the most permissive dynamic\nobserver for a system given by a timed automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.4681v1"
    },
    {
        "title": "Quotient Complexity of Bifix-, Factor-, and Subword-Free Regular\n  Languages",
        "authors": [
            "Janusz Brzozowski",
            "Galina Jirásková",
            "Baiyu Li",
            "Joshua Smith"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  A language L is prefix-free if, whenever words u and v are in L and u is a\nprefix of v, then u=v. Suffix-, factor-, and subword-free languages are defined\nsimilarly, where \"subword\" means \"subsequence\". A language is bifix-free if it\nis both prefix- and suffix-free. We study the quotient complexity, more\ncommonly known as state complexity, of operations in the classes of bifix-,\nfactor-, and subword-free regular languages. We find tight upper bounds on the\nquotient complexity of intersection, union, difference, symmetric difference,\nconcatenation, star, and reversal in these three classes of languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.4843v3"
    },
    {
        "title": "Optimal Time-Abstract Schedulers for CTMDPs and Markov Games",
        "authors": [
            "Markus Rabe",
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We study time-bounded reachability in continuous-time Markov decision\nprocesses for time-abstract scheduler classes. Such reachability problems play\na paramount role in dependability analysis and the modelling of manufacturing\nand queueing systems. Consequently, their analysis has been studied\nintensively, and techniques for the approximation of optimal control are well\nunderstood. From a mathematical point of view, however, the question of\napproximation is secondary compared to the fundamental question whether or not\noptimal control exists.\n  We demonstrate the existence of optimal schedulers for the time-abstract\nscheduler classes for all CTMDPs. Our proof is constructive: We show how to\ncompute optimal time-abstract strategies with finite memory. It turns out that\nthese optimal schedulers have an amazingly simple structure - they converge to\nan easy-to-compute memoryless scheduling policy after a finite number of steps.\n  Finally, we show that our argument can easily be lifted to Markov games: We\nshow that both players have a likewise simple optimal strategy in these more\ngeneral structures.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.5103v1"
    },
    {
        "title": "Compositional closure for Bayes Risk in probabilistic noninterference",
        "authors": [
            "Annabelle McIver",
            "Larissa Meinicke",
            "Carroll Morgan"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We give a sequential model for noninterference security including probability\n(but not demonic choice), thus supporting reasoning about the likelihood that\nhigh-security values might be revealed by observations of low-security\nactivity. Our novel methodological contribution is the definition of a\nrefinement order and its use to compare security measures between\nspecifications and (their supposed) implementations. This contrasts with the\nmore common practice of evaluating the security of individual programs in\nisolation.\n  The appropriateness of our model and order is supported by our showing that\nour refinement order is the greatest compositional relation --the compositional\nclosure-- with respect to our semantics and an \"elementary\" order based on\nBayes Risk --- a security measure already in widespread use. We also relate\nrefinement to other measures such as Shannon Entropy.\n  By applying the approach to a non-trivial example, the anonymous-majority\nThree-Judges protocol, we demonstrate by example that correctness arguments can\nbe simplified by the sort of layered developments --through levels of\nincreasing detail-- that are allowed and encouraged by compositional semantics.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.1054v1"
    },
    {
        "title": "Minimisation of Deterministic Parity and Buchi Automata and Relative\n  Minimisation of Deterministic Finite Automata",
        "authors": [
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this report we study the problem of minimising deterministic automata over\nfinite and infinite words. Deterministic finite automata are the simplest\ndevices to recognise regular languages, and deterministic Buchi, Co-Buchi, and\nparity automata play a similar role in the recognition of \\omega-regular\nlanguages. While it is well known that the minimisation of deterministic finite\nand weak automata is cheap, the complexity of minimising deterministic Buchi\nand parity automata has remained an open challenge. We establish the\nNP-completeness of these problems. A second contribution of this report is the\nintroduction of relaxed minimisation of deterministic finite automata. Like\nhyper-minimisation, relaxed minimisation allows for some changes in the\nlanguage of the automaton: We seek a smallest automaton that, when used as a\nmonitor, provides a wrong answer only a bounded number of times in any run of a\nsystem. We argue that minimisation of finite automata, hyper-minimisation,\nrelaxed minimisation, and the minimisation of deterministic Buchi (or Co-Buchi)\nautomata are operations of increasing reduction power, as the respective\nequivalence relations on automata become coarser from left to right. When we\nallow for minor changes in the language, relaxed minimisation can therefore be\nconsidered as a more powerful minimisation technique than hyper-minimisation\nfrom the perspective of finite automata. From the perspective of Buchi and\nCo-Buchi automata, we gain a cheap algorithm for state-space reduction that\nalso turns out to be beneficial for further heuristic or exhaustive state-space\nreductions put on top of it.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.1333v2"
    },
    {
        "title": "Sampled Semantics of Timed Automata",
        "authors": [
            "Pavel Krcal",
            "Parosh Aziz Abdulla",
            "Wang Yi"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Sampled semantics of timed automata is a finite approximation of their dense\ntime behavior. While the former is closer to the actual software or hardware\nsystems with a fixed granularity of time, the abstract character of the latter\nmakes it appealing for system modeling and verification. We study one aspect of\nthe relation between these two semantics, namely checking whether the system\nexhibits some qualitative (untimed) behaviors in the dense time which cannot be\nreproduced by any implementation with a fixed sampling rate. More formally, the\n\\emph{sampling problem} is to decide whether there is a sampling rate such that\nall qualitative behaviors (the untimed language) accepted by a given timed\nautomaton in dense time semantics can be also accepted in sampled semantics. We\nshow that this problem is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.2783v2"
    },
    {
        "title": "Free iterative and iteration K-semialgebras",
        "authors": [
            "Zoltan Esik",
            "Werner Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider algebras of rational power series over an alphabet $\\Sigma$ with\ncoefficients in a commutative semiring $K$ and characterize them as the free\nalgebras in various classes of algebraic structures.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1507v2"
    },
    {
        "title": "State Complexity of Catenation Combined with Star and Reversal",
        "authors": [
            "Bo Cui",
            "Yuan Gao",
            "Lila Kari",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper is a continuation of our research work on state complexity of\ncombined operations. Motivated by applications, we study the state complexities\nof two particular combined operations: catenation combined with star and\ncatenation combined with reversal. We show that the state complexities of both\nof these combined operations are considerably less than the compositions of the\nstate complexities of their individual participating operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1648v1"
    },
    {
        "title": "Graph-Controlled Insertion-Deletion Systems",
        "authors": [
            "Rudolf Freund",
            "Marian Kogler",
            "Yurii Rogozhin",
            "Sergey Verlan"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this article, we consider the operations of insertion and deletion working\nin a graph-controlled manner. We show that like in the case of context-free\nproductions, the computational power is strictly increased when using a control\ngraph: computational completeness can be obtained by systems with insertion or\ndeletion rules involving at most two symbols in a contextual or in a\ncontext-free manner and with the control graph having only four nodes.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1651v1"
    },
    {
        "title": "Transition Complexity of Incomplete DFAs",
        "authors": [
            "Yuan Gao",
            "Kai Salomaa",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we consider the transition complexity of regular languages\nbased on the incomplete deterministic finite automata. A number of results on\nBoolean operations have been obtained. It is shown that the transition\ncomplexity results for union and complementation are very different from the\nstate complexity results for the same operations. However, for intersection,\nthe transition complexity result is similar to that of state complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1652v1"
    },
    {
        "title": "Ciliate Gene Unscrambling with Fewer Templates",
        "authors": [
            "Lila Kari",
            "Afroza Rahman"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  One of the theoretical models proposed for the mechanism of gene unscrambling\nin some species of ciliates is the template-guided recombination (TGR) system\nby Prescott, Ehrenfeucht and Rozenberg which has been generalized by Daley and\nMcQuillan from a formal language theory perspective. In this paper, we propose\na refinement of this model that generates regular languages using the iterated\nTGR system with a finite initial language and a finite set of templates, using\nfewer templates and a smaller alphabet compared to that of the Daley-McQuillan\nmodel. To achieve Turing completeness using only finite components, i.e., a\nfinite initial language and a finite set of templates, we also propose an\nextension of the contextual template-guided recombination system (CTGR system)\nby Daley and McQuillan, by adding an extra control called permitting contexts\non the usage of templates.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1654v1"
    },
    {
        "title": "Descriptional Complexity of the Languages KaL: Automata, Monoids and\n  Varieties",
        "authors": [
            "Ondřej Klíma",
            "Libor Polák"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The first step when forming the polynomial hierarchies of languages is to\nconsider languages of the form KaL where K and L are over a finite alphabet A\nand from a given variety V of languages, a being a letter from A. All such\nKaL's generate the variety of languages BPol1(V).\n  We estimate the numerical parameters of the language KaL in terms of their\nvalues for K and L. These parameters include the state complexity of the\nminimal complete DFA and the size of the syntactic monoids. We also estimate\nthe cardinality of the image of A* in the Schuetzenberger product of the\nsyntactic monoids of K and L. In these three cases we obtain the optimal\nbounds.\n  Finally, we also consider estimates for the cardinalities of free monoids in\nthe variety of monoids corresponding to BPol1(V) in terms of sizes of the free\nmonoids in the variety of monoids corresponding to V.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1655v1"
    },
    {
        "title": "State Elimination Ordering Strategies: Some Experimental Results",
        "authors": [
            "Nelma Moreira",
            "Davide Nabais",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Recently, the problem of obtaining a short regular expression equivalent to a\ngiven finite automaton has been intensively investigated. Algorithms for\nconverting finite automata to regular expressions have an exponential blow-up\nin the worst-case. To overcome this, simple heuristic methods have been\nproposed.\n  In this paper we analyse some of the heuristics presented in the literature\nand propose new ones. We also present some experimental comparative results\nbased on uniform random generated deterministic finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1656v1"
    },
    {
        "title": "Operational State Complexity of Deterministic Unranked Tree Automata",
        "authors": [
            "Xiaoxue Piao",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider the state complexity of basic operations on tree languages\nrecognized by deterministic unranked tree automata. For the operations of union\nand intersection the upper and lower bounds of both weakly and strongly\ndeterministic tree automata are obtained. For tree concatenation we establish a\ntight upper bound that is of a different order than the known state complexity\nof concatenation of regular string languages. We show that (n+1) (\n(m+1)2^n-2^(n-1) )-1 vertical states are sufficient, and necessary in the worst\ncase, to recognize the concatenation of tree languages recognized by (strongly\nor weakly) deterministic automata with, respectively, m and n vertical states.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1657v1"
    },
    {
        "title": "Transformations Between Different Types of Unranked Bottom-Up Tree\n  Automata",
        "authors": [
            "Xiaoxue Piao",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider the representational state complexity of unranked tree automata.\nThe bottom-up computation of an unranked tree automaton may be either\ndeterministic or nondeterministic, and further variants arise depending on\nwhether the horizontal string languages defining the transitions are\nrepresented by a DFA or an NFA. Also, we consider for unranked tree automata\nthe alternative syntactic definition of determinism introduced by Cristau et\nal. (FCT'05, Lect. Notes Comput. Sci. 3623, pp. 68-79).\n  We establish upper and lower bounds for the state complexity of conversions\nbetween different types of unranked tree automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1658v1"
    },
    {
        "title": "On the Descriptional Complexity of Limited Propagating Lindenmayer\n  Systems",
        "authors": [
            "Bianca Truthe"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We investigate the descriptional complexity of limited propagating\nLindenmayer systems and their deterministic and tabled variants with respect to\nthe number of rules and the number of symbols. We determine the decrease of\ncomplexity when the generative capacity is increased. For incomparable\nfamilies, we give languages that can be described more efficiently in either of\nthese families than in the other.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1660v1"
    },
    {
        "title": "Nondeterministic State Complexity for Suffix-Free Regular Languages",
        "authors": [
            "Yo-Sub Han",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We investigate the nondeterministic state complexity of basic operations for\nsuffix-free regular languages. The nondeterministic state complexity of an\noperation is the number of states that are necessary and sufficient in the\nworst-case for a minimal nondeterministic finite-state automaton that accepts\nthe language obtained from the operation. We consider basic operations\n(catenation, union, intersection, Kleene star, reversal and complementation)\nand establish matching upper and lower bounds for each operation. In the case\nof complementation the upper and lower bounds differ by an additive constant of\ntwo.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1661v1"
    },
    {
        "title": "Complexity in Prefix-Free Regular Languages",
        "authors": [
            "Galina Jirásková",
            "Monika Krausová"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We examine deterministic and nondeterministic state complexities of regular\noperations on prefix-free languages. We strengthen several results by providing\nwitness languages over smaller alphabets, usually as small as possible. We next\nprovide the tight bounds on state complexity of symmetric difference, and\ndeterministic and nondeterministic state complexity of difference and cyclic\nshift of prefix-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1662v1"
    },
    {
        "title": "Learning Residual Finite-State Automata Using Observation Tables",
        "authors": [
            "Anna Kasprzik"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We define a two-step learner for RFSAs based on an observation table by using\nan algorithm for minimal DFAs to build a table for the reversal of the language\nin question and showing that we can derive the minimal RFSA from it after some\nsimple modifications. We compare the algorithm to two other table-based ones of\nwhich one (by Bollig et al. 2009) infers a RFSA directly, and the other is\nanother two-step learner proposed by the author. We focus on the criterion of\nquery complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1663v1"
    },
    {
        "title": "Remembering Chandra Kintala",
        "authors": [
            "Martin Kappes",
            "Andreas Malcher",
            "Detlef Wotschke"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  With this contribution we would like to remember Chandra M. R. Kintala who\npassed away in November 2009. We will give short overviews of his CV and his\ncontributions to the field of theoretical and applied computer science and,\ngiven the opportunity, will attempt to present the current state of limited\nnondeterminism and limited resources for machines. Finally, we will briefly\ntouch on some research topics which hopefully will be addressed in the not so\ndistant future.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1665v1"
    },
    {
        "title": "Finite-State Complexity and the Size of Transducers",
        "authors": [
            "Cristian Calude",
            "Kai Salomaa",
            "Tania Roblot"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Finite-state complexity is a variant of algorithmic information theory\nobtained by replacing Turing machines with finite transducers. We consider the\nstate-size of transducers needed for minimal descriptions of arbitrary strings\nand, as our main result, we show that the state-size hierarchy with respect to\na standard encoding is infinite. We consider also hierarchies yielded by more\ngeneral computable encodings.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1667v1"
    },
    {
        "title": "State Complexity of Testing Divisibility",
        "authors": [
            "Emilie Charlier",
            "Narad Rampersad",
            "Michel Rigo",
            "Laurent Waxweiler"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Under some mild assumptions, we study the state complexity of the trim\nminimal automaton accepting the greedy representations of the multiples of m >=\n2 for a wide class of linear numeration systems. As an example, the number of\nstates of the trim minimal automaton accepting the greedy representations of\nthe multiples of m in the Fibonacci system is exactly 2m^2.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1668v1"
    },
    {
        "title": "Small NFAs from Regular Expressions: Some Experimental Results",
        "authors": [
            "Hugo Gouveia",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Regular expressions (res), because of their succinctness and clear syntax,\nare the common choice to represent regular languages. However, efficient\npattern matching or word recognition depend on the size of the equivalent\nnondeterministic finite automata (NFA). We present the implementation of\nseveral algorithms for constructing small epsilon-free NFAss from res within\nthe FAdo system, and a comparison of regular expression measures and NFA sizes\nbased on experimental results obtained from uniform random generated res. For\nthis analysis, nonredundant res and reduced res in star normal form were\nconsidered.\n",
        "pdf_link": "http://arxiv.org/pdf/1009.3599v1"
    },
    {
        "title": "Free inductive K-semialgebras",
        "authors": [
            "Zoltan Esik",
            "Werner Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider rational power series over an alphabet $\\Sigma$ with coefficients\nin a ordered commutative semiring $K$ and characterize them as the free ordered\n$K$-semialgebras in various classes of ordered $K$-semialgebras equipped with a\nstar operation satisfying the least pre-fixed point rule and/or its dual. The\nresults are generalizations of Kozen's axiomatization of regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1009.4820v2"
    },
    {
        "title": "Regular Expressions, au point",
        "authors": [
            "Andrea Asperti",
            "Claudio Sacerdoti Coen",
            "Enrico Tassi"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We introduce a new technique for constructing a finite state deterministic\nautomaton from a regular expression, based on the idea of marking a suitable\nset of positions inside the expression, intuitively representing the possible\npoints reached after the processing of an initial prefix of the input string.\nPointed regular expressions join the elegance and the symbolic appealingness of\nBrzozowski's derivatives, with the effectiveness of McNaughton and Yamada's\nlabelling technique, essentially combining the best of the two approaches.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.2604v1"
    },
    {
        "title": "Syntactic Complexity of Ideal and Closed Languages",
        "authors": [
            "Janusz Brzozowski",
            "Yuli Ye"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The state complexity of a regular language is the number of states in the\nminimal deterministic automaton accepting the language. The syntactic\ncomplexity of a regular language is the cardinality of its syntactic semigroup.\nThe syntactic complexity of a subclass of regular languages is the worst-case\nsyntactic complexity taken as a function of the state complexity $n$ of\nlanguages in that class. We study the syntactic complexity of the class of\nregular ideal languages and their complements, the closed languages. We prove\nthat $n^{n-1}$ is a tight upper bound on the complexity of right ideals and\nprefix-closed languages, and that there exist left ideals and suffix-closed\nlanguages of syntactic complexity $n^{n-1}+n-1$, and two-sided ideals and\nfactor-closed languages of syntactic complexity $n^{n-2}+(n-2)2^{n-2}+1$.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.3263v1"
    },
    {
        "title": "On the Iterated Hairpin Completion",
        "authors": [
            "Steffen Kopecki"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The (bounded) hairpin completion and its iterated versions are operations on\nformal lan- guages which have been inspired by the hairpin formation in\nDNA-biochemistry. The paper answers two questions asked in the literature about\nthe iterated hairpin completion.\n  The first question is whether the class of regular languages is closed under\niterated bounded hairpin completion. Here we show that this is true by\nproviding a more general result which applies to all the classes of languages\nwhich are closed under finite union, intersection with regular sets, and\nconcatenation with regular sets. In particular, all Chomsky classes and all\nstandard complexity classes are closed under iterated bounded hairpin\ncompletion.\n  In the second part of the paper we address the question whether the iterated\nhairpin completion of a singleton is always regular. In contrast to the first\nquestion, this one has a negative answer. We exhibit an example of a singleton\nlanguage whose iterated hairpin completion is not regular, actually it is not\ncontext-free, but context-sensitive.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.3640v3"
    },
    {
        "title": "A Short Decidability Proof for DPDA Language Equivalence via First-Order\n  Grammars",
        "authors": [
            "Petr Jancar"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The main aim of the paper is to give a short self-contained proof of the\ndecidability of language equivalence for deterministic pushdown automata, which\nis the famous problem solved by G. Senizergues, for which C. Stirling has\nderived a primitive recursive complexity upper bound. The proof here is given\nin the framework of first-order grammars, which seems to be particularly apt\nfor the aim. An appendix presents a modification of Stirling's approach,\nyielding a complexity bound of the form tetr(2,g(n)) where tetr is the\n(nonelementary) operator of iterated exponentiation (tetration) and g is an\nelementary function of the input size.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.4760v4"
    },
    {
        "title": "Minimization of Automata",
        "authors": [
            "Jean Berstel",
            "Luc Boasson",
            "Olivier Carton",
            "Isabelle Fagnot"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This chapter is concerned with the design and analysis of algorithms for\nminimizing finite automata. Getting a minimal automaton is a fundamental issue\nin the use and implementation of finite automata tools in frameworks like text\nprocessing, image analysis, linguistic computer science, and many other\napplications. There are two main families of minimization algorithms. The first\nby a sequence of refinements of a partition of the set of states, the second by\na sequence of fusions or merges of states. Hopcroft's and Moore's algorithms\nbelong to the first family, the linear-time minimization of acyclic automata of\nRevuz belongs to the second family.\n  One of our studies is upon the comparison of the nature of Moore's and\nHopcroft's algorithms. This gives some new insight in both algorithms. As we\nshall see, these algorithms are quite different both in behavior and in\ncomplexity. In particular, we show that it is not possible to simulate the\ncomputations of one of the algorithm by the other. We describe the minimization\nalgorithm by fusion for so-called local automata. A special case of\nminimization is the construction o minimal automata for finite sets. We\nconsider briefly this case, and in particular describe incremental algorithms.\nFinally, we consider the case of updating a minimal automaton when a word is\nadded or removed from the set it recognizes.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.5318v3"
    },
    {
        "title": "Multi-dimensional sets recognizable in all abstract numeration systems",
        "authors": [
            "Emilie Charlier",
            "Anne Lacroix",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We prove that the subsets of N^d that are S-recognizable for all abstract\nnumeration systems S are exactly the 1-recognizable sets. This generalizes a\nresult of Lecomte and Rigo in the one-dimensional setting.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.5391v1"
    },
    {
        "title": "Pumping lemmas for linear and nonlinear context-free languages",
        "authors": [
            "Géza Horváth",
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Pumping lemmas are created to prove that given languages are not belong to\ncertain language classes. There are several known pumping lemmas for the whole\nclass and some special classes of the context-free languages. In this paper we\nprove new, interesting pumping lemmas for special linear and context-free\nlanguage classes. Some of them can be used to pump regular languages in two\nplace simultaneously. Other lemma can be used to pump context-free languages in\narbitrary many places.\n",
        "pdf_link": "http://arxiv.org/pdf/1012.0023v1"
    },
    {
        "title": "Precedence Automata and Languages",
        "authors": [
            "Violetta Lonati",
            "Dino Mandrioli",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Operator precedence grammars define a classical Boolean and deterministic\ncontext-free family (called Floyd languages or FLs). FLs have been shown to\nstrictly include the well-known visibly pushdown languages, and enjoy the same\nnice closure properties. We introduce here Floyd automata, an equivalent\noperational formalism for defining FLs. This also permits to extend the class\nto deal with infinite strings to perform for instance model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/1012.2321v2"
    },
    {
        "title": "Bacteria inspired patterns grown with hyperbolic cellular automata",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper we give three examples of expending patterns defined by\nhyperbolic cellular automata whose growth seems to be very similar to the\ngrowth of colonies of bacteria.\n",
        "pdf_link": "http://arxiv.org/pdf/1012.2771v1"
    },
    {
        "title": "Quotient Complexity of Star-Free Languages",
        "authors": [
            "Janusz Brzozowski",
            "Bo Liu"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The quotient complexity, also known as state complexity, of a regular\nlanguage is the number of distinct left quotients of the language. The quotient\ncomplexity of an operation is the maximal quotient complexity of the language\nresulting from the operation, as a function of the quotient complexities of the\noperands. The class of star-free languages is the smallest class containing the\nfinite languages and closed under boolean operations and concatenation. We\nprove that the tight bounds on the quotient complexities of union,\nintersection, difference, symmetric difference, concatenation, and star for\nstar-free languages are the same as those for regular languages, with some\nsmall exceptions, whereas the bound for reversal is 2^n-1.\n",
        "pdf_link": "http://arxiv.org/pdf/1012.3962v1"
    },
    {
        "title": "Coordinates for a new triangular tiling of the hyperbolic plane",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we define an infinite family of triangular tilings of the\nhyperbolic plane defined by two parameters ranging in the natural nummbers and\nwe give a uniform way to define coordinates for locating the triangles of the\ntiling.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.0530v1"
    },
    {
        "title": "On the expressiveness of Parikh automata and related models",
        "authors": [
            "Michaël Cadilhac",
            "Alain Finkel",
            "Pierre McKenzie"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The Parikh finite word automaton (PA) was introduced and studied by Klaedtke\nand Ruess in 2003. Natural variants of the PA arise from viewing a PA\nequivalently as an automaton that keeps a count of its transitions and\nsemilinearly constrains their numbers. Here we adopt this view and define the\naffine PA (APA), that extends the PA by having each transition induce an affine\ntransformation on the PA registers, and the PA on letters (LPA), that restricts\nthe PA by forcing any two transitions on same letter to affect the registers\nequally. Then we report on the expressiveness, closure, and decidability\nproperties of such PA variants. We note that deterministic PA are strictly\nweaker than deterministic reversal-bounded counter machines. We develop\npumping-style lemmas and identify an explicit PA language recognized by no\ndeterministic PA.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.1547v4"
    },
    {
        "title": "Restarting Automata with Auxiliary Symbols and Small Lookahead",
        "authors": [
            "Natalie Schluter"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We present a study on lookahead hierarchies for restarting automata with\nauxiliary symbols and small lookahead. In particular, we show that there are\njust two different classes of languages recognised RRWW automata, through the\nrestriction of lookahead size. We also show that the respective (left-)\nmonotone restarting automaton models characterise the context-free languages\nand that the respective right-left-monotone restarting automata characterise\nthe linear languages both with just lookahead length 2.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.1640v3"
    },
    {
        "title": "Finite Orbits of Language Operations",
        "authors": [
            "E. Charlier",
            "M. Domaratzki",
            "T. Harju",
            "J. Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider a set of natural operations on languages, and prove that the\norbit of any language L under the monoid generated by this set is finite and\nbounded, independently of L. This generalizes previous results about\ncomplement, Kleene closure, and positive closure.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.1667v2"
    },
    {
        "title": "Finitary languages",
        "authors": [
            "Krishnendu Chatterjee",
            "Nathanaël Fijalkow"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The class of omega-regular languages provides a robust specification language\nin verification. Every omega-regular condition can be decomposed into a safety\npart and a liveness part. The liveness part ensures that something good happens\n\"eventually\". Finitary liveness was proposed by Alur and Henzinger as a\nstronger formulation of liveness. It requires that there exists an unknown,\nfixed bound b such that something good happens within b transitions. In this\nwork we consider automata with finitary acceptance conditions defined by\nfinitary Buchi, parity and Streett languages. We study languages expressible by\nsuch automata: we give their topological complexity and present a\nregular-expression characterization. We compare the expressive power of\nfinitary automata and give optimal algorithms for classical decisions\nquestions. We show that the finitary languages are Sigma 2-complete; we present\na complete picture of the expressive power of various classes of automata with\nfinitary and infinitary acceptance conditions; we show that the languages\ndefined by finitary parity automata exactly characterize the star-free fragment\nof omega B-regular languages; and we show that emptiness is NLOGSPACE-complete\nand universality as well as language inclusion are PSPACE-complete for finitary\nparity and Streett automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.1727v1"
    },
    {
        "title": "An automaton over data words that captures EMSO logic",
        "authors": [
            "Benedikt Bollig"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We develop a general framework for the specification and implementation of\nsystems whose executions are words, or partial orders, over an infinite\nalphabet. As a model of an implementation, we introduce class register\nautomata, a one-way automata model over words with multiple data values. Our\nmodel combines register automata and class memory automata. It has natural\ninterpretations. In particular, it captures communicating automata with an\nunbounded number of processes, whose semantics can be described as a set of\n(dynamic) message sequence charts. On the specification side, we provide a\nlocal existential monadic second-order logic that does not impose any\nrestriction on the number of variables. We study the realizability problem and\nshow that every formula from that logic can be effectively, and in elementary\ntime, translated into an equivalent class register automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.4475v4"
    },
    {
        "title": "Scattered context-free linear orderings",
        "authors": [
            "Zoltan Esik"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We show that it is decidable in exponential time whether the lexicographic\nordering of a context-free language is scattered, or a well-ordering.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.0850v2"
    },
    {
        "title": "Splicing systems and the Chomsky hierarchy",
        "authors": [
            "Jean Berstel",
            "Luc Boasson",
            "Isabelle Fagnot"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper, we prove decidability properties and new results on the\nposition of the family of languages generated by (circular) splicing systems\nwithin the Chomsky hierarchy. The two main results of the paper are the\nfollowing. First, we show that it is decidable, given a circular splicing\nlanguage and a regular language, whether they are equal. Second, we prove the\nlanguage generated by an alphabetic splicing system is context-free. Alphabetic\nsplicing systems are a generalization of simple and semi-simple splicin systems\nalready considered in the literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.0947v1"
    },
    {
        "title": "Efficient Analysis of Probabilistic Programs with an Unbounded Counter",
        "authors": [
            "Tomas Brazdil",
            "Stefan Kiefer",
            "Antonin Kucera"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We show that a subclass of infinite-state probabilistic programs that can be\nmodeled by probabilistic one-counter automata (pOC) admits an efficient\nquantitative analysis. In particular, we show that the expected termination\ntime can be approximated up to an arbitrarily small relative error with\npolynomially many arithmetic operations, and the same holds for the probability\nof all runs that satisfy a given omega-regular property. Further, our results\nestablish a powerful link between pOC and martingale theory, which leads to\nfundamental observations about quantitative properties of runs in pOC. In\nparticular, we provide a \"divergence gap theorem\", which bounds a positive\nnon-termination probability in pOC away from zero.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.2529v1"
    },
    {
        "title": "Towards Nominal Formal Languages",
        "authors": [
            "Alexander Kurz",
            "Tomoyuki Suzuki",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We introduce formal languages over infinite alphabets where words may contain\nbinders. We define the notions of nominal language, nominal monoid, and nominal\nregular expressions. Moreover, we extend history-dependent automata\n(HD-automata) by adding stack, and study the recognisability of nominal\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3174v2"
    },
    {
        "title": "Büchi Automata can have Smaller Quotients",
        "authors": [
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We study novel simulation-like preorders for quotienting nondeterministic\nB\\\"uchi automata. We define fixed-word delayed simulation, a new preorder\ncoarser than delayed simulation. We argue that fixed-word simulation is the\ncoarsest forward simulation-like preorder which can be used for quotienting\nB\\\"uchi automata, thus improving our understanding of the limits of\nquotienting. Also, we show that computing fixed-word simulation is\nPSPACE-complete. On the practical side, we introduce proxy simulations, which\nare novel polynomial-time computable preorders sound for quotienting. In\nparticular, delayed proxy simulation induce quotients that can be smaller by an\narbitrarily large factor than direct backward simulation. We derive proxy\nsimulations as the product of a theory of refinement transformers: A refinement\ntransformer maps preorders non-decreasingly, preserving certain properties. We\nstudy under which general conditions refinement transformers are sound for\nquotienting.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3285v2"
    },
    {
        "title": "On the Hairpin Incompletion",
        "authors": [
            "Fumiya Okubo",
            "Takashi Yokomori"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Hairpin completion and its variant called bounded hairpin completion are\noperations on formal languages, inspired by a hairpin formation in molecular\nbiology. Another variant called hairpin lengthening has been recently\nintroduced and studied on the closure properties and algorithmic problems\nconcerning several families of languages. In this paper, we introduce a new\noperation of this kind, called hairpin incompletion which is not only an\nextension of bounded hairpin completion, but also a restricted (bounded)\nvariant of hairpin lengthening. Further, the hairpin incompletion operation\nprovides a formal language theoretic framework that models a bio-molecular\ntechnique nowadays known as Whiplash PCR. We study the closure properties of\nlanguage families under both the operation and its iterated version. We show\nthat a family of languages closed under intersection with regular sets,\nconcatenation with regular sets, and finite union is closed under one-sided\niterated hairpin incompletion, and that a family of languages containing all\nlinear languages and closed under circular permutation, left derivative and\nsubstitution is also closed under iterated hairpin incompletion.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3503v2"
    },
    {
        "title": "Theory of Atomata",
        "authors": [
            "Janusz Brzozowski",
            "Hellis Tamm"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We show that every regular language defines a unique nondeterministic finite\nautomaton (NFA), which we call \"\\'atomaton\", whose states are the \"atoms\" of\nthe language, that is, non-empty intersections of complemented or\nuncomplemented left quotients of the language. We describe methods of\nconstructing the \\'atomaton, and prove that it is isomorphic to the reverse\nautomaton of the minimal deterministic finite automaton (DFA) of the reverse\nlanguage. We study \"atomic\" NFAs in which the right language of every state is\na union of atoms. We generalize Brzozowski's double-reversal method for\nminimizing a deterministic finite automaton (DFA), showing that the result of\napplying the subset construction to an NFA is a minimal DFA if and only if the\nreverse of the NFA is atomic. We prove that Sengoku's claim that his method\nalways finds a minimal NFA is false.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3901v2"
    },
    {
        "title": "Fife's Theorem Revisited",
        "authors": [
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We give another proof of a theorem of Fife - understood broadly as providing\na finite automaton that gives a complete description of all infinite binary\noverlap-free words. Our proof is significantly simpler than those in the\nliterature. As an application we give a complete characterization of the\noverlap-free words that are 2-automatic.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3932v3"
    },
    {
        "title": "Regular Ideal Languages and Their Boolean Combinations",
        "authors": [
            "Franz Jahn",
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider ideals and Boolean combinations of ideals. For the regular\nlanguages within these classes we give expressively complete automaton models.\nIn addition, we consider general properties of regular ideals and their Boolean\ncombinations. These properties include effective algebraic characterizations\nand lattice identities.\n  In the main part of this paper we consider the following deterministic\none-way automaton models: unions of flip automata, weak automata, and\nStaiger-Wagner automata. We show that each of these models is expressively\ncomplete for regular Boolean combination of right ideals. Right ideals over\nfinite words resemble the open sets in the Cantor topology over infinite words.\nAn omega-regular language is a Boolean combination of open sets if and only if\nit is recognizable by a deterministic Staiger-Wagner automaton; and our result\ncan be seen as a finitary version of this classical theorem. In addition, we\nalso consider the canonical automaton models for right ideals, prefix-closed\nlanguages, and factorial languages.\n  In the last section, we consider a two-way automaton model which is known to\nbe expressively complete for two-variable first-order logic. We show that the\nabove concepts can be adapted to these two-way automata such that the resulting\nlanguages are the right ideals (resp. prefix-closed languages, resp. Boolean\ncombinations of right ideals) definable in two-variable first-order logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.5013v3"
    },
    {
        "title": "Nondeterministic automata: equivalence, bisimulations, and uniform\n  relations",
        "authors": [
            "Miroslav Ćirić",
            "Jelena Ignjatović",
            "Milan Bašić",
            "Ivana Jančić"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we study the equivalence of nondeterministic automata pairing\nthe concept of a bisimulation with the recently introduced concept of a uniform\nrelation. In this symbiosis, uniform relations serve as equivalence relations\nwhich relate states of two possibly different nondeterministic automata, and\nbisimulations ensure compatibility with the transitions, initial and terminal\nstates of these automata. We define six types of bisimulations, but due to the\nduality we discuss three of them: forward, backward-forward, and weak forward\nbisimulations. For each od these three types of bisimulations we provide a\nprocedure which decides whether there is a bisimulation of this type between\ntwo automata, and when it exists, the same procedure computes the greatest one.\nWe also show that there is a uniform forward bisimulation between two automata\nif and only if the factor automata with respect to the greatest forward\nbisimulation equivalences on these automata are isomorphic. We prove a similar\ntheorem for weak forward bisimulations, using the concept of a weak forward\nisomorphism instead of an isomorphism. We also give examples that explain the\nrelationships between the considered types of bisimulations.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.5449v1"
    },
    {
        "title": "On minimising automata with errors",
        "authors": [
            "Paweł Gawrychowski",
            "Artur Jeż",
            "Andreas Maletti"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The problem of k-minimisation for a DFA M is the computation of a smallest\nDFA N (where the size |M| of a DFA M is the size of the domain of the\ntransition function) such that their recognized languages differ only on words\nof length less than k. The previously best algorithm, which runs in time O(|M|\nlog^2 n) where n is the number of states, is extended to DFAs with partial\ntransition functions. Moreover, a faster O(|M| log n) algorithm for DFAs that\nrecognise finite languages is presented. In comparison to the previous\nalgorithm for total DFAs, the new algorithm is much simpler and allows the\ncalculation of a k-minimal DFA for each k in parallel. Secondly, it is\ndemonstrated that calculating the least number of introduced errors is hard:\nGiven a DFA M and numbers k and m, it is NP-hard to decide whether there exists\na k-minimal DFA N differing from DFA M on at most m words. A similar result\nholds for hyper-minimisation of DFAs in general: Given a DFA M and numbers s\nand m, it is NP-hard to decide whether there exists a DFA N with at most s\nstates such that DFA M and N differ on at msot m words.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.5682v1"
    },
    {
        "title": "Decidability and Shortest Strings in Formal Languages",
        "authors": [
            "Levent Alpoge",
            "Thomas Ang",
            "Luke Schaeffer",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Given a formal language L specified in various ways, we consider the problem\nof determining if L is nonempty. If L is indeed nonempty, we find upper and\nlower bounds on the length of the shortest string in L.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.1622v2"
    },
    {
        "title": "Syntactic Complexity of Prefix-, Suffix-, Bifix-, and Factor-Free\n  Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Baiyu Li",
            "Yuli Ye"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The syntactic complexity of a regular language is the cardinality of its\nsyntactic semigroup. The syntactic complexity of a subclass of the class of\nregular languages is the maximal syntactic complexity of languages in that\nclass, taken as a function of the state complexity $n$ of these languages. We\nstudy the syntactic complexity of prefix-, suffix-, bifix-, and factor-free\nregular languages. We prove that $n^{n-2}$ is a tight upper bound for\nprefix-free regular languages. We present properties of the syntactic\nsemigroups of suffix-, bifix-, and factor-free regular languages, conjecture\ntight upper bounds on their size to be $(n-1)^{n-2}+(n-2)$, $(n-1)^{n-3} +\n(n-2)^{n-3} + (n-3)2^{n-3}$, and $(n-1)^{n-3} + (n-3)2^{n-3} + 1$,\nrespectively, and exhibit languages with these syntactic complexities.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.2986v2"
    },
    {
        "title": "On primary and secondary repetitions in words",
        "authors": [
            "Roman Kolpakov"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Combinatorial properties of maximal repetitions (runs) in formal words are\nstudied. We classify all maximal repetitions in a word as primary and secondary\nwhere the set of all primary repetitions determines all the other repetitons in\nthe word. Essential combinatorial properties of primary repetitions are\nestablished.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.5230v1"
    },
    {
        "title": "Context-free ordinals",
        "authors": [
            "Zoltan Esik",
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider context-free languages equipped with the lexicographic ordering.\nWe show that when the lexicographic ordering of a context-free language is\nscattered, then its Hausdorff rank is less than $\\omega^\\omega$. As a corollary\nof this result we obtain that an ordinal is the order type of a well-ordered\ncontext-free language iff it is less than $\\omega^{\\omega^\\omega}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.5421v1"
    },
    {
        "title": "On Non-Complete Sets and Restivo's Conjecture",
        "authors": [
            "Vladimir V. Gusev",
            "Elena V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A finite set S of words over the alphabet A is called non-complete if\nFact(S*) is different from A*. A word w in A* - Fact(S*) is said to be\nuncompletable. We present a series of non-complete sets S_k whose minimal\nuncompletable words have length 5k^2 - 17k + 13, where k > 3 is the maximal\nlength of words in S_k. This is an infinite series of counterexamples to\nRestivo's conjecture, which states that any non-complete set possesses an\nuncompletable word of length at most 2k^2.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.0388v1"
    },
    {
        "title": "On the regularity of iterated hairpin completion of a single word",
        "authors": [
            "Lila Kari",
            "Steffen Kopecki",
            "Shinnosuke Seki"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Hairpin completion is an abstract operation modeling a DNA bio-operation\nwhich receives as input a DNA strand $w = x\\alpha y \\calpha$, and outputs $w' =\nx \\alpha y \\bar{\\alpha} \\bar{x}$, where $\\bar{x}$ denotes the Watson-Crick\ncomplement of $x$. In this paper, we focus on the problem of finding conditions\nunder which the iterated hairpin completion of a given word is regular.\nAccording to the numbers of words $\\alpha$ and $\\calpha$ that initiate hairpin\ncompletion and how they are scattered, we classify the set of all words $w$.\nFor some basic classes of words $w$ containing small numbers of occurrences of\n$\\alpha$ and $\\calpha$, we prove that the iterated hairpin completion of $w$ is\nregular. For other classes with higher numbers of occurrences of $\\alpha$ and\n$\\calpha$, we prove a necessary and sufficient condition for the iterated\nhairpin completion of a word in these classes to be regular.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.2385v1"
    },
    {
        "title": "Optimal Hyper-Minimization",
        "authors": [
            "Andreas Maletti",
            "Daniel Quernheim"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Minimal deterministic finite automata (DFAs) can be reduced further at the\nexpense of a finite number of errors. Recently, such minimization algorithms\nhave been improved to run in time O(n log n), where n is the number of states\nof the input DFA, by [Gawrychowski and Je\\.z: Hyper-minimisation made\nefficient. Proc. MFCS, LNCS 5734, 2009] and [Holzer and Maletti: An n log n\nalgorithm for hyper-minimizing a (minimized) deterministic automaton. Theor.\nComput. Sci. 411, 2010]. Both algorithms return a DFA that is as small as\npossible, while only committing a finite number of errors. These algorithms are\nfurther improved to return a DFA that commits the least number of errors at the\nexpense of an increased (quadratic) run-time. This solves an open problem of\n[Badr, Geffert, and Shipman: Hyper-minimizing minimized deterministic finite\nstate automata. RAIRO Theor. Inf. Appl. 43, 2009]. In addition, an experimental\nstudy on random automata is performed and the effects of the existing\nalgorithms and the new algorithm are reported.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.3007v1"
    },
    {
        "title": "Pushing undecidability of the isolation problem for probabilistic\n  automata",
        "authors": [
            "Nathanaël Fijalkow",
            "Hugo Gimbert",
            "Youssouf Oualhadj"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  This short note aims at proving that the isolation problem is undecidable for\nprobabilistic automata with only one probabilistic transition. This problem is\nknown to be undecidable for general probabilistic automata, without restriction\non the number of probabilistic transitions. In this note, we develop a\nsimulation technique that allows to simulate any probabilistic automaton with\none having only one probabilistic transition.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.3054v1"
    },
    {
        "title": "IUPC: Identification and Unification of Process Constraints",
        "authors": [
            "Juergen Mangler",
            "Stefanie Rinderle-Ma"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Business Process Compliance (BPC) has gained significant momentum in research\nand practice during the last years. Although many approaches address BPC, they\nmostly assume the existence of some kind of unified base of process constraints\nand focus on their verification over the business processes. However, it\nremains unclear how such an inte- grated process constraint base can be built\nup, even though this con- stitutes the essential prerequisite for all further\ncompliance checks. In addition, the heterogeneity of process constraints has\nbeen neglected so far. Without identification and separation of process\nconstraints from domain rules as well as unification of process constraints,\nthe success- ful IT support of BPC will not be possible. In this technical\nreport we introduce a unified representation framework that enables the\nidentifica- tion of process constraints from domain rules and their later\nunification within a process constraint base. Separating process constraints\nfrom domain rules can lead to significant reduction of compliance checking\neffort. Unification enables consistency checks and optimizations as well as\nmaintenance and evolution of the constraint base on the other side.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.3609v1"
    },
    {
        "title": "Primitive words and roots of words",
        "authors": [
            "Gerhard Lischke"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In the algebraic theory of codes and formal languages, the set $Q$ of all\nprimitive words over some alphabet $\\zi $ has received special interest. With\nthis survey article we give an overview about relevant research to this topic\nduring the last twenty years including own investigations and some new results.\nIn Section 1 after recalling the most important notions from formal language\ntheory we illustrate the connection between coding theory and primitive words\nby some facts. We define primitive words as words having only a trivial\nrepresentation as the power of another word. Nonprimitive words (without the\nempty word) are exactly the periodic words. Every nonempty word is a power of\nan uniquely determined primitive word which is called the root of the former\none. The set of all roots of nonempty words of a language is called the root of\nthe language. The primitive words have interesting combinatorial properties\nwhich we consider in Section 2. In Section 3 we investigate the relationship\nbetween the set $Q$ of all primitive words over some fixed alphabet and the\nlanguage classes of the Chomsky Hierarchy and the contextual languages over the\nsame alphabet. The computational complexity of the set $Q$ and of the roots of\nlanguages are considered in Section 4. The set of all powers of the same degree\nof all words from a language is the power of this language. We examine the\npowers of languages for different sets of exponents, and especially their\nregularity and context-freeness, in Section 5, and the decidability of\nappropriate questions in Section 6. Section 7 is dedicated to several\ngeneralizations of the notions of periodicity and primitivity of words.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.4427v1"
    },
    {
        "title": "Experimental Study of the Shortest Reset Word of Random Automata",
        "authors": [
            "Evgeny Skvortsov",
            "Evgeny Tipikin"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we describe an approach to finding the shortest reset word of a\nfinite synchronizing automaton by using a SAT solver. We use this approach to\nperform an experimental study of the length of the shortest reset word of a\nfinite synchronizing automaton. The largest automata we considered had 100\nstates. The results of the experiments allow us to formulate a hypothesis that\nthe length of the shortest reset word of a random finite automaton with $n$\nstates and 2 input letters with high probability is sublinear with respect to\n$n$ and can be estimated as $1.95 n^{0.55}.$\n",
        "pdf_link": "http://arxiv.org/pdf/1105.1704v1"
    },
    {
        "title": "Pattern avoidance with involution",
        "authors": [
            "James D. Currie"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We give the avoidance indices (morphic and antimorphic) for all unary\npatterns with involution.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.2849v1"
    },
    {
        "title": "On the number of Dejean words over alphabets of 5, 6, 7, 8, 9 and 10\n  letters",
        "authors": [
            "Roman Kolpakov",
            "Michael Rao"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We give lower bounds on the growth rate of Dejean words, i.e. minimally\nrepetitive words, over a k-letter alphabet, for k=5, 6, 7, 8, 9, 10. Put\ntogether with the known upper bounds, we estimate these growth rates with the\nprecision of 0,005. As an consequence, we establish the exponential growth of\nthe number of Dejean words over a k-letter alphabet, for k=5, 6, 7, 8, 9, 10.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.3116v1"
    },
    {
        "title": "Construction of fuzzy automata from fuzzy regular expressions",
        "authors": [
            "Aleksandar Stamenković",
            "Miroslav Ćirić"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Li and Pedrycz [Y. M. Li, W. Pedrycz, Fuzzy finite automata and fuzzy regular\nexpressions with membership values in lattice ordered monoids, Fuzzy Sets and\nSystems 156 (2005) 68--92] have proved fundamental results that provide\ndifferent equivalent ways to represent fuzzy languages with membership values\nin a lattice-ordered monoid, and generalize the well-known results of the\nclassical theory of formal languages. In particular, they have shown that a\nfuzzy language over an integral lattice-ordered monoid can be represented by a\nfuzzy regular expression if and only if it can be recognized by a fuzzy finite\nautomaton. However, they did not give any effective method for constructing an\nequivalent fuzzy finite automaton from a given fuzzy regular expression. In\nthis paper we provide such an effective method. Transforming scalars appearing\nin a fuzzy regular expression {\\alpha} into letters of the new extended\nalphabet, we convert the fuzzy regular expression {\\alpha} to an ordinary\nregular expression {\\alpha}_{R}. Then, starting from an arbitrary\nnondeterministic finite automaton A that recognizes the language ||{\\alpha}_R||\nrepresented by the regular expression {\\alpha}_R, we construct fuzzy finite\nautomata A_{\\alpha} and A_{\\alpha}^r with the same or even less number of\nstates than the automaton A, which recognize the fuzzy language ||{\\alpha}||\nrepresented by the fuzzy regular expression {\\alpha}. The starting\nnondeterministic finite automaton A can be obtained from {\\alpha}_R using any\nof the well-known constructions for converting regular expressions to\nnondeterministic finite automata, such as Glushkov-McNaughton-Yamada's position\nautomaton, Brzozowski's derivative automaton, Antimirov's partial derivative\nautomaton, or Ilie-Yu's follow automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.6190v1"
    },
    {
        "title": "Arenas of Finite State Machines",
        "authors": [
            "Giordano Pola",
            "Maria D. Di Benedetto",
            "Elena De Santis"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Finite state machines are widely used as a sound mathematical formalism that\nappropriately describes large scale, distributed and complex systems. Multiple\ninteractions of finite state machines in complex systems are well captured by\nthe notion of non-flat systems. Non--flat systems are \"finite state machines\"\nwhere each \"state\" can be either a basic state or an aggregate of finite state\nmachines. By expanding a non-flat system, a flat system is obtained which is an\nordinary finite state machine. In this paper we introduce a novel class of\nnon--flat systems called Arena of Finite State Machines (AFSM). AFSMs are\ncollections of finite state machines that interact concurrently through a\ncommunication network. We propose a notion of compositional bisimulation that\nallows checking bisimulation equivalence of AFSMs by directly exploiting their\ncommunication networks and hence, without the need of expanding the AFSMs to\nfinite state machines. Compositional bisimulation allows a computational\ncomplexity reduction when checking bisimulation equivalence of AFSMs, as\nformally quantified in the paper. An application of the proposed framework to\nthe regulation of gene expression in the bacterium Escherichia coli is also\npresented.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.0342v2"
    },
    {
        "title": "A Decidable Extension of Data Automata",
        "authors": [
            "Zhilin Wu"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Data automata on data words is a decidable model proposed by Boja\\'nczyk et\nal. in 2006. Class automata, introduced recently by Boja\\'nczyk and Lasota, is\nan extension of data automata which unifies different automata models on data\nwords. The nonemptiness of class automata is undecidable, since class automata\ncan simulate two-counter machines. In this paper, a decidable model called\nclass automata with priority class condition, which restricts class automata\nbut strictly extends data automata, is proposed. The decidability of this model\nis obtained by establishing a correspondence with priority multicounter\nautomata. This correspondence also completes the picture of the links between\nvarious class conditions of class automata and various models of counter\nmachines. Moreover, this model is applied to extend a decidability result of\nAlur, Cern\\'y and Weinstein on the algorithmic analysis of array-accessing\nprograms.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.1235v1"
    },
    {
        "title": "Shuffling and Unshuffling",
        "authors": [
            "D. Henshall",
            "N. Rampersad",
            "J. Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider various shuffling and unshuffling operations on languages and\nwords, and examine their closure properties. Although the main goal is to\nprovide some good and novel exercises and examples for undergraduate formal\nlanguage theory classes, we also provide some new results and some open\nproblems.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.5767v4"
    },
    {
        "title": "Parameterized Regular Expressions and their Languages",
        "authors": [
            "Pablo Barceló",
            "Leonid Libkin",
            "Juan Reutter"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We study regular expressions that use variables, or parameters, which are\ninterpreted as alphabet letters. We consider two classes of languages denoted\nby such expressions: under the possibility semantics, a word belongs to the\nlanguage if it is denoted by some regular expression obtained by replacing\nvariables with letters; under the certainly semantics, the word must be denoted\nby every such expression. Such languages are regular, and we show that they\nnaturally arise in several applications such as querying graph databases and\nprogram analysis. As the main contribution of the paper, we provide a complete\ncharacterization of the complexity of the main computational problems related\nto such languages: nonemptiness, universality, containment, membership, as well\nas the problem of constructing NFAs capturing such languages. We also look at\nthe extension when domains of variables could be arbitrary regular languages,\nand show that under the certainty semantics, languages remain regular and the\ncomplexity of the main computational problems does not change.\n",
        "pdf_link": "http://arxiv.org/pdf/1107.0577v1"
    },
    {
        "title": "Decidable Problems for Probabilistic Automata on Infinite Words",
        "authors": [
            "Krishnendu Chatterjee",
            "Mathieu Tracol"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider probabilistic automata on infinite words with acceptance defined\nby parity conditions. We consider three qualitative decision problems: (i) the\npositive decision problem asks whether there is a word that is accepted with\npositive probability; (ii) the almost decision problem asks whether there is a\nword that is accepted with probability 1; and (iii) the limit decision problem\nasks whether for every epsilon > 0 there is a word that is accepted with\nprobability at least 1 - epsilon. We unify and generalize several decidability\nresults for probabilistic automata over infinite words, and identify a robust\n(closed under union and intersection) subclass of probabilistic automata for\nwhich all the qualitative decision problems are decidable for parity\nconditions. We also show that if the input words are restricted to lasso shape\n(regular) words, then the positive and almost problems are decidable for all\nprobabilistic automata with parity conditions. For most decidable problems we\nshow an optimal PSPACE-complete complexity bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1107.2091v1"
    },
    {
        "title": "A State-Based Characterisation of the Conflict Preorder",
        "authors": [
            "Simon Ware",
            "Robi Malik"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  This paper proposes a way to effectively compare the potential of processes\nto cause conflict. In discrete event systems theory, two concurrent systems are\nsaid to be in conflict if they can get trapped in a situation where they are\nboth waiting or running endlessly, forever unable to complete their common\ntask. The conflict preorder is a process-algebraic pre-congruence that compares\ntwo processes based on their possible conflicts in combination with other\nprocesses. This paper improves on previous theoretical descriptions of the\nconflict preorder by introducing less conflicting pairs as a concrete\nstate-based characterisation. Based on this characterisation, an effective\nalgorithm is presented to determine whether two processes are related according\nto the conflict preorder.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.0230v1"
    },
    {
        "title": "Deciding Regularity of Hairpin Completions of Regular Languages in\n  Polynomial Time",
        "authors": [
            "Volker Diekert",
            "Steffen Kopecki",
            "Victor Mitrana"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The hairpin completion is an operation on formal languages that has been\ninspired by the hairpin formation in DNA biochemistry and by DNA computing. In\nthis paper we investigate the hairpin completion of regular languages.\n  It is well known that hairpin completions of regular languages are linear\ncontext-free and not necessarily regular. As regularity of a (linear)\ncontext-free language is not decidable, the question arose whether regularity\nof a hairpin completion of regular languages is decidable. We prove that this\nproblem is decidable and we provide a polynomial time algorithm.\n  Furthermore, we prove that the hairpin completion of regular languages is an\nunambiguous linear context-free language and, as such, it has an effectively\ncomputable growth function. Moreover, we show that the growth of the hairpin\ncompletion is exponential if and only if the growth of the underlying languages\nis exponential and, in case the hairpin completion is regular, then the hairpin\ncompletion and the underlying languages have the same growth indicator.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.2427v1"
    },
    {
        "title": "Absoluteness of subword inequality is undecidable",
        "authors": [
            "Shinnosuke Seki"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Mateescu, Salomaa, and Yu asked: is it decidable whether a given subword\nhistory assumes only non-negative values for all words over a given alphabet.\nIn this paper, we solve this open problem by proving that this problem is\nundecidable even under stronger conditions than supposed originally.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.2758v1"
    },
    {
        "title": "Proceedings 8th International Conference Words 2011",
        "authors": [
            "Petr Ambrož",
            "Štěpán Holub",
            "Zuzana Masáková"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  WORDS is the main international event in Combinatorics on Words. It is a\nbiannual conference devoted to research of words (i.e., finite or infinite\nsequences of symbols over a finite alphabet) from combinatorial, algebraic and\nalgorithmic points of view. The emphasis of the conference is on mathematical\ntheory of words but the conference is also open to applications, mainly in\ncomputer science, biology, linguistics and physics, gaining from the fact that\nwords arise as a natural object in many areas.\n  The eighth edition of the conference was organized in Prague from 12th to\n16th September 2011 as a joint undertaking of the Czech Technical University\nand the Charles University. This volume consists of contributed papers accepted\nfor presentation at the conference and summaries of invited lectures.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3412v1"
    },
    {
        "title": "Infinite permutations vs. infinite words",
        "authors": [
            "Anna E. Frid"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  I am going to compare well-known properties of infinite words with those of\ninfinite permutations, a new object studied since middle 2000s. Basically, it\nwas Sergey Avgustinovich who invented this notion, although in an early study\nby Davis et al. permutations appear in a very similar framework as early as in\n1977. I am going to tell about periodicity of permutations, their complexity\naccording to several definitions and their automatic properties, that is, about\nusual parameters of words, now extended to permutations and behaving sometimes\nsimilarly to those for words, sometimes not. Another series of results concerns\npermutations generated by infinite words and their properties. Although this\ndirection of research is young, many people, including two other speakers of\nthis meeting, have participated in it, and I believe that several more topics\nfor further study are really promising.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3616v1"
    },
    {
        "title": "Combinatorics on words in information security: Unavoidable regularities\n  in the construction of multicollision attacks on iterated hash functions",
        "authors": [
            "Juha Kortelainen"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Classically in combinatorics on words one studies unavoidable regularities\nthat appear in sufficiently long strings of symbols over a fixed size alphabet.\nIn this paper we take another viewpoint and focus on combinatorial properties\nof long words in which the number of occurrences of any symbol is restritced by\na fixed constant. We then demonstrate the connection of these properties to\nconstructing multicollision attacks on so called generalized iterated hash\nfunctions.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3617v1"
    },
    {
        "title": "Bounded Parikh Automata",
        "authors": [
            "Michaël Cadilhac",
            "Alain Finkel",
            "Pierre McKenzie"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The Parikh finite word automaton model (PA) was introduced and studied by\nKlaedtke and Ruess in 2003. Here, by means of related models, it is shown that\nthe bounded languages recognized by PA are the same as those recognized by\ndeterministic PA. Moreover, this class of languages is the class of bounded\nlanguages whose set of iterations is semilinear.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3625v1"
    },
    {
        "title": "From Regular to Strictly Locally Testable Languages",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Pierluigi San Pietro"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A classical result (often credited to Y. Medvedev) states that every language\nrecognized by a finite automaton is the homomorphic image of a local language,\nover a much larger so-called local alphabet, namely the alphabet of the edges\nof the transition graph. Local languages are characterized by the value k=2 of\nthe sliding window width in the McNaughton and Papert's infinite hierarchy of\nstrictly locally testable languages (k-slt). We generalize Medvedev's result in\na new direction, studying the relationship between the width and the alphabetic\nratio telling how much larger the local alphabet is. We prove that every\nregular language is the image of a k-slt language on an alphabet of doubled\nsize, where the width logarithmically depends on the automaton size, and we\nexhibit regular languages for which any smaller alphabetic ratio is\ninsufficient. More generally, we express the trade-off between alphabetic ratio\nand width as a mathematical relation derived from a careful encoding of the\nstates. At last we mention some directions for theoretical development and\napplication.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3626v1"
    },
    {
        "title": "On Pansiot Words Avoiding 3-Repetitions",
        "authors": [
            "Irina A. Gorbunova",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The recently confirmed Dejean's conjecture about the threshold between\navoidable and unavoidable powers of words gave rise to interesting and\nchallenging problems on the structure and growth of threshold words. Over any\nfinite alphabet with k >= 5 letters, Pansiot words avoiding 3-repetitions form\na regular language, which is a rather small superset of the set of all\nthreshold words. Using cylindric and 2-dimensional words, we prove that, as k\napproaches infinity, the growth rates of complexity for these regular languages\ntend to the growth rate of complexity of some ternary 2-dimensional language.\nThe numerical estimate of this growth rate is about 1.2421.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3630v1"
    },
    {
        "title": "Constructing Premaximal Binary Cube-free Words of Any Level",
        "authors": [
            "Elena A. Petrova",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We study the structure of the language of binary cube-free words. Namely, we\nare interested in the cube-free words that cannot be infinitely extended\npreserving cube-freeness. We show the existence of such words with arbitrarily\nlong finite extensions, both to one side and to both sides.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3634v1"
    },
    {
        "title": "Systems of Word Equations and Polynomials: a New Approach",
        "authors": [
            "Aleksi Saarela"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We develop new polynomial methods for studying systems of word equations. We\nuse them to improve some earlier results and to analyze how sizes of systems of\nword equations satisfying certain independence properties depend on the lengths\nof the equations. These methods give the first nontrivial upper bounds for the\nsizes of the systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3637v1"
    },
    {
        "title": "Iterated Hairpin Completions of Non-crossing Words",
        "authors": [
            "Lila Kari",
            "Steffen Kopecki",
            "Shinnosuke Seki"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Iterated hairpin completion is an operation on formal languages that is\ninspired by the hairpin formation in DNA biochemistry. Iterated hairpin\ncompletion of a word (or more precisely a singleton language) is always a\ncontext-sensitive language and for some words it is known to be\nnon-context-free. However, it is unknown whether regularity of iterated hairpin\ncompletion of a given word is decidable. Also the question whether iterated\nhairpin completion of a word can be context-free but not regular was asked in\nliterature. In this paper we investigate iterated hairpin completions of\nnon-crossing words and, within this setting, we are able to answer both\nquestions. For non-crossing words we prove that the regularity of iterated\nhairpin completions is decidable and that if iterated hairpin completion of a\nnon-crossing word is not regular, then it is not context-free either.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.0760v1"
    },
    {
        "title": "Treating Insomnia, Amnesia, and Acalculia in Regular Expression Matching",
        "authors": [
            "Luis Quesada",
            "Fernando Berzal",
            "Francisco J. Cortijo"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Regular expressions provide a flexible means for matching strings and they\nare often used in data-intensive applications. They are formally equivalent to\neither deterministic finite automata (DFAs) or nondeterministic finite automata\n(NFAs). Both DFAs and NFAs are affected by two problems known as amnesia and\nacalculia, and DFAs are also affected by a problem known as insomnia. Existing\ntechniques require an automata conversion and compaction step that prevents the\nuse of existing automaton databases and hinders the maintenance of the\nresulting compact automata. In this paper, we propose Parallel Finite State\nMachines (PFSMs), which are able to run any DFA- or NFA-like state machines\nwithout a previous conversion or compaction step. PFSMs report, online, all the\nmatches found within an input string and they solve the three aforementioned\nproblems. Parallel Finite State Machines require quadratic time and linear\nmemory and they are distributable. Parallel Finite State Machines make very\nfast distributed regular expression matching in data-intensive applications\nfeasible.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.1716v2"
    },
    {
        "title": "Compressed Membership for NFA (DFA) with Compressed Labels is in NP (P)",
        "authors": [
            "Artur Jeż"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper, a compressed membership problem for finite automata, both\ndeterministic and non-deterministic, with compressed transition labels is\nstudied. The compression is represented by straight-line programs (SLPs), i.e.\ncontext-free grammars generating exactly one string. A novel technique of\ndealing with SLPs is introduced: the SLPs are recompressed, so that substrings\nof the input text are encoded in SLPs labelling the transitions of the NFA\n(DFA) in the same way, as in the SLP representing the input text. To this end,\nthe SLPs are locally decompressed and then recompressed in a uniform way.\nFurthermore, such recompression induces only small changes in the automaton, in\nparticular, the size of the automaton remains polynomial.\n  Using this technique it is shown that the compressed membership for NFA with\ncompressed labels is in NP, thus confirming the conjecture of Plandowski and\nRytter and extending the partial result of Lohrey and Mathissen; as it is\nalready known, that this problem is NP-hard, we settle its exact computational\ncomplexity. Moreover, the same technique applied to the compressed membership\nfor DFA with compressed labels yields that this problem is in P; for this\nproblem, only trivial upper-bound PSPACE was known.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.2318v1"
    },
    {
        "title": "The non-abelian squares are not context-free",
        "authors": [
            "Shuo Tan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Answering a recent question of Crochemore, we prove that the language of\nwords that are not abelian squares is not context-free.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.4136v1"
    },
    {
        "title": "Büchi Complementation and Size-Change Termination",
        "authors": [
            "Seth Fogarty",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We compare tools for complementing nondeterministic B\\\"uchi automata with a\nrecent termination-analysis algorithm. Complementation of B\\\"uchi automata is a\nkey step in program verification. Early constructions using a Ramsey-based\nargument have been supplanted by rank-based constructions with exponentially\nbetter bounds. In 2001 Lee et al. presented the size-change termination (SCT)\nproblem, along with both a reduction to B\\\"uchi automata and a Ramsey-based\nalgorithm. The Ramsey-based algorithm was presented as a more practical\nalternative to the automata-theoretic approach, but strongly resembles the\ninitial complementation constructions for B\\\"uchi automata. We prove that the\nSCT algorithm is a specialized realization of the Ramsey-based complementation\nconstruction. To do so, we extend the Ramsey-based complementation construction\nto provide a containment-testing algorithm. Surprisingly, empirical analysis\nsuggests that despite the massive gap in worst-case complexity, Ramsey-based\napproaches are superior over the domain of SCT problems. Upon further analysis\nwe discover an interesting property of the problem space that both explains\nthis result and provides a chance to improve rank-based tools. With these\nimprovements, we show that theoretical gains in efficiency of the rank-based\napproach are mirrored in empirical performance.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.6183v3"
    },
    {
        "title": "Equational theories of profinite structures",
        "authors": [
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we consider a general way of constructing profinite struc-\ntures based on a given framework - a countable family of objects and a\ncountable family of recognisers (e.g. formulas). The main theorem states:\n  A subset of a family of recognisable sets is a lattice if and only if it is\ndefinable by a family of profinite equations.\n  This result extends Theorem 5.2 from [GGEP08] expressed only for finite words\nand morphisms to finite monoids. One of the applications of our theorem is the\nsituation where objects are finite relational structures and recognisers are\nfirst order sentences. In that setting a simple characterisation of lattices of\nfirst order formulas arise.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.0476v1"
    },
    {
        "title": "Quantitative Languages Defined by Functional Automata",
        "authors": [
            "Emmanuel Filiot",
            "Raffaella Gentilini",
            "Jean-FranÃ§ois Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A weighted automaton is functional if any two accepting runs on the same\nfinite word have the same value. In this paper, we investigate functional\nweighted automata for four different measures: the sum, the mean, the\ndiscounted sum of weights along edges and the ratio between rewards and costs.\nOn the positive side, we show that functionality is decidable for the four\nmeasures. Furthermore, the existential and universal threshold problems, the\nlanguage inclusion problem and the equivalence problem are all decidable when\nthe weighted automata are functional. On the negative side, we also study the\nquantitative extension of the realizability problem and show that it is\nundecidable for sum, mean and ratio. We finally show how to decide whether the\nlanguage associated with a given functional automaton can be defined with a\ndeterministic one, for sum, mean and discounted sum. The results on\nfunctionality and determinizability are expressed for the more general class of\nfunctional group automata. This allows one to formulate within the same\nframework new results related to discounted sum automata and known results on\nsum and mean automata. Ratio automata do not fit within this general scheme and\ndifferent techniques are required to decide functionality.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.0862v4"
    },
    {
        "title": "Star-Free Languages are Church-Rosser Congruential",
        "authors": [
            "Volker Diekert",
            "Manfred Kufleitner",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The class of Church-Rosser congruential languages has been introduced by\nMcNaughton, Narendran, and Otto in 1988. A language L is Church-Rosser\ncongruential (belongs to CRCL), if there is a finite, confluent, and\nlength-reducing semi-Thue system S such that L is a finite union of congruence\nclasses modulo S. To date, it is still open whether every regular language is\nin CRCL. In this paper, we show that every star-free language is in CRCL. In\nfact, we prove a stronger statement: For every star-free language L there\nexists a finite, confluent, and subword-reducing semi-Thue system S such that\nthe total number of congruence classes modulo S is finite and such that L is a\nunion of congruence classes modulo S. The construction turns out to be\neffective.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.4300v1"
    },
    {
        "title": "Reaction Automata",
        "authors": [
            "Fumiya Okubo",
            "Satoshi Kobayashi",
            "Takashi Yokomori"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Reaction systems are a formal model that has been introduced to investigate\nthe interactive behaviors of biochemical reactions. Based on the formal\nframework of reaction systems, we propose new computing models called reaction\nautomata that feature (string) language acceptors with multiset manipulation as\na computing mechanism, and show that reaction automata are computationally\nTuring universal. Further, some subclasses of reaction automata with space\ncomplexity are investigated and their language classes are compared to the ones\nin the Chomsky hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.5038v2"
    },
    {
        "title": "Independent sets of words and the synchronization problem",
        "authors": [
            "Arturo Carpi",
            "Flavio D'Alessandro"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The synchronization problem is investigated for the class of locally strongly\ntransitive automata introduced in a previous work of the authors. Some\nextensions of this problem related to the notions of stable set and word of\nminimal rank of an automaton are studied. An application to synchronizing\ncolorings of aperiodic graphs with a Hamiltonian path is also considered.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.5467v1"
    },
    {
        "title": "Autonomous push-down automaton built on DNA",
        "authors": [
            "Tadeusz Krasinski",
            "Sebastian Sakowski",
            "Tomasz Poplawski"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we propose a biomolecular implementation of the push-down\nautomaton (one of theoretical models of computing device with unbounded memory)\nusing DNA molecules. The idea of this improved implementation was inspired by\nCavaliere et al. (2005).\n",
        "pdf_link": "http://arxiv.org/pdf/1111.5807v1"
    },
    {
        "title": "Unique decodability of bigram counts by finite automata",
        "authors": [
            "Aryeh Kontorovich",
            "Ari Trachtenberg"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We revisit the problem of deciding whether a given string is uniquely\ndecodable from its bigram counts by means of a finite automaton. An efficient\nalgorithm for constructing a polynomial-size nondeterministic finite automaton\nthat decides unique decodability is given. Conversely, we show that the minimum\ndeterministic finite automaton for deciding unique decodability has at least\nexponentially many states in alphabet size.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.6431v1"
    },
    {
        "title": "An Extension of Parikh's Theorem beyond Idempotence",
        "authors": [
            "Michael Luttenberger",
            "Maximilian Schlund"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The commutative ambiguity of a context-free grammar G assigns to each Parikh\nvector v the number of distinct leftmost derivations yielding a word with\nParikh vector v. Based on the results on the generalization of Newton's method\nto omega-continuous semirings, we show how to approximate the commutative\nambiguity by means of rational formal power series, and give a lower bound on\nthe convergence speed of these approximations. From the latter result we deduce\nthat the commutative ambiguity itself is rational modulo the generalized\nidempotence identity k=k+1 (for k some positive integer), and, subsequently,\nthat it can be represented as a weighted sum of linear sets. This extends\nParikh's well-known result that the commutative image of context-free languages\nis semilinear (k=1).\n  Based on the well-known relationship between context-free grammars and\nalgebraic systems over semirings, our results extend the work by Green et al.\non the computation of the provenance of Datalog queries over commutative\nomega-continuous semirings.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.2864v4"
    },
    {
        "title": "A new approach to cross-bifix-free sets",
        "authors": [
            "Stefano Bilotta",
            "Elisa Pergola",
            "Renzo Pinzani"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Cross-bifix-free sets are sets of words such that no prefix of any word is a\nsuffix of any other word. In this paper, we introduce a general constructive\nmethod for the sets of cross-bifix-free binary words of fixed length. It\nenables us to determine a cross-bifix-free words subset which has the property\nto be non-expandable.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.3168v1"
    },
    {
        "title": "An Alternative Interpretation of Linguistic Variables as Linguistic\n  Finite Automata",
        "authors": [
            "Supriya Raheja",
            "Reena Dhadich",
            "Smita Rajpal"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Linguistic variables represent crisp information in a form and precision\nappropriate for the problem. For example, to answer the question \"How are you?\"\none may say \"I am fine.\" the linguistic variables like \"fine\", so common in\neveryday speech. In this paper an alternative interpretation of linguistic\nvariables is introduced with the notion of a linguistic description of a value\nor set of values. The use of linguistic variables in many applications reduces\nthe overall computation complexity of the application. Linguistic variables\nhave been shown to be particularly useful in complex non-linear applications.\nHere we are applying the concept of reasoning with Linguistic Quantifiers to\ndefine the Linguistic Finite Automata along with the expansion of \\delta^{\\box}\nand \\lambda^{\\box} over \\delta and \\lambda.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.3435v1"
    },
    {
        "title": "Filtrations of Formal Languages by Arithmetic Progressions",
        "authors": [
            "Hamoon Mousavi",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A filtration of a formal language L by a sequence s maps L to the set of\nwords formed by taking the letters of words of L indexed only by s. We consider\nthe languages resulting from filtering by all arithmetic progressions. If L is\nregular, it is easy to see that only finitely many distinct languages result.\nBy contrast, there exist CFL's that give infinitely many distinct languages as\na result. We use our technique to show that the operation diag, which extracts\nthe diagonal of words of square length arranged in a square array, preserves\nregularity but does not preserve context-freeness.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.3758v2"
    },
    {
        "title": "A Sufficient Condition for Hanna Neumann Property of Submonoids of a\n  Free Monoid",
        "authors": [
            "Shubh Narayan Singh",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Using automata-theoretic approach, Giambruno and Restivo have investigated on\nthe intersection of two finitely generated submonoids of the free monoid over a\nfinite alphabet. In particular, they have obtained Hanna Neumann property for a\nspecial class of submonoids generated by finite prefix sets. This work\ncontinues their work and provides a sufficient condition for Hanna Neumann\nproperty for the entire class of submonoids generated by finite prefix sets. In\nthis connection, a general rank formula for the submonoids which are accepted\nby semi-flower automata is also obtained.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.4256v3"
    },
    {
        "title": "On the Complexity of the Equivalence Problem for Probabilistic Automata",
        "authors": [
            "Stefan Kiefer",
            "Andrzej S. Murawski",
            "Joël Ouaknine",
            "Björn Wachter",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Checking two probabilistic automata for equivalence has been shown to be a\nkey problem for efficiently establishing various behavioural and anonymity\nproperties of probabilistic systems. In recent experiments a randomised\nequivalence test based on polynomial identity testing outperformed\ndeterministic algorithms. In this paper we show that polynomial identity\ntesting yields efficient algorithms for various generalisations of the\nequivalence problem. First, we provide a randomized NC procedure that also\noutputs a counterexample trace in case of inequivalence. Second, we show how to\ncheck for equivalence two probabilistic automata with (cumulative) rewards. Our\nalgorithm runs in deterministic polynomial time, if the number of reward\ncounters is fixed. Finally we show that the equivalence problem for\nprobabilistic visibly pushdown automata is logspace equivalent to the\nArithmetic Circuit Identity Testing problem, which is to decide whether a\npolynomial represented by an arithmetic circuit is identically zero.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.4644v2"
    },
    {
        "title": "Deciding Whether a Regular Language is Generated by a Splicing System",
        "authors": [
            "Lila Kari",
            "Steffen Kopecki"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Splicing as a binary word/language operation is inspired by the DNA\nrecombination under the action of restriction enzymes and ligases, and was\nfirst introduced by Tom Head in 1987. Shortly thereafter, it was proven that\nthe languages generated by (finite) splicing systems form a proper subclass of\nthe class of regular languages. However, the question of whether or not one can\ndecide if a given regular language is generated by a splicing system remained\nopen. In this paper we give a positive answer to this question. Namely, we\nprove that, if a language is generated by a splicing system, then it is also\ngenerated by a splicing system whose size is a function of the size of the\nsyntactic monoid of the input language, and which can be effectively\nconstructed.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.4897v4"
    },
    {
        "title": "Regular Languages are Church-Rosser Congruential",
        "authors": [
            "Volker Diekert",
            "Manfred Kufleitner",
            "Klaus Reinhardt",
            "Tobias Walter"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper proves a long standing conjecture in formal language theory. It\nshows that all regular languages are Church-Rosser congruential. The class of\nChurch-Rosser congruential languages was introduced by McNaughton, Narendran,\nand Otto in 1988. A language L is Church-Rosser congruential, if there exists a\nfinite confluent, and length-reducing semi-Thue system S such that L is a\nfinite union of congruence classes modulo S. It was known that there are\ndeterministic linear context-free languages which are not Church-Rosser\ncongruential, but on the other hand it was strongly believed that all regular\nlanguage are of this form. Actually, this paper proves a more general result.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.1148v1"
    },
    {
        "title": "A family of weakly universal cellular automata in the hyperbolic plane\n  with two states",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this paper, we construct a family of weakly universal rotation invariant\ncellular automaton for all grids $\\{p,3\\}$ of the hyperbolic plane for $p\\geq\n13$. The scheme is general for $p\\geq 17$ and for $13\\leq p<17$, we give such a\ncellular automaton for $p=13$, which is enough. Also, an important property of\nthis family is that the set of cells of the cellular automaton which are\nsubject to changes is actually a planar set. The problem for $p<13$ for a truly\nplanar construction is still open. The best result, for $p=7$, is four states\nand was obtained by the same author.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.1709v1"
    },
    {
        "title": "Late Weak Bisimulation for Markov Automata",
        "authors": [
            "Christian Eisentraut",
            "Jens Chr. Godskesen",
            "Holger Hermanns",
            "Lei Song",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Weak bisimilarity is a distribution-based equivalence notion for Markov\nautomata. It has gained some popularity as the coarsest reasonable behavioural\nequivalence on Markov automata. This paper studies a strictly coarser notion:\nLate weak bisimilarity enjoys valuable properties if restricting to important\nsubclasses of schedulers: Trace distribution equivalence is implied for partial\ninformation schedulers, and compositionality is preserved by distributed\nschedulers. The intersection of the two scheduler classes thus spans a coarser\nand still reasonable compositional theory of Markov automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.4116v2"
    },
    {
        "title": "Periodic scheduling of marked graphs using balanced binary words",
        "authors": [
            "Jean-Vivien Millo",
            "Robert De Simone"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This report presents an algorithm to statically schedule live and strongly\nconnected Marked Graphs (MG). The proposed algorithm computes the best\nexecution where the execution rate is maximal and place sizes are minimal. The\nproposed algorithm provides transition schedules represented as binary words.\nThese words are chosen to be balanced. The contributions of this paper is the\nproposed algorithm itself along with the characterization of the best execution\nof any MG.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.4912v1"
    },
    {
        "title": "Synthesis of Succinct Systems",
        "authors": [
            "John Fearnley",
            "Doron Peled",
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Synthesis of correct by design systems from specification has recently\nattracted much attention. The theoretical results imply that this problem is\nhighly intractable, e.g., synthesizing a system is 2EXPTIME-complete for an LTL\nspecification, and EXPTIME-complete for a CTL specification. However, an\nargument against it is that the temporal specification is highly compact, and\nthe complexity reflects the large size of the system constructed. In that\nrespect, the complexity should, perhaps, be specified relative to the size of\nthe minimal satisfying system. A careful observation reveals that the size of\nthe system is presented in such arguments as the size of its state space. This\nview is a bit nonstandard, in the sense that the state space can be\nexponentially larger than the size of a reasonable implementation such as a\ncircuit or a program. Although this alternative measure of the size of the\nsynthesized system is more intuitive (e.g., this is the standard way model\nchecking problems are measured), research on synthesis has so far stayed with\nmeasuring the system in terms of the explicit state space. This raises the\nquestion of whether or not there always exists a small system. In this paper,\nwe show that this is the case if, and only if, PSPACE = EXPTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.5449v2"
    },
    {
        "title": "The FC-rank of a context-free language",
        "authors": [
            "Arnaud Carayol",
            "Zoltan Esik"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We prove that the finite condensation rank (FC-rank) of the lexicographic\nordering of a context-free language is strictly less than $\\omega^\\omega$.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.6275v2"
    },
    {
        "title": "On Quotients of Formal Power Series",
        "authors": [
            "Yongming Li",
            "Qian Wang",
            "Sanjiang Li"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Quotient is a basic operation of formal languages, which plays a key role in\nthe construction of minimal deterministic finite automata (DFA) and the\nuniversal automata. In this paper, we extend this operation to formal power\nseries and systemically investigate its implications in the study of weighted\nautomata. In particular, we define two quotient operations for formal power\nseries that coincide when calculated by a word. We term the first operation as\n(left or right) \\emph{quotient}, and the second as (left or right)\n\\emph{residual}. To support the definitions of quotients and residuals, the\nunderlying semiring is restricted to complete semirings or complete\nc-semirings. Algebraical properties that are similar to the classical case are\nobtained in the formal power series case. Moreover, we show closure properties,\nunder quotients and residuals, of regular series and weighted context-free\nseries are similar as in formal languages. Using these operations, we define\nfor each formal power series $A$ two weighted automata ${\\cal M}_A$ and ${\\cal\nU}_A$. Both weighted automata accepts $A$, and ${\\cal M}_A$ is the minimal\ndeterministic weighted automaton of $A$. The universality of ${\\cal U}_A$ is\njustified and, in particular, we show that ${\\cal M}_A$ is a sub-automaton of\n${\\cal U}_A$. Last but not least, an effective method to construct the\nuniversal automaton is also presented in this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.2236v1"
    },
    {
        "title": "Syntactic Complexity of Finite/Cofinite, Definite, and Reverse Definite\n  Languages",
        "authors": [
            "Janusz Brzozowski",
            "David Liu"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study the syntactic complexity of finite/cofinite, definite and reverse\ndefinite languages. The syntactic complexity of a class of languages is defined\nas the maximal size of syntactic semigroups of languages from the class, taken\nas a function of the state complexity n of the languages. We prove that (n-1)!\nis a tight upper bound for finite/cofinite languages and that it can be reached\nonly if the alphabet size is greater than or equal to (n-1)!-(n-2)!. We prove\nthat the bound is also (n-1)! for reverse definite languages, but the minimal\nalphabet size is (n-1)!-2(n-2)!. We show that \\lfloor e\\cdot (n-1)!\\rfloor is a\nlower bound on the syntactic complexity of definite languages, and conjecture\nthat this is also an upper bound, and that the alphabet size required to meet\nthis bound is \\floor{e \\cdot (n-1)!} - \\floor{e \\cdot (n-2)!}. We prove the\nconjecture for n\\le 4.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.2873v2"
    },
    {
        "title": "Synchronizing Automata on Quasi Eulerian Digraph",
        "authors": [
            "Mikhail V. Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In 1964 \\v{C}ern\\'{y} conjectured that each $n$-state synchronizing automaton\nposesses a reset word of length at most $(n-1)^2$. From the other side the best\nknown upper bound on the reset length (minimum length of reset words) is cubic\nin $n$. Thus the main problem here is to prove quadratic (in $n$) upper bounds.\nSince 1964, this problem has been solved for few special classes of \\sa. One of\nthis result is due to Kari \\cite{Ka03} for automata with Eulerian digraphs. In\nthis paper we introduce a new approach to prove quadratic upper bounds and\nexplain it in terms of Markov chains and Perron-Frobenius theories. Using this\napproach we obtain a quadratic upper bound for a generalization of Eulerian\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.3402v1"
    },
    {
        "title": "The state complexity of star-complement-star",
        "authors": [
            "Galina Jiraskova",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We resolve an open question by determining matching (asymptotic) upper and\nlower bounds on the state complexity of the operation that sends a language L\nto (c(L*))*, where c() denotes complement.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.5353v1"
    },
    {
        "title": "Interrupt Timed Automata: verification and expressiveness",
        "authors": [
            "Béatrice Bérard",
            "Serge Haddad",
            "Mathieu Sassolas"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We introduce the class of Interrupt Timed Automata (ITA), a subclass of\nhybrid automata well suited to the description of timed multi-task systems with\ninterruptions in a single processor environment. While the reachability problem\nis undecidable for hybrid automata we show that it is decidable for ITA. More\nprecisely we prove that the untimed language of an ITA is regular, by building\na finite automaton as a generalized class graph. We then establish that the\nreachability problem for ITA is in NEXPTIME and in PTIME when the number of\nclocks is fixed. To prove the first result, we define a subclass ITA- of ITA,\nand show that (1) any ITA can be reduced to a language-equivalent automaton in\nITA- and (2) the reachability problem in this subclass is in NEXPTIME (without\nany class graph). In the next step, we investigate the verification of real\ntime properties over ITA. We prove that model checking SCL, a fragment of a\ntimed linear time logic, is undecidable. On the other hand, we give model\nchecking procedures for two fragments of timed branching time logic. We also\ncompare the expressive power of classical timed automata and ITA and prove that\nthe corresponding families of accepted languages are incomparable. The result\nalso holds for languages accepted by controlled real-time automata (CRTA), that\nextend timed automata. We finally combine ITA with CRTA, in a model which\nencompasses both classes and show that the reachability problem is still\ndecidable. Additionally we show that the languages of ITA are neither closed\nunder complementation nor under intersection.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.6453v1"
    },
    {
        "title": "Bounded Counter Languages",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We show that deterministic finite automata equipped with $k$ two-way heads\nare equivalent to deterministic machines with a single two-way input head and\n$k-1$ linearly bounded counters if the accepted language is strictly bounded,\ni.e., a subset of $a_1^*a_2^*... a_m^*$ for a fixed sequence of symbols $a_1,\na_2,..., a_m$. Then we investigate linear speed-up for counter machines. Lower\nand upper time bounds for concrete recognition problems are shown, implying\nthat in general linear speed-up does not hold for counter machines. For bounded\nlanguages we develop a technique for speeding up computations by any constant\nfactor at the expense of adding a fixed number of counters.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.0833v1"
    },
    {
        "title": "The Cerny Conjecture",
        "authors": [
            "Mikhail Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The \\v{C}ern\\'y conjecture (\\v{C}ern\\'y, 1964) states that each n-state \\san\\\npossess a \\sw\\ of length $(n-1)^2$. From the other side the best upper bound\nfor the \\rl\\ of n-state \\sa\\ known so far is equal to $\\frac{n^3-n}6$ (Pin,\n1983) and so is cubic (a slightly better though still cubic upper bound\n$\\frac{n(7n^2+6n-16)}{48}$ has been claimed in Trahtman but the published proof\nof this result contains an unclear place) in $n$. In the paper the \\v{C}ern\\'y\nconjecture is reduced to a simpler conjecture. In particular, we prove\n\\v{C}ern\\'y conjecture for one-cluster automata and quadratic upper bounds for\nautomata closed to one-cluster automata. Our approach utilize theory of Markov\nchains and one simple fact from linear programming.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.0856v4"
    },
    {
        "title": "First-Order Quantifiers and the Syntactic Monoid of Height Fragments of\n  Picture Languages",
        "authors": [
            "Oliver Matz"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate the expressive power of first-order quantifications in the\ncontext of monadic second-order logic over pictures. We show that k+1 set\nquantifier alternations allow to define a picture language that cannot be\ndefined using k set quantifier alternations preceded by arbitrarily many\nfirst-order quantifier alternations. The approach uses, for a given picture\nlanguage L and an integer m > 0 the height-m fragment of L, which is defined as\nthe word language obtained by considering each picture p of height m in L as a\nword, where the letters of that word are the columns of p. A key idea is to\nmeasure the complexity of a regular word language by the group complexity of\nits syntactic monoid. Given a picture language L, such a word language measure\nmay be applied to each of its height fragments, so that the complexity of the\npicture language is a function that maps each m to the complexity of the\nheight-m fragment of L. The asymptotic growth rate of that function may be\nbounded based on the structure of a monadic second-order formula that defines\nL. The core argument for that lower bound proof is based on Straubing's\nalgebraic characterization of the effect of first-order quantifiers on the\nsyntactic monoid of word languages by means of Rhodes' and Tilson's block\nproduct.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.4443v2"
    },
    {
        "title": "The Join Levels of the Trotter-Weil Hierarchy are Decidable",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The variety DA of finite monoids has a huge number of different\ncharacterizations, ranging from two-variable first-order logic FO^2 to\nunambiguous polynomials. In order to study the structure of the subvarieties of\nDA, Trotter and Weil considered the intersection of varieties of finite monoids\nwith bands, i.e., with idempotent monoids. The varieties of idempotent monoids\nare very well understood and fully classified. Trotter and Weil showed that for\nevery band variety V there exists a unique maximal variety W inside DA such\nthat the intersection with bands yields the given band variety V. These maximal\nvarieties W define the Trotter-Weil hierarchy. This hierarchy is infinite and\nit exhausts DA; induced by band varieties, it naturally has a zigzag shape. In\ntheir paper, Trotter and Weil have shown that the corners and the intersection\nlevels of this hierarchy are decidable.\n  In this paper, we give a single identity of omega-terms for every join level\nof the Trotter-Weil hierarchy; this yields decidability. Moreover, we show that\nthe join levels and the subsequent intersection levels do not coincide. Almeida\nand Azevedo have shown that the join of R-trivial and L-trivial finite monoids\nis decidable; this is the first non-trivial join level of the Trotter-Weil\nhierarchy. We extend this result to the other join levels of the Trotter-Weil\nhierarchy. At the end of the paper, we give two applications. First, we show\nthat the hierarchy of deterministic and codeterministic products is decidable.\nAnd second, we show that the direction alternation depth of unambiguous\ninterval logic is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.4672v1"
    },
    {
        "title": "The Join of the Varieties of R-trivial and L-trivial Monoids via\n  Combinatorics on Words",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The join of two varieties is the smallest variety containing both. In finite\nsemigroup theory, the varieties of R-trivial and L-trivial monoids are two of\nthe most prominent classes of finite monoids. Their join is known to be\ndecidable due to a result of Almeida and Azevedo. In this paper, we give a new\nproof for Almeida and Azevedo's effective characterization of the join of\nR-trivial and L-trivial monoids. This characterization is a single identity of\nomega-terms using three variables.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.5368v2"
    },
    {
        "title": "Implementing Turing Machines in Dynamic Field Architectures",
        "authors": [
            "Peter beim Graben",
            "Roland Potthast"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Cognitive computation such as e.g. language processing, is conventionally\nregarded as Turing computation, and Turing machines can be uniquely implemented\nas nonlinear dynamical systems using generalized shifts and subsequent G\\\"odel\nencoding of the symbolic repertoire. The resulting nonlinear dynamical automata\n(NDA) are piecewise affine-linear maps acting on the unit square that is\npartitioned into rectangular domains. Iterating a single point, i.e. a\nmicrostate, by the dynamics yields a trajectory of, in principle, infinitely\nmany points scattered through phase space. Therefore, the NDAs microstate\ndynamics does not necessarily terminate in contrast to its counterpart, the\nsymbolic dynamics obtained from the rectangular partition. In order to regain\nthe proper symbolic interpretation, one has to prepare ensembles of randomly\ndistributed microstates with rectangular supports. Only the resulting\nmacrostate evolution corresponds then to the original Turing machine\ncomputation. However, the introduction of random initial conditions into a\ndeterministic dynamics is not really satisfactory. As a possible solution for\nthis problem we suggest a change of perspective. Instead of looking at point\ndynamics in phase space, we consider functional dynamics of probability\ndistributions functions (p.d.f.s) over phase space. This is generally described\nby a Frobenius-Perron integral transformation that can be regarded as a neural\nfield equation over the unit square as feature space of a dynamic field theory\n(DFT). Solving the Frobenius-Perron equation, yields that uniform p.d.f.s with\nrectangular support are mapped onto uniform p.d.f.s with rectangular support,\nagain. Thus, the symbolically meaningful NDA macrostate dynamics becomes\nrepresented by iterated function dynamics in DFT; hence we call the resulting\nrepresentation dynamic field automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.5462v3"
    },
    {
        "title": "A Survey of Multi-Tape Automata",
        "authors": [
            "Carlo A. Furia"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper summarizes the fundamental expressiveness, closure, and\ndecidability properties of various finite-state automata classes with multiple\ninput tapes. It also includes an original algorithm for the intersection of\none-way nondeterministic finite-state automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.0178v2"
    },
    {
        "title": "Deciding Probabilistic Automata Weak Bisimulation in Polynomial Time",
        "authors": [
            "Holger Hermanns",
            "Andrea Turrini"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Deciding in an efficient way weak probabilistic bisimulation in the context\nof Probabilistic Automata is an open problem for about a decade. In this work\nwe close this problem by proposing a procedure that checks in polynomial time\nthe existence of a weak combined transition satisfying the step condition of\nthe bisimulation. We also present several extensions of weak combined\ntransitions, such as hyper-transitions and the new concepts of allowed weak\ncombined and hyper-transitions and of equivalence matching, that turn out to be\nverifiable in polynomial time as well. These results set the ground for the\ndevelopment of more effective compositional analysis algorithms for\nprobabilistic systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.0376v2"
    },
    {
        "title": "Derivatives of Approximate Regular Expressions",
        "authors": [
            "Jean-Marc Champarnaud",
            "Hadrien Jeanne",
            "Ludovic Mignot"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Our aim is to construct a finite automaton recognizing the set of words that\nare at a bounded distance from some word of a given regular language. We define\nnew regular operators, the similarity operators, based on a generalization of\nthe notion of distance and we introduce the family of regular expressions\nextended to similarity operators, that we call AREs (Approximate Regular\nExpressions). We set formulae to compute the Brzozowski derivatives and the\nAntimirov derivatives of an ARE, which allows us to give a solution to the ARE\nmembership problem and to provide the construction of two recognizers for the\nlanguage denoted by an ARE. As far as we know, the family of approximative\nregular expressions is introduced for the first time in this paper. Classical\napproximate regular expression matching algorithms are approximate matching\nalgorithms on regular expressions. Our approach is rather to process an exact\nmatching on approximate regular expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.1825v3"
    },
    {
        "title": "Structured Grammars are Effective",
        "authors": [
            "Ondřej Bílka"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Top-down parsing has received much attention recently. Parsing expression\ngrammars (PEG) allows construction of linear time parsers using packrat\nalgorithm. These techniques however suffer from problem of prefix hiding. We\nuse alternative formalism of relativized regular expressions REGREG for which\ntop-down backtracking parser runs in linear time. This formalism allows to\nconstruct fast parsers with modest memory requirements for practical grammars.\nWe show that our formalism is equivalent to PEG.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.1877v1"
    },
    {
        "title": "A note on the factorization conjecture",
        "authors": [
            "Clelia De Felice"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We give partial results on the factorization conjecture on codes proposed by\nSchutzenberger. We consider finite maximal codes C over the alphabet A = {a, b}\nwith C \\cap a^* = a^p, for a prime number p. Let P, S in Z <A>, with S = S_0 +\nS_1, supp(S_0) \\subset a^* and supp(S_1) \\subset a^*b supp(S_0). We prove that\nif (P,S) is a factorization for C then (P,S) is positive, that is P,S have\ncoefficients 0,1, and we characterize the structure of these codes. As a\nconsequence, we prove that if C is a finite maximal code such that each word in\nC has at most 4 occurrences of b's and a^p is in C, then each factorization for\nC is a positive factorization. We also discuss the structure of these codes.\nThe obtained results show once again relations between (positive)\nfactorizations and factorizations of cyclic groups.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.2310v2"
    },
    {
        "title": "Visibly pushdown automata on trees: universality and u-universality",
        "authors": [
            "Véronique Bruyère",
            "Marc Ducobu",
            "Olivier Gauwin"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  An automaton is universal if it accepts every possible input. We study the\nnotion of u-universality, which asserts that the automaton accepts every input\nstarting with u. Universality and u-universality are both EXPTIME-hard for\nnon-deterministic tree automata. We propose efficient antichain-based\ntechniques to address these problems for visibly pushdown automata operating on\ntrees. One of our approaches yields algorithms for the universality and\nu-universality of hedge automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.2841v1"
    },
    {
        "title": "Infinite Synchronizing Words for Probabilistic Automata (Erratum)",
        "authors": [
            "Laurent Doyen",
            "Thierry Massart",
            "Mahsa Shirmohammadi"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In [1], we introduced the weakly synchronizing languages for probabilistic\nautomata. In this report, we show that the emptiness problem of weakly\nsynchronizing languages for probabilistic automata is undecidable. This implies\nthat the decidability result of [1-3] for the emptiness problem of weakly\nsynchronizing language is incorrect.\n",
        "pdf_link": "http://arxiv.org/pdf/1206.0995v1"
    },
    {
        "title": "Algebraic Characterization of the Class of Languages recognized by\n  Measure Only Quantum Automata",
        "authors": [
            "Carlo Comin",
            "Maria Paola Bianchi"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study a model of one-way quantum automaton where only measurement\noperations are allowed (MOn-1qfa). We give an algebraic characterization of\nLMO, showing that the syntactic monoids of the languages in LMO are exactly the\nliteral pseudovariety of J-trivial literally idempotent monoids, where J is the\nGreen's relation determined by two-sided ideals. We also prove that LMO\ncoincides with the literal variety of literally idempotent piecewise testable\nregular languages. This allows us to prove the existence of a polynomial time\nalgorithm for deciding whether a regular language belongs to LMO.\n",
        "pdf_link": "http://arxiv.org/pdf/1206.1702v2"
    },
    {
        "title": "Left Recursion in Parsing Expression Grammars",
        "authors": [
            "Sérgio Medeiros",
            "Fabio Mascarenhas",
            "Roberto Ierusalimschy"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Parsing Expression Grammars (PEGs) are a formalism that can describe all\ndeterministic context-free languages through a set of rules that specify a\ntop-down parser for some language. PEGs are easy to use, and there are\nefficient implementations of PEG libraries in several programming languages.\n  A frequently missed feature of PEGs is left recursion, which is commonly used\nin Context-Free Grammars (CFGs) to encode left-associative operations. We\npresent a simple conservative extension to the semantics of PEGs that gives\nuseful meaning to direct and indirect left-recursive rules, and show that our\nextensions make it easy to express left-recursive idioms from CFGs in PEGs,\nwith similar results. We prove the conservativeness of these extensions, and\nalso prove that they work with any left-recursive PEG.\n  PEGs can also be compiled to programs in a low-level parsing machine. We\npresent an extension to the semantics of the operations of this parsing machine\nthat let it interpret left-recursive PEGs, and prove that this extension is\ncorrect with regards to our semantics for left-recursive PEGs.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.0443v3"
    },
    {
        "title": "Universal Witnesses for State Complexity of Basic Operations Combined\n  with Reversal",
        "authors": [
            "Janusz Brzozowski",
            "David Liu"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study the state complexity of boolean operations, concatenation and star\nwith one or two of the argument languages reversed. We derive tight upper\nbounds for the symmetric differences and differences of such languages. We\nprove that the previously discovered bounds for union, intersection,\nconcatenation and star of such languages can all be met by the recently\nintroduced universal witnesses and their variants.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.0535v1"
    },
    {
        "title": "Universal Witnesses for State Complexity of Boolean Operations and\n  Concatenation Combined with Star",
        "authors": [
            "Janusz Brzozowski",
            "David Liu"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study the state complexity of boolean operations and product\n(concatenation, catenation) combined with star. We derive tight upper bounds\nfor the symmetric differences and differences of two languages, one or both of\nwhich are starred, and for the product of two starred languages. We prove that\nthe previously discovered bounds for the union and the intersection of\nlanguages with one or two starred arguments, for the product of two languages\none of which is starred, and for the star of the product of two languages can\nall be met by the recently introduced universal witnesses and their variants.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.1982v1"
    },
    {
        "title": "The Cerny conjecture for automata respecting intervals of a directed\n  graph",
        "authors": [
            "M. Grech",
            "A. Kisielewicz"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The \\v{C}ern\\'y's conjecture states that for every synchronizing automaton\nwith n states there exists a reset word of length not exceeding (n-11)^2. We\nprove this conjecture for a class of automata preserving certain properties of\nintervals of a directed graph. Our result unifies and generalizes some earlier\nresults obtained by other authors.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.2556v1"
    },
    {
        "title": "A Proof of the Pumping Lemma for Context-Free Languages Through Pushdown\n  Automata",
        "authors": [
            "Antoine Amarilli",
            "Marc Jeanmougin"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The pumping lemma for context-free languages is a result about pushdown\nautomata which is strikingly similar to the well-known pumping lemma for\nregular languages. However, though the lemma for regular languages is simply\nproved by using the pigeonhole principle on deterministic automata, the lemma\nfor pushdown automata is proven through an equivalence with context-free\nlanguages and through the more powerful Ogden's lemma. We present here a proof\nof the pumping lemma for context-free languages which relies on pushdown\nautomata instead of context-free grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.2819v2"
    },
    {
        "title": "On the Relationship between LTL Normal Forms and Buechi Automata",
        "authors": [
            "Jianwen Li",
            "Geguang Pu",
            "Lijun Zhang",
            "Zheng Wang",
            "Jifeng He",
            "Kim G. Larsen"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this paper, we consider the problem of translating LTL formulas to Buechi\nautomata. We first translate the given LTL formula into a special\ndisjuctive-normal form (DNF). The formula will be part of the state, and its\nDNF normal form specifies the atomic properties that should hold immediately\n(labels of the transitions) and the formula that should hold afterwards (the\ncorresponding successor state). Surprisingly, if the given formula is\nUntil-free or Release-free, the Buechi automaton can be obtained directly in\nthis manner. For a general formula, the construction is slightly involved: an\nadditional component will be needed for each formula that helps us to identify\nthe set of accepting states. Notably, our construction is an on-the-fly\nconstruction, and the resulting Buechi automaton has in worst case 2^{2n+1}\nstates where n denotes the number of subformulas. Moreover, it has a better\nbound 2^{n+1} when the formula is Until- (or Release-) free.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.3866v1"
    },
    {
        "title": "Off-line test selection with test purposes for non-deterministic timed\n  automata",
        "authors": [
            "Nathalie Bertrand",
            "Thierry Jéron",
            "Amélie Stainer",
            "Moez Krichen"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This article proposes novel off-line test generation techniques from\nnon-deterministic timed automata with inputs and outputs (TAIOs) in the formal\nframework of the tioco conformance theory. In this context, a first problem is\nthe determinization of TAIOs, which is necessary to foresee next enabled\nactions after an observable trace, but is in general impossible because not all\ntimed automata are determinizable. This problem is solved thanks to an\napproximate determinization using a game approach. The algorithm performs an\nio-abstraction which preserves the tioco conformance relation and thus\nguarantees the soundness of generated test cases. A second problem is the\nselection of test cases from a TAIO specification. The selection here relies on\na precise description of timed behaviors to be tested which is carried out by\nexpressive test purposes modeled by a generalization of TAIOs. Finally, an\nalgorithm is described which generates test cases in the form of TAIOs equipped\nwith verdicts, using a symbolic co-reachability analysis guided by the test\npurpose. Properties of test cases are then analyzed with respect to the\nprecision of the approximate determinization: when determinization is exact,\nwhich is the case on known determinizable classes, in addition to soundness,\nproperties characterizing the adequacy of test cases verdicts are also\nguaranteed.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.6267v3"
    },
    {
        "title": "On the Existence of Universal Finite or Pushdown Automata",
        "authors": [
            "Manfred Kudlek"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate the (non)-existence of universal automata for some classes of\nautomata, such as finite automata and pushdown automata, and in particular the\ninfluence of the representation and encoding function. An alternative approach,\nusing transition systems, is presented too.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.7149v1"
    },
    {
        "title": "Embracing divergence: a formalism for when your semiring is simply not\n  complete, with applications in quantum simulation",
        "authors": [
            "Gregory Crosswhite"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  There is a fundamental difficulty in generalizing weighted automata to the\ncase of infinite words: in general the infinite sum-of-products from which the\nweight of a given word is derived will diverge. Many solutions to this problem\nhave been proposed, including restricting the type of weights used and\nemploying a different valuation function that forces convergence. In this paper\nwe describe an alternative approach that, rather than seeking to avoid the\ninevitable divergences, instead embraces them as a source of useful\ninformation. Specifically, rather than taking coefficients from an arbitrary\nsemiring S we instead take them from S^N. Doing this is useful because it gives\nus information about how the weight of an infinite word does or does not\ndiverge, and if it does diverge what form the divergence takes --- e.g.,\npolynomial, exponential, etc. This approach has proved to be incredibly useful\nin the field of quantum simulation because when studying infinite systems,\ninformation about how quantities of interest, such as energy or magnetization,\ndiverge is exactly what we want.\n  In this paper we introduce a new kind of automaton which we call a diverging\nautomaton that maps infinite words to sequences of weights from a semiring and\nwhich employs a Buchi-like boundary condition. We then develop a theory for\ndiverging power series and prove a Kleene Theorem connecting rational diverging\npower series to diverging automata. Afterward we repeat this process by\nintroducing bidiverging automata which map biinfinite words to elements in S^(Z\nx N), developing a theory for bidiverging power series, and proving another\nKleene Theorem. We conclude by describing how bidiverging automata are applied\nto simulate biinfinite quantum systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.0659v2"
    },
    {
        "title": "The Power of Centralized PC Systems of Pushdown Automata",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Parallel communicating systems of pushdown automata (PCPA) were introduced in\n(Csuhaj-Varj{\\'u} et. al. 2000) and in their centralized variants shown to be\nable to simulate nondeterministic one-way multi-head pushdown automata. A\nclaimed converse simulation for returning mode (Balan 2009) turned out to be\nincomplete (Otto 2012) and a language was suggested for separating these PCPA\nof degree two (number of pushdown automata) from nondeterministic one-way\ntwo-head pushdown automata. We show that the suggested language can be accepted\nby the latter computational model. We present a different example over a single\nletter alphabet indeed ruling out the possibility of a simulation between the\nmodels. The open question about the power of centralized PCPA working in\nreturning mode is then settled by showing them to be universal. Since the\nconstruction is possible using systems of degree two, this also improves the\nprevious bound three for generating all recursively enumerable languages.\nFinally PCPAs are restricted in such a way that a simulation by multi-head\nautomata is possible.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.1283v2"
    },
    {
        "title": "Partially-commutative context-free languages",
        "authors": [
            "Wojciech Czerwiński",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The paper is about a class of languages that extends context-free languages\n(CFL) and is stable under shuffle. Specifically, we investigate the class of\npartially-commutative context-free languages (PCCFL), where non-terminal\nsymbols are commutative according to a binary independence relation, very much\nlike in trace theory. The class has been recently proposed as a robust class\nsubsuming CFL and commutative CFL. This paper surveys properties of PCCFL. We\nidentify a natural corresponding automaton model: stateless multi-pushdown\nautomata. We show stability of the class under natural operations, including\nhomomorphic images and shuffle. Finally, we relate expressiveness of PCCFL to\ntwo other relevant classes: CFL extended with shuffle and trace-closures of\nCFL. Among technical contributions of the paper are pumping lemmas, as an\nelegant completion of known pumping properties of regular languages, CFL and\ncommutative CFL.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2747v1"
    },
    {
        "title": "The Chomsky-Schützenberger Theorem for Quantitative Context-Free\n  Languages",
        "authors": [
            "Manfred Droste",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Weighted automata model quantitative aspects of systems like the consumption\nof resources during executions. Traditionally, the weights are assumed to form\nthe algebraic structure of a semiring, but recently also other weight\ncomputations like average have been considered. Here, we investigate\nquantitative context-free languages over very general weight structures\nincorporating all semirings, average computations, lattices, and more. In our\nmain result, we derive the fundamental Chomsky-Sch\\\"utzenberger theorem for\nsuch quantitative context-free languages, showing that each arises as the image\nof a Dyck language and a regular language under a suitable morphism. Moreover,\nwe show that quantitative context-free language are expressively equivalent to\na model of weighted pushdown automata. This generalizes results previously\nknown only for semirings. We also investigate when quantitative context-free\nlanguages assume only finitely many values.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.3942v2"
    },
    {
        "title": "Syntactic Complexity of R- and J-Trivial Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Baiyu Li"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The syntactic complexity of a regular language is the cardinality of its\nsyntactic semigroup. The syntactic complexity of a subclass of the class of\nregular languages is the maximal syntactic complexity of languages in that\nclass, taken as a function of the state complexity n of these languages. We\nstudy the syntactic complexity of R- and J-trivial regular languages, and prove\nthat n! and floor of [e(n-1)!] are tight upper bounds for these languages,\nrespectively. We also prove that 2^{n-1} is the tight upper bound on the state\ncomplexity of reversal of J-trivial regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.4650v2"
    },
    {
        "title": "A Note on Limited Pushdown Alphabets in Stateless Deterministic Pushdown\n  Automata",
        "authors": [
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Recently, an infinite hierarchy of languages accepted by stateless\ndeterministic pushdown automata has been established based on the number of\npushdown symbols. However, the witness language for the n-th level of the\nhierarchy is over an input alphabet with 2(n-1) elements. In this paper, we\nimprove this result by showing that a binary alphabet is sufficient to\nestablish this hierarchy. As a consequence of our construction, we solve the\nopen problem formulated by Meduna et al. Then we extend these results to\nm-state realtime deterministic pushdown automata, for all m at least 1. The\nexistence of such a hierarchy for m-state deterministic pushdown automata is\nleft open.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5002v1"
    },
    {
        "title": "Piecewise testable tree languages",
        "authors": [
            "Mikołaj Bojańczyk",
            "Luc Segoufin",
            "Howard Straubing"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper presents a decidable characterization of tree languages that can\nbe defined by a boolean combination of Sigma_1 sentences. This is a tree\nextension of the Simon theorem, which says that a string language can be\ndefined by a boolean combination of Sigma_1 sentences if and only if its\nsyntactic monoid is J-trivial.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5129v2"
    },
    {
        "title": "Forward and Backward Application of Symbolic Tree Transducers",
        "authors": [
            "Zoltán Fülöp",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We consider symbolic tree automata (sta) and symbolic tree transducers (stt).\nWe characterize s-recognizable tree languages (which are the tree languages\nrecognizable by sta) in terms of (classical) recognizable tree languages and\nrelabelings. We prove that sta and the recently introduced variable tree\nautomata are incomparable with respect to their recognition power. We define\nsymbolic regular tree grammars and characterize s-regular tree languages in\nterms of regular tree languages and relabelings. As a consequence, we obtain\nthat s-recognizable tree languages are the same as s-regular tree languages.\n  We show that the syntactic composition of two stt computes the composition of\nthe tree transformations computed by each stt, provided that (1) the first one\nis deterministic or the second one is linear and (2) the first one is total or\nthe second is nondeleting. We consider forward application and backward\napplication of stt and prove that the backward application of an stt to any\ns-recognizable tree language yields an s-recognizable tree language. We give a\nlinear stt of which the range is not an s-recognizable tree language. We show\nthat the forward application of simple and linear stt preserves\ns-recognizability. As a corollary, we obtain that the type checking problem of\nsimple and linear stt and the inverse type checking problem of arbitrary stt is\ndecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5324v1"
    },
    {
        "title": "On sets of numbers rationally represented in a rational base number\n  system",
        "authors": [
            "Victor Marsault",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this work, it is proved that a set of numbers closed under addition and\nwhose representations in a rational base numeration system is a rational\nlanguage is not a finitely generated additive monoid.\n  A key to the proof is the definition of a strong combinatorial property on\nlanguages : the bounded left iteration property. It is both an unnatural\nproperty in usual formal language theory (as it contradicts any kind of pumping\nlemma) and an ideal fit to the languages defined through rational base number\nsystems.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5412v2"
    },
    {
        "title": "In the Maze of Data Languages",
        "authors": [
            "Loris D'Antoni"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In data languages the positions of strings and trees carry a label from a\nfinite alphabet and a data value from an infinite alphabet. Extensions of\nautomata and logics over finite alphabets have been defined to recognize data\nlanguages, both in the string and tree cases. In this paper we describe and\ncompare the complexity and expressiveness of such models to understand which\nones are better candidates as regular models.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5980v1"
    },
    {
        "title": "Ostrowski Numeration and the Local Period of Sturmian Words",
        "authors": [
            "Luke Schaeffer"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We show that the local period at position n in a characteristic Sturmian word\ncan be given in terms of the Ostrowski representation for n + 1.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2343v1"
    },
    {
        "title": "Learn with SAT to Minimize Büchi Automata",
        "authors": [
            "Stephan Barth",
            "Martin Hofmann"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We describe a minimization procedure for nondeterministic B\\\"uchi automata\n(NBA). For an automaton A another automaton A_min with the minimal number of\nstates is learned with the help of a SAT-solver.\n  This is done by successively computing automata A' that approximate A in the\nsense that they accept a given finite set of positive examples and reject a\ngiven finite set of negative examples. In the course of the procedure these\nexample sets are successively increased. Thus, our method can be seen as an\ninstance of a generic learning algorithm based on a \"minimally adequate\nteacher\" in the sense of Angluin.\n  We use a SAT solver to find an NBA for given sets of positive and negative\nexamples. We use complementation via construction of deterministic parity\nautomata to check candidates computed in this manner for equivalence with A.\nFailure of equivalence yields new positive or negative examples. Our method\nproved successful on complete samplings of small automata and of quite some\nexamples of bigger automata.\n  We successfully ran the minimization on over ten thousand automata with\nmostly up to ten states, including the complements of all possible automata\nwith two states and alphabet size three and discuss results and runtimes;\nsingle examples had over 100 states.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2452v1"
    },
    {
        "title": "Higher-Order Pushdown Systems with Data",
        "authors": [
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We propose a new extension of higher-order pushdown automata, which allows to\nuse an infinite alphabet. The new automata recognize languages of data words\n(instead of normal words), which beside each its letter from a finite alphabet\nhave a data value from an infinite alphabet. Those data values can be loaded to\nthe stack of the automaton, and later compared with some farther data values on\nthe input. Our main purpose for introducing these automata is that they may\nhelp in analyzing normal automata (without data). As an example, we give a\nproof that deterministic automata with collapse can recognize more languages\nthan deterministic automata without collapse. This proof is simpler than in the\nno-data case. We also state a hypothesis how the new automaton model can be\nrelated to the original model of higher-order pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2460v1"
    },
    {
        "title": "Unambiguous Tree Languages Are Topologically Harder Than Deterministic\n  Ones",
        "authors": [
            "Szczepan Hummel"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The paper gives an example of a tree language G that is recognised by an\nunambiguous parity automaton and is analytic-complete as a set in Cantor space.\nThis already shows that the unambiguous languages are topologically more\ncomplex than the deterministic ones, that are all coanalytic.\n  Using set G as a building block we construct an unambiguous language that is\ntopologically harder than any countable boolean combination of analytic and\ncoanalytic sets. In particular the language is harder than any set in\ndifference hierarchy of analytic sets considered by O.Finkel and P.Simonnet in\nthe context of nondeterministic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2463v1"
    },
    {
        "title": "Combining Insertion and Deletion in RNA-editing Preserves Regularity",
        "authors": [
            "E. P. de Vink",
            "H. Zantema",
            "D. Bošnački"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Inspired by RNA-editing as occurs in transcriptional processes in the living\ncell, we introduce an abstract notion of string adjustment, called guided\nrewriting. This formalism allows simultaneously inserting and deleting\nelements. We prove that guided rewriting preserves regularity: for every\nregular language its closure under guided rewriting is regular too. This\ncontrasts an earlier abstraction of RNA-editing separating insertion and\ndeletion for which it was proved that regularity is not preserved. The\nparticular automaton construction here relies on an auxiliary notion of slice\nsequence which enables to sweep from left to right through a completed rewrite\nsequence.\n",
        "pdf_link": "http://arxiv.org/pdf/1211.4092v1"
    },
    {
        "title": "Converting Nondeterministic Automata and Context-Free Grammars into\n  Parikh Equivalent One-Way and Two-Way Deterministic Automata",
        "authors": [
            "Giovanna J. Lavado",
            "Giovanni Pighizzini",
            "Shinnosuke Seki"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate the conversion of one-way nondeterministic finite automata and\ncontext-free grammars into Parikh equivalent one-way and two-way deterministic\nfinite automata, from a descriptional complexity point of view.\n  We prove that for each one-way nondeterministic automaton with $n$ states\nthere exist Parikh equivalent one-way and two-way deterministic automata with\n$e^{O(\\sqrt{n \\ln n})}$ and $p(n)$ states, respectively, where $p(n)$ is a\npolynomial. Furthermore, these costs are tight. In contrast, if all the words\naccepted by the given automaton contain at least two different letters, then a\nParikh equivalent one-way deterministic automaton with a polynomial number of\nstates can be found.\n  Concerning context-free grammars, we prove that for each grammar in Chomsky\nnormal form with h variables there exist Parikh equivalent one-way and two-way\ndeterministic automata with $2^{O(h^2)}$ and $2^{O(h)}$ states, respectively.\nEven these bounds are tight.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.1346v2"
    },
    {
        "title": "A General Framework for the Derivation of Regular Expressions",
        "authors": [
            "Pascal Caron",
            "Jean-Marc Champarnaud",
            "Ludovic Mignot"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The aim of this paper is to design a theoretical framework that allows us to\nperform the computation of regular expression derivatives through a space of\ngeneric structures. Thanks to this formalism, the main properties of regular\nexpression derivation, such as the finiteness of the set of derivatives, need\nonly be stated and proved one time, at the top level. Moreover, it is shown how\nto construct an alternating automaton associated with the derivation of a\nregular expression in this general framework. Finally, Brzozowski's derivation\nand Antimirov's derivation turn out to be a particular case of this general\nscheme and it is shown how to construct a DFA, a NFA and an AFA for both of\nthese derivations.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.5003v1"
    },
    {
        "title": "Regular Cost Functions, Part I: Logic and Algebra over Words",
        "authors": [
            "Thomas Colcombet"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The theory of regular cost functions is a quantitative extension to the\nclassical notion of regularity. A cost function associates to each input a\nnon-negative integer value (or infinity), as opposed to languages which only\nassociate to each input the two values \"inside\" and \"outside\". This theory is a\ncontinuation of the works on distance automata and similar models. These models\nof automata have been successfully used for solving the star-height problem,\nthe finite power property, the finite substitution problem, the relative\ninclusion star-height problem and the boundedness problem for monadic-second\norder logic over words. Our notion of regularity can be -- as in the classical\ntheory of regular languages -- equivalently defined in terms of automata,\nexpressions, algebraic recognisability, and by a variant of the monadic\nsecond-order logic. These equivalences are strict extensions of the\ncorresponding classical results. The present paper introduces the cost monadic\nlogic, the quantitative extension to the notion of monadic second-order logic\nwe use, and show that some problems of existence of bounds are decidable for\nthis logic. This is achieved by introducing the corresponding algebraic\nformalism: stabilisation monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.6937v3"
    },
    {
        "title": "Composition Closure of Linear Extended Top-down Tree Transducers",
        "authors": [
            "Zoltán Fülöp",
            "Andreas Maletti"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Linear extended top-down tree transducers (or synchronous tree-substitution\ngrammars) are popular formal models of tree transformations. The expressive\npower of compositions of such transducers with and without regular look-ahead\nis investigated. In particular, the restrictions of nondeletion,\nepsilon-freeness, and strictness are considered. The composition hierarchy\nturns out to be finite for all epsilon-free (all rules consume input) variants\nof these transducers except for nondeleting epsilon-free linear extended\ntop-down tree transducers. The least number of transducers needed for the full\nexpressive power of arbitrary compositions is presented. In all remaining cases\n(including nondeleting epsilon-free linear extended top-down tree transducers)\nthe composition hierarchy does not collapse.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.1514v1"
    },
    {
        "title": "Three Simulation Algorithms for Labelled Transition Systems",
        "authors": [
            "Gérard Cécé"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Algorithms which compute the coarsest simulation preorder are generally\ndesigned on Kripke structures. Only in a second time they are extended to\nlabelled transition systems. By doing this, the size of the alphabet appears in\ngeneral as a multiplicative factor to both time and space complexities. Let $Q$\ndenotes the state space, $\\rightarrow$ the transition relation, $\\Sigma$ the\nalphabet and $P_{sim}$ the partition of $Q$ induced by the coarsest simulation\nequivalence. In this paper, we propose a base algorithm which minimizes, since\nthe first stages of its design, the incidence of the size of the alphabet in\nboth time and space complexities. This base algorithm, inspired by the one of\nPaige and Tarjan in 1987 for bisimulation and the one of Ranzato and Tapparo in\n2010 for simulation, is then derived in three versions. One of them has the\nbest bit space complexity up to now,\n$O(|P_{sim}|^2+|{\\rightarrow}|.\\log|{\\rightarrow}|)$, while another one has the\nbest time complexity up to now, $O(|P_{sim}|.|{\\rightarrow}|)$. Note the\nabsence of the alphabet in these complexities. A third version happens to be a\nnice compromise between space and time since it runs in\n$O(b.|P_{sim}|.|{\\rightarrow}|)$ time, with $b$ a branching factor generally\nfar below $|P_{sim}|$, and uses\n$O(|P_{sim}|^2.\\log|P_{sim}|+|{\\rightarrow}|.\\log|{\\rightarrow}|)$ bits.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.1638v1"
    },
    {
        "title": "The Černý conjecture for small automata: experimental report",
        "authors": [
            "Jakub Kowalski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We present a report from a series of experiments involving computation of the\nshortest reset words for automata with small number of states. We confirm that\nthe \\v{C}ern\\'{y} conjecture is true for all automata with at most 11 states on\n2 letters. Also some new interesting results were obtained, including the third\ngap in the distribution of the shortest reset words and new slowly\nsynchronizing classes of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.2092v1"
    },
    {
        "title": "Equivalence of Deterministic One-Counter Automata is NL-complete",
        "authors": [
            "Stanislav Böhm",
            "Stefan Göller",
            "Petr Jančar"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We prove that language equivalence of deterministic one-counter automata is\nNL-complete. This improves the superpolynomial time complexity upper bound\nshown by Valiant and Paterson in 1975. Our main contribution is to prove that\ntwo deterministic one-counter automata are inequivalent if and only if they can\nbe distinguished by a word of length polynomial in the size of the two input\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.2181v1"
    },
    {
        "title": "Operator Precedence ω-languages",
        "authors": [
            "Federica Panella",
            "Matteo Pradella",
            "Dino Mandrioli",
            "Violetta Lonati"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  \\omega-languages are becoming more and more relevant nowadays when most\napplications are 'ever-running'. Recent literature, mainly under the motivation\nof widening the application of model checking techniques, extended the analysis\nof these languages from the simple regular ones to various classes of languages\nwith 'visible syntax structure', such as visibly pushdown languages (VPLs).\nOperator precedence languages (OPLs), instead, were originally defined to\nsupport deterministic parsing and, though seemingly unrelated, exhibit\ninteresting relations with these classes of languages: OPLs strictly include\nVPLs, enjoy all relevant closure properties and have been characterized by a\nsuitable automata family and a logic notation. In this paper we introduce\noperator precedence \\omega-languages (\\omega OPLs), investigating various\nacceptance criteria and their closure properties. Whereas some properties are\nnatural extensions of those holding for regular languages, others required\nnovel investigation techniques. Application-oriented examples show the gain in\nexpressiveness and verifiability offered by \\omega OPLs w.r.t. smaller classes.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.2476v2"
    },
    {
        "title": "Ultimate periodicity of b-recognisable sets : a quasilinear procedure",
        "authors": [
            "Victor Marsault",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  It is decidable if a set of numbers, whose representation in a base b is a\nregular language, is ultimately periodic. This was established by Honkala in\n1986.\n  We give here a structural description of minimal automata that accept an\nultimately periodic set of numbers. We then show that it can verified in linear\ntime if a given minimal automaton meets this description.\n  This thus yields a O(n log(n)) procedure for deciding whether a general\ndeterministic automaton accepts an ultimately periodic set of numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.2691v2"
    },
    {
        "title": "Two-Sided Derivatives for Regular Expressions and for Hairpin\n  Expressions",
        "authors": [
            "Jean-Marc Champarnaud",
            "Jean-Philippe Dubernard",
            "Hadrien Jeanne",
            "Ludovic Mignot"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The aim of this paper is to design the polynomial construction of a finite\nrecognizer for hairpin completions of regular languages. This is achieved by\nconsidering completions as new expression operators and by applying derivation\ntechniques to the associated extended expressions called hairpin expressions.\nMore precisely, we extend partial derivation of regular expressions to\ntwo-sided partial derivation of hairpin expressions and we show how to deduce a\nrecognizer for a hairpin expression from its two-sided derived term automaton,\nproviding an alternative proof of the fact that hairpin completions of regular\nlanguages are linear context-free.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.3316v1"
    },
    {
        "title": "(Extended Version) Algebraic Characterization of the Class of Languages\n  recognized by Measure Only Quantum Automata",
        "authors": [
            "Carlo Comin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study a model of one-way quantum automaton where only measurement\noperations are allowed ($\\mon$). We give an algebraic characterization of\n$\\lmo(\\Sigma)$, showing that the syntactic monoids of the languages in\n$\\lmo(\\Sigma)$ are exactly the $J$-trivial literally idempotent syntactic\nmonoids, where $J$ is the Green's relation determined by two-sided ideals. We\nalso prove that $\\lmo(\\Sigma)$ coincides with the literal variety of literally\nidempotent piecewise testable regular languages. This allows us to prove the\nexistence of a polynomial time algorithm for deciding whether a regular\nlanguage belongs to $\\lmo(\\Sigma)$ and to discuss definability issues in terms\nof the existential first-order logic $\\Sigma_1[<]$ and the linear temporal\nlogic without the next operator LTLWN.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.3931v3"
    },
    {
        "title": "Minimal Nondeterministic Finite Automata and Atoms of Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Hellis Tamm"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We examine the NFA minimization problem in terms of atomic NFA's, that is,\nNFA's in which the right language of every state is a union of atoms, where the\natoms of a regular language are non-empty intersections of complemented and\nuncomplemented left quotients of the language. We characterize all reduced\natomic NFA's of a given language, that is, those NFA's that have no equivalent\nstates. Using atomic NFA's, we formalize Sengoku's approach to NFA minimization\nand prove that his method fails to find all minimal NFA's. We also formulate\nthe Kameda-Weiner NFA minimization in terms of quotients and atoms.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.5585v1"
    },
    {
        "title": "Weak Concurrent Kleene Algebra with Application to Algebraic\n  Verification",
        "authors": [
            "Annabelle McIver",
            "Tahiry Rabehaja",
            "Georg Struth"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We propose a generalisation of concurrent Kleene algebra \\cite{Hoa09} that\ncan take account of probabilistic effects in the presence of concurrency. The\nalgebra is proved sound with respect to a model of automata modulo a variant of\nrooted $\\eta$-simulation equivalence. Applicability is demonstrated by\nalgebraic treatments of two examples: algebraic may testing and Rabin's\nsolution to the choice coordination problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.7153v1"
    },
    {
        "title": "Incomplete Transition Complexity of Basic Operations on Finite Languages",
        "authors": [
            "Eva Maia",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The state complexity of basic operations on finite languages (considering\ncomplete DFAs) has been in studied the literature. In this paper we study the\nincomplete (deterministic) state and transition complexity on finite languages\nof boolean operations, concatenation, star, and reversal. For all operations we\ngive tight upper bounds for both description measures. We correct the published\nstate complexity of concatenation for complete DFAs and provide a tight upper\nbound for the case when the right automaton is larger than the left one. For\nall binary operations the tightness is proved using family languages with a\nvariable alphabet size. In general the operational complexities depend not only\non the complexities of the operands but also on other refined measures.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.0750v1"
    },
    {
        "title": "Unifying Büchi Complementation Constructions",
        "authors": [
            "Seth J. Fogarty",
            "Orna Kupferman",
            "Thomas Wilke",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Complementation of B\\\"uchi automata, required for checking automata\ncontainment, is of major theoretical and practical interest in formal\nverification. We consider two recent approaches to complementation. The first\nis the rank-based approach of Kupferman and Vardi, which operates over a DAG\nthat embodies all runs of the automaton. This approach is based on the\nobservation that the vertices of this DAG can be ranked in a certain way,\ntermed an odd ranking, iff all runs are rejecting. The second is the\nslice-based approach of K\\\"ahler and Wilke. This approach tracks levels of\n\"split trees\" - run trees in which only essential information about the history\nof each run is maintained. While the slice-based construction is conceptually\nsimple, the complementing automata it generates are exponentially larger than\nthose of the recent rank-based construction of Schewe, and it suffers from the\ndifficulty of symbolically encoding levels of split trees. In this work we\nreformulate the slice-based approach in terms of run DAGs and preorders over\nstates. In doing so, we begin to draw parallels between the rank-based and\nslice-based approaches. Through deeper analysis of the slice-based approach, we\nstrongly restrict the nondeterminism it generates. We are then able to employ\nthe slice-based approach to provide a new odd ranking, called a retrospective\nranking, that is different from the one provided by Kupferman and Vardi. This\nnew ranking allows us to construct a deterministic-in-the-limit rank-based\nautomaton with a highly restricted transition function. Further, by phrasing\nthe slice-based approach in terms of ranks, our approach affords a simple\nsymbolic encoding and achieves the tight bound of Schewe's construction\n",
        "pdf_link": "http://arxiv.org/pdf/1302.2675v2"
    },
    {
        "title": "On the Complexity of Equivalence and Minimisation for Q-weighted\n  Automata",
        "authors": [
            "Stefan Kiefer",
            "Andrzej Murawski",
            "Joel Ouaknine",
            "Bjoern Wachter",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper is concerned with the computational complexity of equivalence and\nminimisation for automata with transition weights in the field Q of rational\nnumbers. We use polynomial identity testing and the Isolation Lemma to obtain\ncomplexity bounds, focussing on the class NC of problems within P solvable in\npolylogarithmic parallel time. For finite Q-weighted automata, we give a\nrandomised NC procedure that either outputs that two automata are equivalent or\nreturns a word on which they differ. We also give an NC procedure for deciding\nwhether a given automaton is minimal, as well as a randomised NC procedure that\nminimises an automaton. We consider probabilistic automata with rewards,\nsimilar to Markov Decision Processes. For these automata we consider two\nnotions of equivalence: expectation equivalence and distribution equivalence.\nThe former requires that two automata have the same expected reward on each\ninput word, while the latter requires that each input word induce the same\ndistribution on rewards in each automaton. For both notions we give algorithms\nfor deciding equivalence by reduction to equivalence of Q-weighted automata.\nFinally we show that the equivalence problem for Q-weighted visibly pushdown\nautomata is logspace equivalent to the polynomial identity testing problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.2818v2"
    },
    {
        "title": "Reachability in Two-Clock Timed Automata is PSPACE-complete",
        "authors": [
            "John Fearnley",
            "Marcin Jurdziński"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A recent result of Haase et al. has shown that reachability in two-clock\ntimed automata is log-space equivalent to reachability in bounded one-counter\nautomata. We show that reachability in bounded one-counter automata is\nPSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.3109v2"
    },
    {
        "title": "Bisimulations over DLTS in O(m.log n)-time",
        "authors": [
            "Gérard Cece"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The well known Hopcroft's algorithm to minimize deterministic complete\nautomata runs in $O(kn\\log n)$-time, where $k$ is the size of the alphabet and\n$n$ the number of states. The main part of this algorithm corresponds to the\ncomputation of a coarsest bisimulation over a finite Deterministic Labelled\nTransition System (DLTS). By applying techniques we have developed in the case\nof simulations, we design a new algorithm which computes the coarsest\nbisimulation over a finite DLTS in $O(m\\log n)$-time and $O(k+m+n)$-space, with\n$m$ the number of transitions. The underlying DLTS does not need to be complete\nand thus: $m\\leq kn$. This new algorithm is much simpler than the two others\nfound in the literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.3489v1"
    },
    {
        "title": "Silent Transitions in Automata with Storage",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We consider the computational power of silent transitions in one-way automata\nwith storage. Specifically, we ask which storage mechanisms admit a\ntransformation of a given automaton into one that accepts the same language and\nreads at least one input symbol in each step.\n  We study this question using the model of valence automata. Here, a finite\nautomaton is equipped with a storage mechanism that is given by a monoid.\n  This work presents generalizations of known results on silent transitions.\nFor two classes of monoids, it provides characterizations of those monoids that\nallow the removal of \\lambda-transitions. Both classes are defined by graph\nproducts of copies of the bicyclic monoid and the group of integers. The first\nclass contains pushdown storages as well as the blind counters while the second\nclass contains the blind and the partially blind counters.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.3798v1"
    },
    {
        "title": "Maximal Syntactic Complexity of Regular Languages Implies Maximal\n  Quotient Complexities of Atoms",
        "authors": [
            "Janusz Brzozowski",
            "Gareth Davies"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We relate two measures of complexity of regular languages. The first is\nsyntactic complexity, that is, the cardinality of the syntactic semigroup of\nthe language. That semigroup is isomorphic to the semigroup of transformations\nof states induced by non-empty words in the minimal deterministic finite\nautomaton accepting the language. If the language has n left quotients (its\nminimal automaton has n states), then its syntactic complexity is at most n^n\nand this bound is tight. The second measure consists of the quotient (state)\ncomplexities of the atoms of the language, where atoms are non-empty\nintersections of complemented and uncomplemented quotients. A regular language\nhas at most 2^n atoms and this bound is tight. The maximal quotient complexity\nof any atom with r complemented quotients is 2^n-1, if r=0 or r=n, and\n1+\\sum_{k=1}^{r} \\sum_{h=k+1}^{k+n-r} \\binom{h}{n} \\binom{k}{h}, otherwise. We\nprove that if a language has maximal syntactic complexity, then it has 2^n\natoms and each atom has maximal quotient complexity, but the converse is false.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.3906v2"
    },
    {
        "title": "Fresh-Variable Automata for Service Composition",
        "authors": [
            "Walid Belkhir",
            "Yannick Chevalier",
            "Michael Rusinowitch"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  To model Web services handling data from an infinite domain, or with multiple\nsessions, we introduce fresh-variable automata, a simple extension of\nfinite-state automata in which some transitions are labeled with variables that\ncan be refreshed in some specified states. We prove several closure properties\nfor this class of automata and study their decision problems. We then introduce\na notion of simulation that enables us to reduce the Web service composition\nproblem to the construction of a simulation of a target service by the\nasynchronous product of existing services, and prove that this construction is\ncomputable.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.4205v3"
    },
    {
        "title": "Primitive digraphs with large exponents and slowly synchronizing\n  automata",
        "authors": [
            "Dmitry S. Ananichev",
            "Vladimir V. Gusev",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We present several infinite series of synchronizing automata for which the\nminimum length of reset words is close to the square of the number of states.\nAll these automata are tightly related to primitive digraphs with large\nexponent.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.5793v2"
    },
    {
        "title": "Efficient Separability of Regular Languages by Subsequences and Suffixes",
        "authors": [
            "Wojciech Czerwiński",
            "Wim Martens",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  When can two regular word languages K and L be separated by a simple\nlanguage? We investigate this question and consider separation by piecewise-\nand suffix-testable languages and variants thereof. We give characterizations\nof when two languages can be separated and present an overview of when these\nproblems can be decided in polynomial time if K and L are given by\nnondeterministic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.0966v1"
    },
    {
        "title": "The separation problem for regular languages by piecewise testable\n  languages",
        "authors": [
            "Lorijn van Rooijen",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Separation is a classical problem in mathematics and computer science. It\nasks whether, given two sets belonging to some class, it is possible to\nseparate them by another set of a smaller class. We present and discuss the\nseparation problem for regular languages. We then give a direct polynomial time\nalgorithm to check whether two given regular languages are separable by a\npiecewise testable language, that is, whether a $B{\\Sigma}1(<)$ sentence can\nwitness that the languages are indeed disjoint. The proof is a reformulation\nand a refinement of an algebraic argument already given by Almeida and the\nsecond author.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.2143v1"
    },
    {
        "title": "Quantum finite automata and linear context-free languages: a decidable\n  problem",
        "authors": [
            "A. Bertoni",
            "Ch. Choffrut",
            "F. D'Alessandro"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We consider the so-called measure once finite quantum automata model\nintroduced by Moore and Crutchfield in 2000. We show that given a language\nrecognized by such a device and a linear context-free language, it is\nrecursively decidable whether or not they have a nonempty intersection. This\nextends a result of Blondel et al. which can be interpreted as solving the\nproblem with the free monoid in place of the family of linear context-free\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.2967v1"
    },
    {
        "title": "Revisiting the Equivalence Problem for Finite Multitape Automata",
        "authors": [
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The decidability of determining equivalence of deterministic multitape\nautomata (or transducers) was a longstanding open problem until it was resolved\nby Harju and Karhum\\\"{a}ki in the early 1990s. Their proof of decidability\nyields a co_NP upper bound, but apparently not much more is known about the\ncomplexity of the problem. In this paper we give an alternative proof of\ndecidability, which follows the basic strategy of Harju and Karhumaki but\nreplaces their use of group theory with results on matrix algebras. From our\nproof we obtain a simple randomised algorithm for deciding language equivalence\nof deterministic multitape automata and, more generally, multiplicity\nequivalence of nondeterministic multitape automata. The algorithm involves only\nmatrix exponentiation and runs in polynomial time for each fixed number of\ntapes. If the two input automata are inequivalent then the algorithm outputs a\nword on which they differ.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.6704v2"
    },
    {
        "title": "On the State Complexity of the Reverse of R- and J-trivial Regular\n  Languages",
        "authors": [
            "Galina Jirásková",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The tight upper bound on the state complexity of the reverse of R-trivial and\nJ-trivial regular languages of the state complexity n is 2^{n-1}. The witness\nis ternary for R-trivial regular languages and (n-1)-ary for J-trivial regular\nlanguages. In this paper, we prove that the bound can be met neither by a\nbinary R-trivial regular language nor by a J-trivial regular language over an\n(n-2)-element alphabet. We provide a characterization of tight bounds for\nR-trivial regular languages depending on the state complexity of the language\nand the size of its alphabet. We show the tight bound for J-trivial regular\nlanguages over an (n-2)-element alphabet and a few tight bounds for binary\nJ-trivial regular languages. The case of J-trivial regular languages over an\n(n-k)-element alphabet, for 2 <= k <= n-3, is open.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.0733v2"
    },
    {
        "title": "On the Relation between Context-Free Grammars and Parsing Expression\n  Grammars",
        "authors": [
            "Fabio Mascarenhas",
            "Sérgio Medeiros",
            "Roberto Ierusalimschy"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Context-Free Grammars (CFGs) and Parsing Expression Grammars (PEGs) have\nseveral similarities and a few differences in both their syntax and semantics,\nbut they are usually presented through formalisms that hinder a proper\ncomparison. In this paper we present a new formalism for CFGs that highlights\nthe similarities and differences between them. The new formalism borrows from\nPEGs the use of parsing expressions and the recognition-based semantics. We\nshow how one way of removing non-determinism from this formalism yields a\nformalism with the semantics of PEGs. We also prove, based on these new\nformalisms, how LL(1) grammars define the same language whether interpreted as\nCFGs or as PEGs, and also show how strong-LL(k), right-linear, and LL-regular\ngrammars have simple language-preserving translations from CFGs to PEGs.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.3177v2"
    },
    {
        "title": "Principal ideal languages and synchronizing automata",
        "authors": [
            "Vladimir V. Gusev",
            "Marina I. Maslennikova",
            "Elena V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study ideal languages generated by a single word. We provide an algorithm\nto construct a strongly connected synchronizing automaton for which such a\nlanguage serves as the language of synchronizing words. Also we present a\ncompact formula to calculate the syntactic complexity of this language.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.3307v1"
    },
    {
        "title": "Decidability of Weak Simulation on One-counter Nets",
        "authors": [
            "Piotr Hofman",
            "Richard Mayr",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  One-counter nets (OCN) are Petri nets with exactly one unbounded place. They\nare equivalent to a subclass of one-counter automata with only a weak test for\nzero. We show that weak simulation preorder is decidable for OCN and that weak\nsimulation approximants do not converge at level omega, but only at omega^2. In\ncontrast, other semantic relations like weak bisimulation are undecidable for\nOCN, and so are weak (and strong) trace inclusion.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.4104v2"
    },
    {
        "title": "Graph Logics with Rational Relations",
        "authors": [
            "Pablo Barcelo",
            "Diego Figueira",
            "Leonid Libkin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We investigate some basic questions about the interaction of regular and\nrational relations on words. The primary motivation comes from the study of\nlogics for querying graph topology, which have recently found numerous\napplications. Such logics use conditions on paths expressed by regular\nlanguages and relations, but they often need to be extended by rational\nrelations such as subword or subsequence. Evaluating formulae in such extended\ngraph logics boils down to checking nonemptiness of the intersection of\nrational relations with regular or recognizable relations (or, more generally,\nto the generalized intersection problem, asking whether some projections of a\nregular relation have a nonempty intersection with a given rational relation).\n  We prove that for several basic and commonly used rational relations, the\nintersection problem with regular relations is either undecidable (e.g., for\nsubword or suffix, and some generalizations), or decidable with\nnon-primitive-recursive complexity (e.g., for subsequence and its\ngeneralizations). These results are used to rule out many classes of graph\nlogics that freely combine regular and rational relations, as well as to\nprovide the simplest problem related to verifying lossy channel systems that\nhas non-primitive-recursive complexity. We then prove a dichotomy result for\nlogics combining regular conditions on individual paths and rational relations\non paths, by showing that the syntactic form of formulae classifies them into\neither efficiently checkable or undecidable cases. We also give examples of\nrational relations for which such logics are decidable even without syntactic\nrestrictions.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.4150v2"
    },
    {
        "title": "Guarded Variable Automata over Infinite Alphabets",
        "authors": [
            "Walid Belkhir",
            "Yannick Chevalier",
            "Michael Rusinowitch"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We define guarded variable automata (GVAs), a simple extension of finite\nautomata over infinite alphabets. In this model the transitions are labelled by\nletters or variables ranging over an infinite alphabet and guarded by\nconjunction of equalities and disequalities. GVAs are well-suited for modeling\ncomponent-based applications such as web services. They are closed under\nintersection, union, concatenation and Kleene operator, and their nonemptiness\nproblem is PSPACE-complete. We show that the simulation preorder of GVAs is\ndecidable. Our proof relies on the characterization of the simulation by means\nof games and strategies. This result can be applied to service composition\nsynthesis.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.6297v6"
    },
    {
        "title": "Operational characterization of scattered MCFLs -- Technical Report",
        "authors": [
            "Zoltan Esik",
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We give a Kleene-type operational characterization of Muller context-free\nlanguages (MCFLs) of well-ordered and scattered words.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.6388v1"
    },
    {
        "title": "Separating regular languages by piecewise testable and unambiguous\n  languages",
        "authors": [
            "Thomas Place",
            "Lorijn van Rooijen",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Separation is a classical problem asking whether, given two sets belonging to\nsome class, it is possible to separate them by a set from a smaller class. We\ndiscuss the separation problem for regular languages. We give a Ptime algorithm\nto check whether two given regular languages are separable by a piecewise\ntestable language, that is, whether a $B{\\Sigma}1(<)$ sentence can witness that\nthe languages are disjoint. The proof refines an algebraic argument from\nAlmeida and the third author. When separation is possible, we also express a\nseparator by saturating one of the original languages by a suitable congruence.\nFollowing the same line, we show that one can as well decide whether two\nregular languages can be separated by an unambiguous language, albeit with a\nhigher complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.6734v1"
    },
    {
        "title": "Decision Problems for Additive Regular Functions",
        "authors": [
            "Rajeev Alur",
            "Mukund Raghothaman"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Additive Cost Register Automata (ACRA) map strings to integers using a finite\nset of registers that are updated using assignments of the form \"x := y + c\" at\nevery step. The corresponding class of additive regular functions has multiple\nequivalent characterizations, appealing closure properties, and a decidable\nequivalence problem. In this paper, we solve two decision problems for this\nmodel. First, we define the register complexity of an additive regular function\nto be the minimum number of registers that an ACRA needs to compute it. We\ncharacterize the register complexity by a necessary and sufficient condition\nregarding the largest subset of registers whose values can be made far apart\nfrom one another. We then use this condition to design a PSPACE algorithm to\ncompute the register complexity of a given ACRA, and establish a matching lower\nbound. Our results also lead to a machine-independent characterization of the\nregister complexity of additive regular functions. Second, we consider\ntwo-player games over ACRAs, where the objective of one of the players is to\nreach a target set while minimizing the cost. We show the corresponding\ndecision problem to be EXPTIME-complete when costs are non-negative integers,\nbut undecidable when costs are integers.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.7029v1"
    },
    {
        "title": "Reachability in Higher-Order-Counters",
        "authors": [
            "Alexander Heußner",
            "Alexander Kartzow"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Higher-order counter automata (\\HOCS) can be either seen as a restriction of\nhigher-order pushdown automata (\\HOPS) to a unary stack alphabet, or as an\nextension of counter automata to higher levels. We distinguish two principal\nkinds of \\HOCS: those that can test whether the topmost counter value is zero\nand those which cannot.\n  We show that control-state reachability for level $k$ \\HOCS with $0$-test is\ncomplete for \\mbox{$(k-2)$}-fold exponential space; leaving out the $0$-test\nleads to completeness for \\mbox{$(k-2)$}-fold exponential time. Restricting\n\\HOCS (without $0$-test) to level $2$, we prove that global (forward or\nbackward) reachability analysis is $\\PTIME$-complete. This enhances the known\nresult for pushdown systems which are subsumed by level $2$ \\HOCS without\n$0$-test.\n  We transfer our results to the formal language setting. Assuming that $\\PTIME\n\\subsetneq \\PSPACE \\subsetneq \\mathbf{EXPTIME}$, we apply proof ideas of\nEngelfriet and conclude that the hierarchies of languages of \\HOPS and of \\HOCS\nform strictly interleaving hierarchies. Interestingly, Engelfriet's\nconstructions also allow to conclude immediately that the hierarchy of\ncollapsible pushdown languages is strict level-by-level due to the existing\ncomplexity results for reachability on collapsible pushdown graphs. This\nanswers an open question independently asked by Parys and by Kobayashi.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.1069v1"
    },
    {
        "title": "Detecting Useless Transitions in Pushdown Automata",
        "authors": [
            "Wan Fokkink",
            "Dick Grune",
            "Brinio Hond",
            "Peter Rutgers"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Pushdown automata may contain transitions that are never used in any\naccepting run of the automaton. We present an algorithm for detecting such\nuseless transitions. A finite automaton that captures the possible stack\ncontent during runs of the pushdown automaton, is first constructed in a\nforward procedure to determine which transitions are reachable, and then\nemployed in a backward procedure to determine which of these transitions can\nlead to a final stat\n",
        "pdf_link": "http://arxiv.org/pdf/1306.1947v1"
    },
    {
        "title": "The Holonomy Decomposition of Circular Semi-Flower Automata",
        "authors": [
            "Shubh Narayan Singh",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Eilenberg's holonomy decomposition is useful to ascertain the structural\nproperties of automata. Using this method, Egri-Nagy and Nehaniv characterized\nthe absence of certain types of cycles in automata. In the direction of\nstudying the structure of automata with cycles, this work focuses on a special\nclass of semi-flower automata and establish the holonomy decompositions of\ncertain circular semi-flower automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.2548v1"
    },
    {
        "title": "Syntactic Complexity of Circular Semi-Flower Automata",
        "authors": [
            "Shubh Narayan Singh",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We investigate the syntactic complexity of certain types of finitely\ngenerated submonoids of a free monoid. In fact, we consider those submonoids\nwhich are accepted by circular semi-flower automata (CSFA). Here, we show that\nthe syntactic complexity of CSFA with at most one `branch point going in' (bpi)\nis linear. Further, we prove that the syntactic complexity of $n$-state CSFA\nwith two bpis over a binary alphabet is $2n(n+1)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.3492v1"
    },
    {
        "title": "Extended to Multi-Tilde-Bar Regular Expressions and Efficient Finite\n  Automata Constructions",
        "authors": [
            "Jean-Marc Champarnaud",
            "Faissal Ouardi",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Several algorithms have been designed to convert a regular expression into an\nequivalent finite automaton. One of the most popular constructions, due to\nGlushkov and to McNaughton and Yamada, is based on the computation of the Null,\nFirst, Last and Follow sets (called Glushkov functions) associated with a\nlinearized version of the expression. Recently Mignot considered a family of\nextended expressions called Extended to multi-tilde-bar Regular Expressions\n(EmtbREs) and he showed that, under some restrictions, Glushkov functions can\nbe defined for an EmtbRE. In this paper we present an algorithm which\nefficiently computes the Glushkov functions of an unrestricted EmtbRE. Our\napproach is based on a recursive definition of the language associated with an\nEmtbRE which enlightens the fact that the worst case time complexity of the\nconversion of an EmtbRE into an automaton is related to the worst case time\ncomplexity of the computation of the Null function. Finally we show how to\nextend the ZPC-structure to EmtbREs, which allows us to apply to this family of\nextended expressions the efficient constructions based on this structure (in\nparticular the construction of the c-continuation automaton, the position\nautomaton, the follow automaton and the equation automaton).\n",
        "pdf_link": "http://arxiv.org/pdf/1306.3507v1"
    },
    {
        "title": "Automatic functions, linear time and learning",
        "authors": [
            "John Case",
            "Sanjay Jain",
            "Samuel Seah",
            "Frank Stephan"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The present work determines the exact nature of {\\em linear time computable}\nnotions which characterise automatic functions (those whose graphs are\nrecognised by a finite automaton). The paper also determines which type of\nlinear time notions permit full learnability for learning in the limit of\nautomatic classes (families of languages which are uniformly recognised by a\nfinite automaton). In particular it is shown that a function is automatic iff\nthere is a one-tape Turing machine with a left end which computes the function\nin linear time where the input before the computation and the output after the\ncomputation both start at the left end. It is known that learners realised as\nautomatic update functions are restrictive for learning. In the present work it\nis shown that one can overcome the problem by providing work tapes additional\nto a resource-bounded base tape while keeping the update-time to be linear in\nthe length of the largest datum seen so far. In this model, one additional such\nwork tape provides additional learning power over the automatic learner model\nand two additional work tapes give full learning power. Furthermore, one can\nalso consider additional queues or additional stacks in place of additional\nwork tapes and for these devices, one queue or two stacks are sufficient for\nfull learning power while one stack is insufficient.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.3726v3"
    },
    {
        "title": "On Separation by Locally Testable and Locally Threshold Testable\n  Languages",
        "authors": [
            "Thomas Place",
            "Lorijn van Rooijen",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A separator for two languages is a third language containing the first one\nand disjoint from the second one. We investigate the following decision\nproblem: given two regular input languages, decide whether there exists a\nlocally testable (resp. a locally threshold testable) separator. In both cases,\nwe design a decision procedure based on the occurrence of special patterns in\nautomata accepting the input languages. We prove that the problem is\ncomputationally harder than deciding membership. The correctness proof of the\nalgorithm yields a stronger result, namely a description of a possible\nseparator. Finally, we discuss the same problem for context-free input\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.0181v4"
    },
    {
        "title": "Text Compression using Abstract Numeration System on a Regular Language",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  An abstract numeration system (ANS) is a numeration system that provides a\none-to-one correspondence between the natural numbers and a regular language.\nIn this paper, we define an ANS-based compression as an extension of this\ncorrespondence. In addition, we show the following results: 1) an average\ncompression ratio is computable from a language, 2) an ANS-based compression\nruns in sublinear time with respect to the length of the input string, and 3)\nan ANS-based compression can be extended to block-based compression using a\nfactorial language.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.0267v2"
    },
    {
        "title": "Maximally Atomic Languages",
        "authors": [
            "Janusz Brzozowski",
            "Gareth Davies"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The atoms of a regular language are non-empty intersections of complemented\nand uncomplemented quotients of the language. Tight upper bounds on the number\nof atoms of a language and on the quotient complexities of atoms are known. We\nintroduce a new class of regular languages, called the maximally atomic\nlanguages, consisting of all languages meeting these bounds. We prove the\nfollowing result: If L is a regular language of quotient complexity n and G is\nthe subgroup of permutations in the transition semigroup T of the minimal DFA\nof L, then L is maximally atomic if and only if G is transitive on k-subsets of\n1,...,n for 0 <= k <= n and T contains a transformation of rank n-1.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.4368v2"
    },
    {
        "title": "Thue's 1914 paper: a translation",
        "authors": [
            "James F. Power"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper includes notes to accompany a reading of Thue's 1914 paper\n\"Probleme uber Veranderungen von Zeichenreihen nach gegebenen Reglen\", along\nwith a translation of that paper. Thue's 1914 paper is mainly famous for\nproving an early example of an undecidable problem, cited prominently by Post.\nHowever, Post's paper principally makes use of the definition of Thue systems,\ndescribed on the first two pages of Thue's paper, and does not depend on the\nmore specific results in the remainder of Thue's paper. A closer study of the\nremaining parts of that paper highlight a number of important themes in the\nhistory of computing: the transition from algebra to formal language theory,\nthe analysis of the \"computational power\" (in a pre-1936 sense) of rules, and\nthe development of algorithms to generate rule-sets.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.5858v1"
    },
    {
        "title": "Reversible Logic Elements with Memory and Their Universality",
        "authors": [
            "Kenichi Morita"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Reversible computing is a paradigm of computation that reflects physical\nreversibility, one of the fundamental microscopic laws of Nature. In this\nsurvey, we discuss topics on reversible logic elements with memory (RLEM),\nwhich can be used to build reversible computing systems, and their\nuniversality. An RLEM is called universal, if any reversible sequential machine\n(RSM) can be realized as a circuit composed only of it. Since a finite-state\ncontrol and a tape cell of a reversible Turing machine (RTM) are formalized as\nRSMs, any RTM can be constructed from a universal RLEM. Here, we investigate\n2-state RLEMs, and show that infinitely many kinds of non-degenerate RLEMs are\nall universal besides only four exceptions. Non-universality of these\nexceptional RLEMs is also argued.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1264v1"
    },
    {
        "title": "How to Obtain Computational Completeness in P Systems with One Catalyst",
        "authors": [
            "Rudolf Freund",
            "Gheorghe Păun"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Whether P systems with only one catalyst can already be computationally\ncomplete, is still an open problem. Here we establish computational\ncompleteness by using specific variants of additional control mechanisms. At\neach step using only multiset rewriting rules from one set of a finite number\nof sets of multiset rewriting rules allows for obtaining computational\ncompleteness with one catalyst and only one membrane. If the targets are used\nfor choosing the multiset of rules to be applied, for getting computational\ncompleteness with only one catalyst more than one membrane is needed. If the\navailable sets of rules change periodically with time, computational\ncompleteness can be obtained with one catalyst in one membrane. Moreover, we\nalso improve existing computational completeness results for P systems with\nmobile catalysts and for P systems with membrane creation.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1267v1"
    },
    {
        "title": "One-dimensional Array Grammars and P Systems with Array Insertion and\n  Deletion Rules",
        "authors": [
            "Rudolf Freund",
            "Sergiu Ivanov",
            "Marion Oswald",
            "K. G. Subramanian"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We consider the (one-dimensional) array counterpart of contextual as well as\ninsertion and deletion string grammars and consider the operations of array\ninsertion and deletion in array grammars. First we show that the emptiness\nproblem for P systems with (one-dimensional) insertion rules is undecidable.\nThen we show computational completeness of P systems using (one-dimensional)\narray insertion and deletion rules even of norm one only. The main result of\nthe paper exhibits computational completeness of one-dimensional array grammars\nusing array insertion and deletion rules of norm at most two.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1268v1"
    },
    {
        "title": "Hyperbolic tilings and formal language theory",
        "authors": [
            "Maurice Margenstern",
            "K. G. Subramamian"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In this paper, we try to give the appropriate class of languages to which\nbelong various objects associated with tessellations in the hyperbolic plane.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1271v1"
    },
    {
        "title": "Emptiness and Universality Problems in Timed Automata with Positive\n  Frequency",
        "authors": [
            "Nathalie Bertrand",
            "Patricia Bouyer",
            "Thomas Brihaye",
            "Amelie Stainer"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The languages of infinite timed words accepted by timed automata are\ntraditionally defined using Buchi-like conditions. These acceptance conditions\nfocus on the set of locations visited infinitely often along a run, but\ncompletely ignore quantitative timing aspects. In this paper we propose a\nnatural quantitative semantics for timed automata based on the so-called\nfrequency, which measures the proportion of time spent in the accepting\nlocations. We study various properties of timed languages accepted with\npositive frequency, and in particular the emptiness and universality problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.2842v1"
    },
    {
        "title": "Searching of gapped repeats and subrepetitions in a word",
        "authors": [
            "Roman Kolpakov",
            "Mikhail Podolskiy",
            "Mikhail Posypkin",
            "Nickolay Khrapov"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A gapped repeat is a factor of the form $uvu$ where $u$ and $v$ are nonempty\nwords. The period of the gapped repeat is defined as $|u|+|v|$. The gapped\nrepeat is maximal if it cannot be extended to the left or to the right by at\nleast one letter with preserving its period. The gapped repeat is called\n$\\alpha$-gapped if its period is not greater than $\\alpha |v|$. A\n$\\delta$-subrepetition is a factor which exponent is less than 2 but is not\nless than $1+\\delta$ (the exponent of the factor is the quotient of the length\nand the minimal period of the factor). The $\\delta$-subrepetition is maximal if\nit cannot be extended to the left or to the right by at least one letter with\npreserving its minimal period. We reveal a close relation between maximal\ngapped repeats and maximal subrepetitions. Moreover, we show that in a word of\nlength $n$ the number of maximal $\\alpha$-gapped repeats is bounded by\n$O(\\alpha^2n)$ and the number of maximal $\\delta$-subrepetitions is bounded by\n$O(n/\\delta^2)$. Using the obtained upper bounds, we propose algorithms for\nfinding all maximal $\\alpha$-gapped repeats and all maximal\n$\\delta$-subrepetitions in a word of length $n$. The algorithm for finding all\nmaximal $\\alpha$-gapped repeats has $O(\\alpha^2n)$ time complexity for the case\nof constant alphabet size and $O(n\\log n + \\alpha^2n)$ time complexity for the\ngeneral case. For finding all maximal $\\delta$-subrepetitions we propose two\nalgorithms. The first algorithm has $O(\\frac{n\\log\\log n}{\\delta^2})$ time\ncomplexity for the case of constant alphabet size and $O(n\\log n\n+\\frac{n\\log\\log n}{\\delta^2})$ time complexity for the general case. The\nsecond algorithm has $O(n\\log n+\\frac{n}{\\delta^2}\\log \\frac{1}{\\delta})$\nexpected time complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.4055v2"
    },
    {
        "title": "Transducers with origin information",
        "authors": [
            "Mikołaj Bojańczyk"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Call a string-to-string transducer regular if it can be realised by one of\nthe following equivalent models: mso transductions, two-way deterministic\nautomata with output, and streaming transducers with registers. This paper\nproposes to treat origin information as part of the semantics of a regular\nstring-to-string transducer. With such semantics, the model admits a\nmachine-independent characterisation, Angluin-style learning in polynomial\ntime, as well as effective characterisations of natural subclasses such as\none-way transducers or first-order definable transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.6124v1"
    },
    {
        "title": "A Note on Pushdown Automata Systems",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In (Csuhaj-Varju et. al. 2000) Parallel Communicating Systems of Pushdown\nAutomata (PCPA) were introduced and shown to be able to simulate\nnondeterministic one-way multi-head pushdown automata in returning mode, even\nif communication is restricted to be one-way having a single target component.\nA simulation of such centralized PCPA by one-way multi-head pushdown automata\n(Balan 2009) turned out to be incomplete (Otto 2012). Subsequently it was shown\nthat centralized returning PCPA are universal even if the number of components\nis two (Petersen 2013) and thus are separated from one-way multi-head pushdown\nautomata. Another line of research modified the definition of PCPA such that\ncommunication is asynchronous (Otto 2013). While the simulation of one-way\nmulti-head pushdown automata is still possible, now a converse construction\nshows this model in returning mode to be equivalent to the one-way multi-head\npushdown automaton in a very precise sense. It was left open, whether\nnon-centralized returning PCPA of degree two are universal. In the first part\nof the paper we show this to be the case. Then we turn our attention to Uniform\nDistributed Pushdown Automata Systems (UDPAS). These systems of automata work\nin turn on a single tape. We show that UPDAS accepting with empty stack do not\nform a hierarchy depending on the number of components and that the membership\nproblem is complete in NP, answering two open problems from (Arroyo et. al.\n2012).\n",
        "pdf_link": "http://arxiv.org/pdf/1310.0504v4"
    },
    {
        "title": "Symmetric Groups and Quotient Complexity of Boolean Operations",
        "authors": [
            "Jason Bell",
            "Janusz Brzozowski",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The quotient complexity of a regular language L is the number of left\nquotients of L, which is the same as the state complexity of L. Suppose that L\nand L' are binary regular languages with quotient complexities m and n, and\nthat the transition semigroups of the minimal deterministic automata accepting\nL and L' are the symmetric groups S_m and S_n of degrees m and n, respectively.\nDenote by o any binary boolean operation that is not a constant and not a\nfunction of one argument only. For m,n >= 2 with (m,n) not in\n{(2,2),(3,4),(4,3),(4,4)} we prove that the quotient complexity of LoL' is mn\nif and only either (a) m is not equal to n or (b) m=n and the bases (ordered\npairs of generators) of S_m and S_n are not conjugate. For (m,n)\\in\n{(2,2),(3,4),(4,3),(4,4)} we give examples to show that this need not hold. In\nproving these results we generalize the notion of uniform minimality to direct\nproducts of automata. We also establish a non-trivial connection between\ncomplexity of boolean operations and group theory.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.1841v1"
    },
    {
        "title": "Saturation of Concurrent Collapsible Pushdown Systems",
        "authors": [
            "Matthew Hague"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Multi-stack pushdown systems are a well-studied model of concurrent\ncomputation using threads with first-order procedure calls. While, in general,\nreachability is undecidable, there are numerous restrictions on stack behaviour\nthat lead to decidability. To model higher-order procedures calls, a\ngeneralisation of pushdown stacks called collapsible pushdown stacks are\nrequired. Reachability problems for multi-stack collapsible pushdown systems\nhave been little studied. Here, we study ordered, phase-bounded and\nscope-bounded multi-stack collapsible pushdown systems using saturation\ntechniques, showing decidability of control state reachability and giving a\nregular representation of all configurations that can reach a given control\nstate.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.2631v1"
    },
    {
        "title": "Introduction to Functional Grammars",
        "authors": [
            "Abhinav Aggarwal"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Formal grammars are extensively used in Computer Science and related fields\nto study the rules which govern production of a language. The use of these\ngrammars can be extended beyond mere language production. One possibility is to\nview these grammars as logical machines, similar to automata, which can be\nmodified to compute or help in computation, while also performing the basic\ntask of language production. The difference between such a modified grammar and\nan automaton will then lie in the semantics of computation performed. It is\neven possible for such a grammar to appear non-functional (when no language is\nproduced as a result of its productions), but in reality, it might be carrying\nout important tasks. Such grammars have been named Functional Grammars\n(including a special sub-category, called Virtual Grammars), and their\nproperties are studied in the paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.2823v2"
    },
    {
        "title": "Acceptance conditions for omega-languages and the Borel hierarchy",
        "authors": [
            "Julien Cervelle",
            "Alberto Dennunzio",
            "Enrico Formenti",
            "Julien Provillard"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper investigates acceptance conditions for finite automata recognizing\nomega-regular languages. As a first result, we show that, under any acceptance\ncondition that can be defined in the MSO logic, a finite automaton can\nrecognize at most omega-regular languages. Starting from this, the paper aims\nat classifying acceptance conditions according to their expressive power and at\nfinding the exact position of the classes of omega-languages they induced\naccording to the Borel hierarchy. A new interesting acceptance condition is\nintroduced and fully characterized. A step forward is also made in the\nunderstanding of the expressive power of (fin, =).\n",
        "pdf_link": "http://arxiv.org/pdf/1310.5032v1"
    },
    {
        "title": "Avoiding Shared Clocks in Networks of Timed Automata",
        "authors": [
            "Sandie Balaguer",
            "Thomas Chatain"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Networks of timed automata (NTA) are widely used to model distributed\nreal-time systems. Quite often in the literature, the automata are allowed to\nshare clocks, i.e. transitions of one automaton may be guarded by conditions on\nthe value of clocks reset by another automaton. This is a problem when one\nconsiders implementing such model in a distributed architecture, since reading\nclocks a priori requires communications which are not explicitly described in\nthe model. We focus on the following question: given an NTA A1 || A2 where A2\nreads some clocks reset by A1, does there exist an NTA A'1 || A'2 without\nshared clocks with the same behavior as the initial NTA? For this, we allow the\nautomata to exchange information during synchronizations only, in particular by\ncopying the value of their neighbor's clocks. We discuss a formalization of the\nproblem and define an appropriate behavioural equivalence. Then we give a\ncriterion using the notion of contextual timed transition system, which\nrepresents the behavior of A2 when in parallel with A1. Finally, we effectively\nbuild A'1 || A'2 when it exists.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.5558v2"
    },
    {
        "title": "Full characterisation of attractors of two intersected asynchronous\n  Boolean automata cycles",
        "authors": [
            "Tarek Melliti",
            "Mathilde Noual",
            "Damien Regnault",
            "Sylvain Sené",
            "Jérémy Sobieraj"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The understanding of Boolean automata networks dynamics takes an important\nplace in various domains of computer science such as computability, complexity\nand discrete dynamical systems. In this paper, we make a step further in this\nunderstanding by focusing on their cycles, whose necessity in networks is known\nas the brick of their complexity. We present new results that provide a\ncharacterisation of the transient and asymptotic dynamics, i.e. of the\ncomputational abilities, of asynchronous Boolean automata networks composed of\ntwo cycles that intersect at one automaton, the so-called double-cycles. To do\nso, we introduce an efficient formalism inspired by algorithms to define long\nsequences of updates, that allows a better description of their dynamics than\nprevious works in this area.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.5747v2"
    },
    {
        "title": "Simulation Over One-counter Nets is PSPACE-Complete",
        "authors": [
            "Piotr Hofman",
            "Slawomir Lasota",
            "Richard Mayr",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  One-counter nets (OCN) are Petri nets with exactly one unbounded place. They\nare equivalent to a subclass of one-counter automata with just a weak test for\nzero. Unlike many other semantic equivalences, strong and weak simulation\npreorder are decidable for OCN, but the computational complexity was an open\nproblem. We show that both strong and weak simulation preorder on OCN are\nPSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.6303v1"
    },
    {
        "title": "Nominal Regular Expressions for Languages over Infinite Alphabets.\n  Extended Abstract",
        "authors": [
            "Alexander Kurz",
            "Tomoyuki Suzuki",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We propose regular expressions to abstractly model and study properties of\nresource-aware computations. Inspired by nominal techniques -- as those popular\nin process calculi -- we extend classical regular expressions with names (to\nmodel computational resources) and suitable operators (for allocation,\ndeallocation, scoping of, and freshness conditions on resources). We discuss\nclasses of such nominal regular expressions, show how such expressions have\nnatural interpretations in terms of languages over infinite alphabets, and give\nKleene theorems to characterise their formal languages in terms of nominal\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.7093v1"
    },
    {
        "title": "On the effect of the IO-substitution on the Parikh image of semilinear\n  AFLs",
        "authors": [
            "Pierre Bourreau"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Back in the 80s, the class of mildly context-sensitive formalisms was\nintroduced so as to capture the syntax of natural languages. While the\nlanguages generated by such formalisms are constrained by the constant-growth\nproperty, the most well-known and used mildly-context sensitive formalisms,\nlike tree-adjoining grammars or multiple context-free grammars, generate\nlanguages which verify the stronger property of being semilinear. In (Bourreau\net al., 2012), the operation of IO-ubstitution was created so as to exhibit\nmildly context-sensitive classes of languages which are not semilinear,\nalthough they verify the constant-growth property. In the present article, we\nextend the notion of semilinearity, and characterise the Parikh image of the\nIO-MCFLs (i.e. languages which belong to the closure of MCFLs under\nIO-subsitution) as universally-linear. Based on this result and on the work of\nFischer on macro-grammars, we then show IO-MCFLs are not closed under inverse\nhomomorphism, which proves that the family of IO-MCFLs is not an abstract\nfamily of languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.0632v1"
    },
    {
        "title": "Look-Ahead Removal for Top-Down Tree Transducers",
        "authors": [
            "Joost Engelfriet",
            "Sebastian Maneth",
            "Helmut Seidl"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Top-down tree transducers are a convenient formalism for describing tree\ntransformations. They can be equipped with regular look-ahead, which allows\nthem to inspect a subtree before processing it. In certain cases, such a\nlook-ahead can be avoided and the transformation can be realized by a\ntransducer without look-ahead. Removing the look-ahead from a transducer, if\npossible, is technically highly challenging. For a restricted class of\ntransducers with look-ahead, namely those that are total, deterministic,\nultralinear, and bounded erasing, we present an algorithm that, for a given\ntransducer from that class, (1) decides whether it is equivalent to a total\ndeterministic transducer without look-ahead, and (2) constructs such a\ntransducer if the answer is positive. For the whole class of total\ndeterministic transducers with look-ahead we present a similar algorithm, which\nassumes that a so-called difference bound is known for the given transducer.\nThe designer of a transducer can usually also determine a difference bound for\nit.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.2400v3"
    },
    {
        "title": "Finite-type-Dyck shift spaces",
        "authors": [
            "Marie-Pierre Béal",
            "Michel Blockelet",
            "Cǎtǎlin Dima"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study some basic properties of sofic-Dyck shifts and finite-type-Dyck\nshifts. We prove that the class of sofic-Dyck shifts is stable under proper\nconjugacies. We prove a Decomposition Theorem of a proper conjugacy between\nedge-Dyck shifts into a sequence of Dyck splittings and amalgamations.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.4223v1"
    },
    {
        "title": "Most Complex Regular Right-Ideal Languages",
        "authors": [
            "Janusz Brzozowski",
            "Gareth Davies"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A right ideal is a language L over an alphabet A that satisfies L = LA*. We\nshow that there exists a stream (sequence) (R_n : n \\ge 3) of regular right\nideal languages, where R_n has n left quotients and is most complex under the\nfollowing measures of complexity: the state complexities of the left quotients,\nthe number of atoms (intersections of complemented and uncomplemented left\nquotients), the state complexities of the atoms, the size of the syntactic\nsemigroup, the state complexities of the operations of reversal, star, and\nproduct, and the state complexities of all binary boolean operations. In that\nsense, this stream of right ideals is a universal witness.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.4448v1"
    },
    {
        "title": "Random Generation of Nondeterministic Finite-State Tree Automata",
        "authors": [
            "Thomas Hanneforth",
            "Andreas Maletti",
            "Daniel Quernheim"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Algorithms for (nondeterministic) finite-state tree automata (FTAs) are often\ntested on random FTAs, in which all internal transitions are equiprobable. The\nrun-time results obtained in this manner are usually overly optimistic as most\nsuch generated random FTAs are trivial in the sense that the number of states\nof an equivalent minimal deterministic FTA is extremely small. It is\ndemonstrated that nontrivial random FTAs are obtained only for a narrow band of\ntransition probabilities. Moreover, an analytic analysis yields a formula to\napproximate the transition probability that yields the most complex random\nFTAs, which should be used in experiments.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5568v1"
    },
    {
        "title": "Expressiveness of Visibly Pushdown Transducers",
        "authors": [
            "Mathieu Caralp",
            "Emmanuel Filiot",
            "Pierre-Alain Reynier",
            "Frédéric Servais",
            "Jean-Marc Talbot"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Visibly pushdown transducers (VPTs) are visibly pushdown automata extended\nwith outputs. They have been introduced to model transformations of nested\nwords, i.e. words with a call/return structure. As trees and more generally\nhedges can be linearized into (well) nested words, VPTs are a natural formalism\nto express tree transformations evaluated in streaming. This paper aims at\ncharacterizing precisely the expressive power of VPTs with respect to other\ntree transducer models.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5571v1"
    },
    {
        "title": "Brzozowski type determinization for fuzzy automata",
        "authors": [
            "Zorana Jančić",
            "Miroslav Ćirić"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In this paper we adapt the well-known Brzozowski determinization method to\nfuzzy automata. This method gives better results than all previously known\nmethods for determinization of fuzzy automata developed by B\\v{e}lohl\\'avek\n[Inform Sciences 143 (2002) 205--209], Li and Pedrycz [Fuzzy Set Syst 156\n(2005) 68--92], Ignjatovi\\'c et al. [Inform Sciences 178 (2008) 164--180], and\nJan\\v{c}i\\'c et al. [Inform Sciences 181 (2011) 1358--1368]. Namely, as in the\ncase of ordinary nondeterministic automata, Brzozowski type determinization of\na fuzzy automaton results in a minimal crisp-deterministic fuzzy automaton\nequivalent to the starting fuzzy automaton, and we show that there are cases\nwhen all previous methods result in infinite automata, while Brzozowski type\ndeterminization results in a finite one. The paper deals with fuzzy automata\nover complete residuated lattices, but identical results can also be obtained\nin a more general context, for fuzzy automata over lattice-ordered monoids, and\neven for weighted automata over commutative semirings.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5799v2"
    },
    {
        "title": "On Even Linear Indexed Languages with a Reduction to the Learning of\n  Context-Free Languages",
        "authors": [
            "Benjamin Caulfield"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper presents a restricted form of linear indexed grammars, called even\nlinear indexed grammars, which yield the even linear indexed languages. These\nlanguages properly contain the context-free languages and are contained in the\nset of linear indexed languages. We show that several patterns found in natural\nlanguages are also generated by these grammars, including crossing\ndependencies, copying, and multiple agreements. We discuss the learning problem\nfor even linear indexed languages and show that it is reducible to that of the\ncontext-free languages. The closure properties for this class of languages are\nalso presented.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.0175v2"
    },
    {
        "title": "Inclusion of regular and linear languages in group languages",
        "authors": [
            "Krasimir Yordzhev"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Let $\\Sigma = X\\cup X^{-1} = \\{ x_1 ,x_2 ,..., x_m ,x_1^{-1} ,x_2^{-1} ,...,\nx_m^{-1} \\}$ and let $G$ be a group with set of generators $\\Sigma$. Let\n$\\mathfrak{L} (G) =\\left\\{ \\left. \\omega \\in \\Sigma^* \\; \\right\\vert \\;\\omega\n\\equiv e \\; (\\textrm{mod} \\; G) \\right\\} \\subseteq \\Sigma^*$ be the group\nlanguage representing $G$, where $\\Sigma^*$ is a free monoid over $\\Sigma$ and\n$e$ is the identity in $G$. The problem of determining whether a context-free\nlanguage is subset of a group language is discussed. Polynomial algorithms are\npresented for testing whether a regular language, or a linear language is\nincluded in a group language. A few finite sets are built, such that each of\nthem is included in the group language $\\mathfrak{L} (G)$ if and only if the\nrespective context-free language is included in $\\mathfrak{L} (G)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.0190v1"
    },
    {
        "title": "Finite automata with advice tapes",
        "authors": [
            "Uğur Küçük",
            "A. C. Cem Say",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We define a model of advised computation by finite automata where the advice\nis provided on a separate tape. We consider several variants of the model where\nthe advice is deterministic or randomized, the input tape head is allowed\nreal-time, one-way, or two-way access, and the automaton is classical or\nquantum. We prove several separation results among these variants, demonstrate\nan infinite hierarchy of language classes recognized by automata with\nincreasing advice lengths, and establish the relationships between this and the\npreviously studied ways of providing advice to finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.2268v2"
    },
    {
        "title": "Universal neural field computation",
        "authors": [
            "Peter beim Graben",
            "Roland Potthast"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Turing machines and G\\\"odel numbers are important pillars of the theory of\ncomputation. Thus, any computational architecture needs to show how it could\nrelate to Turing machines and how stable implementations of Turing computation\nare possible. In this chapter, we implement universal Turing computation in a\nneural field environment. To this end, we employ the canonical symbologram\nrepresentation of a Turing machine obtained from a G\\\"odel encoding of its\nsymbolic repertoire and generalized shifts. The resulting nonlinear dynamical\nautomaton (NDA) is a piecewise affine-linear map acting on the unit square that\nis partitioned into rectangular domains. Instead of looking at point dynamics\nin phase space, we then consider functional dynamics of probability\ndistributions functions (p.d.f.s) over phase space. This is generally described\nby a Frobenius-Perron integral transformation that can be regarded as a neural\nfield equation over the unit square as feature space of a dynamic field theory\n(DFT). Solving the Frobenius-Perron equation yields that uniform p.d.f.s with\nrectangular support are mapped onto uniform p.d.f.s with rectangular support,\nagain. We call the resulting representation \\emph{dynamic field automaton}.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.3550v1"
    },
    {
        "title": "Regular Combinators for String Transformations",
        "authors": [
            "Rajeev Alur",
            "Adam Freilich",
            "Mukund Raghothaman"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We focus on (partial) functions that map input strings to a monoid such as\nthe set of integers with addition and the set of output strings with\nconcatenation. The notion of regularity for such functions has been defined\nusing two-way finite-state transducers, (one-way) cost register automata, and\nMSO-definable graph transformations. In this paper, we give an algebraic and\nmachine-independent characterization of this class analogous to the definition\nof regular languages by regular expressions. When the monoid is commutative, we\nprove that every regular function can be constructed from constant functions\nusing the combinators of choice, split sum, and iterated sum, that are analogs\nof union, concatenation, and Kleene-*, respectively, but enforce unique (or\nunambiguous) parsing. Our main result is for the general case of\nnon-commutative monoids, which is of particular interest for capturing regular\nstring-to-string transformations for document processing. We prove that the\nfollowing additional combinators suffice for constructing all regular\nfunctions: (1) the left-additive versions of split sum and iterated sum, which\nallow transformations such as string reversal; (2) sum of functions, which\nallows transformations such as copying of strings; and (3) function\ncomposition, or alternatively, a new concept of chained sum, which allows\noutput values from adjacent blocks to mix.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3021v1"
    },
    {
        "title": "Weak $ω$-Regular Trace Languages",
        "authors": [
            "Namit Chaturvedi",
            "Marcus Gelderie"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Mazurkiewicz traces describe concurrent behaviors of distributed systems.\nTrace-closed word languages, which are \"linearizations\" of trace languages,\nconstitute a weaker notion of concurrency but still give us tools to\ninvestigate the latter. In this vein, our contribution is twofold. Firstly, we\ndevelop definitions that allow classification of $\\omega$-regular trace\nlanguages in terms of the corresponding trace-closed $\\omega$-regular word\nlanguages, capturing E-recognizable (reachability) and (deterministically)\nB\\\"uchi recognizable languages. Secondly, we demonstrate the first\nautomata-theoretic result that shows the equivalence of $\\omega$-regular\ntrace-closed word languages and Boolean combinations of deterministically\n$I$-diamond B\\\"uchi recognizable trace-closed languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3199v1"
    },
    {
        "title": "Revision of Specification Automata under Quantitative Preferences",
        "authors": [
            "Kangjin Kim",
            "Georgios Fainekos"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the problem of revising specifications with preferences for automata\nbased control synthesis problems. In this class of revision problems, the user\nprovides a numerical ranking of the desirability of the subgoals in their\nspecifications. When the specification cannot be satisfied on the system, then\nour algorithms automatically revise the specification so that the least\ndesirable user goals are removed from the specification. We propose two\ndifferent versions of the revision problem with preferences. In the first\nversion, the algorithm returns an exact solution while in the second version\nthe algorithm is an approximation algorithm with non-constant approximation\nratio. Finally, we demonstrate the scalability of our algorithms and we\nexperimentally study the approximation ratio of the approximation algorithm on\nrandom problem instances.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3611v1"
    },
    {
        "title": "Nondeterministic automatic complexity of overlap-free and almost\n  square-free words",
        "authors": [
            "Kayleigh Hyde",
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Shallit and Wang studied deterministic automatic complexity of words. They\nshowed that the automatic Hausdorff dimension $I(\\mathbf t)$ of the infinite\nThue word satisfies $1/3\\le I(\\mathbf t)\\le 2/3$. We improve that result by\nshowing that $I(\\mathbf t)\\ge 1/2$. For nondeterministic automatic complexity\nwe show $I(\\mathbf t)=1/2$. We prove that such complexity $A_N$ of a word $x$\nof length $n$ satisfies $A_N(x)\\le b(n):=\\lfloor n/2\\rfloor + 1$. This enables\nus to define the complexity deficiency $D(x)=b(n)-A_N(x)$. If $x$ is\nsquare-free then $D(x)=0$. If $x$ almost square-free in the sense of Fraenkel\nand Simpson, or if $x$ is a strongly cube-free binary word such as the infinite\nThue word, then $D(x)\\le 1$. On the other hand, there is no constant upper\nbound on $D$ for strongly cube-free words in a ternary alphabet, nor for\ncube-free words in a binary alphabet. The decision problem whether $D(x)\\ge d$\nfor given $x$, $d$ belongs to $NP\\cap E$.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3856v2"
    },
    {
        "title": "A note on groups of a family of hyperbolic tessellations",
        "authors": [
            "Anthony Gasperin",
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we study the word problem of groups corresponding to\ntessellations of the hyperbolic plane. In particular using the Fibonacci\ntechnology developed by the second author we show that groups corresponding to\nthe pentagrid or the heptagrid are not automatic.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.4337v1"
    },
    {
        "title": "Further improvements of determinization methods for fuzzy finite\n  automata",
        "authors": [
            "Zorana Jančić",
            "Ivana Micić",
            "Jelena Ignjatović",
            "Miroslav Ćirić"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we combine determinization and state reduction methods into\ntwo-in-one algorithms that simultaneously perform determinization and state\nreduction. These algorithms perform better than all previous determinization\nalgorithms for fuzzy finite automata, developed by Belohlavek [Inform Sciences\n143 (2002) 205-209], Li and Pedrycz [Fuzzy Set Syst 156 (2005) 68-92],\nIgnjatovi\\'c et al. [Inform Sciences 178 (2008) 164-180], and Jan\\v{c}i\\'c et\nal. [Inform Sciences 181 (2011) 1358-1368], in the sense that they produce\nsmaller automata, while require the same computation time. The only exception\nis the Brzozowski type determinization algorithm developed recently by\nJan\\v{c}i\\'c and \\'Ciri\\'c [Fuzzy Set Syst (2014), to appear], which produces a\nminimal crisp-deterministic fuzzy automaton, but the algorithms created here\ncan also be used within the Brzozowski type algorithm and improve its\nperformances.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.6510v4"
    },
    {
        "title": "Zenoness for Timed Pushdown Automata",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "Jari Stenman"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Timed pushdown automata are pushdown automata extended with a finite set of\nreal-valued clocks. Additionaly, each symbol in the stack is equipped with a\nvalue representing its age. The enabledness of a transition may depend on the\nvalues of the clocks and the age of the topmost symbol. Therefore, dense-timed\npushdown automata subsume both pushdown automata and timed automata. We have\npreviously shown that the reachability problem for this model is decidable. In\nthis paper, we study the zenoness problem and show that it is EXPTIME-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.6784v1"
    },
    {
        "title": "On nonpermutational transformation semigroups with an application to\n  syntactic complexity",
        "authors": [
            "Szabolcs Ivan",
            "Judit Nagy-Gyorgy"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We give an upper bound of $n((n-1)!-(n-3)!)$ for the possible largest size of\na subsemigroup of the full transformational semigroup over $n$ elements\nconsisting only of nonpermutational transformations. As an application we gain\nthe same upper bound for the syntactic complexity of (generalized) definite\nlanguages as well.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.7289v1"
    },
    {
        "title": "Upper Bounds on Syntactic Complexity of Left and Two-Sided Ideals",
        "authors": [
            "Janusz Brzozowski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We solve two open problems concerning syntactic complexity: We prove that the\ncardinality of the syntactic semigroup of a left ideal or a suffix-closed\nlanguage with $n$ left quotients (that is, with state complexity $n$) is at\nmost $n^{n-1}+n-1$, and that of a two-sided ideal or a factor-closed language\nis at most $n^{n-2}+(n-2)2^{n-2}+1$. Since these bounds are known to be\nreachable, this settles the problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.2090v2"
    },
    {
        "title": "Subset Synchronization and Careful Synchronization of Binary Finite\n  Automata",
        "authors": [
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present a strongly exponential lower bound that applies both to the subset\nsynchronization threshold for binary deterministic automata and to the careful\nsynchronization threshold for binary partial automata. In the later form, the\nresult finishes the research initiated by Martyugin (2013). Moreover, we show\nthat both the thresholds remain strongly exponential even if restricted to\nstrongly connected binary automata. In addition, we apply our methods to\ncomputational complexity. Existence of a subset reset word is known to be\nPSPACE-complete; we show that this holds even under the restriction to strongly\nconnected binary automata. The results apply also to the corresponding\nthresholds in two more general settings: D1- and D3-directable nondeterministic\nautomata and composition sequences over finite domains.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.3972v4"
    },
    {
        "title": "Reset thresholds of automata with two cycle lengths",
        "authors": [
            "Vladimir V. Gusev",
            "Elena V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present several series of synchronizing automata with multiple parameters,\ngeneralizing previously known results. Let p and q be two arbitrary co-prime\npositive integers, q > p. We describe reset thresholds of the colorings of\nprimitive digraphs with exactly one cycle of length p and one cycle of length\nq. Also, we study reset thresholds of the colorings of primitive digraphs with\nexactly one cycle of length q and two cycles of length p.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.3992v1"
    },
    {
        "title": "Parameterized Complexity of Synchronization and Road Coloring",
        "authors": [
            "Vojtěch Vorel",
            "Adam Roman"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  First, we close the multivariate analysis of a canonical problem concerning\nshort reset words (SYN), as it was started by Fernau et al. (2013). Namely, we\nprove that the problem, parameterized by the number of states, does not admit a\npolynomial kernel unless the polynomial hierarchy collapses. Second, we\nconsider a related canonical problem concerning synchronizing road colorings\n(SRCP). Here we give a similar complete multivariate analysis. Namely, we show\nthat the problem, parameterized by the number of states, admits a polynomial\nkernel and we close the previous research of restrictions to particular values\nof both the alphabet size and the maximum word length.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.4749v3"
    },
    {
        "title": "Enforcing Operational Properties including Blockfreeness for\n  Deterministic Pushdown Automata",
        "authors": [
            "Sven Schneider",
            "Uwe Nestmann"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present an algorithm which modifies a deterministic pushdown automaton\n(DPDA) such that (i) the marked language is preserved, (ii) lifelocks are\nremoved, (iii) deadlocks are removed, (iv) all states and edges are accessible,\nand (v) operational blockfreeness is established (i.e., coaccessibility in the\nsense that every initial derivation can be continued to a marking\nconfiguration). This problem can be trivially solved for deterministic finite\nautomata (DFA) but is not solvable for standard petri net classes. The\nalgorithm is required for an operational extension of the supervisory control\nproblem (SCP) to the situation where the specification in modeled by a DPDA.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.5081v2"
    },
    {
        "title": "Rhythmic generation of infinite trees and languages",
        "authors": [
            "Victor Marsault",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This work builds on the notion of breadth-first signature of infinite trees\nand (prefix-closed) languages introduced by the authors in a previous work. We\nfocus here on periodic signatures, a case coming from the study of rational\nbase numeration systems; the language of integer representations in\nbase~$\\frac{p}{q}$ has a purely periodic signature whose period is derived from\nthe Christoffel word of slope~$\\frac{p}{q}$. Conversely, we characterise\nlanguages whose signature are purely periodic as representations of integers in\nsuch number systems with non-canonical alphabets of digits.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.5190v2"
    },
    {
        "title": "Synchronizing weighted automata",
        "authors": [
            "Szabolcs Iván"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We introduce two generalizations of synchronizability to automata with\ntransitions weighted in an arbitrary semiring K=(K,+,*,0,1). (or equivalently,\nto finite sets of matrices in K^nxn.) Let us call a matrix A\nlocation-synchronizing if there exists a column in A consisting of nonzero\nentries such that all the other columns of A are filled by zeros. If\nadditionally all the entries of this designated column are the same, we call A\nsynchronizing. Note that these notions coincide for stochastic matrices and\nalso in the Boolean semiring. A set M of matrices in K^nxn is called\n(location-)synchronizing if M generates a matrix subsemigroup containing a\n(location-)synchronizing matrix. The K-(location-)synchronizability problem is\nthe following: given a finite set M of nxn matrices with entries in K, is it\n(location-)synchronizing?\n  Both problems are PSPACE-hard for any nontrivial semiring. We give sufficient\nconditions for the semiring K when the problems are PSPACE-complete and show\nseveral undecidability results as well, e.g. synchronizability is undecidable\nif 1 has infinite order in (K,+,0) or when the free semigroup on two generators\ncan be embedded into (K,*,1).\n",
        "pdf_link": "http://arxiv.org/pdf/1403.5729v3"
    },
    {
        "title": "$L$-Primitive Words in Submonoids",
        "authors": [
            "Shubh Narayan Singh",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This work considers a natural generalization of primitivity with respect to a\nlanguage. Given a language $L$, a nonempty word $w$ is said to be $L$-primitive\nif $w$ is not a proper power of any word in $L$. After ascertaining the number\nof primitive words in submonoids of a free monoid, the work proceeds to count\n$L$-primitive words in submonoids of a free monoid. The work also studies the\ndistribution of $L$-primitive words in certain subsets of free monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.5788v1"
    },
    {
        "title": "Topologies of Stochastic Markov Models: Computational Aspects",
        "authors": [
            "Giorgio Bacci",
            "Giovanni Bacci",
            "Kim G. Larsen",
            "Radu Mardare"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we propose two behavioral distances that support approximate\nreasoning on Stochastic Markov Models (SMMs), that are continuous-time\nstochastic transition systems where the residence time on each state is\ndescribed by a generic probability measure on the positive real line. In\nparticular, we study the problem of measuring the behavioral dissimilarity of\ntwo SMMs against linear real-time specifications expressed as Metric Temporal\nLogic (MTL) formulas or Deterministic Timed-Automata (DTA). The most natural\nchoice for such a distance is the one that measures the maximal difference that\ncan be observed comparing two SMMs with respect to their probability of\nsatisfying an arbitrary specification. We show that computing this metric is\nNP-hard. In addition, we show that any algorithm that approximates the distance\nwithin a certain absolute error, depending on the size of the SMMs, is NP-hard.\nNevertheless, we introduce an alternative distance, based on the Kantorovich\nmetric, that is an over-approximation of the former and we show that, under\nmild assumptions on the residence time distributions, it can be computed in\npolynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.6032v2"
    },
    {
        "title": "Monoid automata for displacement context-free languages",
        "authors": [
            "Alexey Sorokin"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In 2007 Kambites presented an algebraic interpretation of\nChomsky-Schutzenberger theorem for context-free languages. We give an\ninterpretation of the corresponding theorem for the class of displacement\ncontext-free languages which are equivalent to well-nested multiple\ncontext-free languages. We also obtain a characterization of k-displacement\ncontext-free languages in terms of monoid automata and show how such automata\ncan be simulated on two stacks. We introduce the simultaneous two-stack\nautomata and compare different variants of its definition. All the definitions\nconsidered are shown to be equivalent basing on the geometric interpretation of\nmemory operations of these automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.6060v1"
    },
    {
        "title": "Pumping lemma and Ogden lemma for displacement context-free grammars",
        "authors": [
            "Alexey Sorokin"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The pumping lemma and Ogden lemma offer a powerful method to prove that a\nparticular language is not context-free. In 2008 Kanazawa proved an analogue of\npumping lemma for well-nested multiple-context free languages. However, the\nstatement of lemma is too weak for practical usage. We prove a stronger variant\nof pumping lemma and an analogue of Ogden lemma for this language family. We\nalso use these statements to prove that some natural context-sensitive\nlanguages cannot be generated by tree-adjoining grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.6230v3"
    },
    {
        "title": "K-Position, Follow, Equation and K-C-Continuation Tree Automata\n  Constructions",
        "authors": [
            "Ludovic Mignot",
            "Nadia Ouali Sebti",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  There exist several methods of computing an automaton recognizing the\nlanguage denoted by a given regular expression: In the case of words, the\nposition automaton P due to Glushkov, the c-continuation automaton C due to\nChamparnaud and Ziadi, the follow automaton F due to Ilie and Yu and the\nequation automaton E due to Antimirov. It has been shown that P and C are\nisomorphic and that E (resp. F) is a quotient of C (resp. of P). In this paper,\nwe define from a given regular tree expression the k-position tree automaton P\nand the follow tree automaton F . Using the definition of the equation tree\nautomaton E of Kuske and Meinecke and our previously defined k-C-continuation\ntree automaton C, we show that the previous morphic relations are still valid\non tree expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.6251v4"
    },
    {
        "title": "On the state complexity of closures and interiors of regular languages\n  with subwords and superwords",
        "authors": [
            "Prateek Karandikar",
            "Matthias Niewerth",
            "Philippe Schnoebelen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The downward and upward closures of a regular language $L$ are obtained by\ncollecting all the subwords and superwords of its elements, respectively. The\ndownward and upward interiors of $L$ are obtained dually by collecting words\nhaving all their subwords and superwords in $L$, respectively. We provide lower\nand upper bounds on the size of the smallest automata recognizing these\nclosures and interiors. We also consider the computational complexity of\ndecision problems for closures of regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.0690v4"
    },
    {
        "title": "McCammond's normal forms for free aperiodic semigroups revisited",
        "authors": [
            "Jorge Almeida",
            "José Carlos Costa",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper revisits the solution of the word problem for $\\omega$-terms\ninterpreted over finite aperiodic semigroups, obtained by J. McCammond. The\noriginal proof of correctness of McCammond's algorithm, based on normal forms\nfor such terms, uses McCammond's solution of the word problem for certain\nBurnside semigroups. In this paper, we establish a new, simpler, correctness\nproof of McCammond's algorithm, based on properties of certain regular\nlanguages associated with the normal forms. This method leads to new\napplications.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.0888v1"
    },
    {
        "title": "An efficient algorithm for computing the edit distance of a regular\n  language via input-altering transducers",
        "authors": [
            "Lila Kari",
            "Stavros Konstantinidis",
            "Steffen Kopecki",
            "Meng Yang"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We revisit the problem of computing the edit distance of a regular language\ngiven via an NFA. This problem relates to the inherent maximal error-detecting\ncapability of the language in question. We present an efficient algorithm for\nsolving this problem which executes in time $O(r^2n^2d)$, where $r$ is the\ncardinality of the alphabet involved, $n$ is the number of transitions in the\ngiven NFA, and $d$ is the computed edit distance. We have implemented the\nalgorithm and present here performance tests. The correctness of the algorithm\nis based on the result (also presented here) that the particular\nerror-detection property related to our problem can be defined via an\ninput-altering transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.1041v1"
    },
    {
        "title": "Tight Bounds for Complementing Parity Automata",
        "authors": [
            "Sven Schewe",
            "Thomas Varghese"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We follow a connection between tight determinisation and complementation and\nestablish a complementation procedure from parity automata to nondeterministic\nB\\\"uchi automata and prove it to be tight up to an $O(n)$ factor, where $n$ is\nthe size of the nondeterministic parity automaton. This factor does not depend\non the number of priorities.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.1090v1"
    },
    {
        "title": "Eigenvalues and Transduction of Morphic Sequences: Extended Version",
        "authors": [
            "David Sprunger",
            "William Tune",
            "Jörg Endrullis",
            "Lawrence S. Moss"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study finite state transduction of automatic and morphic sequences.\nDekking proved that morphic sequences are closed under transduction and in\nparticular morphic images. We present a simple proof of this fact, and use the\nconstruction in the proof to show that non-erasing transductions preserve a\ncondition called alpha-substitutivity. Roughly, a sequence is\nalpha-substitutive if the sequence can be obtained as the limit of iterating a\nsubstitution with dominant eigenvalue alpha. Our results culminate in the\nfollowing fact: for multiplicatively independent real numbers alpha and beta,\nif v is an alpha-substitutive sequence and w is a beta-substitutive sequence,\nthen v and w have no common non-erasing transducts except for the ultimately\nperiodic sequences. We rely on Cobham's theorem for substitutions, a recent\nresult of Durand.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.1754v1"
    },
    {
        "title": "Integer Vector Addition Systems with States",
        "authors": [
            "Christoph Haase",
            "Simon Halfon"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper studies reachability, coverability and inclusion problems for\nInteger Vector Addition Systems with States (ZVASS) and extensions and\nrestrictions thereof. A ZVASS comprises a finite-state controller with a finite\nnumber of counters ranging over the integers. Although it is folklore that\nreachability in ZVASS is NP-complete, it turns out that despite their\nnaturalness, from a complexity point of view this class has received little\nattention in the literature. We fill this gap by providing an in-depth analysis\nof the computational complexity of the aforementioned decision problems. Most\ninterestingly, it turns out that while the addition of reset operations to\nordinary VASS leads to undecidability and Ackermann-hardness of reachability\nand coverability, respectively, they can be added to ZVASS while retaining\nNP-completness of both coverability and reachability.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.2590v2"
    },
    {
        "title": "(k,l)-Unambiguity and Quasi-Deterministic Structures",
        "authors": [
            "Pascal Caron",
            "Marianne Flouret",
            "Ludovic Mignot"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We focus on the family of $(k,l)$-unambiguous automata that encompasses the\none of deterministic $k$-lookahead automata introduced by Han and Wood. We show\nthat this family presents nice theoretical properties that allow us to compute\nquasi-deterministic structures. These structures are smaller than DFAs and can\nbe used to solve the membership problem faster than NFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.3214v2"
    },
    {
        "title": "On Infinite Words Determined by Indexed Languages",
        "authors": [
            "Tim Smith"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We characterize the infinite words determined by indexed languages. An\ninfinite language $L$ determines an infinite word $\\alpha$ if every string in\n$L$ is a prefix of $\\alpha$. If $L$ is regular or context-free, it is known\nthat $\\alpha$ must be ultimately periodic. We show that if $L$ is an indexed\nlanguage, then $\\alpha$ is a morphic word, i.e., $\\alpha$ can be generated by\niterating a morphism under a coding. Since the other direction, that every\nmorphic word is determined by some indexed language, also holds, this implies\nthat the infinite words determined by indexed languages are exactly the morphic\nwords. To obtain this result, we prove a new pumping lemma for the indexed\nlanguages, which may be of independent interest.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.3373v2"
    },
    {
        "title": "Constrained Expressions and their Derivatives",
        "authors": [
            "Jean-Marc Champarnaud",
            "Ludovic Mignot",
            "Florent Nicart"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper proposes an extension to classical regular expressions by the\naddition of two operators allowing the inclusion of boolean formulae from the\nzeroth order logic. These expressions are called constrained expressions. The\nassociated language is defined thanks to the notion of interpretation and of\nrealization.\n  We show that the language associated when both interpretation and realization\nare fixed is stricly regular and can be not regular otherwise.\n  Furthermore, we use an extension of Antimirov partial derivatives in order to\nsolve the membership test in the general case. Finally, we show that once the\ninterpretation is fixed, the membership test of a word in the language denoted\nby a constrained expression can be undecidable whereas it is always decidable\nwhen the interpretation is not fixed.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.6144v2"
    },
    {
        "title": "Context-Free Grammars with Storage",
        "authors": [
            "Joost Engelfriet"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Context-free S grammars are introduced, for arbitrary (storage) type S, as a\nuniform framework for recursion-based grammars, automata, and transducers,\nviewed as programs. To each occurrence of a nonterminal of a context-free S\ngrammar an object of type S is associated, that can be acted upon by tests and\noperations, as indicated in the rules of the grammar. Taking particular storage\ntypes gives particular formalisms, such as indexed grammars, top-down tree\ntransducers, attribute grammars, etc. Context-free S grammars are equivalent to\npushdown S automata. The context-free S languages can be obtained from the\ndeterministic one-way S automaton languages by way of the delta operations on\nlanguages, introduced in this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.0683v1"
    },
    {
        "title": "On Practical Regular Expressions",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We report on simulation, hierarchy, and decidability results for Practical\nRegular Expressions (PRE), which may include back references in addition to the\nstandard operations union, concatenation, and star.\n  The following results are obtained:\n  PRE can be simulated by the classical model of nondeterministic finite\nautomata with sensing one-way heads. The number of heads depends on the number\nof different variables in the expressions.\n  A space bound O(n log m) for matching a text of length m with a PRE with n\nvariables based on the previous simulation. This improves the bound O(nm) from\n(C\\^ampeanu and Santean 2009).\n  PRE cannot be simulated by deterministic finite automata with at most three\nsensing one-way heads or deterministic finite automata with any number of\nnon-sensing one-way heads.\n  PRE with a bounded number of occurrences of variables in any match can be\nsimulated by nondeterministic finite automata with one-way heads.\n  There is a tight hierarchy of PRE with a growing number of non-nested\nvariables over a fixed alphabet. A previously known hierarchy was based on\nnested variables and growing alphabets (Larsen 1998).\n  Matching of PRE without star over a single-letter alphabet is NP-complete.\nThis strengthens the corresponding result for expressions over larger alphabets\nand with star (Aho 1990).\n  Inequivalence of PRE without closure operators is Sigma^P_2-complete.\n  The decidability of universality of PRE over a single letter alphabet is\nlinked to the existence of Fermat Primes.\n  Greibach's Theorem applies to languages characterized by PRE.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.1258v2"
    },
    {
        "title": "Star-free languages and local divisors",
        "authors": [
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A celebrated result of Sch\\\"utzenberger says that a language is star-free if\nand only if it is is recognized by a finite aperiodic monoid. We give a new\nproof for this theorem using local divisors.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.2842v1"
    },
    {
        "title": "Strong inapproximability of the shortest reset word",
        "authors": [
            "Pawel Gawrychowski",
            "Damian Straszak"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The \\v{C}ern\\'y conjecture states that every $n$-state synchronizing\nautomaton has a reset word of length at most $(n-1)^2$. We study the hardness\nof finding short reset words. It is known that the exact version of the\nproblem, i.e., finding the shortest reset word, is NP-hard and coNP-hard, and\ncomplete for the DP class, and that approximating the length of the shortest\nreset word within a factor of $O(\\log n)$ is NP-hard [Gerbush and Heeringa,\nCIAA'10], even for the binary alphabet [Berlinkov, DLT'13]. We significantly\nimprove on these results by showing that, for every $\\epsilon>0$, it is NP-hard\nto approximate the length of the shortest reset word within a factor of\n$n^{1-\\epsilon}$. This is essentially tight since a simple $O(n)$-approximation\nalgorithm exists.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5248v2"
    },
    {
        "title": "Synthesis of Deterministic Top-down Tree Transducers from Automatic Tree\n  Relations",
        "authors": [
            "Christof Löding",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the synthesis of deterministic tree transducers from automaton\ndefinable specifications, given as binary relations, over finite trees. We\nconsider the case of specifications that are deterministic top-down tree\nautomatic, meaning the specification is recognizable by a deterministic\ntop-down tree automaton that reads the two given trees synchronously in\nparallel. In this setting we study tree transducers that are allowed to have\neither bounded delay or arbitrary delay. Delay is caused whenever the\ntransducer reads a symbol from the input tree but does not produce output. We\nprovide decision procedures for both bounded and arbitrary delay that yield\ndeterministic top-down tree transducers which realize the specification for\nvalid input trees. Similar to the case of relations over words, we use\ntwo-player games to obtain our results.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5959v1"
    },
    {
        "title": "Hourglass Automata",
        "authors": [
            "Yuki Osada",
            "Tim French",
            "Mark Reynolds",
            "Harry Smallbone"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper, we define the class of hourglass automata, which are timed\nautomata with bounded clocks that can be made to progress backwards as well as\nforwards at a constant rate. We then introduce a new clock update for timed\nautomata that allows hourglass automata to be expressed. This allows us to show\nthat language emptiness remains decidable with this update when the number of\nclocks is two or less. This is done by showing that we can construct a finite\nuntimed graph using clock regions from any timed automaton that use this new\nupdate.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5965v1"
    },
    {
        "title": "Deterministic Automata for Unordered Trees",
        "authors": [
            "Adrien Boiret",
            "Vincent Hugot",
            "Joachim Niehren",
            "Ralf Treinen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Automata for unordered unranked trees are relevant for defining schemas and\nqueries for data trees in Json or Xml format. While the existing notions are\nwell-investigated concerning expressiveness, they all lack a proper notion of\ndeterminism, which makes it difficult to distinguish subclasses of automata for\nwhich problems such as inclusion, equivalence, and minimization can be solved\nefficiently. In this paper, we propose and investigate different notions of\n\"horizontal determinism\", starting from automata for unranked trees in which\nthe horizontal evaluation is performed by finite state automata. We show that a\nrestriction to confluent horizontal evaluation leads to polynomial-time\nemptiness and universality, but still suffers from coNP-completeness of the\nemptiness of binary intersections. Finally, efficient algorithms can be\nobtained by imposing an order of horizontal evaluation globally for all\nautomata in the class. Depending on the choice of the order, we obtain\ndifferent classes of automata, each of which has the same expressiveness as\nCMso.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5966v1"
    },
    {
        "title": "Deterministic Timed Finite State Machines: Equivalence Checking and\n  Expressive Power",
        "authors": [
            "Davide Bresolin",
            "Khaled El-Fakih",
            "Tiziano Villa",
            "Nina Yevtushenko"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  There has been a growing interest in defining models of automata enriched\nwith time. For instance, timed automata were introduced as automata extended\nwith clocks. In this paper, we study models of timed finite state machines\n(TFSMs), i.e., FSMs enriched with time, which accept timed input words and\ngenerate timed output words. Here we discuss some models of TFSMs with a single\nclock: TFSMs with timed guards, TFSMs with timeouts, and TFSMs with both timed\nguards and timeouts. We solve the problem of equivalence checking for all three\nmodels, and we compare their expressive power, characterizing subclasses of\nTFSMs with timed guards and of TFSMs with timeouts that are equivalent to each\nother.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5967v1"
    },
    {
        "title": "Plane-Walking Automata",
        "authors": [
            "Ville Salo",
            "Ilkka Törmä"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this article, we study classes of multidimensional subshifts defined by\nmultihead finite automata, in particular the hierarchy of classes of subshifts\ndefined as the number of heads grows. The hierarchy collapses on the third\nlevel, where all co-recursively enumerable subshifts are obtained in every\ndimension. We also compare these classes to SFTs and sofic shifts. We are\nunable to separate the second and third level of the hierarchy in one and two\ndimensions, and suggest a related open problem for two-counter machines.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.6701v1"
    },
    {
        "title": "Control Improvisation",
        "authors": [
            "Daniel J. Fremont",
            "Alexandre Donzé",
            "Sanjit A. Seshia",
            "David Wessel"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We formalize and analyze a new automata-theoretic problem termed control\nimprovisation. Given an automaton, the problem is to produce an improviser, a\nprobabilistic algorithm that randomly generates words in its language, subject\nto two additional constraints: the satisfaction of an admissibility predicate,\nand the exhibition of a specified amount of randomness. Control improvisation\nhas multiple applications, including, for example, generating musical\nimprovisations that satisfy rhythmic and melodic constraints, where\nadmissibility is determined by some bounded divergence from a reference melody.\nWe analyze the complexity of the control improvisation problem, giving cases\nwhere it is efficiently solvable and cases where it is #P-hard or undecidable.\nWe also show how symbolic techniques based on Boolean satisfiability (SAT)\nsolvers can be used to approximately solve some of the intractable cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.0698v5"
    },
    {
        "title": "An Intuitive Procedure for Converting PDA to CFG, by Construction of\n  Single State PDA",
        "authors": [
            "Arjun Bhardwaj",
            "N. S. Narayanaswamy"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present here the proof for an alternative procedure to convert a Push Down\nAutomata (PDA) into a Context Free Grammar (CFG). The procedure involves\nintermediate conversion to a single state PDA. In view of the authors, this\nconversion is conceptually intuitive and can serve as a teaching aid for the\nrelevant topics.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.0813v1"
    },
    {
        "title": "Metamorphosis of Fuzzy Regular Expressions to Fuzzy Automata using the\n  Follow Automata",
        "authors": [
            "Rahul Kumar",
            "Ajay Kumar"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  To deal with system uncertainty, finite automata have been generalized into\nfuzzy automata. Stamenkovic and Ciric proposed an approach using the position\nautomata for the construction of fuzzy automata from fuzzy regular expressions.\nThere exist multifarious methodologies for the construction of finite automata\nfrom regular expressions known as Thompson construction, Antimirov partial\nderivatives, Glushkov automata and follow automata etc. In this paper, we\npropose an approach for the conversion of fuzzy regular expressions into fuzzy\nautomata using the concept of follow automata. The number of states of the\nobtained Fuzzy automata using the proposed approach is lesser than the extant\napproaches in the literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.2865v2"
    },
    {
        "title": "A Complete Refinement Procedure for Regular Separability of Context-Free\n  Languages",
        "authors": [
            "Graeme Gange",
            "Jorge A. Navas",
            "Peter Schachte",
            "Harald Sondergaard",
            "Peter J. Stuckey"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Often, when analyzing the behaviour of systems modelled as context-free\nlanguages, we wish to know if two languages overlap. To this end, we present an\neffective semi-decision procedure for regular separability of context-free\nlanguages, based on counter-example guided abstraction refinement. We propose\ntwo refinement methods, one inexpensive but incomplete, and the other complete\nbut more expensive. We provide an experimental evaluation of this procedure,\nand demonstrate its practicality on a range of verification and\nlanguage-theoretic instances.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.5131v1"
    },
    {
        "title": "Zeno machines and Running Turing machine for infinite time",
        "authors": [
            "Bryce M. Kim"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper explores and clarifies several issues surrounding Zeno machines\nand the issue of running a Turing machine for infinite time. Without a minimum\nhypothetical bound on physical conditions, any magical machine can be created,\nand therefore, a thesis on the bound is formulated. This paper then proves that\nthe halting problem algorithm for every Turing-recognizable program and every\ninput cannot be devised whatever method is used to exploit infinite\nrunning-time of Turing machine.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.5679v1"
    },
    {
        "title": "Concurrent Timed Port Automata",
        "authors": [
            "Radu Grosu",
            "Bernhard Rumpe"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present a new and powerful class of automata which are explicitly\nconcurrent and allow a very simple definition of composition. The novelty of\nthese automata is their time-synchronous message-asynchronous communication\nmechanism. Time synchrony is obtained by using global clock. Message asynchrony\nis obtained by requiring the automata to react to every input. Explicit\nconcurrency is obtained by marking each transition with a set of input and\noutput messages. We compare these automata with a history based approach which\nuses the same communication mechanism and show that they are equivalent.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.6027v1"
    },
    {
        "title": "Quotient of Acceptance Specifications under Reachability Constraints",
        "authors": [
            "Guillaume Verdier",
            "Jean-Baptiste Raclet"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The quotient operation, which is dual to the composition, is crucial in\nspecification theories as it allows the synthesis of missing specifications and\nthus enables incremental design. In this paper, we consider a specification\ntheory based on marked acceptance specifications (MAS) which are automata\nenriched with variability information encoded by acceptance sets and with\nreachability constraints on states. We define a sound and complete quotient for\nMAS hence ensuring reachability properties by construction.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.6463v1"
    },
    {
        "title": "Preset Distinguishing Sequences and Diameter of Transformation\n  Semigroups",
        "authors": [
            "Pavel Panteleev"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We investigate the length $\\ell(n,k)$ of a shortest preset distinguishing\nsequence (PDS) in the worst case for a $k$-element subset of an $n$-state Mealy\nautomaton. It was mentioned by Sokolovskii that this problem is closely related\nto the problem of finding the maximal subsemigroup diameter\n$\\ell(\\mathbf{T}_n)$ for the full transformation semigroup $\\mathbf{T}_n$ of an\n$n$-element set. We prove that\n$\\ell(\\mathbf{T}_n)=2^n\\exp\\{\\sqrt{\\frac{n}{2}\\ln n}(1+ o(1))\\}$ as\n$n\\to\\infty$ and, using approach of Sokolovskii, find the asymptotics of\n$\\log_2 \\ell(n,k)$ as $n,k\\to\\infty$ and $k/n\\to a\\in (0,1)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.0034v1"
    },
    {
        "title": "Complexity of Road Coloring with Prescribed Reset Words",
        "authors": [
            "Vojtěch Vorel",
            "Adam Roman"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  By the Road Coloring Theorem (Trahtman, 2008), the edges of any aperiodic\ndirected multigraph with a constant out-degree can be colored such that the\nresulting automaton admits a reset word. There may also be a need for a\nparticular reset word to be admitted. For certain words it is NP-complete to\ndecide whether there is a suitable coloring of a given multigraph. We present a\nclassification of all words over the binary alphabet that separates such words\nfrom those that make the problem solvable in polynomial time. We show that the\nclassification becomes different if we consider only strongly connected\nmultigraphs. In this restricted setting the classification remains incomplete.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.0799v1"
    },
    {
        "title": "The Emptiness Problem for Tree Automata with at Least One Disequality\n  Constraint is NP-hard",
        "authors": [
            "P. -C Héam",
            "V. Hugot",
            "O. Kouchnarenko"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The model of tree automata with equality and disequality constraints was\nintroduced in 2007 by Filiot, Talbot and Tison. In this paper we show that if\nthere is at least one disequality constraint, the emptiness problem is NP-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.0839v1"
    },
    {
        "title": "A Note on a Recent Attempt to Improve the Pin-Frankl Bound",
        "authors": [
            "François Gonze",
            "Raphaël M. Jungers",
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We provide a counterexample to a lemma used in a recent tentative improvement\nof the the Pin-Frankl bound for synchronizing automata. This example naturally\nleads us to formulate an open question, whose answer could fix the line of\nproof, and improve the bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.0975v1"
    },
    {
        "title": "On $k$-piecewise testability (preliminary report)",
        "authors": [
            "Tomáš Masopust",
            "Michaël Thomazo"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  For a non-negative integer $k$, a language is $k$-piecewise test\\-able\n($k$-PT) if it is a finite boolean combination of languages of the form\n$\\Sigma^* a_1 \\Sigma^* \\cdots \\Sigma^* a_n \\Sigma^*$ for $a_i\\in\\Sigma$ and\n$0\\le n \\le k$. We study the following problem: Given a DFA recognizing a\npiecewise testable language, decide whether the language is $k$-PT. We provide\na complexity bound and a detailed analysis for small $k$'s. The result can be\nused to find the minimal $k$ for which the language is $k$-PT. We show that the\nupper bound on $k$ given by the depth of the minimal DFA can be exponentially\nbigger than the minimal possible $k$, and provide a tight upper bound on the\ndepth of the minimal DFA recognizing a $k$-PT language.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.1641v2"
    },
    {
        "title": "Syntactic Complexity of Suffix-Free Languages",
        "authors": [
            "Janusz Brzozowski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We solve an open problem concerning syntactic complexity: We prove that the\ncardinality of the syntactic semigroup of a suffix-free language with $n$ left\nquotients (that is, with state complexity $n$) is at most $(n-1)^{n-2}+n-2$ for\n$n\\ge 6$. Since this bound is known to be reachable, this settles the problem.\nWe also reduce the alphabet of the witness languages reaching this bound to\nfive letters instead of $n+2$, and show that it cannot be any smaller. Finally,\nwe prove that the transition semigroup of a minimal deterministic automaton\naccepting a witness language is unique for each $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.2281v2"
    },
    {
        "title": "Permutations of context-free and indexed languages",
        "authors": [
            "Tara Brough",
            "Laura Ciobanu",
            "Murray Elder"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the cyclic closure of a language, and its generalisation to the\noperators $C^k$ introduced by Brandst\\\"adt. We prove that the cyclic closure of\nan indexed language is indexed, and that if $L$ is a context-free language then\n$C^k(L)$ is indexed.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.5512v2"
    },
    {
        "title": "The Timestamp of Timed Automata",
        "authors": [
            "Amnon Rosenmann"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Given a member A of the class of non-deterministic timed automata with silent\ntransitions (eNTA), we effectively compute its timestamp: the set of all pairs\n(time value, action) of all observable timed traces of A, a generalization of\nthe reachability problem. We show that the timestamp is eventually periodic and\nthat one can compute a simple deterministic timed automaton with the same\ntimestamp as that of A. As a consequence, we have a partial method, not bounded\nby time or number of steps, for the general language non-inclusion problem for\neNTA. We also show that the language of A is periodic with respect to suffixes.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.5669v5"
    },
    {
        "title": "Representation of (Left) Ideal Regular Languages by Synchronizing\n  Automata",
        "authors": [
            "Marina Maslennikova",
            "Emanuele Rodaro"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We follow language theoretic approach to synchronizing automata and\n\\v{C}ern\\'{y}'s conjecture initiated in a series of recent papers. We find a\nprecise lower bound for the reset complexity of a principal ideal languages.\nAlso we show a strict connection between principal left ideals and\nsynchronizing automata. We characterize regular languages whose minimal\ndeterministic finite automaton is synchronizing and possesses a reset word\nbelonging to the recognized language.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.6767v1"
    },
    {
        "title": "Algebraic synchronization criterion and computing reset words",
        "authors": [
            "Mikhail Berlinkov",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We refine a uniform algebraic approach for deriving upper bounds on reset\nthresholds of synchronizing automata. We express the condition that an\nautomaton is synchronizing in terms of linear algebra, and obtain upper bounds\nfor the reset thresholds of automata with a short word of a small rank. The\nresults are applied to make several improvements in the area.\n  We improve the best general upper bound for reset thresholds of finite prefix\ncodes (Huffman codes): we show that an $n$-state synchronizing decoder has a\nreset word of length at most $O(n \\log^3 n)$. In addition to that, we prove\nthat the expected reset threshold of a uniformly random synchronizing binary\n$n$-state decoder is at most $O(n \\log n)$. We also show that for any non-unary\nalphabet there exist decoders whose reset threshold is in $\\varTheta(n)$.\n  We prove the \\v{C}ern\\'{y} conjecture for $n$-state automata with a letter of\nrank at most $\\sqrt[3]{6n-6}$. In another corollary, based on the recent\nresults of Nicaud, we show that the probability that the \\v{C}ern\\'y conjecture\ndoes not hold for a random synchronizing binary automaton is exponentially\nsmall in terms of the number of states, and also that the expected value of the\nreset threshold of an $n$-state random synchronizing binary automaton is at\nmost $n^{3/2+o(1)}$.\n  Moreover, reset words of lengths within all of our bounds are computable in\npolynomial time. We present suitable algorithms for this task for various\nclasses of automata, such as (quasi-)one-cluster and (quasi-)Eulerian automata,\nfor which our results can be applied.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.8363v3"
    },
    {
        "title": "A Solution to Yamakami's Problem on Advised Context-free Languages",
        "authors": [
            "Toshio Suzuki"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Yamakami [2011, Theoret. Comput. Sci.] studies context-free languages with\nadvice functions. Here, the length of an advice is assumed to be the same as\nthat of an input. Let CFL and CFL/n denote the class of all context-free\nlanguages and that with advice functions, respectively. We let CFL(2) denote\nthe class of intersections of two context-free languages. An interesting\ndirection of a research is asking how complex CFL(2) is, relative to CFL.\nYamakami raised a problem whether there is a CFL-immune set in CFL(2) - CFL/n.\nThe best known so far is that LSPACE - CFL/n has a CFL-immune set, where LSPACE\ndenotes the class of languages recognized in logarithmic-space. We present an\naffirmative solution to his problem. Two key concepts of our proof are the\nnested palindrome and Yamakami's swapping lemma. The swapping lemma is\napplicable to the setting where the pumping lemma (Bar-Hillel's lemma) does not\nwork. Our proof is an example showing how useful the swapping lemma is.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.00367v1"
    },
    {
        "title": "Reversibility of d-State Finite Cellular Automata",
        "authors": [
            "Kamalika Bhattacharjee",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This paper investigates reversibility properties of 1-dimensional\n3-neighborhood d-state finite cellular automata (CAs) of length n under\nperiodic boundary condition. A tool named reachability tree has been developed\nfrom de Bruijn graph which represents all possible reachable configurations of\nan n-cell CA. This tool has been used to test reversibility of CAs. We have\nidentified a large set of reversible CAs using this tool by following some\ngreedy strategies.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.01187v2"
    },
    {
        "title": "Automata and rational expressions",
        "authors": [
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This text is an extended version of the chapter 'Automata and rational\nexpressions' in the AutoMathA Handbook that will appear soon, published by the\nEuropean Science Foundation and edited by JeanEricPin.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.03573v1"
    },
    {
        "title": "Varieties",
        "authors": [
            "Howard Straubing",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This text is devoted to the theory of varieties, which provides an important\ntool, based in universal algebra, for the classification of regular languages.\nIn the introductory section, we present a number of examples that illustrate\nand motivate the fundamental concepts. We do this for the most part without\nproofs, and often without precise definitions, leaving these to the formal\ndevelopment of the theory that begins in Section 2. Our presentation of the\ntheory draws heavily on the work of Gehrke, Grigorieff and Pin (2008) on the\nequational theory of lattices of regular languages. In the subsequent sections\nwe consider in more detail aspects of varieties that were only briefly evoked\nin the introduction: Decidability, operations on languages, and\ncharacterizations in formal logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.03951v3"
    },
    {
        "title": "Rewriting Higher-Order Stack Trees",
        "authors": [
            "Vincent Penelle"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Higher-order pushdown systems and ground tree rewriting systems can be seen\nas extensions of suffix word rewriting systems. Both classes generate infinite\ngraphs with interesting logical properties. Indeed, the model-checking problem\nfor monadic second order logic (respectively first order logic with a\nreachability predicate) is decidable on such graphs. We unify both models by\nintroducing the notion of stack trees, trees whose nodes are labelled by\nhigher-order stacks, and define the corresponding class of higher-order ground\ntree rewriting systems. We show that these graphs retain the decidability\nproperties of ground tree rewriting graphs while generalising the pushdown\nhierarchy of graphs.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.04653v1"
    },
    {
        "title": "Annotated Stack Trees",
        "authors": [
            "Matthew Hague",
            "Vincent Penelle"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Annotated pushdown automata provide an automaton model of higher-order\nrecursion schemes, which may in turn be used to model higher-order programs for\nthe purposes of verification. We study Ground Annotated Stack Tree Rewrite\nSystems -- a tree rewrite system where each node is labelled by the\nconfiguration of an annotated pushdown automaton. This allows the modelling of\nfork and join constructs in higher-order programs and is a generalisation of\nhigher-order stack trees recently introduced by Penelle.\n  We show that, given a regular set of annotated stack trees, the set of trees\nthat can reach this set is also regular, and constructible in n-EXPTIME for an\norder-n system, which is optimal. We also show that our construction can be\nextended to allow a global state through which unrelated nodes of the tree may\ncommunicate, provided the number of communications is subject to a fixed bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.05873v2"
    },
    {
        "title": "Algorithm for the k-Position Tree Automaton Construction",
        "authors": [
            "Nadia Ouali Sebti",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The word position automaton was introduced by Glushkov and McNaughton in the\nearly 1960. This automaton is homogeneous and has (||\\E||+1) states for a word\nexpression of alphabetic width ||\\E||. This kind of automata is extended to\nregular tree expressions.\n  In this paper, we give an efficient algorithm that computes the \\Follow sets,\nwhich are used in different algorithms of conversion of a regular expression\ninto tree automata. In the following, we consider the k-position tree automaton\nconstruction. We prove that for a regular expression \\E of a size |\\E| and\nalphabetic width ||\\E||, the \\Follow sets can be computed in O(||\\E||\\cdot\n|\\E|) time complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.06194v1"
    },
    {
        "title": "Growth rate of binary words avoiding $xxx^R$",
        "authors": [
            "James D. Currie",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Consider the set of those binary words with no non-empty factors of the form\n$xxx^R$. Du, Mousavi, Schaeffer, and Shallit asked whether this set of words\ngrows polynomially or exponentially with length. In this paper, we demonstrate\nthe existence of upper and lower bounds on the number of such words of length\n$n$, where each of these bounds is asymptotically equivalent to a (different)\nfunction of the form $Cn^{\\lg n+c}$, where $C$, $c$ are constants.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.07014v1"
    },
    {
        "title": "Partial Derivative Automaton for Regular Expressions with Shuffle",
        "authors": [
            "Sabine Broda",
            "António Machiavelo",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We generalize the partial derivative automaton to regular expressions with\nshuffle and study its size in the worst and in the average case. The number of\nstates of the partial derivative automata is in the worst case at most 2^m,\nwhere m is the number of letters in the expression, while asymptotically and on\naverage it is no more than (4/3)^m.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.00279v1"
    },
    {
        "title": "Regular realizability problems and context-free languages",
        "authors": [
            "Alexander A. Rubtsov",
            "Mikhail N. Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate regular realizability (RR) problems, which are the problems of\nverifying whether intersection of a regular language -- the input of the\nproblem -- and fixed language called filter is non-empty. In this paper we\nfocus on the case of context-free filters. Algorithmic complexity of the RR\nproblem is a very coarse measure of context-free languages complexity. This\ncharacteristic is compatible with rational dominance. We present examples of\nP-complete RR problems as well as examples of RR problems in the class NL. Also\nwe discuss RR problems with context-free filters that might have intermediate\ncomplexity. Possible candidates are the languages with polynomially bounded\nrational indices.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.00295v2"
    },
    {
        "title": "An approach to computing downward closures",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The downward closure of a word language is the set of all (not necessarily\ncontiguous) subwords of its members. It is well-known that the downward closure\nof any language is regular. While the downward closure appears to be a powerful\nabstraction, algorithms for computing a finite automaton for the downward\nclosure of a given language have been established only for few language\nclasses.\n  This work presents a simple general method for computing downward closures.\nFor language classes that are closed under rational transductions, it is shown\nthat the computation of downward closures can be reduced to checking a certain\nunboundedness property.\n  This result is used to prove that downward closures are computable for (i)\nevery language class with effectively semilinear Parikh images that are closed\nunder rational transductions, (ii) matrix languages, and (iii) indexed\nlanguages (equivalently, languages accepted by higher-order pushdown automata\nof order 2).\n",
        "pdf_link": "http://arxiv.org/pdf/1503.01068v2"
    },
    {
        "title": "Quotient Complexities of Atoms in Regular Ideal Languages",
        "authors": [
            "Janusz Brzozowski",
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A (left) quotient of a language $L$ by a word $w$ is the language\n$w^{-1}L=\\{x\\mid wx\\in L\\}$. The quotient complexity of a regular language $L$\nis the number of quotients of $L$; it is equal to the state complexity of $L$,\nwhich is the number of states in a minimal deterministic finite automaton\naccepting $L$. An atom of $L$ is an equivalence class of the relation in which\ntwo words are equivalent if for each quotient, they either are both in the\nquotient or both not in it; hence it is a non-empty intersection of\ncomplemented and uncomplemented quotients of $L$. A right (respectively, left\nand two-sided) ideal is a language $L$ over an alphabet $\\Sigma$ that satisfies\n$L=L\\Sigma^*$ (respectively, $L=\\Sigma^*L$ and $L=\\Sigma^*L\\Sigma^*$). We\ncompute the maximal number of atoms and the maximal quotient complexities of\natoms of right, left and two-sided regular ideals.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.02208v2"
    },
    {
        "title": "The Kinetic Basis of Morphogenesis",
        "authors": [
            "Yuri Shalygo"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  It has been shown recently (Shalygo, 2014) that stationary and dynamic\npatterns can arise in the proposed one-component model of the analog\n(continuous state) kinetic automaton, or kinon for short, defined as a\nreflexive dynamical system with active transport. This paper presents\nextensions of the model, which increase further its complexity and tunability,\nand shows that the extended kinon model can produce spatio-temporal patterns\npertaining not only to pattern formation but also to morphogenesis in real\nphysical and biological systems. The possible applicability of the model to\nmorphogenetic engineering and swarm robotics is also discussed.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.03321v2"
    },
    {
        "title": "On the Coverability Problem for Pushdown Vector Addition Systems in One\n  Dimension",
        "authors": [
            "Jérôme Leroux",
            "Grégoire Sutre",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Does the trace language of a given vector addition system (VAS) intersect\nwith a given context-free language? This question lies at the heart of several\nverification questions involving recursive programs with integer parameters. In\nparticular, it is equivalent to the coverability problem for VAS that operate\non a pushdown stack. We show decidability in dimension one, based on an\nanalysis of a new model called grammar-controlled vector addition systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.04018v3"
    },
    {
        "title": "Diverse Palindromic Factorization is NP-Complete",
        "authors": [
            "Hideo Bannai",
            "Travis Gagie",
            "Shunsuke Inenaga",
            "Juha Karkkainen",
            "Dominik Kempa",
            "Marcin Piatkowski",
            "Simon J. Puglisi",
            "Shiho Sugimoto"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We prove that it is NP-complete to decide whether a given string can be\nfactored into palindromes that are each unique in the factorization.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.04045v3"
    },
    {
        "title": "Factorization in Formal Languages",
        "authors": [
            "Paul Bell",
            "Daniel Reidenbach",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider several novel aspects of unique factorization in formal\nlanguages. We reprove the familiar fact that the set uf(L) of words having\nunique factorization into elements of L is regular if L is regular, and from\nthis deduce an quadratic upper and lower bound on the length of the shortest\nword not in uf(L). We observe that uf(L) need not be context-free if L is\ncontext-free.\n  Next, we consider variations on unique factorization. We define a notion of\n\"semi-unique\" factorization, where every factorization has the same number of\nterms, and show that, if L is regular or even finite, the set of words having\nsuch a factorization need not be context-free. Finally, we consider additional\nvariations, such as unique factorization \"up to permutation\" and \"up to\nsubset\".\n",
        "pdf_link": "http://arxiv.org/pdf/1503.06365v1"
    },
    {
        "title": "Pairs of Languages Closed under Shuffle Projection",
        "authors": [
            "Peter Ochsenschläger",
            "Roland Rieke"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Shuffle projection is motivated by the verification of safety properties of\nspecial parameterized systems. Basic definitions and properties, especially\nrelated to alphabetic homomorphisms, are presented. The relation between\niterated shuffle products and shuffle projections is shown. A special class of\nmulti-counter automata is introduced, to formulate shuffle projection in terms\nof computations of these automata represented by transductions. This\nreformulation of shuffle projection leads to construction principles for pairs\nof languages closed under shuffle projection. Additionally, it is shown that\nunder certain conditions these transductions are rational, which implies\ndecidability of closure against shuffle projection. Decidability of these\nconditions is proven for regular languages. Finally, without additional\nconditions, decidability of the question, whether a pair of regular languages\nis closed under shuffle projection, is shown. In an appendix the relation\nbetween shuffle projection and the shuffle product of two languages is\ndiscussed. Additionally, a kind of shuffle product for computations in\nS-automata is defined.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.08602v1"
    },
    {
        "title": "On the Sizes of DPDAs, PDAs, LBAs",
        "authors": [
            "Richard Beigel",
            "William Gasarch"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  There are languages A such that there is a Pushdown Automata (PDA) that\nrecognizes A which is much smaller than any Deterministic Pushdown Automata\n(DPDA) that recognizes A. There are languages A such that there is a Linear\nBounded Automata (Linear Space Turing Machine, henceforth LBA) that recognizes\nA which is much smaller than ny PDA that recognizes A. There are languages A\nsuch that both A and compliment(A) are recognizable by a PDA, but the PDA for A\nis much smaller than the PDA for compliment(A). There are languages A1, A2 such\nthat A1,A2,A1 INTERSECT A_2 are recognizable by a PDA, but the PDA for A1 and\nA2 are much smaller than the PDA for A1 INTERSECT A2. We investigate these\nphenomenon and show that, in all these cases, the size difference is captured\nby a function whose Turing degree is on the second level of the arithmetic\nhierarchy.\n  Our theorems lead to infinitely-often results. For example: for infinitely\nmany $n$ there exists a language An recognized by a DPDA such that there is a\nsmall PDA for An, but any DPDA for An is large. We look at cases where we can\nget almost-all results, though with much smaller size differences.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.08847v3"
    },
    {
        "title": "On the Combinatorics of Palindromes and Antipalindromes",
        "authors": [
            "Chuan Guo",
            "Jeffrey Shallit",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We prove a number of results on the structure and enumeration of palindromes\nand antipalindromes. In particular, we study conjugates of palindromes,\npalindromic pairs, rich words, and the counterparts of these notions for\nantipalindromes.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.09112v1"
    },
    {
        "title": "Equivalence of Deterministic Top-Down Tree-to-String Transducers is\n  Decidable",
        "authors": [
            "Helmut Seidl",
            "Sebastian Maneth",
            "Gregor Kemper"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We show that equivalence of deterministic top-down tree-to-string transducers\nis decidable, thus solving a long standing open problem in formal language\ntheory. We also present efficient algorithms for subclasses: polynomial time\nfor total transducers with unary output alphabet (over a given top-down regular\ndomain language), and co-randomized polynomial time for linear transducers;\nthese results are obtained using techniques from multi-linear algebra.\n  For our main result, we prove that equivalence can be certified by means of\ninductive invariants using polynomial ideals. This allows us to construct two\nsemi-algorithms, one searching for a proof of equivalence, one for a witness of\nnon-equivalence. Furthermore, we extend our result to deterministic top-down\ntree-to-string transducers which produce output not in a free monoid but in a\nfree group.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.09163v2"
    },
    {
        "title": "Copyless Cost-Register Automata: Structure, Expressiveness, and Closure\n  Properties",
        "authors": [
            "Filip Mazowiecki",
            "Cristian Riveros"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Cost register automata (CRA) and its subclass, copyless CRA, were recently\nproposed by Alur et al. as a new model for computing functions over strings. We\nstudy some structural properties, expressiveness, and closure properties of\ncopyless CRA. We show that copyless CRA are strictly less expressive than\nweighted automata and are not closed under reverse operation. To find a better\nclass we impose restrictions on copyless CRA, which ends successfully with a\nnew robust computational model that is closed under reverse and other\nextensions.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.01709v2"
    },
    {
        "title": "Multi-Sequential Word Relations",
        "authors": [
            "Ismaël Jecker",
            "Emmanuel Filiot"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Rational relations are binary relations of finite words that are realised by\nnon-deterministic finite state transducers (NFT). A particular kind of rational\nrelations is the sequential functions. Sequential functions are the functions\nthat can be realised by input-deterministic transducers. Some rational\nfunctions are not sequential. However, based on a property on transducers\ncalled the twinning property, it is decidable in PTime whether a rational\nfunction given by an NFT is sequential. In this paper, we investigate the\ngeneralisation of this result to multi-sequential relations, i.e. relations\nthat are equal to a finite union of sequential functions. We show that given an\nNFT, it is decidable in PTime whether the relation it defines is\nmulti-sequential, based on a property called the weak twinning property. If the\nweak twinning property is satisfied, we give a procedure that effectively\nconstructs a finite set of input-deterministic transducers whose union defines\nthe relation. This procedure generalises to arbitrary NFT the determinisation\nprocedure of functional NFT.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.03864v1"
    },
    {
        "title": "Deciding the value 1 problem for probabilistic leaktight automata",
        "authors": [
            "Nathanaël Fijalkow",
            "Hugo Gimbert",
            "Edon Kelmendi",
            "Youssouf Oualhadj"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The value 1 problem is a decision problem for probabilistic automata over\nfinite words: given a probabilistic automaton, are there words accepted with\nprobability arbitrarily close to 1? This problem was proved undecidable\nrecently; to overcome this, several classes of probabilistic automata of\ndifferent nature were proposed, for which the value 1 problem has been shown\ndecidable. In this paper, we introduce yet another class of probabilistic\nautomata, called leaktight automata, which strictly subsumes all classes of\nprobabilistic automata whose value 1 problem is known to be decidable. We prove\nthat for leaktight automata, the value 1 problem is decidable (in fact,\nPSPACE-complete) by constructing a saturation algorithm based on the\ncomputation of a monoid abstracting the behaviours of the automaton. We rely on\nalgebraic techniques developed by Simon to prove that this abstraction is\ncomplete. Furthermore, we adapt this saturation algorithm to decide whether an\nautomaton is leaktight. Finally, we show a reduction allowing to extend our\ndecidability results from finite words to infinite ones, implying that the\nvalue 1 problem for probabilistic leaktight parity automata is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.04136v3"
    },
    {
        "title": "Polynomial Interrupt Timed Automata",
        "authors": [
            "Béatrice Bérard",
            "Serge Haddad",
            "Claudine Picaronny",
            "Mohab Safey El Din",
            "Mathieu Sassolas"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Interrupt Timed Automata (ITA) form a subclass of stopwatch automata where\nreachability and some variants of timed model checking are decidable even in\npresence of parameters. They are well suited to model and analyze real-time\noperating systems. Here we extend ITA with polynomial guards and updates,\nleading to the class of polynomial ITA (PolITA). We prove the decidability of\nthe reachability and model checking of a timed version of CTL by an adaptation\nof the cylindrical decomposition method for the first-order theory of reals.\nCompared to previous approaches, our procedure handles parameters and clocks in\na unified way. Moreover, we show that PolITA are incomparable with stopwatch\nautomata. Finally additional features are introduced while preserving\ndecidability.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.04541v1"
    },
    {
        "title": "Symbolic Manipulation of Code Properties",
        "authors": [
            "Stavros Konstantinidis",
            "Casey Meijer",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The FAdo system is a symbolic manipulator of formal languages objects,\nimplemented in Python. In this work, we extend its capabilities by implementing\nmethods to manipulate transducers and we go one level higher than existing\nformal language systems and implement methods to manipulate objects\nrepresenting classes of independent languages (widely known as code\nproperties). Our methods allow users to define their own code properties and\ncombine them between themselves or with fixed properties such as prefix codes,\nsuffix codes, error detecting codes, etc. The satisfaction and maximality\ndecision questions are solvable for any of the definable properties. The new\nonline system LaSer allows to query about code properties and obtain the answer\nin a batch mode. Our work is founded on independence theory as well as the\ntheory of rational relations and transducers and contributes with improveded\nalgorithms on these objects.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.04715v2"
    },
    {
        "title": "Homing Vector Automata",
        "authors": [
            "Özlem Salehi",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We introduce homing vector automata, which are finite automata augmented by a\nvector that is multiplied at each step by a matrix determined by the current\ntransition, and have to return the vector to its original setting in order to\naccept the input. The computational power of the deterministic,\nnondeterministic and blind versions of these real-time machines are examined\nand compared to various related types of automata. A generalized version of the\nStern-Brocot encoding method, suitable for representing strings on arbitrary\nalphabets, is also developed.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.04859v2"
    },
    {
        "title": "Complexity of Suffix-Free Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study various complexity properties of suffix-free regular languages. The\nquotient complexity of a regular language $L$ is the number of left quotients\nof $L$; this is the same as the state complexity of $L$. A regular language\n$L'$ is a dialect of a regular language $L$ if it differs only slightly from\n$L$. The quotient complexity of an operation on regular languages is the\nmaximal quotient complexity of the result of the operation expressed as a\nfunction of the quotient complexities of the operands. A sequence\n$(L_k,L_{k+1},\\dots)$ of regular languages in some class ${\\mathcal C}$, where\n$n$ is the quotient complexity of $L_n$, is called a stream. A stream is most\ncomplex in class ${\\mathcal C}$ if its languages $L_n$ meet the complexity\nupper bounds for all basic measures. It is known that there exist such most\ncomplex streams in the class of regular languages, in the class of prefix-free\nlanguages, and also in the classes of right, left, and two-sided ideals. In\ncontrast to this, we prove that there does not exist a most complex stream in\nthe class of suffix-free regular languages. However, we do exhibit one ternary\nsuffix-free stream that meets the bound for product and whose restrictions to\nbinary alphabets meet the bounds for star and boolean operations. We also\nexhibit a quinary stream that meets the bounds for boolean operations,\nreversal, size of syntactic semigroup, and atom complexities. Moreover, we\nsolve an open problem about the bound for the product of two languages of\nquotient complexities $m$ and $n$ in the binary case by showing that it can be\nmet for infinitely many $m$ and $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.05159v4"
    },
    {
        "title": "Nested Weighted Automata",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Recently there has been a significant effort to handle quantitative\nproperties in formal verification and synthesis. While weighted automata over\nfinite and infinite words provide a natural and flexible framework to express\nquantitative properties, perhaps surprisingly, some basic system properties\nsuch as average response time cannot be expressed using weighted automata, nor\nin any other know decidable formalism. In this work, we introduce nested\nweighted automata as a natural extension of weighted automata which makes it\npossible to express important quantitative properties such as average response\ntime. In nested weighted automata, a master automaton spins off and collects\nresults from weighted slave automata, each of which computes a quantity along a\nfinite portion of an infinite word. Nested weighted automata can be viewed as\nthe quantitative analogue of monitor automata, which are used in run-time\nverification. We establish an almost complete decidability picture for the\nbasic decision problems about nested weighted automata, and illustrate their\napplicability in several domains. In particular, nested weighted automata can\nbe used to decide average response time properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.06117v1"
    },
    {
        "title": "Language Emptiness of Continuous-Time Parametric Timed Automata",
        "authors": [
            "Nikola Beneš",
            "Peter Bezděk",
            "Kim G. Larsen",
            "Jiří Srba"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Parametric timed automata extend the standard timed automata with the\npossibility to use parameters in the clock guards. In general, if the\nparameters are real-valued, the problem of language emptiness of such automata\nis undecidable even for various restricted subclasses. We thus focus on the\ncase where parameters are assumed to be integer-valued, while the time still\nremains continuous. On the one hand, we show that the problem remains\nundecidable for parametric timed automata with three clocks and one parameter.\nOn the other hand, for the case with arbitrary many clocks where only one of\nthese clocks is compared with (an arbitrary number of) parameters, we show that\nthe parametric language emptiness is decidable. The undecidability result\ntightens the bounds of a previous result which assumed six parameters, while\nthe decidability result extends the existing approaches that deal with\ndiscrete-time semantics only. To the best of our knowledge, this is the first\npositive result in the case of continuous-time and unbounded integer\nparameters, except for the rather simple case of single-clock automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.07838v1"
    },
    {
        "title": "Edit Distance for Pushdown Automata",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Rasmus Ibsen-Jensen",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The edit distance between two words $w_1, w_2$ is the minimal number of word\noperations (letter insertions, deletions, and substitutions) necessary to\ntransform $w_1$ to $w_2$. The edit distance generalizes to languages\n$\\mathcal{L}_1, \\mathcal{L}_2$, where the edit distance from $\\mathcal{L}_1$ to\n$\\mathcal{L}_2$ is the minimal number $k$ such that for every word from\n$\\mathcal{L}_1$ there exists a word in $\\mathcal{L}_2$ with edit distance at\nmost $k$. We study the edit distance computation problem between pushdown\nautomata and their subclasses. The problem of computing edit distance to a\npushdown automaton is undecidable, and in practice, the interesting question is\nto compute the edit distance from a pushdown automaton (the implementation, a\nstandard model for programs with recursion) to a regular language (the\nspecification). In this work, we present a complete picture of decidability and\ncomplexity for the following problems: (1)~deciding whether, for a given\nthreshold $k$, the edit distance from a pushdown automaton to a finite\nautomaton is at most $k$, and (2)~deciding whether the edit distance from a\npushdown automaton to a finite automaton is finite.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.08259v4"
    },
    {
        "title": "Zero-One Law for Regular Languages and Semigroups with Zero",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A regular language has the zero-one law if its asymptotic density converges\nto either zero or one. We prove that the class of all zero-one languages is\nclosed under Boolean operations and quotients. Moreover, we prove that a\nregular language has the zero-one law if and only if its syntactic monoid has a\nzero element. Our proof gives both algebraic and automata characterisation of\nthe zero-one law for regular languages, and it leads the following two\ncorollaries: (i) There is an O(n log n) algorithm for testing whether a given\nregular language has the zero-one law. (ii) The Boolean closure of existential\nfirst-order logic over finite words has the zero-one law.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.03343v3"
    },
    {
        "title": "Counting Branches in Trees Using Games",
        "authors": [
            "Arnaud Carayol",
            "Axel Haddad",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study finite automata running over infinite binary trees. A run of such an\nautomaton is usually said to be accepting if all its branches are accepting. In\nthis article, we relax the notion of accepting run by allowing a certain\nquantity of rejecting branches.\n  More precisely we study the following criteria for a run to be accepting: -\nit contains at most finitely (resp countably) many rejecting branches; - it\ncontains infinitely (resp uncountably) many accepting branches; - the set of\naccepting branches is topologically \"big\".\n  In all situations we provide a simple acceptance game that later permits to\nprove that the languages accepted by automata with cardinality constraints are\nalways $\\omega$-regular. In the case (ii) where one counts accepting branches\nit leads to new proofs (without appealing to logic) of an old result of\nBeauquier and Niwinski.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.03852v1"
    },
    {
        "title": "Embedding rationally independent languages into maximal ones",
        "authors": [
            "Stavros Konstantinidis",
            "Mitja Mastnak"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider the embedding problem in coding theory: given an independence (a\ncode-related property) and an independent language $L$, find a maximal\nindependent language containing $L$. We consider the case where the\ncode-related property is defined via a rational binary relation that is\ndecreasing with respect to any fixed total order on the set of words. Our\nmethod works by iterating a max-min operator that has been used before for the\nembedding problem for properties defined by length-increasing-and-transitive\nbinary relations. By going to order-decreasing rational relations, represented\nby input-decreasing transducers, we are able to include many known properties\nfrom both the noiseless and noisy domains of coding theory, as well as any\ncombination of such properties. Moreover, in many cases the desired maximal\nembedding is effectively computable.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.00600v1"
    },
    {
        "title": "A Note on Monitors and Büchi automata",
        "authors": [
            "Volker Diekert",
            "Anca Muscholl",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  When a property needs to be checked against an unknown or very complex\nsystem, classical exploration techniques like model-checking are not applicable\nanymore. Sometimes a~monitor can be used, that checks a given property on the\nunderlying system at runtime. A monitor for a property $L$ is a deterministic\nfinite automaton $M_L$ that after each finite execution tells whether (1) every\npossible extension of the execution is in $L$, or (2) every possible extension\nis in the complement of $L$, or neither (1) nor (2) holds. Moreover, $L$ being\nmonitorable means that it is always possible that in some future the monitor\nreaches (1) or (2). Classical examples for monitorable properties are safety\nand cosafety properties. On the other hand, deterministic liveness properties\nlike \"infinitely many $a$'s\" are not monitorable. We discuss various monitor\nconstructions with a focus on deterministic omega-regular languages. We locate\na proper subclass of of deterministic omega-regular languages but also strictly\nlarge than the subclass of languages which are deterministic and\ncodeterministic, and for this subclass there exists a canonical monitor which\nalso accepts the language itself.\n  We also address the problem to decide monitorability in comparison with\ndeciding liveness. The state of the art is as follows. Given a B\\\"uchi\nautomaton, it is PSPACE-complete to decide liveness or monitorability. Given an\nLTL formula, deciding liveness becomes EXPSPACE-complete, but the complexity to\ndecide monitorability remains open.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.01020v1"
    },
    {
        "title": "Unboundedness and Downward Closures of Higher-Order Pushdown Automata",
        "authors": [
            "Matthew Hague",
            "Jonathan Kochems",
            "C. -H. Luke Ong"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We show the diagonal problem for higher-order pushdown automata (HOPDA), and\nhence the simultaneous unboundedness problem, is decidable. From recent work by\nZetzsche this means that we can construct the downward closure of the set of\nwords accepted by a given HOPDA. This also means we can construct the downward\nclosure of the Parikh image of a HOPDA. Both of these consequences play an\nimportant role in verifying concurrent higher-order programs expressed as HOPDA\nor safe higher-order recursion schemes.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.03304v2"
    },
    {
        "title": "A theory of probabilistic automata, part 1",
        "authors": [
            "Andrew M. Mironov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In the book we present main concepts of probabilistic automata theory.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.05164v1"
    },
    {
        "title": "Watson-Crick Quantum Finite Automata",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  1-way quantum finite automata are deterministic and reversible in nature,\nwhich greatly reduces its accepting property. In fact the set of languages\naccepted by 1-way quantum finite automata is a proper subset of regular\nlanguages. In this paper we replace the tape head of 1-way quantum finite\nautomata with DNA double strand and name the model Watson-Crick quantum finite\nautomata. The non-injective complementarity relation of Watson-Crick automata\nintroduces non-determinism in the quantum model. We show that this introduction\nof non-determinism increases the computational power of 1-way Quantum finite\nautomata significantly. We establish that Watson-Crick quantum finite automata\ncan accept all regular languages and that it also accepts some languages not\naccepted by any multihead deterministic finite automata. Exploiting the\nsuperposition property of quantum finite automata we show that Watson-Crick\nquantum finite automata accept the language L=ww where w belongs to {a,b}*.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.05282v2"
    },
    {
        "title": "Reversible Watson-Crick Automata",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Watson-Crick automata are finite automata working on double strands.\nExtensive research work has already been done on non-deterministic Watson-Crick\nautomata and on deterministic Watson-Crick automata. In this paper, we\nintroduce a new model of Watson-Crick automata which is reversible in nature\nnamed reversible Watson-Crick automata and explore its computational power. We\nshow even though the model is reversible and one way it accepts all regular\nlanguages and also analyze the state complexity of the above stated model with\nrespect to non-deterministic block automata and non-deterministic finite\nautomata and establish its superiority. We further explore the relation of the\nreversible model with twin-shuffle language and recursively enumerable\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.05283v2"
    },
    {
        "title": "Deterministic parallel communicating Watson-Crick automata systems",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper, we have introduced the deterministic variant of parallel\ncommunicating Watson-Crick automata systems. We show that similar to the\nnon-deterministic version, the deterministic version can also recognise some\nnon-regular uniletter languages. We further establish that strongly\ndeterministic Watson-Crick automata systems and deterministic Watson-Crick\nautomata system are incomparable in terms of their computational ability. We\nhave also compared the computational ability of our system with multihead\nfinite automata and parallel communicating finite automata systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.05284v1"
    },
    {
        "title": "On Boundedness Problems for Pushdown Vector Addition Systems",
        "authors": [
            "Jérôme Leroux",
            "Grégoire Sutre",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study pushdown vector addition systems, which are synchronized products of\npushdown automata with vector addition systems. The question of the boundedness\nof the reachability set for this model can be refined into two decision\nproblems that ask if infinitely many counter values or stack configurations are\nreachable, respectively.\n  Counter boundedness seems to be the more intricate problem. We show\ndecidability in exponential time for one-dimensional systems. The proof is via\na small witness property derived from an analysis of derivation trees of\ngrammar-controlled vector addition systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.07362v1"
    },
    {
        "title": "Normal forms for linear displacement context-free grammars",
        "authors": [
            "Alexey Sorokin"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we prove several results on normal forms for linear\ndisplacement context-free grammars. The results themselves are rather simple\nand use well-known techniques, but they are extensively used in more complex\nconstructions. Therefore this article mostly serves educational and referential\npurposes.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.08600v1"
    },
    {
        "title": "On the Number of Synchronizing Colorings of Digraphs",
        "authors": [
            "Vladimir V. Gusev",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We deal with $k$-out-regular directed multigraphs with loops (called simply\n\\emph{digraphs}). The edges of such a digraph can be colored by elements of\nsome fixed $k$-element set in such a way that outgoing edges of every vertex\nhave different colors. Such a coloring corresponds naturally to an automaton.\nThe road coloring theorem states that every primitive digraph has a\nsynchronizing coloring.\n  In the present paper we study how many synchronizing colorings can exist for\na digraph with $n$ vertices. We performed an extensive experimental\ninvestigation of digraphs with small number of vertices. This was done by using\nour dedicated algorithm exhaustively enumerating all small digraphs. We also\npresent a series of digraphs whose fraction of synchronizing colorings is equal\nto $1-1/k^d$, for every $d \\ge 1$ and the number of vertices large enough.\n  On the basis of our results we state several conjectures and open problems.\nIn particular, we conjecture that $1-1/k$ is the smallest possible fraction of\nsynchronizing colorings, except for a single exceptional example on 6 vertices\nfor $k=2$.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.02133v1"
    },
    {
        "title": "Bounded Determinization of Timed Automata with Silent Transitions",
        "authors": [
            "Florian Lorber",
            "Amnon Rosenmann",
            "Dejan Nickovic",
            "Bernhard Aichernig"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Deterministic timed automata are strictly less expressive than their\nnon-deterministic counterparts, which are again less expressive than those with\nsilent transitions. As a consequence, timed automata are in general\nnon-determinizable. This is unfortunate since deterministic automata play a\nmajor role in model-based testing, observability and implementability. However,\nby bounding the length of the traces in the automaton, effective\ndeterminization becomes possible. We propose a novel procedure for bounded\ndeterminization of timed automata. The procedure unfolds the automata to\nbounded trees, removes all silent transitions and determinizes via disjunction\nof guards. The proposed algorithms are optimized to the bounded setting and\nthus are more efficient and can handle a larger class of timed automata than\nthe general algorithms. The approach is implemented in a prototype tool and\nevaluated on several examples. To our best knowledge, this is the first\nimplementation of this type of procedure for timed automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.03575v1"
    },
    {
        "title": "A note on the avoidability of binary patterns with variables and\n  reversals",
        "authors": [
            "Robert Mercaş"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this note we present a characterisation of all unary and binary patterns\nthat do not only contain variables, but also reversals of their instances.\nThese types of variables were studied recently in either more general or\nparticular cases. We show that the results are not surprising at all in the\ngeneral case, and extend the avoidability of these patterns to enforce\naperiodic words.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.04571v1"
    },
    {
        "title": "On the regularity of $\\{\\lfloor\\log_b(αn+β)\\rfloor\\}_{n\\geq0}$",
        "authors": [
            "Jiemeng Zhang",
            "Yingjun Guo",
            "Zhixiong Wen"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Let $\\alpha,\\beta$ be real numbers and $b\\geq2$ be an integer. Allouche and\nShallit showed that the sequence $\\{\\lfloor\\alpha n+\\beta\\rfloor\\}_{n\\geq0}$ is\n$b$-regular if and only if $\\alpha$ is rational. In this paper, using a\nbase-independent regular language, we prove a similar result that the sequence\n$\\{\\lfloor\\log_b(\\alpha n+\\beta)\\rfloor\\}_{n\\geq0}$ is $b$-regular if and only\nif $\\alpha$ is rational. In particular, when $\\alpha=\\sqrt{2},\\beta=0$ and\n$b=2$, we answer the question of Allouche and Shallit that the sequence\n$\\{\\lfloor\\frac{1}{2}+\\log_2n\\rfloor\\}_{n\\geq0}$ is not $2$-regular, which has\nbeen proved by Bell, Moshe and Rowland respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.06466v1"
    },
    {
        "title": "Testing k-binomial equivalence",
        "authors": [
            "Dominik D. Freydenberger",
            "Pawel Gawrychowski",
            "Juhani Karhumäki",
            "Florin Manea",
            "Wojciech Rytter"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Two words $w_1$ and $w_2$ are said to be $k$-binomial equivalent if every\nnon-empty word $x$ of length at most $k$ over the alphabet of $w_1$ and $w_2$\nappears as a scattered factor of $w_1$ exactly as many times as it appears as a\nscattered factor of $w_2$. We give two different polynomial-time algorithms\ntesting the $k$-binomial equivalence of two words. The first one is\ndeterministic (but the degree of the corresponding polynomial is too high) and\nthe second one is randomised (it is more direct and more efficient). These are\nthe first known algorithms for the problem which run in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.00622v2"
    },
    {
        "title": "Optimal searching of gapped repeats in a word",
        "authors": [
            "Maxime Crochemore",
            "Roman Kolpakov",
            "Gregory Kucherov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Following (Kolpakov et al., 2013; Gawrychowski and Manea, 2015), we continue\nthe study of {\\em $\\alpha$-gapped repeats} in strings, defined as factors $uvu$\nwith $|uv|\\leq \\alpha |u|$. Our main result is the $O(\\alpha n)$ bound on the\nnumber of {\\em maximal} $\\alpha$-gapped repeats in a string of length $n$,\npreviously proved to be $O(\\alpha^2 n)$ in (Kolpakov et al., 2013). For a\nclosely related notion of maximal $\\delta$-subrepetition (maximal factors of\nexponent between $1+\\delta$ and $2$), our result implies the $O(n/\\delta)$\nbound on their number, which improves the bound of (Kolpakov et al., 2010) by a\n$\\log n$ factor.\n  We also prove an algorithmic time bound $O(\\alpha n+S)$ ($S$ size of the\noutput) for computing all maximal $\\alpha$-gapped repeats. Our solution,\ninspired by (Gawrychowski and Manea, 2015), is different from the recently\npublished proof by (Tanimura et al., 2015) of the same bound. Together with our\nbound on $S$, this implies an $O(\\alpha n)$-time algorithm for computing all\nmaximal $\\alpha$-gapped repeats.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.01221v3"
    },
    {
        "title": "Formalization of simplification for context-free grammars",
        "authors": [
            "Marcus V. M. Ramos",
            "Ruy J. G. B. de Queiroz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Context-free grammar simplification is a subject of high importance in\ncomputer language processing technology as well as in formal language theory.\nThis paper presents a formalization, using the Coq proof assistant, of the fact\nthat general context-free grammars generate languages that can be also\ngenerated by simpler and equivalent context-free grammars. Namely, useless\nsymbol elimination, inaccessible symbol elimination, unit rules elimination and\nempty rules elimination operations were described and proven correct with\nrespect to the preservation of the language generated by the original grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.02032v2"
    },
    {
        "title": "A Survey on Operational State Complexity",
        "authors": [
            "Yuan Gao",
            "Nelma Moreira",
            "Rogério Reis",
            "Sheng Yu"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Descriptional complexity is the study of the conciseness of the various\nmodels representing formal languages. The state complexity of a regular\nlanguage is the size, measured by the number of states of the smallest, either\ndeterministic or nondeterministic, finite automaton that recognises it.\nOperational state complexity is the study of the state complexity of operations\nover languages. In this survey, we review the state complexities of individual\nregularity preserving language operations on regular and some subregular\nlanguages. Then we revisit the state complexities of the combination of\nindividual operations. We also review methods of estimation and approximation\nof state complexity of more complex combined operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.03254v1"
    },
    {
        "title": "Syntactic complexity of regular ideals",
        "authors": [
            "Janusz A. Brzozowski",
            "Marek Szykuła",
            "Yuli Ye"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The state complexity of a regular language is the number of states in a\nminimal deterministic finite automaton accepting the language. The syntactic\ncomplexity of a regular language is the cardinality of its syntactic semigroup.\nThe syntactic complexity of a subclass of regular languages is the worst-case\nsyntactic complexity taken as a function of the state complexity $n$ of\nlanguages in that class. We prove that $n^{n-1}$, $n^{n-1}+n-1$, and\n$n^{n-2}+(n-2)2^{n-2}+1$ are tight upper bounds on the syntactic complexities\nof right ideals and prefix-closed languages, left ideals and suffix-closed\nlanguages, and two-sided ideals and factor-closed languages, respectively.\nMoreover, we show that the transition semigroups meeting the upper bounds for\nall three types of ideals are unique, and the numbers of generators (4, 5, and\n6, respectively) cannot be reduced.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.06032v2"
    },
    {
        "title": "Tree Automata",
        "authors": [
            "Ferenc Gécseg",
            "Magnus Steinby"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This is a reissue of the book Tree Automata by F. G\\'ecseg and M. Steinby\noriginally published in 1984 by Akad\\'emiai Kiad\\'o, Budapest. Some mistakes\nhave been corrected and a few obscure passages have been clarified. Moreover,\nsome more recent contributions and current lines of research are reviewed in an\nappendix that also contains several new references.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.06233v1"
    },
    {
        "title": "On the Complexity of Flanked Finite State Automata",
        "authors": [
            "Florent Avellaneda",
            "Silvano Dal Zilio",
            "Jean-Baptiste Raclet"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We define a new subclass of nondeterministic finite automata for\nprefix-closed languages called Flanked Finite Automata (FFA). We show that this\nclass enjoys good complexity properties while preserving the succinctness of\nnondeterministic automata. In particular, we show that the universality problem\nfor FFA is in linear time and that language inclusion can be checked in\npolynomial time. A useful application of FFA is to provide an efficient way to\ncompute the quotient and inclusion of regular languages without the need to use\nthe powerset construction. These operations are the building blocks of several\nverification algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.06501v1"
    },
    {
        "title": "Reachability Analysis of Reversal-bounded Automata on Series-Parallel\n  Graphs",
        "authors": [
            "Rayna Dimitrova",
            "Rupak Majumdar"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Extensions to finite-state automata on strings, such as multi-head automata\nor multi-counter automata, have been successfully used to encode many\ninfinite-state non-regular verification problems. In this paper, we consider a\ngeneralization of automata-theoretic infinite-state verification from strings\nto labeled series-parallel graphs. We define a model of non-deterministic,\n2-way, concurrent automata working on series-parallel graphs and communicating\nthrough shared registers on the nodes of the graph. We consider the following\nverification problem: given a family of series-parallel graphs described by a\ncontext-free graph transformation system (GTS), and a concurrent automaton over\nseries-parallel graphs, is some graph generated by the GTS accepted by the\nautomaton? The general problem is undecidable already for (one-way) multi-head\nautomata over strings. We show that a bounded version, where the automata make\na fixed number of reversals along the graph and use a fixed number of shared\nregisters is decidable, even though there is no bound on the sizes of\nseries-parallel graphs generated by the GTS. Our decidability result is based\non establishing that the number of context switches is bounded and on an\nencoding of the computation of bounded concurrent automata to reduce the\nemptiness problem to the emptiness problem for pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.07202v1"
    },
    {
        "title": "Boolean-type Retractable State-finite Automata Without Outputs",
        "authors": [
            "Mark Füzesdi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  An automaton $\\bf A$ is called a retractable automaton if, for every\nsubautomaton $\\bf B$ of $\\bf A$, there is at least one homomorphism of $\\bf A$\nonto $\\bf B$ which leaves the elements of $B$ fixed (such homomorphism is\ncalled a retract homomorphism of $\\bf A$ onto $\\bf B$). We say that a\nretractable automaton ${\\bf A}$=(A,X,$\\delta$) is Boolean-type if there exists\na family $\\{\\lambda_B \\mid \\textrm{ B is a subautomaton of A } \\}$ of retract\nhomomorphisms $\\lambda _B$ of $\\bf A$ such that, for arbitrary subautomata\n${\\bf B}_1$ and ${\\bf B}_2$ of $\\bf A$, the condition $B_1\\subseteq B_2$\nimplies $Ker\\lambda _{B_2}\\subseteq Ker\\lambda _{B_1}$. In this paper we\ndescribe the Boolean-type retractable state-finite automata without outputs.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.00208v2"
    },
    {
        "title": "Retractable state-finite automata without outputs",
        "authors": [
            "Attila Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A homomorphism of an automaton ${\\bf A}$ without outputs onto a subautomaton\n${\\bf B}$ of ${\\bf A}$ is called a retract homomorphism if it leaves the\nelements of $B$ fixed. An automaton ${\\bf A}$ is called a retractable automaton\nif, for every subautomaton ${\\bf B}$ of ${\\bf A}$, there is a retract\nhomomorphism of ${\\bf A}$ onto ${\\bf B}$. In [1] and [3], special retractable\nautomata are examined. The purpose of this paper is to give a complete\ndescription of state-finite retractable automata without outputs.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.00911v1"
    },
    {
        "title": "On the Problem of Computing the Probability of Regular Sets of Trees",
        "authors": [
            "Henryk Michalewski",
            "Matteo Mio"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider the problem of computing the probability of regular languages of\ninfinite trees with respect to the natural coin-flipping measure. We propose an\nalgorithm which computes the probability of languages recognizable by\n\\emph{game automata}. In particular this algorithm is applicable to all\ndeterministic automata. We then use the algorithm to prove through examples\nthree properties of measure: (1) there exist regular sets having irrational\nprobability, (2) there exist comeager regular sets having probability $0$ and\n(3) the probability of \\emph{game languages} $W_{i,k}$, from automata theory,\nis $0$ if $k$ is odd and is $1$ otherwise.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.01640v1"
    },
    {
        "title": "Tree Automata and Tree Grammars",
        "authors": [
            "Joost Engelfriet"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Lecture notes on tree language theory, in particular recognizable tree\nlanguages and finite state tree transformations.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.02036v1"
    },
    {
        "title": "Non-regular unary language and parallel communicating Watson-Crick\n  automata systems",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In 2006, Czeizler et.al. introduced parallel communicating Watson-Crick\nautomata system. They showed that parallel communicating Watson-Crick automata\nsystem can accept the non-regular unary language L={a^(n^2 ),where n>1} using\nnon-injective complementarity relation and three components. In this paper, we\nimprove on Czeizler et.al. work by showing that parallel communicating\nWatson-Crick automata system can accept the same language L using just two\ncomponents.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.02070v1"
    },
    {
        "title": "Value Automata with Filters",
        "authors": [
            "Michaël Cadilhac",
            "Andreas Krebs",
            "Nutan Limaye"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We propose to study value automata with filters, a natural generalization of\nregular cost automata to nondeterminism. Models such as weighted automata and\nParikh automata appear naturally as specializations. Results on the\nexpressiveness of this model offer a general understanding of the behavior of\nthe models that arise as special cases. A landscape of such restrictions is\ndrawn.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.02393v1"
    },
    {
        "title": "On insertion-deletion systems over relational words",
        "authors": [
            "Igor Potapov",
            "Olena Prianychnykova",
            "Sergey Verlan"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We introduce a new notion of a relational word as a finite totally ordered\nset of positions endowed with three binary relations that describe which\npositions are labeled by equal data, by unequal data and those having an\nundefined relation between their labels. We define the operations of insertion\nand deletion on relational words generalizing corresponding operations on\nstrings. We prove that the transitive and reflexive closure of these operations\nhas a decidable membership problem for the case of short insertion-deletion\nrules (of size two/three and three/two). At the same time, we show that in the\ngeneral case such systems can produce a coding of any recursively enumerable\nlanguage leading to undecidabilty of reachability questions.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.03231v1"
    },
    {
        "title": "Ordered Tree-Pushdown Systems",
        "authors": [
            "Lorenzo Clemente",
            "Paweł Parys",
            "Sylvain Salvati",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We define a new class of pushdown systems where the pushdown is a tree\ninstead of a word. We allow a limited form of lookahead on the pushdown\nconforming to a certain ordering restriction, and we show that the resulting\nclass enjoys a decidable reachability problem. This follows from a preservation\nof recognizability result for the backward reachability relation of such\nsystems. As an application, we show that our simple model can encode several\nformalisms generalizing pushdown systems, such as ordered multi-pushdown\nsystems, annotated higher-order pushdown systems, the Krivine machine, and\nordered annotated multi-pushdown systems. In each case, our procedure yields\ntight complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.03278v1"
    },
    {
        "title": "Marking Shortest Paths On Pushdown Graphs Does Not Preserve MSO\n  Decidability",
        "authors": [
            "Arnaud Carayol",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we consider pushdown graphs, i.e. infinite graphs that can be\ndescribed as transition graphs of deterministic real-time pushdown automata. We\nconsider the case where some vertices are designated as being final and we\nbuilt, in a breadth-first manner, a marking of edges that lead to such vertices\n(i.e., for every vertex that can reach a final one, we mark all out-going edges\nlaying on some shortest path to a final vertex).\n  Our main result is that the edge-marked version of a pushdown graph may\nitself no longer be a pushdown graph, as we prove that this enrich graph may\nhave an undecidable MSO theory.\n  In this paper we consider pushdown graphs, i.e. infinite graphs that can be\ndescribed as transition graphs of deterministic real-time pushdown automata. We\nconsider the case where some vertices are designated as being final and we\nbuild, in a breadth-first manner, a marking of edges that lead to such vertices\n(i.e., for every vertex that can reach a final one, we mark all out-going edges\nlaying on some shortest path to a final vertex).\n  Our main result is that the edge-marked version of a pushdown graph may\nitself no longer be a pushdown graph, as we prove that the MSO theory of this\nenriched graph may be undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.04000v2"
    },
    {
        "title": "Multi-head Watson-Crick automata",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Inspired by multi-head finite automata and Watson-Crick automata in this\npaper, we introduce new structure namely multi-head Watson-Crick automata where\nwe replace the single tape of multi-head finite automaton by a DNA double\nstrand. The content of the second tape is determined using a complementarity\nrelation similar to Watson-Crick complementarity relation. We establish the\nsuperiority of our model over multi-head finite automata and also show that\nboth the deterministic and non-deterministic variant of the model can accept\nnon-regular unary languages. We also compare our model with parallel\ncommunicating Watson-Crick automata systems and prove that both of them have\nthe same computational power.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.04016v2"
    },
    {
        "title": "Formalization of the pumping lemma for context-free languages",
        "authors": [
            "Marcus V. M. Ramos",
            "Ruy J. G. B. de Queiroz",
            "Nelma Moreira",
            "José Carlos Bacelar Almeida"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Context-free languages (CFLs) are highly important in computer language\nprocessing technology as well as in formal language theory. The Pumping Lemma\nis a property that is valid for all context-free languages, and is used to show\nthe existence of non context-free languages. This paper presents a\nformalization, using the Coq proof assistant, of the Pumping Lemma for\ncontext-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.04748v1"
    },
    {
        "title": "Linear Context-Free Tree Languages and Inverse Homomorphisms",
        "authors": [
            "Johannes Osterholzer",
            "Toni Dietze",
            "Luisa Herrmann"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We prove that the class of linear context-free tree languages is not closed\nunder inverse linear tree homomorphisms. The proof is by contradiction: we\nencode Dyck words into a context-free tree language and prove that its preimage\nunder a certain linear tree homomorphism cannot be generated by any\ncontext-free tree grammar. A positive result can still be obtained: the linear\nmonadic context-free tree languages are closed under inverse linear tree\nhomomorphisms.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.04881v2"
    },
    {
        "title": "Varieties of Unranked Tree Languages",
        "authors": [
            "Magnus Steinby",
            "Eija Jurvanen",
            "Antonio Cano"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study varieties that contain unranked tree languages over all alphabets.\nTrees are labeled with symbols from two alphabets, an unranked operator\nalphabet and an alphabet used for leaves only. Syntactic algebras of unranked\ntree languages are defined similarly as for ranked tree languages, and an\nunranked tree language is shown to be recognizable iff its syntactic algebra is\nregular, i.e., a finite unranked algebra in which the operations are defined by\nregular languages over its set of elements. We establish a bijective\ncorrespondence between varieties of unranked tree languages and varieties of\nregular algebras. For this, we develop a basic theory of unranked algebras in\nwhich algebras over all operator alphabets are considered together. Finally, we\nshow that the natural unranked counterparts of several general varieties of\nranked tree languages form varieties in our sense.\n  This work parallels closely the theory of general varieties of ranked tree\nlanguages and general varieties of finite algebras, but many nontrivial\nmodifications are required. For example, principal varieties as the basic\nbuilding blocks of varieties of tree languages have to be replaced by what we\ncall quasi-principal varieties, and we device a general scheme for defining\nthese by certain systems of congruences.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.07402v1"
    },
    {
        "title": "Formalization of context-free language theory",
        "authors": [
            "Marcus V. M. Ramos",
            "Ruy J. G. B. de Queiroz",
            "Nelma Moreira",
            "José Carlos Bacelar Almeida"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Context-free language theory is a subject of high importance in computer\nlanguage processing technology as well as in formal language theory. This paper\npresents a formalization, using the Coq proof assistant, of fundamental results\nrelated to context-free grammars and languages. These include closure\nproperties (union, concatenation and Kleene star), grammar simplification\n(elimination of useless symbols inaccessible symbols, empty rules and unit\nrules) and the existence of a Chomsky Normal Form for context-free grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.09092v1"
    },
    {
        "title": "Unrestricted State Complexity of Binary Operations on Regular Languages",
        "authors": [
            "Janusz Brzozowski"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  I study the state complexity of binary operations on regular languages over\ndifferent alphabets. It is well known that if $L'_m$ and $L_n$ are languages\nrestricted to be over the same alphabet, with $m$ and $n$ quotients,\nrespectively, the state complexity of any binary boolean operation on $L'_m$\nand $L_n$ is $mn$, and that of the product (concatenation) is $(m-1)2^n\n+2^{n-1}$. In contrast to this, I show that if $L'_m$ and $L_n$ are over their\nown different alphabets, the state complexity of union and symmetric difference\nis $mn+m+n+1$, that of intersection is $mn$, that of difference is $mn+m$, and\nthat of the product is $m2^n+2^{n-1}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.01387v3"
    },
    {
        "title": "Busy Beaver Machines and the Observant Otter Heuristic (or How to Tame\n  Dreadful Dragons)",
        "authors": [
            "James Harland"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The busy beaver is a well-known specific example of a non-computable\nfunction. Whilst many aspect of this problem have been investigated, it is not\nalways easy to find thorough and convincing evidence for the claims made about\nthe maximality of particular machines, and the phenomenal size of some of the\nnumbers involved means that it is not obvious that the problem can be feasibly\naddressed at all. In this paper we address both of these issues. We discuss a\nframework in which the busy beaver problem and similar problems may be\naddressed, and the appropriate processes for providing evidence of claims made.\nWe also show how a simple heuristic, which we call the observant otter, can be\nused to evaluate machines with an extremely large number of execution steps\nrequired to terminate. We also show empirical results for an implementation of\nthis heuristic which show how this heuristic is effective for all known\n`monster' machines.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.03228v1"
    },
    {
        "title": "Restricted deterministic Watson-Crick automata",
        "authors": [
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper, we introduce a new model of deterministic Watson-Crick\nautomaton namely restricted deterministic Watson- Crick automaton which is a\ndeterministic Watson-Crick automaton where the complementarity string in the\nlower strand is restricted to a language L. We examine the computational power\nof the restricted model with respect to L being in different language classes\nsuch as regular, unary regular, finite, context free and context sensitive. We\nalso show that computational power of restricted deterministic Watson- Crick\nautomata with L in regular languages is same as that of deterministic\nWatson-Crick automata and that the set of all languages accepted by restricted\ndeterministic Watson-Crick automata with L in unary regular languages is a\nproper subset of context free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05721v1"
    },
    {
        "title": "Corrections to A Menagerie of Timed Automata",
        "authors": [
            "Jeroen J. A. Keiren",
            "Peter Fontana",
            "Rance Cleaveland"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This note corrects a technical error in the ACM Computing Surveys paper\nmentioned in the title. The flaw involved constructions for showing that timed\nautomata with urgent locations have the same expressiveness as timed automata\nthat allow false location invariants. Corrected con- structions are presented\nin this note, and the affected results are reproved.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.07165v1"
    },
    {
        "title": "On Equivalence and Uniformisation Problems for Finite Transducers",
        "authors": [
            "Emmanuel Filiot",
            "Ismaël Jecker",
            "Christof Löding",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Transductions are binary relations of finite words. For rational\ntransductions, i.e., transductions defined by finite transducers, the\ninclusion, equivalence and sequential uniformisation problems are known to be\nundecidable. In this paper, we investigate stronger variants of inclusion,\nequivalence and sequential uniformisation, based on a general notion of\ntransducer resynchronisation, and show their decidability. We also investigate\nthe classes of finite-valued rational transductions and deterministic rational\ntransductions, which are known to have a decidable equivalence problem. We show\nthat sequential uniformisation is also decidable for them.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.08565v1"
    },
    {
        "title": "On automatic subsets of the Gaussian integers",
        "authors": [
            "Wieb Bosma",
            "Robbert Fokkink",
            "Thijmen Krebs"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Suppose that $a$ and $b$ are multiplicatively independent Gaussian integers,\nthat are both of modulus~$\\geq \\sqrt 5$. We prove that there exist a $X\\subset\n\\mathbb Z[i]$ which is $a$-automatic but not $b$-automatic. This settles a\nproblem of Allouche, Cateland, Gilbert, Peitgen, Shallit, and Skordev.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.08579v3"
    },
    {
        "title": "Characterizing classes of regular languages using prefix codes of\n  bounded synchronization delay",
        "authors": [
            "Volker Diekert",
            "Tobias Walter"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper we continue a classical work of Sch\\\"utzenberger on codes with\nbounded synchronization delay. He was interested to characterize those regular\nlanguages where the groups in the syntactic monoid belong to a variety $H$. He\nallowed operations on the language side which are union, intersection,\nconcatenation and modified Kleene-star involving a mapping of a prefix code of\nbounded synchronization delay to a group $G\\in H$, but no complementation. In\nour notation this leads to the language classes $SD_G(A^\\infty)$ and\n$SD_H(A^\\infty$). Our main result shows that $SD_H(A^\\infty)$ always\ncorresponds to the languages having syntactic monoids where all subgroups are\nin $H$. Sch\\\"utzenberger showed this for a variety $H$ if $H$ contains Abelian\ngroups, only. Our method shows the general result for all $H$ directly on\nfinite and infinite words. Furthermore, we introduce the notion of local Rees\nproducts which refers to a simple type of classical Rees extensions. We give a\ndecomposition of a monoid in terms of its groups and local Rees products. This\ngives a somewhat similar, but simpler decomposition than in Rhodes' synthesis\ntheorem. Moreover, we need a singly exponential number of operations, only.\nFinally, our decomposition yields an answer to a question in a recent paper of\nAlmeida and Kl\\'ima about varieties that are closed under Rees products.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.08981v1"
    },
    {
        "title": "On Word and Frontier Languages of Unsafe Higher-Order Grammars",
        "authors": [
            "Kazuyuki Asada",
            "Naoki Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Higher-order grammars are extensions of regular and context-free grammars,\nwhere non-terminals may take parameters. They have been extensively studied in\n1980's, and restudied recently in the context of model checking and program\nverification. We show that the class of unsafe order-(n+1) word languages\ncoincides with the class of frontier languages of unsafe order-n tree\nlanguages. We use intersection types for transforming an order-(n+1) word\ngrammar to a corresponding order-n tree grammar. The result has been proved for\nsafe languages by Damm in 1982, but it has been open for unsafe languages, to\nour knowledge. Various known results on higher-order grammars can be obtained\nas almost immediate corollaries of our result.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.01595v3"
    },
    {
        "title": "Decidability of multiset, set and numerically decipherable directed\n  figure codes",
        "authors": [
            "Włodzimierz Moczurad"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Codes with various kinds of decipherability, weaker than the usual unique\ndecipherability, have been studied since multiset decipherability was\nintroduced in mid-1980s. We consider decipherability of directed figure codes,\nwhere directed figures are defined as labelled polyominoes with designated\nstart and end points, equipped with catenation operation that may use a merging\nfunction to resolve possible conflicts. This is one of possible extensions\ngeneralizing words and variable-length codes to planar structures. Here,\nverification whether a given set is a code is no longer decidable in general.\nWe study the decidability status of figure codes depending on catenation type\n(with or without a merging function), decipherability kind (unique, multiset,\nset or numeric) and code geometry (several classes determined by relative\npositions of start and end points of figures). We give decidability or\nundecidability proofs in all but two cases that remain open.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.02167v3"
    },
    {
        "title": "An Extremal Series of Eulerian Synchronizing Automata",
        "authors": [
            "Marek Szykuła",
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present an infinite series of $n$-state Eulerian automata whose reset\nwords have length at least $(n^2-3)/2$. This improves the current lower bound\non the length of shortest reset words in Eulerian automata. We conjecture that\n$(n^2-3)/2$ also forms an upper bound for this class and we experimentally\nverify it for small automata by an exhaustive computation.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.02879v2"
    },
    {
        "title": "Eilenberg theorems for many-sorted formations",
        "authors": [
            "Juan Climent Vidal",
            "Enric Cosme Llópez"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A theorem of Eilenberg establishes that there exists a bijection between the\nset of all varieties of regular languages and the set of all varieties of\nfinite monoids. In this article after defining, for a fixed set of sorts $S$\nand a fixed $S$-sorted signature $\\Sigma$, the concepts of formation of\ncongruences with respect to $\\Sigma$ and of formation of $\\Sigma$-algebras, we\nprove that the algebraic lattices of all $\\Sigma$-congruence formations and of\nall $\\Sigma$-algebra formations are isomorphic, which is an Eilenberg's type\ntheorem. Moreover, under a suitable condition on the free $\\Sigma$-algebras and\nafter defining the concepts of formation of congruences of finite index with\nrespect to $\\Sigma$, of formation of finite $\\Sigma$-algebras, and of formation\nof regular languages with respect to $\\Sigma$, we prove that the algebraic\nlattices of all $\\Sigma$-finite index congruence formations, of all\n$\\Sigma$-finite algebra formations, and of all $\\Sigma$-regular language\nformations are isomorphic, which is also an Eilenberg's type theorem.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.04792v1"
    },
    {
        "title": "Permutations of context-free, ET0L and indexed languages",
        "authors": [
            "Tara Brough",
            "Laura Ciobanu",
            "Murray Elder",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  For a language $L$, we consider its cyclic closure, and more generally the\nlanguage $C^k(L)$, which consists of all words obtained by partitioning words\nfrom $L$ into $k$ factors and permuting them. We prove that the classes of ET0L\nand EDT0L languages are closed under the operators $C^k$. This both sharpens\nand generalises Brandst\\\"adt's result that if $L$ is context-free then $C^k(L)$\nis context-sensitive and not context-free in general for $k\\geq 3$. We also\nshow that the cyclic closure of an indexed language is indexed.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.05431v2"
    },
    {
        "title": "On Number Conservation of Non-uniform Cellular Automata",
        "authors": [
            "Raju Hazari",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper studies the number conservation property of 1-dimensional\nnon-uniform cellular automata (CAs). In a non-uniform cellular automaton (CA),\ndifferent cells may follow different rules. The present work considers that the\ncells follow Wolfram's CAs rules. A characterization tool, named Reachability\ntree is used to discover the number conservation property of non-uniform CAs.\nThen a decision algorithm is reported to conclude whether a given non-uniform\nCA with $n$ cells is number conserving or not. Finally, a synthesis scheme is\ndeveloped to get an $n$-cell number conserving non-uniform CA.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.06600v1"
    },
    {
        "title": "Derivative-Based Diagnosis of Regular Expression Ambiguity",
        "authors": [
            "Martin Sulzmann",
            "Kenny Zhuo Ming Lu"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Regular expressions are often ambiguous. We present a novel method based on\nBrzozowski's derivatives to aid the user in diagnosing ambiguous regular\nexpressions. We introduce a derivative-based finite state transducer to\ngenerate parse trees and minimal counter-examples. The transducer can be easily\ncustomized to either follow the POSIX or Greedy disambiguation policy and based\non a finite set of examples it is possible to examine if there are any\ndifferences among POSIX and Greedy.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.06644v2"
    },
    {
        "title": "Quantitative Automata under Probabilistic Semantics",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Automata with monitor counters, where the transitions do not depend on\ncounter values, and nested weighted automata are two expressive\nautomata-theoretic frameworks for quantitative properties. For a well-studied\nand wide class of quantitative functions, we establish that automata with\nmonitor counters and nested weighted automata are equivalent. We study for the\nfirst time such quantitative automata under probabilistic semantics. We show\nthat several problems that are undecidable for the classical questions of\nemptiness and universality become decidable under the probabilistic semantics.\nWe present a complete picture of decidability for such automata, and even an\nalmost-complete picture of computational complexity, for the probabilistic\nquestions we consider.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.06764v4"
    },
    {
        "title": "Syntactic complexity of bifix-free languages",
        "authors": [
            "Marek Szykuła",
            "John Wittnebel"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study the properties of syntactic monoids of bifix-free regular languages.\nIn particular, we solve an open problem concerning syntactic complexity: We\nprove that the cardinality of the syntactic semigroup of a bifix-free language\nwith state complexity $n$ is at most $(n-1)^{n-3}+(n-2)^{n-3}+(n-3)2^{n-3}$ for\n$n\\ge 6$. The main proof uses a large construction with the method of injective\nfunction. Since this bound is known to be reachable, and the values for $n \\le\n5$ are known, this completely settles the problem. We also prove that\n$(n-2)^{n-3} + (n-3)2^{n-3} - 1$ is the minimal size of the alphabet required\nto meet the bound for $n \\ge 6$. Finally, we show that the largest transition\nsemigroups of minimal DFAs which recognize bifix-free languages are unique up\nto renaming the states.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.06936v3"
    },
    {
        "title": "The Complexity of Fixed-Height Patterned Tile Self-Assembly",
        "authors": [
            "Shinnosuke Seki",
            "Andrew Winslow"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We characterize the complexity of the PATS problem for patterns of fixed\nheight and color count in variants of the model where seed glues are either\nchosen or fixed and identical (so-called non-uniform and uniform variants). We\nprove that both variants are NP-complete for patterns of height 2 or more and\nadmit O(n)-time algorithms for patterns of height 1. We also prove that if the\nheight and number of colors in the pattern is fixed, the non-uniform variant\nadmits a O(n)-time algorithm while the uniform variant remains NP-complete. The\nNP-completeness results use a new reduction from a constrained version of a\nproblem on finite state transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.07190v2"
    },
    {
        "title": "Stack and register complexity of radix conversions",
        "authors": [
            "Motoya Machida",
            "Alexander Shibakov"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We investigate the question of computational resources (such as stacks and\ncounters) necessary to perform radix conversions. To this end it is shown that\nno PDA can compute the significand of the best $n$-digit floating point\napproximation of a power of an incommensurable radix. This extends the results\nof W.~Clinger. We also prove that a two counter machine with input is capable\nof such conversions. On the other hand we note a curious asymmetry with respect\nto the order in which the digits are input by showing that a two counter\nmachine can decode its input online if the digits are presented in the\nmost-to-least significant order while no such machine can decode its input in\nthis manner if the digits are presented in the least-to-most significant order.\nSome structural results about two counter machines (with input) are also\nestablished.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.08878v1"
    },
    {
        "title": "Two-Way Visibly Pushdown Automata and Transducers",
        "authors": [
            "Luc Dartois",
            "Emmanuel Filiot",
            "Pierre-Alain Reynier",
            "Jean-Marc Talbot"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Automata-logic connections are pillars of the theory of regular languages.\nSuch connections are harder to obtain for transducers, but important results\nhave been obtained recently for word-to-word transformations, showing that the\nthree following models are equivalent: deterministic two-way transducers,\nmonadic second-order (MSO) transducers, and deterministic one-way automata\nequipped with a finite number of registers. Nested words are words with a\nnesting structure, allowing to model unranked trees as their depth-first-search\nlinearisations. In this paper, we consider transformations from nested words to\nwords, allowing in particular to produce unranked trees if output words have a\nnesting structure. The model of visibly pushdown transducers allows to describe\nsuch transformations, and we propose a simple deterministic extension of this\nmodel with two-way moves that has the following properties: i) it is a simple\ncomputational model, that naturally has a good evaluation complexity; ii) it is\nexpressive: it subsumes nested word-to-word MSO transducers, and the exact\nexpressiveness of MSO transducers is recovered using a simple syntactic\nrestriction; iii) it has good algorithmic/closure properties: the model is\nclosed under composition with a unambiguous one-way letter-to-letter transducer\nwhich gives closure under regular look-around, and has a decidable equivalence\nproblem.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.00234v1"
    },
    {
        "title": "On the Complexity and Decidability of Some Problems Involving Shuffle",
        "authors": [
            "Joey Eremondi",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The complexity and decidability of various decision problems involving the\nshuffle operation are studied. The following three problems are all shown to be\n$NP$-complete: given a nondeterministic finite automaton (NFA) $M$, and two\nwords $u$ and $v$, is $L(M)$ not a subset of $u$ shuffled with $v$, is $u$\nshuffled with $v$ not a subset of $L(M)$, and is $L(M)$ not equal to $u$\nshuffled with $v$? It is also shown that there is a polynomial-time algorithm\nto determine, for $NFA$s $M_1, M_2$ and a deterministic pushdown automaton\n$M_3$, whether $L(M_1)$ shuffled with $L(M_2)$ is a subset of $L(M_3)$. The\nsame is true when $M_1, M_2,M_3$ are one-way nondeterministic\n$l$-reversal-bounded $k$-counter machines, with $M_3$ being deterministic.\nOther decidability and complexity results are presented for testing whether\ngiven languages $L_1, L_2$ and $R$ from various languages families satisfy\n$L_1$ shuffled with $L_2$ is a subset of $R$, and $R$ is a subset of $L_1$\nshuffled with $L_2$. Several closure results on shuffle are also shown.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.01199v2"
    },
    {
        "title": "Transducer-based Rewriting Games for Active XML",
        "authors": [
            "Martin Schuster"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Context-free games are two-player rewriting games that are played on nested\nstrings representing XML documents with embedded function symbols. These games\nwere introduced to model rewriting processes for intensional documents in the\nActive XML framework, where input documents are to be rewritten into a given\ntarget schema by calls to external services.\n  This paper studies the setting where dependencies between inputs and outputs\nof service calls are modelled by transducers, which has not been examined\npreviously. It defines transducer models operating on nested words and studies\ntheir properties, as well as the computational complexity of the winning\nproblem for transducer-based context-free games in several scenarios. While the\ncomplexity of this problem is quite high in most settings (ranging from\nNP-complete to undecidable), some tractable restrictions are also identified.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.02879v1"
    },
    {
        "title": "An automata characterisation for multiple context-free languages",
        "authors": [
            "Tobias Denkinger"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce tree stack automata as a new class of automata with storage and\nidentify a restricted form of tree stack automata that recognises exactly the\nmultiple context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.02975v3"
    },
    {
        "title": "Decidable Characterization of FO2(<,+1) and locality of DA",
        "authors": [
            "Thomas Place",
            "Luc Segoufin"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Several years ago Th\\'erien and Wilke exhibited a decidable characterization\nof the languages of words that are definable in FO2(<,+1). Their proof relies\non three separate ingredients. The first one is the characterization of the\nlanguages that are definable in FO2(<) as those whose syntactic semigroup\nbelongs to the variety DA. Then, this result is combined with a wreath product\nargument showing that being definable in FO2(<,+1) corresponds to having a\nsyntactic semigroup in DA*D. Finally, proving that membership of a semigroup in\nDA*D is decidable requires a third ingredient: the \"locality\" of DA, a result\nproved by Almeida. In this note we present a new self-contained and simple\nproof that definability in FO2(<,+1) is decidable. We obtain the locality of DA\nas a corollary.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.03217v2"
    },
    {
        "title": "Deciding Equivalence of Linear Tree-to-Word Transducers in Polynomial\n  Time",
        "authors": [
            "Adrien Boiret",
            "Raphaela Palenta"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We show that the equivalence of deterministic linear top-down tree-to-word\ntransducers is decidable in polynomial time. Linear tree-to-word transducers\nare non-copying but not necessarily order-preserving and can be used to express\nXML and other document transformations. The result is based on a partial normal\nform that provides a basic characterization of the languages produced by linear\ntree-to-word transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.03758v1"
    },
    {
        "title": "A Chomsky-Schützenberger representation for weighted multiple\n  context-free languages",
        "authors": [
            "Tobias Denkinger"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We prove a Chomsky-Sch\\\"utzenberger representation theorem for multiple\ncontext-free languages weighted over complete commutative strong bimonoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.03982v2"
    },
    {
        "title": "A Boyer-Moore Type Algorithm for Timed Pattern Matching",
        "authors": [
            "Masaki Waga",
            "Takumi Akazaki",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The timed pattern matching problem is formulated by Ulus et al. and has been\nactively studied since, with its evident application in monitoring real-time\nsystems. The problem takes as input a timed word/signal and a timed pattern\n(specified either by a timed regular expression or by a timed automaton); and\nit returns the set of those intervals for which the given timed word, when\nrestricted to the interval, matches the given pattern. We contribute a\nBoyer-Moore type optimization in timed pattern matching, relying on the classic\nBoyer-Moore string matching algorithm and its extension to (untimed) pattern\nmatching by Watson and Watson. We assess its effect through experiments; for\nsome problem instances our Boyer-Moore type optimization achieves speed-up by\ntwo times, indicating its potential in real-world monitoring tasks where data\nsets tend to be massive.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.07207v3"
    },
    {
        "title": "Completely Reachable Automata",
        "authors": [
            "Evgenija Bondar",
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present a few results and several open problems concerning complete\ndeterministic finite automata in which every non-empty subset of the state set\noccurs as the image of the whole state set under the action of a suitable input\nword.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.00554v1"
    },
    {
        "title": "2-tape 1-way Quantum Finite State Automata",
        "authors": [
            "Debayan Ganguly",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  1-way quantum finite state automata are reversible in nature, which greatly\nreduces its accepting property. In fact, the set of languages accepted by 1-way\nquantum finite automata is a proper subset of regular languages. We introduce\n2-tape 1-way quantum finite state automaton (2T1QFA(2))which is a modified\nversion of 1-way 2-head quantum finite state automaton(1QFA(2)). In this paper,\nwe replace the single tape of 1-way 2-head quantum finite state automaton with\ntwo tapes. The content of the second tape is determined using a relation\ndefined on input alphabet. The main claims of this paper are as follows: (1)We\nestablish that 2-tape 1-way quantum finite state automaton(2T1QFA(2)) can\naccept all regular languages (2)A language which cannot be accepted by any\nmulti-head deterministic finite automaton can be accepted by 2-tape 1-way\nquantum finite state automaton(2T1QFA(2)) .(3) Exploiting the superposition\nproperty of quantum automata we show that 2-tape 1-way quantum finite state\nautomaton(2T1QFA(2)) can accept the language L=ww.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.00811v1"
    },
    {
        "title": "Deletion Operations on Deterministic Families of Automata",
        "authors": [
            "Joey Eremondi",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Many different deletion operations are investigated applied to languages\naccepted by one-way and two-way deterministic reversal-bounded multicounter\nmachines, deterministic pushdown automata, and finite automata. Operations\nstudied include the prefix, suffix, infix and outfix operations, as well as\nleft and right quotient with languages from different families. It is often\nexpected that language families defined from deterministic machines will not be\nclosed under deletion operations. However, here, it is shown that one-way\ndeterministic reversal-bounded multicounter languages are closed under right\nquotient with languages from many different language families; even those\ndefined by nondeterministic machines such as the context-free languages. Also,\nit is shown that when starting with one-way deterministic machines with one\ncounter that makes only one reversal, taking the left quotient with languages\nfrom many different language families -- again including those defined by\nnondeterministic machines such as the context-free languages -- yields only\none-way deterministic reversal-bounded multicounter languages (by increasing\nthe number of counters). However, if there are two more reversals on the\ncounter, or a second 1-reversal-bounded counter, taking the left quotient (or\neven just the suffix operation) yields languages that can neither be accepted\nby deterministic reversal-bounded multicounter machines, nor by 2-way\nnondeterministic machines with one reversal-bounded counter.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.00931v2"
    },
    {
        "title": "A Note on Nested String Replacements",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We investigate the number of nested string replacements required to reduce a\nstring of identical characters to one character.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.01828v1"
    },
    {
        "title": "Experiments with Synchronizing Automata",
        "authors": [
            "Andrzej Kisielewicz",
            "Jakub Kowalski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We have improved an algorithm generating synchronizing automata with a large\nlength of the shortest reset words. This has been done by refining some known\nresults concerning bounds on the reset length. Our improvements make possible\nto consider a number of conjectures and open questions concerning synchronizing\nautomata, checking them for automata with a small number of states and\ndiscussing the results. In particular, we have verified the \\v{C}ern\\'y\nconjecture for all binary automata with at most 12 states, and all ternary\nautomata with at most 8 states.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.04025v1"
    },
    {
        "title": "State complexity of multiple catenation",
        "authors": [
            "Pascal Caron",
            "Jean-Gabriel Luque",
            "Bruno Patrou"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We improve some results relative to the state complexity of the multiple\ncatenation described by Gao and Yu. In particular we nearly divide by 2 the\nsize of the alphabet needed for witnesses. We also give some refinements to the\nalgebraic expression of the state complexity, which is especially complex with\nthis operation. We obtain these results by using peculiar DFAs defined by\nBrzozowski.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.04031v1"
    },
    {
        "title": "Learning Nominal Automata",
        "authors": [
            "Joshua Moerman",
            "Matteo Sammartino",
            "Alexandra Silva",
            "Bartek Klin",
            "Michał Szynwelski"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present an Angluin-style algorithm to learn nominal automata, which are\nacceptors of languages over infinite (structured) alphabets. The abstract\napproach we take allows us to seamlessly extend known variations of the\nalgorithm to this new setting. In particular we can learn a subclass of nominal\nnon-deterministic automata. An implementation using a recently developed\nHaskell library for nominal computation is provided for preliminary\nexperiments.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.06268v3"
    },
    {
        "title": "Derived-Term Automata of Multitape Rational Expressions (Long version)",
        "authors": [
            "Akim Demaille"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce (weighted) rational expressions to denote series over Cartesian\nproducts of monoids. To this end, we propose the operator $|$ to build\nmultitape expressions such as $(a^+|x + b^+|y)^*$. We define expansions, which\ngeneralize the concept of derivative of a rational expression, but relieved\nfrom the need of a free monoid. We propose an algorithm based on expansions to\nbuild multitape automata from multitape expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.00749v1"
    },
    {
        "title": "Synchronizing Automata with Extremal Properties",
        "authors": [
            "Andrzej Kisielewicz",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present a few classes of synchronizing automata exhibiting certain\nextremal properties with regard to synchronization. The first is a series of\nautomata with subsets whose shortest extending words are of length\n$\\varTheta(n^2)$, where $n$ is the number of states of the automaton. This\ndisproves a conjecture that every subset in a strongly connected synchronizing\nautomaton is $cn$-extendable, for some constant $c$, and in particular, shows\nthat the cubic upper bound on the length of the shortest reset words cannot be\nimproved generally by means of the extension method. A detailed analysis shows\nthat the automata in the series have subsets that require words as long as\n$n^2/4+O(n)$ in order to be extended by at least one element.\n  We also discuss possible relaxations of the conjecture, and propose the\nimage-extension conjecture, which would lead to a quadratic upper bound on the\nlength of the shortest reset words. In this regard we present another class of\nautomata, which turn out to be counterexamples to a key claim in a recent\nattempt to improve the Pin-Frankl bound for reset words.\n  Finally, we present two new series of slowly irreducibly synchronizing\nautomata over a ternary alphabet, whose lengths of the shortest reset words are\n$n^2-3n+3$ and $n^2-3n+2$, respectively. These are the first examples of such\nseries of automata for alphabets of size larger than two.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.01268v1"
    },
    {
        "title": "Few paths, fewer words: model selection with automatic structure\n  functions",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider the problem of finding an optimal statistical model for a given\nbinary string. Following Kolmogorov, we use structure functions. In order to\nget concrete results, we replace Turing machines by finite automata and\nKolmogorov complexity by Shallit and Wang's automatic complexity.\n  The $p$-value of a model for given data $x$ is the probability that there\nexists a model with as few states, accepting as few words, fitting uniformly\nrandomly selected data $y$.\n  Deterministic and nondeterministic automata can give different optimal\nmodels. For $x=011\\, 110\\, 110\\, 11$, the best deterministic model has\n$p$-value $0.3$, whereas the best nondeterministic model has $p$-value $0.04$.\n  In the nondeterministic case, counting paths and counting words can give\ndifferent optimal models. For $x=01100\\, 01000$, the best path-counting model\nhas $p$-value $0.79$, whereas the best word-counting model has $p$-value\n$0.60$.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.01399v1"
    },
    {
        "title": "The Frobenius problem for the shuffle operation",
        "authors": [
            "Jeremy Nicholson",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We characterize the finite sets S of words such that that the iterated\nshuffle of S is co-finite and we give some bounds on the length of a longest\nword not in the iterated shuffle of S.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.08592v1"
    },
    {
        "title": "Deleting Powers in Words",
        "authors": [
            "John Machacek"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider the language consisting of all words such that it is possible to\nobtain the empty word by iteratively deleting powers. It turns out that in the\ncase of deleting squares in binary words this language is regular, and in the\ncase of deleting squares in words over a larger alphabet the language is not\nregular. However, for deleting squares over any alphabet we find that this\nlanguage can be generated by a linear index grammar which is a mildly context\nsensitive grammar formalism. In the general case we show that this language is\ngenerated by an indexed grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.08689v2"
    },
    {
        "title": "Separability of Reachability Sets of Vector Addition Systems",
        "authors": [
            "Lorenzo Clemente",
            "Wojciech Czerwiński",
            "Sławomir Lasota",
            "Charles Paperman"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Given two families of sets $\\mathcal{F}$ and $\\mathcal{G}$, the $\\mathcal{F}$\nseparability problem for $\\mathcal{G}$ asks whether for two given sets $U, V\n\\in \\mathcal{G}$ there exists a set $S \\in \\mathcal{F}$, such that $U$ is\nincluded in $S$ and $V$ is disjoint with $S$. We consider two families of sets\n$\\mathcal{F}$: modular sets $S \\subseteq \\mathbb{N}^d$, defined as unions of\nequivalence classes modulo some natural number $n \\in \\mathbb{N}$, and unary\nsets. Our main result is decidability of modular and unary separability for the\nclass $\\mathcal{G}$ of reachability sets of Vector Addition Systems, Petri\nNets, Vector Addition Systems with States, and for sections thereof.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.00214v1"
    },
    {
        "title": "Language Classes Associated with Automata Over Matrix Groups",
        "authors": [
            "Özlem Salehi",
            "Flavio D'Alessandro",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We investigate the language classes recognized by group automata over matrix\ngroups. We present a summary of the results obtained so far together with a\nnumber of new results. We look at the computational power of time-bounded group\nautomata where the group under consideration has polynomial growth.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.00396v1"
    },
    {
        "title": "Modeling, refining and analyzing Incomplete Büchi Automata",
        "authors": [
            "Claudio Menghi",
            "Paola Spoletini",
            "Carlo Ghezzi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Software development is an iterative process which includes a set of\ndevelopment steps that transform the initial high level specification of the\nsystem into its final, fully specified, implementation. This report discusses\nthe theoretical foundations that allow Incomplete B\\\"uchi Automata (IBAs) to be\nused in the iterative development of a sequential system.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.00610v1"
    },
    {
        "title": "ω-Automata",
        "authors": [
            "Thomas Wilke"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper gives a concise introduction into the basic theory of\n{\\omega}-automata (as of March 2014). The starting point are the different\ntypes of recurrence conditions, modes of operation (deterministic,\nnondeterministic, alternating automata), and directions (forward or backward\nautomata). The main focus is on fundamental automata constructions, for\ninstance, for boolean operations, determinization, disambiguation, and removing\nalternation. It also covers some algebraic aspects such as congruences for\n{\\omega}-automata (and {\\omega}-languages), basic structure theory (loops), and\napplications in mathematical logic. This paper may eventually become a chapter\nin a handbook of automata theory.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.03062v1"
    },
    {
        "title": "Complexity of Universality and Related Problems for Partially Ordered\n  NFAs",
        "authors": [
            "Markus Krötzsch",
            "Tomáš Masopust",
            "Michaël Thomazo"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Partially ordered nondeterminsitic finite automata (poNFAs) are NFAs whose\ntransition relation induces a partial order on states, that is, for which\ncycles occur only in the form of self-loops on a single state. A poNFA is\nuniversal if it accepts all words over its input alphabet. Deciding\nuniversality is PSPACE-complete for poNFAs, and we show that this remains true\neven when restricting to a fixed alphabet. This is nontrivial since standard\nencodings of alphabet symbols in, e.g., binary can turn self-loops into longer\ncycles. A lower coNP-complete complexity bound can be obtained if we require\nthat all self-loops in the poNFA are deterministic, in the sense that the\nsymbol read in the loop cannot occur in any other transition from that state.\nWe find that such restricted poNFAs (rpoNFAs) characterise the class of\n$\\mathcal{R}$-trivial languages, and we establish the complexity of deciding if\nthe language of an NFA is $\\mathcal{R}$-trivial. Nevertheless, the limitation\nto fixed alphabets turns out to be essential even in the restricted case:\ndeciding universality of rpoNFAs with unbounded alphabets is PSPACE-complete.\nBased on a close relation between universality and the problems of inclusion\nand equivalence, we also obtain the complexity results for these two problems.\nFinaly, we show that the languages of rpoNFAs are definable by deterministic\n(one-unambiguous) regular expressions, which makes them interesting in schema\nlanguages for XML data.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.03460v2"
    },
    {
        "title": "Unrestricted State Complexity of Binary Operations on Regular and Ideal\n  Languages",
        "authors": [
            "Janusz Brzozowski",
            "Corwin Sinnamon"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study the state complexity of binary operations on regular languages over\ndifferent alphabets. It is known that if $L'_m$ and $L_n$ are languages of\nstate complexities $m$ and $n$, respectively, and restricted to the same\nalphabet, the state complexity of any binary boolean operation on $L'_m$ and\n$L_n$ is $mn$, and that of product (concatenation) is $m 2^n - 2^{n-1}$. In\ncontrast to this, we show that if $L'_m$ and $L_n$ are over different\nalphabets, the state complexity of union and symmetric difference is\n$(m+1)(n+1)$, that of difference is $mn+m$, that of intersection is $mn$, and\nthat of product is $m2^n+2^{n-1}$. We also study unrestricted complexity of\nbinary operations in the classes of regular right, left, and two-sided ideals,\nand derive tight upper bounds. The bounds for product of the unrestricted cases\n(with the bounds for the restricted cases in parentheses) are as follows: right\nideals $m+2^{n-2}+2^{n-1}$ ($m+2^{n-2}$); left ideals $mn+m+n$ ($m+n-1$);\ntwo-sided ideals $m+2n$ ($m+n-1$). The state complexities of boolean operations\non all three types of ideals are the same as those of arbitrary regular\nlanguages, whereas that is not the case if the alphabets of the arguments are\nthe same. Finally, we update the known results about most complex regular,\nright-ideal, left-ideal, and two-sided-ideal languages to include the\nunrestricted cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.04439v3"
    },
    {
        "title": "L-Convex Polyominoes are Recognizable in Real Time by 2D Cellular\n  Automata",
        "authors": [
            "Anaël Grandjean",
            "Victor Poupet"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A polyomino is said to be L-convex if any two of its cells are connected by a\n4-connected inner path that changes direction at most once. The 2-dimensional\nlanguage representing such polyominoes has been recently proved to be\nrecognizable by tiling systems by S. Brocchi, A. Frosini, R. Pinzani and S.\nRinaldi. In an attempt to compare recognition power of tiling systems and\ncellular automata, we have proved that this language can be recognized by\n2-dimensional cellular automata working on the von Neumann neighborhood in real\ntime.\n  Although the construction uses a characterization of L-convex polyominoes\nthat is similar to the one used for tiling systems, the real time constraint\nwhich has no equivalent in terms of tilings requires the use of techniques that\nare specific to cellular automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.00323v1"
    },
    {
        "title": "Comparing 1D and 2D Real Time on Cellular Automata",
        "authors": [
            "Anaël Grandjean",
            "Victor Poupet"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study the influence of the dimension of cellular automata (CA) for real\ntime language recognition of one-dimensional languages with parallel input.\nSpecifically, we focus on the question of determining whether every language\nthat can be recognized in real time on a 2-dimensional CA working on the Moore\nneighborhood can also be recognized in real time by a 1-dimensional CA working\non the standard two-way neighborhood.\n  We show that 2-dimensional CA in real time can perform a linear number of\nsimulations of a 1-dimensional real time CA. If the two classes are equal then\nthe number of simulated instances can be polynomial.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.00331v1"
    },
    {
        "title": "Complexity of Left-Ideal, Suffix-Closed and Suffix-Free Regular\n  Languages",
        "authors": [
            "Janusz Brzozowski",
            "Corwin Sinnamom"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A language $L$ over an alphabet $\\Sigma$ is suffix-convex if, for any words\n$x,y,z\\in\\Sigma^*$, whenever $z$ and $xyz$ are in $L$, then so is $yz$.\nSuffix-convex languages include three special cases: left-ideal, suffix-closed,\nand suffix-free languages. We examine complexity properties of these three\nspecial classes of suffix-convex regular languages. In particular, we study the\nquotient/state complexity of boolean operations, product (concatenation), star,\nand reversal on these languages, as well as the size of their syntactic\nsemigroups, and the quotient complexity of their atoms.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.00728v1"
    },
    {
        "title": "Decision problems on unary probabilistic and quantum automata",
        "authors": [
            "Mika Hirvensalo",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  It is well known that the emptiness problem for binary probabilistic automata\nand so for quantum automata is undecidable. We present the current status of\nthe emptiness problems for unary probabilistic and quantum automata with\nconnections with Skolem's and positivity problems. We also introduce the\nconcept of linear recurrence automata in order to show the connection\nnaturally. Then, we also give possible generalizations of linear recurrence\nrelations and automata on vectors.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.01397v1"
    },
    {
        "title": "A Symbolic Decision Procedure for Symbolic Alternating Finite Automata",
        "authors": [
            "Loris D'Antoni",
            "Zachary Kincaid",
            "Fang Wang"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce Symbolic Alternating Finite Automata (s-AFA) as an expressive,\nsuccinct, and decidable model for describing sets of finite sequences over\narbitrary alphabets. Boolean operations over s-AFAs have linear complexity,\nwhich is in sharp contrast with the quadratic cost of intersection and union\nfor non-alternating symbolic automata. Due to this succinctness, emptiness and\nequivalence checking are PSpace-hard.\n  We introduce an algorithm for checking the equivalence of two s-AFAs based on\nbisimulation up to congruence. This algorithm allows us to exploit the power of\nSAT and SMT solvers to efficiently search the state space of the s-AFAs. We\nevaluate our decision procedure on two verification and security applications:\n1) checking satisfiability of linear temporal logic formulas over finite\ntraces, and 2) checking equivalence of Boolean combinations of regular\nexpressions. Our experiments show that our technique often outperforms existing\ntechniques and it can be beneficial in both such applications.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.01722v1"
    },
    {
        "title": "Generating Candidate Busy Beaver Machines (Or How to Build the Zany Zoo)",
        "authors": [
            "James Harland"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The busy beaver problem is a well-known example of a non-computable function.\nIn order to determine a particular value of this function, it is necessary to\ngenerate and classify a large number of Turing machines. Previous work on this\nproblem has described the processes used for the generation and classification\nof these machines, but unfortunately has generally not provided details of the\nmachines considered. While there is no reason to doubt the veracity of the\nresults known so far, it is difficult to accept such results as scientifically\nproven without being able to inspect the appropriate evidence. In addition, a\nlist of machines and their classifications can be used for other results, such\nas variations on the busy beaver problem and related problems such as the\nplacid platypus problem. In this paper we investigate how to generate classes\nof machines to be considered for the busy beaver problem. We discuss the\nrelationship between quadruple and quintuple variants of Turing machines, and\nshow that the latter are more general than the former. We give some formal\nresults to justify our strategy for minimising the number of machines\ngenerated, and define a process reflecting this strategy for generating\nmachines. We describe our implementation, and the results of generating various\nclasses of machines with up to 5 states or up to 5 symbols, all of which\n(together with our code) are available on the author's website.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.03184v1"
    },
    {
        "title": "Morphisms on infinite alphabets, countable states automata and regular\n  sequences",
        "authors": [
            "Jie-Meng Zhang",
            "Jin Chen",
            "Yingjun Guo",
            "Zhixiong Wen"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper, we prove that a class of regular sequences can be viewed as\nprojections of fixed points of uniform morphisms on a countable alphabet, and\nalso can be generated by countable states automata. Moreover, we prove that the\nregularity of some regular sequences is invariant under some codings.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.03971v1"
    },
    {
        "title": "Büchi automata recognizing sets of reals definable in first-order\n  logic with addition and order",
        "authors": [
            "Arthur Milchior"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This work considers weak deterministic B\\\"uchi automata reading encodings of\nnon-negative reals in a fixed base. A Real Number Automaton is an automaton\nwhich recognizes all encoding of elements of a set of reals. It is explained\nhow to decide in linear time whether a set of reals recognized by a given\nminimal weak deterministic RNA is ${FO}[\\mathbb R;+,<,1]$-definable.\nFurthermore, it is explained how to compute in quasi-quadratic (respectively,\nquasi-linear) time an existential (respectively, existential-universal)\n${FO}[\\mathbb R;+,<,1]$-formula which defines the set of reals recognized by\nthe automaton. It is also shown that techniques given by Muchnik and by Honkala\nfor automata over vector of natural numbers also works on vector of real\nnumbers. It implies that some problems such as deciding whether a set of tuples\nof reals $R\\subseteq\\mathbb R^{d}$ is a subsemigroup of $(\\mathbb R^{d},+)$ or\nis ${FO}[\\mathbb R;+,<,1]$-definable is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.06027v3"
    },
    {
        "title": "On Finite-Index Indexed Grammars and Their Restrictions",
        "authors": [
            "Flavio D'Alessandro",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The family, L(INDLIN), of languages generated by linear indexed grammars has\nbeen studied in the literature. It is known that the Parikh image of every\nlanguage in L(INDLIN) is semi-linear. However, there are bounded semi linear\nlanguages that are not in L(INDLIN). Here, we look at larger families of\n(restricted) indexed languages and study their properties, their relationships,\nand their decidability properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.06366v4"
    },
    {
        "title": "Partial Derivatives for Context-Free Languages: From $μ$-Regular\n  Expressions to Pushdown Automata",
        "authors": [
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We extend Antimirov's partial derivatives from regular expressions to\n$\\mu$-regular expressions that describe context-free languages. We prove the\ncorrectness of partial derivatives as well as the finiteness of the set of\niterated partial derivatives. The latter are used as pushdown symbols in our\nconstruction of a nondeterministic pushdown automaton, which generalizes\nAntimirov's NFA construction.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.06832v3"
    },
    {
        "title": "A Novel Learning Algorithm for Büchi Automata based on Family of DFAs\n  and Classification Trees",
        "authors": [
            "Yong Li",
            "Yu-Fang Chen",
            "Lijun Zhang",
            "Depeng Liu"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper, we propose a novel algorithm to learn a B\\\"uchi automaton from\na teacher who knows an $\\omega$-regular language. The algorithm is based on\nlearning a formalism named family of DFAs (FDFAs) recently proposed by Angluin\nand Fisman[10]. The main catch is that we use a classification tree structure\ninstead of the standard observation table structure. The worst case storage\nspace required by our algorithm is quadratically better than the table-based\nalgorithm proposed in [10]. We implement the first publicly available library\nROLL (Regular Omega Language Learning ), which consists of all $\\omega$-regular\nlearning algorithms available in the literature and the new algorithms proposed\nin this paper. Experimental results show that our tree-based algorithms have\nthe best performance among others regarding the number of solved learning\ntasks.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07380v2"
    },
    {
        "title": "Some connections between universal algebra and logics for trees",
        "authors": [
            "Mikołaj Bojańczyk",
            "Henryk Michalewski"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  One of the major open problems in automata and logic is the following: is\nthere an algorithm which inputs a regular tree language and decides if the\nlanguage can be defined in first-order logic? The goal of this paper is to\npresent this problem and similar ones using the language of universal algebra,\nhighlighting potential connections to the structural theory of finite algebras,\nincluding Tame Congruence Theory.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.04736v1"
    },
    {
        "title": "A Quasi-Linear Time Algorithm Deciding Whether Weak Büchi Automata\n  Reading Vectors of Reals Recognize Saturated Languages",
        "authors": [
            "Arthur Milchior"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This work considers weak deterministic B\\\"uchi automata reading encodings of\nnon-negative $d$-vectors of reals in a fixed base. A saturated language is a\nlanguage which contains all encoding of elements belonging to a set of\n$d$-vectors of reals. A Real Vector Automaton is an automaton which recognizes\na saturated language. It is explained how to decide in quasi-linear time\nwhether a minimal weak deterministic B\\\"uchi automaton is a Real Vector\nAutomaton. The problem is solved both for the two standard encodings of vectors\nof numbers: the sequential encoding and the parallel encoding. This algorithm\nruns in linear time for minimal weak B\\\"uchi automata accepting set of reals.\nFinally, the same problem is also solved for parallel encoding of automata\nreading vectors of relative reals.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.04834v1"
    },
    {
        "title": "Green's Relations in Finite Transformation Semigroups",
        "authors": [
            "Lukas Fleischer",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider the complexity of Green's relations when the semigroup is given\nby transformations on a finite set. Green's relations can be defined by\nreachability in the (right/left/two-sided) Cayley graph. The equivalence\nclasses then correspond to the strongly connected components. It is not\ndifficult to show that, in the worst case, the number of equivalence classes is\nin the same order of magnitude as the number of elements. Another important\nparameter is the maximal length of a chain of components. Our main contribution\nis an exponential lower bound for this parameter. There is a simple\nconstruction for an arbitrary set of generators. However, the proof for\nconstant alphabet is rather involved. Our results also apply to automata and\ntheir syntactic semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.04941v1"
    },
    {
        "title": "Deriving Generic Bounds for Time-Series Constraints Based on Regular\n  Expressions Characteristics",
        "authors": [
            "Ekaterina Arafailova",
            "Nicolas Beldiceanu",
            "Helmut Simonis"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce the concept of regular expression characteristics as a unified\nway to concisely express bounds on time-series constraints. This allows us not\nonly to define time-series constraints in a compositional way, but also to deal\nwith their combinatorial aspect in a compositional way, without developing\nad-hoc bounds for each time-series constraint separately.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.06783v1"
    },
    {
        "title": "Approximation of Weighted Automata with Storage",
        "authors": [
            "Tobias Denkinger"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We use a non-deterministic variant of storage types to develop a framework\nfor the approximation of automata with storage. This framework is used to\nprovide automata-theoretic views on the approximation of multiple context-free\nlanguages and on coarse-to-fine parsing.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.09910v2"
    },
    {
        "title": "Parikh-reducing Church-Rosser representations for some classes of\n  regular languages",
        "authors": [
            "Tobias Walter"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper the concept of Parikh-reducing Church-Rosser systems is\nstudied. It is shown that for two classes of regular languages there exist such\nsystems which describe the languages using finitely many equivalence classes of\nthe rewriting system. The two classes are: 1.) the class of all regular\nlanguages such that the syntactic monoid contains only abelian groups and 2.)\nthe class of all group languages over a two-letter alphabet. The construction\nof the systems yield a monoid representation such that all subgroups are\nabelian. Additionally, the complexity of those representations is studied.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.10056v1"
    },
    {
        "title": "CALF: Categorical Automata Learning Framework",
        "authors": [
            "Gerco van Heerdt",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Automata learning is a technique that has successfully been applied in\nverification, with the automaton type varying depending on the application\ndomain. Adaptations of automata learning algorithms for increasingly complex\ntypes of automata have to be developed from scratch because there was no\nabstract theory offering guidelines. This makes it hard to devise such\nalgorithms, and it obscures their correctness proofs. We introduce a simple\ncategory-theoretic formalism that provides an appropriately abstract foundation\nfor studying automata learning. Furthermore, our framework establishes formal\nrelations between algorithms for learning, testing, and minimization. We\nillustrate its generality with two examples: deterministic and weighted\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.05676v3"
    },
    {
        "title": "Control Improvisation",
        "authors": [
            "Daniel J. Fremont",
            "Alexandre Donzé",
            "Sanjit A. Seshia"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We formalize and analyze a new problem in formal language theory termed\ncontrol improvisation. Given a specification language, the problem is to\nproduce an improviser, a probabilistic algorithm that randomly generates words\nin the language, subject to two additional constraints: the satisfaction of a\nquantitative soft constraint, and the exhibition of a specified amount of\nrandomness. Control improvisation has many applications, including for example\nsystematically generating random test vectors satisfying format constraints or\npreconditions while being similar to a library of seed inputs. Other\napplications include robotic surveillance, machine improvisation of music, and\nrandomized variants of the supervisory control problem. We describe a general\nframework for solving the control improvisation problem, and use it to give\nefficient algorithms for several practical classes of instances with finite\nautomaton and context-free grammar specifications. We also provide a detailed\ncomplexity analysis, establishing #P-hardness of the problem in many other\ncases. For these intractable cases, we show how symbolic techniques based on\nBoolean satisfiability (SAT) solvers can be used to find approximate solutions.\nFinally, we discuss an extension of control improvisation to multiple soft\nconstraints that is useful in some applications.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.06319v1"
    },
    {
        "title": "Separability by Piecewise Testable Languages is PTime-Complete",
        "authors": [
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Piecewise testable languages form the first level of the Straubing-Th\\'erien\nhierarchy. The membership problem for this level is decidable and testing if\nthe language of a DFA is piecewise testable is NL-complete. The question has\nnot yet been addressed for NFAs. We fill in this gap by showing that it is\nPSpace-complete. The main result is then the lower-bound complexity of\nseparability of regular languages by piecewise testable languages. Two regular\nlanguages are separable by a piecewise testable language if the piecewise\ntestable language includes one of them and is disjoint from the other. For\nlanguages represented by NFAs, separability by piecewise testable languages is\nknown to be decidable in PTime. We show that it is PTime-hard and that it\nremains PTime-hard even for minimal DFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.07856v2"
    },
    {
        "title": "Universality of Confluent, Self-Loop Deterministic Partially Ordered\n  NFAs is Hard",
        "authors": [
            "Tomáš Masopust",
            "Markus Krötzsch"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  An automaton is partially ordered if the only cycles in its transition\ndiagram are self-loops. The expressivity of partially ordered NFAs (poNFAs) can\nbe characterized by the Straubing-Th\\'erien hierarchy. Level 3/2 is recognized\nby poNFAs, level 1 by confluent, self-loop deterministic poNFAs as well as by\nconfluent poDFAs, and level 1/2 by saturated poNFAs. We study the universality\nproblem for confluent, self-loop deterministic poNFAs. It asks whether an\nautomaton accepts all words over its alphabet. Universality for both NFAs and\npoNFAs is a PSpace-complete problem. For confluent, self-loop deterministic\npoNFAs, the complexity drops to coNP-complete if the alphabet is fixed but is\nopen if the alphabet may grow. We solve this problem by showing that it is\nPSpace-complete if the alphabet may grow polynomially. Consequently, our result\nprovides a lower-bound complexity for some other problems, including inclusion,\nequivalence, and $k$-piecewise testability. Since universality for saturated\npoNFAs is easy, confluent, self-loop deterministic poNFAs are the simplest and\nnatural kind of NFAs characterizing a well-known class of languages, for which\ndeciding universality is as difficult as for general NFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.07860v1"
    },
    {
        "title": "Preimage problems for deterministic finite automata",
        "authors": [
            "Mikhail V. Berlinkov",
            "Robert Ferens",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Given a subset of states $S$ of a deterministic finite automaton and a word\n$w$, the preimage is the subset of all states mapped to a state in $S$ by the\naction of $w$. We study three natural problems concerning words giving certain\npreimages. The first problem is whether, for a given subset, there exists a\nword \\emph{extending} the subset (giving a larger preimage). The second problem\nis whether there exists a \\emph{totally extending} word (giving the whole set\nof states as a preimage)---equivalently, whether there exists an\n\\emph{avoiding} word for the complementary subset. The third problem is whether\nthere exists a \\emph{resizing} word. We also consider variants where the length\nof the word is upper bounded, where the size of the given subset is restricted,\nand where the automaton is strongly connected, synchronizing, or binary. We\nconclude with a summary of the complexities in all combinations of the cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.08233v4"
    },
    {
        "title": "Busy Beaver Scores and Alphabet Size",
        "authors": [
            "Holger Petersen"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the Busy Beaver Game introduced by Rado (1962) generalized to\nnon-binary alphabets. Harland (2016) conjectured that activity (number of\nsteps) and productivity (number of non-blank symbols) of candidate machines\ngrow as the alphabet size increases. We prove this conjecture for any alphabet\nsize under the condition that the number of states is sufficiently large. For\nthe measure activity we show that increasing the alphabet size from two to\nthree allows an increase. By a classical construction it is even possible to\nobtain a two-state machine increasing activity and productivity of any machine\nif we allow an alphabet size depending on the number of states of the original\nmachine. We also show that an increase of the alphabet by a factor of three\nadmits an increase of activity.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.08752v1"
    },
    {
        "title": "Stream Processing using Grammars and Regular Expressions",
        "authors": [
            "Ulrik Terp Rasmussen"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this dissertation we study regular expression based parsing and the use of\ngrammatical specifications for the synthesis of fast, streaming\nstring-processing programs.\n  In the first part we develop two linear-time algorithms for regular\nexpression based parsing with Perl-style greedy disambiguation. The first\nalgorithm operates in two passes in a semi-streaming fashion, using a constant\namount of working memory and an auxiliary tape storage which is written in the\nfirst pass and consumed by the second. The second algorithm is a single-pass\nand optimally streaming algorithm which outputs as much of the parse tree as is\nsemantically possible based on the input prefix read so far, and resorts to\nbuffering as many symbols as is required to resolve the next choice. Optimality\nis obtained by performing a PSPACE-complete pre-analysis on the regular\nexpression.\n  In the second part we present Kleenex, a language for expressing\nhigh-performance streaming string processing programs as regular grammars with\nembedded semantic actions, and its compilation to streaming string transducers\nwith worst-case linear-time performance. Its underlying theory is based on\ntransducer decomposition into oracle and action machines, and a finite-state\nspecialization of the streaming parsing algorithm presented in the first part.\nIn the second part we also develop a new linear-time streaming parsing\nalgorithm for parsing expression grammars (PEG) which generalizes the regular\ngrammars of Kleenex. The algorithm is based on a bottom-up tabulation algorithm\nreformulated using least fixed points and evaluated using an instance of the\nchaotic iteration scheme by Cousot and Cousot.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.08820v1"
    },
    {
        "title": "Generalizing input-driven languages: theoretical and practical benefits",
        "authors": [
            "Dino Mandrioli",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Regular languages (RL) are the simplest family in Chomsky's hierarchy. Thanks\nto their simplicity they enjoy various nice algebraic and logic properties that\nhave been successfully exploited in many application fields. Practically all of\ntheir related problems are decidable, so that they support automatic\nverification algorithms. Also, they can be recognized in real-time.\n  Context-free languages (CFL) are another major family well-suited to\nformalize programming, natural, and many other classes of languages; their\nincreased generative power w.r.t. RL, however, causes the loss of several\nclosure properties and of the decidability of important problems; furthermore\nthey need complex parsing algorithms. Thus, various subclasses thereof have\nbeen defined with different goals, spanning from efficient, deterministic\nparsing to closure properties, logic characterization and automatic\nverification techniques.\n  Among CFL subclasses, so-called structured ones, i.e., those where the\ntypical tree-structure is visible in the sentences, exhibit many of the\nalgebraic and logic properties of RL, whereas deterministic CFL have been\nthoroughly exploited in compiler construction and other application fields.\n  After surveying and comparing the main properties of those various language\nfamilies, we go back to operator precedence languages (OPL), an old family\nthrough which R. Floyd pioneered deterministic parsing, and we show that they\noffer unexpected properties in two fields so far investigated in totally\nindependent ways: they enable parsing parallelization in a more effective way\nthan traditional sequential parsers, and exhibit the same algebraic and logic\nproperties so far obtained only for less expressive language families.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.00984v1"
    },
    {
        "title": "On the Height of Towers of Subsequences and Prefixes",
        "authors": [
            "Štěpán Holub",
            "Tomáš Masopust",
            "Michaël Thomazo"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A tower is a sequence of words alternating between two languages in such a\nway that every word is a subsequence of the following word. The height of the\ntower is the number of words in the sequence. If there is no infinite tower (a\ntower of infinite height), then the height of all towers between the languages\nis bounded. We study upper and lower bounds on the height of maximal finite\ntowers with respect to the size of the NFA (the DFA) representation of the\nlanguages. We show that the upper bound is polynomial in the number of states\nand exponential in the size of the alphabet, and that it is asymptotically\ntight if the size of the alphabet is fixed. If the alphabet may grow, then,\nusing an alphabet of size approximately the number of states of the automata,\nthe lower bound on the height of towers is exponential with respect to that\nnumber. In this case, there is a gap between the lower and upper bound, and the\nasymptotically optimal bound remains an open problem. Since, in many cases, the\nconstructed towers are sequences of prefixes, we also study towers of prefixes.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.02813v1"
    },
    {
        "title": "The Impact of Alternation",
        "authors": [
            "Radu Iosif",
            "Xiao Xu"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Alternating automata have been widely used to model and verify systems that\nhandle data from finite domains, such as communication protocols or hardware.\nThe main advantage of the alternating model of computation is that\ncomplementation is possible in linear time, thus allowing to concisely encode\ntrace inclusion problems that occur often in verification. In this paper we\nconsider alternating automata over infinite alphabets, whose transition rules\nare formulae in a combined theory of booleans and some infinite data domain,\nthat relate past and current values of the data variables. The data theory is\nnot fixed, but rather it is a parameter of the class. We show that union,\nintersection and complementation are possible in linear time in this model and,\nthough the emptiness problem is undecidable, we provide two efficient\nsemi-algorithms, inspired by two state-of-the-art abstraction refinement model\nchecking methods: lazy predicate abstraction \\cite{HJMS02} and the \\impact~\nsemi-algorithm \\cite{mcmillan06}. We have implemented both methods and report\nthe results of an experimental comparison.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.05606v2"
    },
    {
        "title": "A Characterization of Infinite LSP Words",
        "authors": [
            "Gwenaël Richomme"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  G. Fici proved that a finite word has a minimal suffix automaton if and only\nif all its left special factors occur as prefixes. He called LSP all finite and\ninfinite words having this latter property. We characterize here infinite LSP\nwords in terms of $S$-adicity. More precisely we provide a finite set of\nmorphisms $S$ and an automaton ${\\cal A}$ such that an infinite word is LSP if\nand only if it is $S$-adic and all its directive words are recognizable by\n${\\cal A}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.05786v1"
    },
    {
        "title": "Completeness Theorems for Pomset Languages and Concurrent Kleene\n  Algebras",
        "authors": [
            "Michael R Laurence",
            "Georg Struth"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Pomsets constitute one of the most basic models of concurrency. A pomset is a\ngeneralisation of a word over an alphabet in that letters may be partially\nordered. A term $t$ using the bi-Kleene operations $0,1, +, \\cdot\\, ,^*,\n\\parallel, ^{(*)}$ defines a language $ \\mathopen{[\\![ } t \\mathclose{]\\!] } $\nof pomsets in a natural way.\n  We prove that every valid universal equality over pomset languages using\nthese operations is a consequence of the equational theory of regular languages\n(in which parallel multiplication and iteration are undefined) plus that of the\ncommutative-regular languages (in which sequential multiplication and iteration\nare undefined). We also show that the class of $\\textit{rational}$ pomset\nlanguages (that is, those languages generated from singleton pomsets using the\nbi-Kleene operations) is closed under all Boolean operations.\n  An $ \\textit{ideal}$ of a pomset $p$ is a pomset using the letters of $p$,\nbut having an ordering at least as strict as $p$. A bi-Kleene term $t$ thus\ndefines the set $ \\textbf{Id} (\\mathopen{[\\![ } t \\mathclose{]\\!] }) $ of\nideals of pomsets in $ \\mathopen{[\\![ } t \\mathclose{]\\!] } $. We prove that if\n$t$ does not contain commutative iteration $^{(*)}$ (in our terminology, $t$ is\nbw-rational) then $\\textbf{Id} (\\mathopen{[\\![ } t \\mathclose{]\\!] }) \\cap\n\\textbf{Pom}_{sp}$, where $ \\textbf{Pom}_{sp}$ is the set of pomsets generated\nfrom singleton pomsets using sequential and parallel multiplication ($ \\cdot$\nand $ \\parallel$) is defined by a bw-rational term, and if two such terms\n$t,t'$ define the same ideal language, then $t'=t$ is provable from the Kleene\naxioms for $0,1, +, \\cdot\\, ,^*$ plus the commutative idempotent semiring\naxioms for $0,1, +, \\parallel$ plus the exchange law $ (u \\parallel v)\\cdot ( x\n\\parallel y) \\le v \\cdot y \\parallel u \\cdot x $.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.05896v1"
    },
    {
        "title": "Weighted Regular Tree Grammars with Storage",
        "authors": [
            "Zoltán Fülöp",
            "Luisa Herrmann",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce weighted regular tree grammars with storage as combination of\n(a) regular tree grammars with storage and (b) weighted tree automata over\nmultioperator monoids. Each weighted regular tree grammar with storage\ngenerates a weighted tree language, which is a mapping from the set of trees to\nthe multioperator monoid. We prove that, for multioperator monoids canonically\nassociated to particular strong bi-monoids, the support of the generated\nweighted tree languages can be generated by (unweighted) regular tree grammars\nwith storage. We characterize the class of all generated weighted tree\nlanguages by the composition of three basic concepts. Moreover, we prove\nresults on the elimination of chain rules and of finite storage types, and we\ncharacterize weighted regular tree grammars with storage by a new weighted\nMSO-logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.06681v6"
    },
    {
        "title": "State Complexity of Reversals of Deterministic Finite Automata with\n  Output",
        "authors": [
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the worst-case state complexity of reversals of deterministic\nfinite automata with output (DFAOs). In these automata, each state is assigned\nsome output value, rather than simply being labelled final or non-final. This\ndirectly generalizes the well-studied problem of determining the worst-case\nstate complexity of reversals of ordinary deterministic finite automata. If a\nDFAO has $n$ states and $k$ possible output values, there is a known upper\nbound of $k^n$ for the state complexity of reversal. We show this bound can be\nreached with a ternary input alphabet. We conjecture it cannot be reached with\na binary input alphabet except when $k = 2$, and give a lower bound for the\ncase $3 \\le k < n$. We prove that the state complexity of reversal depends\nsolely on the transition monoid of the DFAO and the mapping that assigns output\nvalues to states.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.07150v2"
    },
    {
        "title": "On winning shifts of marked uniform substitutions",
        "authors": [
            "Jarkko Peltomäki",
            "Ville Salo"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The second author introduced with I. T\\\"orm\\\"a a two-player word-building\ngame [Playing with Subshifts, Fund. Inform. 132 (2014), 131--152]. The game has\na predetermined (possibly finite) choice sequence $\\alpha_1$, $\\alpha_2$,\n$\\ldots$ of integers such that on round $n$ the player $A$ chooses a subset\n$S_n$ of size $\\alpha_n$ of some fixed finite alphabet and the player $B$ picks\na letter from the set $S_n$. The outcome is determined by whether the word\nobtained by concatenating the letters $B$ picked lies in a prescribed target\nset $X$ (a win for player $A$) or not (a win for player $B$). Typically, we\nconsider $X$ to be a subshift. The winning shift $W(X)$ of a subshift $X$ is\ndefined as the set of choice sequences for which $A$ has a winning strategy\nwhen the target set is the language of $X$. The winning shift $W(X)$ mirrors\nsome properties of $X$. For instance, $W(X)$ and $X$ have the same entropy.\nVirtually nothing is known about the structure of the winning shifts of\nsubshifts common in combinatorics on words. In this paper, we study the winning\nshifts of subshifts generated by marked uniform substitutions, and show that\nthese winning shifts, viewed as subshifts, also have a substitutive structure.\nParticularly, we give an explicit description of the winning shift for the\ngeneralized Thue-Morse substitutions. It is known that $W(X)$ and $X$ have the\nsame factor complexity. As an example application, we exploit this connection\nto give a simple derivation of the first difference and factor complexity\nfunctions of subshifts generated by marked substitutions. We describe these\nfunctions in particular detail for the generalized Thue-Morse substitutions.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.08747v2"
    },
    {
        "title": "Higher-Order Operator Precedence Languages",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Floyd's Operator Precedence (OP) languages are a deterministic context-free\nfamily having many desirable properties. They are locally and parallely\nparsable, and languages having a compatible structure are closed under Boolean\noperations, concatenation and star; they properly include the family of Visibly\nPushdown (or Input Driven) languages. OP languages are based on three relations\nbetween any two consecutive terminal symbols, which assign syntax structure to\nwords. We extend such relations to k-tuples of consecutive terminal symbols, by\nusing the model of strictly locally testable regular languages of order k at\nleast 3. The new corresponding class of Higher-order Operator Precedence\nlanguages (HOP) properly includes the OP languages, and it is still included in\nthe deterministic (also in reverse) context free family. We prove Boolean\nclosure for each subfamily of structurally compatible HOP languages. In each\nsubfamily, the top language is called max-language. We show that such languages\nare defined by a simple cancellation rule and we prove several properties, in\nparticular that max-languages make an infinite hierarchy ordered by parameter\nk. HOP languages are a candidate for replacing OP languages in the various\napplications where they have have been successful though sometimes too\nrestrictive.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.09093v2"
    },
    {
        "title": "Regularity of languages generated by non context-free grammars over a\n  singleton terminal alphabet",
        "authors": [
            "Alberto Pettorossi",
            "Maurizio Proietti"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  It is well-known that: (i) every context-free language over a singleton\nterminal alphabet is regular, and (ii) the class of languages that satisfy the\nPumping Lemma is a proper super-class of the context-free languages. We show\nthat any language in this superclass over a singleton terminal alphabet is\nregular. Our proof is based on a transformational approach and does not rely on\nParikh's Theorem. Our result extends previously known results because there are\nlanguages that are not context-free, do satisfy the Pumping Lemma, and do not\nsatisfy the hypotheses of Parikh's Theorem.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.09695v2"
    },
    {
        "title": "Variations of Checking Stack Automata: Obtaining Unexpected Decidability\n  Properties",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce a model of one-way language acceptors (a variant of a checking\nstack automaton) and show the following decidability properties: (1) The\ndeterministic version has a decidable membership problem but has an undecidable\nemptiness problem. (2) The nondeterministic version has an undecidable\nmembership problem and emptiness problem. There are many models of accepting\ndevices for which there is no difference with these problems between\ndeterministic and nondeterministic versions, and the same holds for the\nemptiness problem. As far as we know, the model we introduce above is the first\none-way model to exhibit properties (1) and (2). We define another family of\none-way acceptors where the nondeterministic version has an undecidable\nemptiness problem, but the deterministic version has a decidable emptiness\nproblem. We also know of no other model with this property in the literature.\nWe also investigate decidability properties of other variations of checking\nstack automata (e.g., allowing multiple stacks, two-way input, etc.).\nSurprisingly, two-way deterministic machines with multiple checking stacks and\nmultiple reversal-bounded counters are shown to have a decidable membership\nproblem, a very general model with this property.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.09732v2"
    },
    {
        "title": "Reversible Languages Having Finitely Many Reduced Automata",
        "authors": [
            "Kitti Gelle",
            "Szabolcs Iván"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Reversible forms of computations are often interesting from an energy\nefficiency point of view. When the computation device in question is an\nautomaton, it is known that the minimal reversible automaton recognizing a\ngiven language is not necessarily unique, moreover, there are languages having\narbitrarily large reversible recognizers possessing no nontrivial reversible\ncongruence. However, the exact characterization of this class of languages was\nopen. In this paper we give a forbidden pattern capturing the reversible\nregular languages having only finitely many reduced reversible automata,\nallowing an efficient (NL) decision procedure.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.10533v2"
    },
    {
        "title": "On the decidability of $k$-Block determinism",
        "authors": [
            "Pascal Caron",
            "Ludovic Mignot",
            "Clément Miklarz"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Br\\\"uggemann-Klein and Wood define a one-unambiguous regular language as a\nlanguage that can be recognized by a deterministic Glushkov automaton. They\ngive a procedure performed on the minimal DFA, the BW-test, to decide whether a\nlanguage is one-unambiguous. Block determinism is an extension of\none-unambiguity while considering non-empty words as symbols and\nprefix-freeness as determinism. A block automaton is compact if it does not\nhave two equivalent states (same right language). We showed that a language is\n$k$-block deterministic if it is recognized by some deterministic $k$-block\nautomaton passing the BW-test. In this paper, we show that any $k$-block\ndeterministic language is recognized by a compact deterministic $k$-block\nautomaton passing the BW-test. We also give a procedure which enumerates, for a\ngiven language, the finite set of compact deterministic $k$-block automata. It\ngives us a decidable procedure to test whether a language is $k$-block\ndeterministic.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.10625v1"
    },
    {
        "title": "Pumping Lemma for Higher-order Languages",
        "authors": [
            "Kazuyuki Asada",
            "Naoki Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study a pumping lemma for the word/tree languages generated by\nhigher-order grammars. Pumping lemmas are known up to order-2 word languages\n(i.e., for regular/context-free/indexed languages), and have been used to show\nthat a given language does not belong to the classes of\nregular/context-free/indexed languages. We prove a pumping lemma for word/tree\nlanguages of arbitrary orders, modulo a conjecture that a higher-order version\nof Kruskal's tree theorem holds. We also show that the conjecture indeed holds\nfor the order-2 case, which yields a pumping lemma for order-2 tree languages\nand order-3 word languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.10699v1"
    },
    {
        "title": "Distinct Squares in Circular Words",
        "authors": [
            "Mika Amit",
            "Paweł Gawrychowski"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A circular word, or a necklace, is an equivalence class under conjugation of\na word. A fundamental question concerning regularities in standard words is\nbounding the number of distinct squares in a word of length $n$. The famous\nconjecture attributed to Fraenkel and Simpson is that there are at most $n$\nsuch distinct squares, yet the best known upper bound is $1.84n$ by Deza et al.\n[Discr. Appl. Math. 180, 52-69 (2015)]. We consider a natural generalization of\nthis question to circular words: how many distinct squares can there be in all\ncyclic rotations of a word of length $n$? We prove an upper bound of $3.14n$.\nThis is complemented with an infinite family of words implying a lower bound of\n$1.25n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.00639v1"
    },
    {
        "title": "Communicating Timed Processes with Perfect Timed Channels",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "S. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce the model of communicating timed automata (CTA) that extends the\nclassical models of finite-state processes communicating through FIFO perfect\nchannels and timed automata, in the sense that the finite-state processes are\nreplaced by timed automata, and messages inside the perfect channels are\nequipped with clocks representing their ages. In addition to the standard\noperations (resetting clocks, checking guards of clocks) each automaton can\neither (1) append a message to the tail of a channel with an initial age or (2)\nreceive the message at the head of a channel if its age satisfies a set of\ngiven constraints. In this paper, we show that the reachability problem is\nundecidable even in the case of two timed automata connected by one\nunidirectional timed channel if one allows global clocks (that the two automata\ncan check and manipulate). We prove that this undecidability still holds even\nfor CTA consisting of three timed automata and two unidirectional timed\nchannels (and without any global clock). However, the reachability problem\nbecomes decidable (in $\\mathsf{EXPTIME}$) in the case of two automata linked\nwith one unidirectional timed channel and with no global clock. Finally, we\nconsider the bounded-context case, where in each context, only one timed\nautomaton is allowed to receive messages from one channel while being able to\nsend messages to all the other timed channels. In this case we show that the\nreachability problem is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.05063v4"
    },
    {
        "title": "Proceedings 15th International Conference on Automata and Formal\n  Languages",
        "authors": [
            "Erzsébet Csuhaj-Varjú",
            "Pál Dömösi",
            "György Vaszil"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The 15th International Conference on Automata and Formal Languages (AFL 2017)\nwas held in Debrecen, Hungary, from September 4 to 6, 2017. The conference was\norganized by the Faculty of Informatics of the University of Debrecen and the\nFaculty of Informatics of the E\\\"otv\\\"os Lor\\'and University of Budapest.\nTopics of interest covered all aspects of automata and formal languages,\nincluding theory and applications.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06226v1"
    },
    {
        "title": "(Tissue) P Systems with Vesicles of Multisets",
        "authors": [
            "Artiom Alhazov",
            "Rudolf Freund",
            "Sergiu Ivanov",
            "Sergey Verlan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider tissue P systems working on vesicles of multisets with the very\nsimple operations of insertion, deletion, and substitution of single objects.\nWith the whole multiset being enclosed in a vesicle, sending it to a target\ncell can be indicated in those simple rules working on the multiset. As\nderivation modes we consider the sequential mode, where exactly one rule is\napplied in a derivation step, and the set maximal mode, where in each\nderivation step a non-extendable set of rules is applied. With the set maximal\nmode, computational completeness can already be obtained with tissue P systems\nhaving a tree structure, whereas tissue P systems even with an arbitrary\ncommunication structure are not computationally complete when working in the\nsequential mode. Adding polarizations (-1, 0, 1 are sufficient) allows for\nobtaining computational completeness even for tissue P systems working in the\nsequential mode.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06458v1"
    },
    {
        "title": "Unavoidable Sets of Partial Words of Uniform Length",
        "authors": [
            "Joey Becker",
            "F. Blanchet-Sadri",
            "Laure Flapan",
            "Stephen Watkins"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A set X of partial words over a finite alphabet A is called unavoidable if\nevery two-sided infinite word over A has a factor compatible with an element of\nX. Unlike the case of a set of words without holes, the problem of deciding\nwhether or not a given finite set of n partial words over a k-letter alphabet\nis avoidable is NP-hard, even when we restrict to a set of partial words of\nuniform length. So classifying such sets, with parameters k and n, as avoidable\nor unavoidable becomes an interesting problem. In this paper, we work towards\nthis classification problem by investigating the maximum number of holes we can\nfill in unavoidable sets of partial words of uniform length over an alphabet of\nany fixed size, while maintaining the unavoidability property.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06459v1"
    },
    {
        "title": "On the Descriptional Complexity of Operations on Semilinear Sets",
        "authors": [
            "Simon Beier",
            "Markus Holzer",
            "Martin Kutrib"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the descriptional complexity of operations on semilinear sets.\nRoughly speaking, a semilinear set is the finite union of linear sets, which\nare built by constant and period vectors. The interesting parameters of a\nsemilinear set are: (i) the maximal value that appears in the vectors of\nperiods and constants and (ii) the number of such sets of periods and constants\nnecessary to describe the semilinear set under consideration. More precisely,\nwe prove upper bounds on the union, intersection, complementation, and inverse\nhomomorphism. In particular, our result on the complementation upper bound\nanswers an open problem from [G. J. LAVADO, G. PIGHIZZINI, S. SEKI: Operational\nState Complexity of Parikh Equivalence, 2014].\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06460v1"
    },
    {
        "title": "Dyck Words, Lattice Paths, and Abelian Borders",
        "authors": [
            "F. Blanchet-Sadri",
            "Kun Chen",
            "Kenneth Hawes"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We use results on Dyck words and lattice paths to derive a formula for the\nexact number of binary words of a given length with a given minimal abelian\nborder length, tightening a bound on that number from Christodoulakis et al.\n(Discrete Applied Mathematics, 2014). We also extend to any number of distinct\nabelian borders a result of Rampersad et al. (Developments in Language Theory,\n2013) on the exact number of binary words of a given length with no abelian\nborders. Furthermore, we generalize these results to partial words.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06461v1"
    },
    {
        "title": "The Triple-Pair Construction for Weighted $ω$-Pushdown Automata",
        "authors": [
            "Manfred Droste",
            "Zoltán Ésik",
            "Werner Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Let S be a complete star-omega semiring and Sigma be an alphabet. For a\nweighted omega-pushdown automaton P with stateset 1...n, n greater or equal to\n1, we show that there exists a mixed algebraic system over a complete\nsemiring-semimodule pair ((S<<Sigma*>>)^nxn, (S<<Sigma^omega>>)^n) such that\nthe behavior ||P|| of P is a component of a solution of this system. In case\nthe basic semiring is the Boolean semiring or the semiring of natural numbers\n(augmented with infinity), we show that there exists a mixed context-free\ngrammar that generates ||P||. The construction of the mixed context-free\ngrammar from P is a generalization of the well known triple construction and is\ncalled now triple-pair construction for omega-pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06463v1"
    },
    {
        "title": "Input-Driven Double-Head Pushdown Automata",
        "authors": [
            "Markus Holzer",
            "Martin Kutrib",
            "Andreas Malcher",
            "Matthias Wendlandt"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce and study input-driven deterministic and nondeterministic\ndouble-head pushdown automata. A double-head pushdown automaton is a slight\ngeneralization of an ordinary pushdown automaton working with two input heads\nthat move in opposite directions on the common input tape. In every step one\nhead is moved and the automaton decides on acceptance if the heads meet.\nDemanding the automaton to work input-driven it is required that every input\nsymbol uniquely defines the action on the pushdown store (push, pop, state\nchange). Normally this is modeled by a partition of the input alphabet and is\ncalled a signature. Since our automaton model works with two heads either both\nheads respect the same signature or each head owes its own signature. This\nresults in two variants of input-driven double-head pushdown automata. The\ninduced language families on input-driven double-head pushdown automata are\nstudied from the perspectives of their language describing capability, their\nclosure properties, and decision problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06464v1"
    },
    {
        "title": "Weakly and Strongly Irreversible Regular Languages",
        "authors": [
            "Giovanna J. Lavado",
            "Giovanni Pighizzini",
            "Luca Prigioniero"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Finite automata whose computations can be reversed, at any point, by knowing\nthe last k symbols read from the input, for a fixed k, are considered. These\ndevices and their accepted languages are called k-reversible automata and\nk-reversible languages, respectively. The existence of k-reversible languages\nwhich are not (k-1)-reversible is known, for each k>1. This gives an infinite\nhierarchy of weakly irreversible languages, i.e., languages which are\nk-reversible for some k. Conditions characterizing the class of k-reversible\nlanguages, for each fixed k, and the class of weakly irreversible languages are\nobtained. From these conditions, a procedure that given a finite automaton\ndecides if the accepted language is weakly or strongly (i.e., not weakly)\nirreversible is described. Furthermore, a construction which allows to\ntransform any finite automaton which is not k-reversible, but which accepts a\nk-reversible language, into an equivalent k-reversible finite automaton, is\npresented.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06465v1"
    },
    {
        "title": "Descriptional Complexity of Non-Unary Self-Verifying Symmetric\n  Difference Automata",
        "authors": [
            "Laurette Marais",
            "Lynette van Zijl"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Previously, self-verifying symmetric difference automata were defined and a\ntight bound of 2^n-1-1 was shown for state complexity in the unary case. We now\nconsider the non-unary case and show that, for every n at least 2, there is a\nregular language L_n accepted by a non-unary self-verifying symmetric\ndifference nondeterministic automaton with n states, such that its equivalent\nminimal deterministic finite automaton has 2^n-1 states. Also, given any\nSV-XNFA with n states, it is possible, up to isomorphism, to find at most\nanother |GL(n,Z_2)|-1 equivalent SV-XNFA.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06466v1"
    },
    {
        "title": "CD Grammar Systems with Two Propagating Scattered Context Components\n  Characterize the Family of Context Sensitive Languages",
        "authors": [
            "Alexander Meduna",
            "Jakub Martiško"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The L(PSCG)=L(CS) problem asks whether propagating scattered context grammars\nand context sensitive grammars are equivalent. The presented paper reformulates\nand answers this problem in terms of CD grammar systems. More specifically, it\ncharacterizes the family of context sensitive languages by two-component CD\ngrammar systems with propagating scattered context rules.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06467v1"
    },
    {
        "title": "A New Sensing 5'-->3' Watson-Crick Automata Concept",
        "authors": [
            "Benedek Nagy",
            "Shaghayegh Parchami",
            "Hamid Mir-Mohammad-Sadeghi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Watson-Crick (WK) finite automata are working on a Watson-Crick tape, that\nis, on a DNA molecule. Therefore, it has two reading heads. While in\ntraditional WK automata both heads read the whole input in the same physical\ndirection, in 5'->3' WK automata the heads start from the two extremes and read\nthe input in opposite direction. In sensing 5'->3' WK automata the process on\nthe input is finished when the heads meet. Since the heads of a WK automaton\nmay read longer strings in a transition, in previous models a so-called sensing\nparameter took care for the proper meeting of the heads (not allowing to read\nthe same positions of the input in the last step). In this paper, a new model\nis investigated, which works without the sensing parameter (it is done by an\nappropriate change of the concept of configuration). Consequently, the accepted\nlanguage classes of the variants are also changed. Various hierarchy results\nare proven in the paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06469v1"
    },
    {
        "title": "On h-Lexicalized Restarting Automata",
        "authors": [
            "Martin Plátek",
            "Friedrich Otto"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Following some previous studies on restarting automata, we introduce a\nrefined model - the h-lexicalized restarting automaton (h-RLWW). We argue that\nthis model is useful for expressing lexicalized syntax in computational\nlinguistics. We compare the input languages, which are the languages\ntraditionally considered in automata theory, to the so-called basic and\nh-proper languages, which are (implicitly) used by categorial grammars, the\noriginal tool for the description of lexicalized syntax. The basic and h-proper\nlanguages allow us to stress several nice properties of h-lexicalized\nrestarting automata, and they are suitable for modeling the analysis by\nreduction and, subsequently, for the development of categories of a lexicalized\nsyntax. Based on the fact that a two-way deterministic monotone restarting\nautomaton can be transformed into an equivalent deterministic monotone\nRL-automaton in (Marcus) contextual form, we obtain a transformation from\nmonotone RLWW-automata that recognize the class CFL of context-free languages\nas their input languages to deterministic monotone h-RLWW-automata that\nrecognize CFL through their h-proper languages. Through this transformation we\nobtain automata with the complete correctness preserving property and an\ninfinite hierarchy within CFL, based on the size of the read/write window.\nAdditionally, we consider h-RLWW-automata that are allowed to perform multiple\nrewrite steps per cycle, and we establish another infinite hierarchy above CFL\nthat is based on the number of rewrite steps that may be executed within a\ncycle. The corresponding separation results and their proofs illustrate the\ntransparency of h-RLWW-automata that work with the (complete or cyclic)\ncorrectness preserving property\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06470v1"
    },
    {
        "title": "Büchi VASS recognise w-languages that are Sigma^1_1 - complete",
        "authors": [
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This short note exhibits an example of a Sigma^1_1-complete language that can\nbe recognised by a one blind counter B\\\"uchi automaton (or equivalently a\nB\\\"uchi VASS with only one place).\n",
        "pdf_link": "http://arxiv.org/pdf/1708.09658v2"
    },
    {
        "title": "LTL to Deterministic Emerson-Lei Automata",
        "authors": [
            "David Müller",
            "Salomon Sickert"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce a new translation from linear temporal logic (LTL) to\ndeterministic Emerson-Lei automata, which are omega-automata with a Muller\nacceptance condition symbolically expressed as a Boolean formula. The richer\nacceptance condition structure allows the shift of complexity from the state\nspace to the acceptance condition. Conceptually the construction is an enhanced\nproduct construction that exploits knowledge of its components to reduce the\nnumber of states. We identify two fragments of LTL, for which one can easily\nconstruct deterministic automata and show how knowledge of these components can\nreduce the number of states. We extend this idea to a general LTL framework,\nwhere we can use arbitrary LTL to deterministic automata translators for parts\nof formulas outside the mentioned fragments. Further, we show succinctness of\nthe translation compared to existing construction. The construction is\nimplemented in the tool Delag, which we evaluate on several benchmarks of LTL\nformulas and probabilistic model checking case studies.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.02102v1"
    },
    {
        "title": "Trading Bounds for Memory in Games with Counters",
        "authors": [
            "Nathanaël Fijalkow",
            "Florian Horn",
            "Denis Kuperberg",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study two-player games with counters, where the objective of the first\nplayer is that the counter values remain bounded. We investigate the existence\nof a trade-off between the size of the memory and the bound achieved on the\ncounters, which has been conjectured by Colcombet and Loeding.\n  We show that unfortunately this conjecture does not hold: there is no\ntrade-off between bounds and memory, even for finite arenas. On the positive\nside, we prove the existence of a trade-off for the special case of thin tree\narenas. This allows to extend the theory of regular cost functions over thin\ntrees, and obtain as a corollary the decidability of cost monadic second-order\nlogic over thin trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.03121v1"
    },
    {
        "title": "Two Recursively Inseparable Problems for Probabilistic Automata",
        "authors": [
            "Nathanaël Fijalkow",
            "Hugo Gimbert",
            "Florian Horn",
            "Youssouf Oualhadj"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This paper introduces and investigates decision problems for numberless\nprobabilistic automata, i.e. probabilistic automata where the support of each\nprobabilistic transitions is specified, but the exact values of the\nprobabilities are not. A numberless probabilistic automaton can be instantiated\ninto a probabilistic automaton by specifying the exact values of the non-zero\nprobabilistic transitions.\n  We show that the two following properties of numberless probabilistic\nautomata are recursively inseparable: - all instances of the numberless\nautomaton have value 1, - no instance of the numberless automaton has value 1.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.03122v1"
    },
    {
        "title": "Computing Maximal Expected Termination Time of Probabilistic Timed\n  Automata",
        "authors": [
            "Omar Al-Bataineh",
            "Michael Fisher",
            "David Rosenblum"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The paper addresses the problem of computing maximal expected time to\ntermination of probabilistic timed automata (PTA) models, under the condition\nthat the system will, eventually, terminate. This problem can exhibit high\ncomputational complexity, in particular when the automaton under analysis\ncontains cycles that may be repeated very often (due to very high\nprobabilities, e.g. p =0.999). Such cycles can degrade the performance of\ntypical model checking algorithms, as the likelihood of repeating the cycle\nconverges to zero arbitrarily slowly. We introduce an acceleration technique\nthat can be applied to improve the execution of such cycles by collapsing their\niterations. The acceleration process of a cyclic PTA consists of several formal\nsteps necessary to handle the cumulative timing and probability information\nthat result from successive executions of a cycle. The advantages of\nacceleration are twofold. First, it helps to reduce the computational\ncomplexity of the problem without adversely affecting the outcome of the\nanalysis. Second, it can bring the \"worst case execution time\" problem of PTAs\nwithin the bounds of feasibility for model checking techniques. To our\nknowledge, this is the first work that addresses the problem of accelerating\nexecution of cycles that exhibit both timing and probabilistic behavior.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.07171v8"
    },
    {
        "title": "Directable Fuzzy and Nondeterministic Automata",
        "authors": [
            "Magnus Steinby"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study three notions of directability of fuzzy automata akin to the D1-,\nD2- and D3-directability of nondeterministic automata. Thus an input word $w$\nof a fuzzy automaton is D1-directing if a fixed single state is reachable by\n$w$ from all states, D2-directing if exactly the same states are reachable by\n$w$ from every state, and D3-directing if there is a state reachable by $w$\nfrom every state. We study the various sets of directing words of fuzzy\nautomata, prove that the directability properties are decidable, and show how\nsuch results can be deduced from the theory of directable nondeterministic\nautomata. Moreover, we establish the closure properties of the different\nclasses of directable fuzzy automata under the class operations of forming\nsubautomata, homomorphic images and finite direct products.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.07719v1"
    },
    {
        "title": "Adding successor: A transfer theorem for separation and covering",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Given a class C of word languages, the C-separation problem asks for an\nalgorithm that, given as input two regular languages, decides whether there\nexists a third language in C containing the first language, while being\ndisjoint from the second. Separation is usually investigated as a means to\nobtain a deep understanding of the class C.\n  In the paper, we are mainly interested in classes defined by logical\nformalisms. Such classes are often built on top of each other: given some\nlogic, one builds a stronger one by adding new predicates to its signature. A\nnatural construction is to enrich a logic with the successor relation. In this\npaper, we present a transfer result applying to this construction: we show that\nfor suitable logically defined classes, separation for the logic enriched with\nthe successor relation reduces to separation for the original logic. Our\ntheorem also applies to a problem that is stronger than separation: covering.\nMoreover, we actually present two reductions: one for languages of finite words\nand the other for languages of infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.10052v1"
    },
    {
        "title": "Language properties and Grammar of Parallel and Series Parallel\n  Languages",
        "authors": [
            "N. Mohana",
            "Kalyani Desikan",
            "V. Rajkumar Dare"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we have defined the language theoretical properties of Parallel\nlanguages and series parallel languages. Parallel languages and Series parallel\nlanguages play vital roles in parallel processing and many applications in\ncomputer programming. We have defined regular expressions and context free\ngrammar for parallel and series parallel languages based on sequential\nlanguages [2]. We have also discussed the recognizability of parallel and\nseries parallel languages using regular expression and regular grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.01799v1"
    },
    {
        "title": "Automata Minimization: a Functorial Approach",
        "authors": [
            "Thomas Colcombet",
            "Daniela Petrişan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we regard languages and their acceptors -- such as\ndeterministic or weighted automata, transducers, or monoids -- as functors from\ninput categories that specify the type of the languages and of the machines to\ncategories that specify the type of outputs.\n  Our results are as follows: a) We provide sufficient conditions on the output\ncategory so that minimization of the corresponding automata is guaranteed. b)\nWe show how to lift adjunctions between the categories for output values to\nadjunctions between categories of automata. c) We show how this framework can\nbe applied to several phenomena in automata theory, starting with\ndeterminization and minimization (previously studied from a coalgebraic and\nduality theoretic perspective). We apply in particular these techniques to\nChoffrut's minimization algorithm for subsequential transducers and revisit\nBrzozowski's minimization algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.03063v1"
    },
    {
        "title": "Singular value automata and approximate minimization",
        "authors": [
            "Borja Balle",
            "Prakash Panangaden",
            "Doina Precup"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The present paper uses spectral theory of linear operators to construct\napproximately minimal realizations of weighted languages. Our new contributions\nare: (i) a new algorithm for the SVD decomposition of infinite Hankel matrices\nbased on their representation in terms of weighted automata, (ii) a new\ncanonical form for weighted automata arising from the SVD of its corresponding\nHankel matrix and (iii) an algorithm to construct approximate minimizations of\ngiven weighted automata by truncating the canonical form. We give bounds on the\nquality of our approximation.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.05994v2"
    },
    {
        "title": "Automata in the Category of Glued Vector Spaces",
        "authors": [
            "Thomas Colcombet",
            "Daniela Petrişan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we adopt a category-theoretic approach to the conception of\nautomata classes enjoying minimization by design. The main instantiation of our\nconstruction is a new class of automata that are hybrid between deterministic\nautomata and automata weighted over a field.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.06065v1"
    },
    {
        "title": "Event-Clock Nested Automata",
        "authors": [
            "Laura Bozzelli",
            "Aniello Murano",
            "Adriano Peron"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we introduce and study Event-Clock Nested Automata (ECNA), a\nformalism that combines Event Clock Automata (ECA) and Visibly Pushdown\nAutomata (VPA). ECNA allow to express real-time properties over non-regular\npatterns of recursive programs. We prove that ECNA retain the same closure and\ndecidability properties of ECA and VPA being closed under Boolean operations\nand having a decidable language-inclusion problem. In particular, we prove that\nemptiness, universality, and language-inclusion for ECNA are EXPTIME-complete\nproblems. As for the expressiveness, we have that ECNA properly extend any\nprevious attempt in the literature of combining ECA and VPA.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.08314v1"
    },
    {
        "title": "The Intersection Problem for Finite Monoids",
        "authors": [
            "Lukas Fleischer",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the intersection problem for finite monoids, which asks for a\ngiven set of regular languages, represented by recognizing morphisms to finite\nmonoids from a variety V, whether there exists a word contained in their\nintersection. Our main result is that the problem is PSPACE-complete if V is\ncontained in DS and NP-complete if V is non-trivial and contained in DO. Our\nNP-algorithm for the case that V is contained in DO uses novel methods, based\non compression techniques and combinatorial properties of DO. We also show that\nthe problem is log-space reducible to the intersection problem for\ndeterministic finite automata (DFA) and that a variant of the problem is\nlog-space reducible to the membership problem for transformation monoids. In\nlight of these reductions, our hardness results can be seen as a generalization\nof both a classical result by Kozen and a theorem by Beaudry, McKenzie and\nTherien.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.08717v2"
    },
    {
        "title": "Random Words in a (Weighted) Regular Language: a Free Energy Approach",
        "authors": [
            "Cewei Cui",
            "Zhe Dang"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study random words in a weighted regular language that achieve the maximal\nfree energy using thermodynamics formalism. In particular, typical words in the\nlanguage are algorithmically generated which have applications in computer\nsecurity (anomaly detection) and software enegineering (test case generation).\n",
        "pdf_link": "http://arxiv.org/pdf/1711.08963v1"
    },
    {
        "title": "Most Complex Deterministic Union-Free Regular Languages",
        "authors": [
            "Janusz A. Brzozowski",
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A regular language $L$ is union-free if it can be represented by a regular\nexpression without the union operation. A union-free language is deterministic\nif it can be accepted by a deterministic one-cycle-free-path finite automaton;\nthis is an automaton which has one final state and exactly one cycle-free path\nfrom any state to the final state. Jir\\'askov\\'a and Masopust proved that the\nstate complexities of the basic operations reversal, star, product, and boolean\noperations in deterministic union-free languages are exactly the same as those\nin the class of all regular languages. To prove that the bounds are met they\nused five types of automata, involving eight types of transformations of the\nset of states of the automata. We show that for each $n\\ge 3$ there exists one\nternary witness of state complexity $n$ that meets the bound for reversal and\nproduct. Moreover, the restrictions of this witness to binary alphabets meet\nthe bounds for star and boolean operations. We also show that the tight upper\nbounds on the state complexity of binary operations that take arguments over\ndifferent alphabets are the same as those for arbitrary regular languages.\nFurthermore, we prove that the maximal syntactic semigroup of a union-free\nlanguage has $n^n$ elements, as in the case of regular languages, and that the\nmaximal state complexities of atoms of union-free languages are the same as\nthose for regular languages. Finally, we prove that there exists a most complex\nunion-free language that meets the bounds for all these complexity measures.\nAltogether this proves that the complexity measures above cannot distinguish\nunion-free languages from regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.09149v2"
    },
    {
        "title": "Timed Comparisons of Semi-Markov Processes",
        "authors": [
            "Mathias Ruggaard Pedersen",
            "Nathanaël Fijalkow",
            "Giorgio Bacci",
            "Kim Guldstrand Larsen",
            "Radu Mardare"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Semi-Markov processes are Markovian processes in which the firing time of the\ntransitions is modelled by probabilistic distributions over positive reals\ninterpreted as the probability of firing a transition at a certain moment in\ntime. In this paper we consider the trace-based semantics of semi-Markov\nprocesses, and investigate the question of how to compare two semi-Markov\nprocesses with respect to their time-dependent behaviour. To this end, we\nintroduce the relation of being \"faster than\" between processes and study its\nalgorithmic complexity. Through a connection to probabilistic automata we\nobtain hardness results showing in particular that this relation is\nundecidable. However, we present an additive approximation algorithm for a\ntime-bounded variant of the faster-than problem over semi-Markov processes with\nslow residence-time functions, and a coNP algorithm for the exact faster-than\nproblem over unambiguous semi-Markov processes.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.10216v3"
    },
    {
        "title": "A Taxonomy of Morphic Sequences",
        "authors": [
            "Jean-Paul Allouche",
            "Julien Cassaigne",
            "Jeffrey Shallit",
            "Luca Q. Zamboni"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this note we classify sequences according to whether they are morphic,\npure morphic, uniform morphic, pure uniform morphic, primitive morphic, or pure\nprimitive morphic, and for each possibility we either give an example or prove\nthat no example is possible.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.10807v1"
    },
    {
        "title": "Lower Bounds on Regular Expression Size",
        "authors": [
            "Hamoon Mousavi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce linear programs encoding regular expressions of finite\nlanguages. We show that, given a language, the optimum value of the associated\nlinear program is a lower bound on the size of any regular expression of the\nlanguage. Moreover we show that any regular expression can be turned into a\ndual feasible solution with an objective value that is equal to the size of the\nregular expression. For binomial languages we can relax the associated linear\nprogram using duality theorem. We use this relaxation to prove lower bounds on\nthe size of regular expressions of binomial and threshold languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.00811v2"
    },
    {
        "title": "On co-counter-fragments of automata",
        "authors": [
            "Oleksiy Kurganskyy",
            "Alexandra Maximova"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This paper contains results related to synthesis and presentation of abstract\nautomata by fragments of behaviour and investigates the structure of the\nclasses of finite connected initial output-less automata specified by systems\nof defining relations considered as fragments, co-fragments, counter-fragments\nand co-counter-fragments of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.05227v1"
    },
    {
        "title": "On Varieties of Ordered Automata",
        "authors": [
            "Ondřej Klíma",
            "Libor Polák"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The Eilenberg correspondence relates varieties of regular languages to\npseudovarieties of finite monoids. Various modifications of this correspondence\nhave been found with more general classes of regular languages on one hand and\nclasses of more complex algebraic structures on the other hand. It is also\npossible to consider classes of automata instead of algebraic structures as a\nnatural counterpart of classes of languages. Here we deal with the\ncorrespondence relating positive $\\mathcal C$-varieties of languages to\npositive $\\mathcal C$-varieties of ordered automata and we present various\nspecific instances of this correspondence. These bring certain well-known\nresults from a new perspective and also some new observations. Moreover,\ncomplexity aspects of the membership problem are discussed both in the\nparticular examples and in a general setting.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.08455v2"
    },
    {
        "title": "Label Languages of 8-directional Array P System",
        "authors": [
            "William Suresh Kumar",
            "Kalpana Mahalingam",
            "Raghavan Rama"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  An 8-directional array P system is one where the rewriting of an array can\nhappen in any 8-directions. The array rules of such a system are labelled thus\nresulting in a labelled 8-directional array P system. The labelling is not\nunique and the label language is obtained by recording the strings over the\nlabels used in any terminating derivation of the P system. The system is shown\nto generate interesting pictures. The label language is compared with Chomsky\nhierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.09791v1"
    },
    {
        "title": "A Class of Automatic Sequences",
        "authors": [
            "Michel Rigo",
            "Robert Underwood"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Let $k\\ge 2$. We prove that the characteristic sequence of a regular language\nover a $k$-letter alphabet is $k$-automatic. More generally, if $t\\ge 2$ and\n$t,k$ are multiplicatively dependent, we show that the characteristic sequence\nof a regular language over a $t$-letter alphabet is $k$-automatic.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.10259v2"
    },
    {
        "title": "Codes induced by alternative codes",
        "authors": [
            "Ngo Thi Hien",
            "Do Long Van"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Alternative codes, an extension of the notion of ordinary codes, have been\nfirst introduced and considered by P. T. Huy et al. in 2004. As seen below,\nevery alternative code, in its turn, defines an ordinary code. Such codes are\ncalled codes induced by alternative codes or alt-induced codes, for short. In\nthis paper we consider these alt-induced codes and subclasses of them. In\nparticular, characteristic properties of such codes are established, and an\nalgorithm to check whether a finite code is alt-induced or not is proposed.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.02598v1"
    },
    {
        "title": "On strong alt-induced codes",
        "authors": [
            "Ngo Thi Hien"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Strong alt-induced codes, a particular case of alt-induced codes, has been\nintroduced and considered by D. L. Van and the author in earlier papers. In\nthis note, an algorithm to check whether a regular code is strong alt-induced\nor not is proposed, and the embedding problem for the classes of prefix\n(suffix, bifix) strong alt-induced codes in both the finite and regular case is\nalso exhibited.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.02603v1"
    },
    {
        "title": "Comparing the power of advice strings: a notion of complexity for\n  infinite words",
        "authors": [
            "Gaëtan Douéneau-Tabot"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper is the extended version of On the Complexity of Infinite Advice\nStrings (ICALP 2018). We investigate a notion of comparison between infinite\nstrings. In a general way, if M is a computation model (e.g. Turing machines)\nand C a class of objects (e.g. languages), the complexity of an infinite word\nalpha can be measured with respect to the amount of objects from C that are\npresentable with machines from M using alpha as an oracle. In our case, the\nmodel M is finite automata and the objects C are either recognized languages or\npresentable structures, known respectively as advice regular languages and\nadvice automatic structures. This leads to several different classifications of\ninfinite words that are studied in detail; we also derive logical and\ncomputational equivalent measures. Our main results explore the connections\nbetween classes of advice automatic structures, MSO-transductions and two-way\ntransducers. They suggest a closer study of the resulting hierarchy over\ninfinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.04908v4"
    },
    {
        "title": "Using Sat solvers for synchronization issues in non-deterministic\n  automata",
        "authors": [
            "Hanan Shabana",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We approach the problem of computing a $D_{3}$-synchronizing word of minimum\nlength for a given nondeterministic automaton via its encoding as an instance\nof SAT and invoking a SAT solver. We also present some experimental results.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.05391v1"
    },
    {
        "title": "A more reasonable proof of Cobham's theorem",
        "authors": [
            "Thijmen J. P. Krebs"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We present a short new proof of Cobham's theorem without using Kronecker's\napproximation theorem, making it suitable for generalization beyond automatic\nsequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.06704v1"
    },
    {
        "title": "Sequential Circuits from Regular Expressions Revisited",
        "authors": [
            "Dogan Ulus"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We revisit the long-neglected problem of sequential circuit constructions\nfrom regular expressions. The class of languages that are recognized by\nsequential circuits is equivalent to the class of regular languages. This fact\nis shown in [5] together with an inductive construction technique from regular\nexpressions. In this note, we present an alternative algorithm, called the\ntrigger-set approach, obtained by reversing well-known the follow-set approach\nto construct automata. We use our algorithm to obtain a regular expression\nmatcher based on sequential circuits. Finally, we report our performance\nresults in comparison with existing automata-based matchers.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.08979v1"
    },
    {
        "title": "Some Issues on the Theory of the Mimic-Computing-Oriented Automata",
        "authors": [
            "Weijun Zhu"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A mimic computing oriented automaton can directly portray the behaviors of a\nmimic computing system. In this paper, we investigate the following theoretical\nproblems on this type of automata: operational semantics and computational\nability. First, we model a systematic structure of mimic computing via a mimic\nautomaton. Second, we propose the operational semantics of the automaton in\nthis scene. Third, the computational ability of this type of automata is\nstudied.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.09034v1"
    },
    {
        "title": "Lower Bounds for Synchronizing Word Lengths in Partial Automata",
        "authors": [
            "Michiel de Bondt",
            "Henk Don",
            "Hans Zantema"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  It was conjectured by \\v{C}ern\\'y in 1964, that a synchronizing DFA on $n$\nstates always has a synchronizing word of length at most $(n-1)^2$, and he gave\na sequence of DFAs for which this bound is reached. Until now a full analysis\nof all DFAs reaching this bound was only given for $n \\leq 5$, and with bounds\non the number of symbols for $n \\leq 12$. Here we give the full analysis for $n\n\\leq 7$, without bounds on the number of symbols.\n  For PFAs (partial automata) on $\\leq 7$ states we do a similar analysis as\nfor DFAs and find the maximal shortest synchronizing word lengths, exceeding\n$(n-1)^2$ for $n \\geq 4$. Where DFAs with long synchronization typically have\nvery few symbols, for PFAs we observe that more symbols may increase the\nsynchronizing word length. For PFAs on $\\leq 10$ states and two symbols we\ninvestigate all occurring synchronizing word lengths.\n  We give series of PFAs on two and three symbols, reaching the maximal\npossible length for some small values of $n$. For $n=6,7,8,9$, the construction\non two symbols is the unique one reaching the maximal length. For both series\nthe growth is faster than $(n-1)^2$, although still quadratic.\n  Based on string rewriting, for arbitrary size we construct a PFA on three\nsymbols with exponential shortest synchronizing word length, giving\nsignificantly better bounds than earlier exponential constructions. We give a\ntransformation of this PFA to a PFA on two symbols keeping exponential shortest\nsynchronizing word length, yielding a better bound than applying a similar\nknown transformation. Both PFAs are transitive.\n  Finally, we show that exponential lengths are even possible with just one\nsingle undefined transition, again with transitive constructions.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.10436v3"
    },
    {
        "title": "Regular Transducer Expressions for Regular Transformations",
        "authors": [
            "Vrunda Dave",
            "Paul Gastin",
            "Krishna Shankara Narayanan"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Functional MSO transductions, deterministic two-way transducers, as well as\nstreaming string transducers are all equivalent models for regular functions.\nIn this paper, we show that every regular function, either on finite words or\non infinite words, captured by a deterministic two-way transducer, can be\ndescribed with a regular transducer expression (RTE). For infinite words, the\ntransducer uses Muller acceptance and $\\omega$-regular look-ahead. \\RTEs are\nconstructed from constant functions using the combinators if-then-else\n(deterministic choice), Hadamard product, and unambiguous versions of the\nCauchy product, the 2-chained Kleene-iteration and the 2-chained\nomega-iteration. Our proof works for transformations of both finite and\ninfinite words, extending the result on finite words of Alur et al.\\ in\nLICS'14. In order to construct an RTE associated with a deterministic two-way\nMuller transducer with look-ahead, we introduce the notion of transition monoid\nfor such two-way transducers where the look-ahead is captured by some backward\ndeterministic B\\\"uchi automaton. Then, we use an unambiguous version of Imre\nSimon's famous forest factorization theorem in order to derive a \"good\"\n($\\omega$-)regular expression for the domain of the two-way transducer. \"Good\"\nexpressions are unambiguous and Kleene-plus as well as $\\omega$-iterations are\nonly used on subexpressions corresponding to \\emph{idempotent} elements of the\ntransition monoid. The combinator expressions are finally constructed by\nstructural induction on the \"good\" ($\\omega$-)regular expression describing the\ndomain of the transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.02094v1"
    },
    {
        "title": "A generic characterization of Pol(C)",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the polynomial closure operation (C -> Pol(C)) defined on\nclasses of regular languages. We present an interesting and useful connection\nrelating the separation problem for the class C and the membership problem for\nit polynomial closure Pol(C). This connection is formulated as an algebraic\ncharacterization of Pol(C) which holds when C is an arbitrary \\pvari of regular\nlanguages and whose statement is parameterized by C-separation. Its main\napplication is an effective reduction from Pol(C)-membership to C-separation.\nThus, as soon as one designs a C-separation algorithm, this yields \"for free\" a\nmembership algorithm for the more complex class Pol(C).\n",
        "pdf_link": "http://arxiv.org/pdf/1802.06141v1"
    },
    {
        "title": "Randomness of formal languages via automatic martingales",
        "authors": [
            "Birzhan Moldagaliyev"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We define a notion of randomness for individual and collections of formal\nlanguages based on automatic martingales acting on sequences of words from some\nunderlying domain. An automatic martingale bets if the incoming word belongs to\nthe target language or not. Then randomness of both single languages and\ncollections of languages is defined as a failure of automatic martingale to\ngain an unbounded capital by betting on the target language according to an\nincoming sequence of words, or a text. The randomness of formal languages\nturned out to be heavily dependent on the text. For very general classes of\ntexts, any nonregular language happens to be random when considered\nindividually. As for collections of languages, very general classes of texts\npermits nonrandomness of automatic families of languages only. On the other\nhand, an arbitrary computable language is be shown to be nonrandom under\ncertain dynamic texts.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.06207v1"
    },
    {
        "title": "Automatic supermartingales acting on sequences",
        "authors": [
            "Birzhan Moldagaliyev"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper describes a construction of supermartingales realized as automatic\nfunctions. A capital of supermartingales is represented using automatic capital\ngroups~(ACG). Properties of these automatic supermartingales are then studied.\nAutomatic supermartingales induce a notion of random infinite binary sequence.\nWe show that the class of random sequences coincide with that of disjunctive\nsequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.06529v1"
    },
    {
        "title": "Unboundedness problems for languages of vector addition systems",
        "authors": [
            "Wojciech Czerwiński",
            "Piotr Hofman",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A vector addition system (VAS) with an initial and a final marking and\ntransition labels induces a language. In part because the reachability problem\nin VAS remains far from being well-understood, it is difficult to devise\ndecision procedures for such languages. This is especially true for checking\nproperties that state the existence of infinitely many words of a particular\nshape. Informally, we call these \\emph{unboundedness properties}. We present a\nsimple set of axioms for predicates that can express unboundedness properties.\nOur main result is that such a predicate is decidable for VAS languages as soon\nas it is decidable for regular languages. Among other results, this allows us\nto show decidability of (i)~separability by bounded regular languages,\n(ii)~unboundedness of occurring factors from a language $K$ with mild\nconditions on $K$, and (iii)~universality of the set of factors.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.06683v1"
    },
    {
        "title": "PTL-separability and closures for WQOs on words",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a flexible class of well-quasi-orderings (WQOs) on words that\ngeneralizes the ordering of (not necessarily contiguous) subwords. Each such\nWQO induces a class of piecewise testable languages (PTLs) as Boolean\ncombinations of upward closed sets. In this way, a range of regular language\nclasses arises as PTLs. Moreover, each of the WQOs guarantees regularity of all\ndownward closed sets. We consider two problems. First, we study which (perhaps\nnon-regular) language classes permit a decision procedure to decide whether two\ngiven languages are separable by a PTL with respect to a given WQO. Second, we\nwant to effectively compute downward closures with respect to these WQOs. Our\nfirst main result that for each of the WQOs, under mild assumptions, both\nproblems reduce to the simultaneous unboundedness problem (SUP) and are thus\nsolvable for many powerful system classes. In the second main result, we apply\nthe framework to show decidability of separability of regular languages by\n$\\mathcal{B}\\Sigma_1[<, \\mathsf{mod}]$, a fragment of first-order logic with\nmodular predicates.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.07397v1"
    },
    {
        "title": "Improved Upper Bounds on all Maximal $α$-gapped Repeats and\n  Palindromes",
        "authors": [
            "Tomohiro I",
            "Dominik Köppl"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We show that the number of all maximal $\\alpha$-gapped repeats and\npalindromes of a word of length $n$ is at most $3(\\pi^2/6 + 5/2) \\alpha n$ and\n$7 (\\pi^2 / 6 + 1/2) \\alpha n - 5 n - 1$, respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.10355v1"
    },
    {
        "title": "Derivation languages, descriptional complexity measures and decision\n  problems of a class of flat splicing systems",
        "authors": [
            "Prithwineel Paul",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we associate the idea of derivation languages with flat\nsplicing systems and compare the families of derivation languages (Szilard and\ncontrol languages) of these systems with the family of languages in Chomsky\nhierarchy. We show that the family of Szilard languages of labeled flat finite\nsplicing systems of type $( m, n)$ (i.e., $SZLS_{n, FIN}^{m}$ ) and $REG$, $CF$\nand $CS$ are incomparable. Also, it is decidable whether or not $SZ_{n,\nFIN}^{m}(\\mathscr{LS}) \\subseteq R$ and $R \\subseteq SZ_{n,\nFIN}^{m}(\\mathscr{LS})$ for any regular language $R$ and labeled flat finite\nsplicing system $\\mathscr{LS}$. Also, any non-empty regular, non-empty\ncontext-free and recursively enumerable language can be obtained as homomorphic\nimage of Szilard language of the labeled flat finite splicing systems of type\n$(1, 2), (2, 2)$ and $(4, 2)$ respectively. We also introduce the idea of\ncontrol languages for labeled flat finite splicing systems and show that any\nnon-empty regular and context-free language can be obtained as a control\nlanguage of labeled flat finite splicing systems of type $(1,2)$ and $(2, 2)$\nrespectively. At the end, we show that any recursively enumerable language can\nbe obtained as a control language of labeled flat finite splicing systems of\ntype $(4,2)$ when $\\lambda$-labeled rules are allowed.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.02312v2"
    },
    {
        "title": "Weak Cost Register Automata are Still Powerful",
        "authors": [
            "Shaull Almagor",
            "Michaël Cadilhac",
            "Filip Mazowiecki",
            "Guillermo A. Pérez"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider one of the weakest variants of cost register automata over a\ntropical semiring, namely copyless cost register automata over $\\mathbb{N}$\nwith updates using $\\min$ and increments. We show that this model can simulate,\nin some sense, the runs of counter machines with zero-tests. We deduce that a\nnumber of problems pertaining to that model are undecidable, in particular\nequivalence, disproving a conjecture of Alur et al. from 2012. To emphasize how\nweak these machines are, we also show that they can be expressed as a\nrestricted form of linearly-ambiguous weighted automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.06336v1"
    },
    {
        "title": "A non-regular language of infinite trees that is recognizable by a\n  sort-wise finite algebra",
        "authors": [
            "Mikołaj Bojańczyk",
            "Bartek Klin"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  $\\omega$-clones are multi-sorted structures that naturally emerge as algebras\nfor infinite trees, just as $\\omega$-semigroups are convenient algebras for\ninfinite words. In the algebraic theory of languages, one hopes that a language\nis regular if and only if it is recognized by an algebra that is finite in some\nsimple sense. We show that, for infinite trees, the situation is not so simple:\nthere exists an $\\omega$-clone that is finite on every sort and finitely\ngenerated, but recognizes a non-regular language.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.06667v4"
    },
    {
        "title": "A Heuristic for Reachability Problem in Asynchronous Binary Automata\n  Networks",
        "authors": [
            "Xinwei Chai",
            "Morgan Magnin",
            "Olivier Roux"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  On demand of efficient reachability analysis due to the inevitable complexity\nof large-scale biological models, this paper is dedicated to a novel approach:\nPermReach, for reachability problem of our new framework, Asynchronous Binary\nAutomata Networks (ABAN). ABAN is an expressive modeling framework which\ncontains all the dynamics behaviors performed by Asynchronous Boolean Networks.\nCompared to Boolean Networks (BN), ABAN has a finer description of state\ntransitions (from a local state to another, instead of symmetric Boolean\nfunctions). To analyze the reachability properties on large-scale models (like\nthe ones from systems biology), previous works exhibited an efficient\nabstraction technique called Local Causality Graph (LCG). However, this\ntechnique may be not conclusive. Our contribution here is to extend these\nresults by tackling those complex intractable cases via a heuristic technique.\nTo validate our method, tests were conducted in large biological networks,\nshowing that our method is more conclusive than existing ones.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.07543v1"
    },
    {
        "title": "When is Containment Decidable for Probabilistic Automata?",
        "authors": [
            "Laure Daviaud",
            "Marcin Jurdziński",
            "Ranko Lazić",
            "Filip Mazowiecki",
            "Guillermo A. Pérez",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The emptiness and containment problems for probabilistic automata are natural\nquantitative generalisations of the classical language emptiness and inclusion\nproblems for Boolean automata. It is well known that both problems are\nundecidable. In this paper we provide a more refined view of these problems in\nterms of the degree of ambiguity of probabilistic automata. We show that a gap\nversion of the emptiness problem (that is known be undecidable in general)\nbecomes decidable for automata of polynomial ambiguity. We complement this\npositive result by showing that the emptiness problem remains undecidable even\nwhen restricted to automata of linear ambiguity. We then turn to finitely\nambiguous automata. Here we show decidability of containment in case one of the\nautomata is assumed to be unambiguous while the other one is allowed to be\nfinitely ambiguous. Our proof of this last result relies on the decidability of\nthe theory of real exponentiation, which has been shown, subject to Schanuel's\nConjecture, by Macintyre and Wilkie.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.09077v4"
    },
    {
        "title": "Note on the Lower Bounds of Bimachines",
        "authors": [
            "Stefan Gerdjikov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This is a brief note on the lower bound of bimachines. Particularly, we\nreport that there is a class of functional transducers with $O(n)$ states that\ndo not admit a bimachine with fewer than $\\Theta(2^n)$ states.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.10146v1"
    },
    {
        "title": "Streaming Rewriting Games: Winning Strategies and Complexity",
        "authors": [
            "Christian Coester",
            "Thomas Schwentick",
            "Martin Schuster"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Context-free games on strings are two-player rewriting games based on a set\nof production rules and a regular target language. In each round, the first\nplayer selects a position of the current string; then the second player\nreplaces the symbol at that position according to one of the production rules.\nThe first player wins as soon as the current string belongs to the target\nlanguage. In this paper the one-pass setting for context-free games is studied,\nwhere the knowledge of the first player is incomplete, she selects positions in\na left-to-right fashion and only sees the current symbol and the symbols from\nprevious rounds. The paper studies conditions under which dominant or\nundominated strategies for the first player exist and investigates the\ncomplexity of some related algorithmic problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.10292v1"
    },
    {
        "title": "Testing Simon's congruence",
        "authors": [
            "Lukas Fleischer",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Piecewise testable languages are a subclass of the regular languages. There\nare many equivalent ways of defining them; Simon's congruence $\\sim_k$ is one\nof the most classical approaches. Two words are $\\sim_k$-equivalent if they\nhave the same set of (scattered) subwords of length at most k. A language L is\npiecewise testable if there exists some k such that L is a union of\n$\\sim_k$-classes. For each equivalence class of $\\sim_k$, one can define a\ncanonical representative in shortlex normal form, that is, the minimal word\nwith respect to the lexicographic order among the shortest words in $\\sim_k$.\nWe present an algorithm for computing the canonical representative of the\n$\\sim_k$-class of a given word $w \\in A^*$ of length n. The running time of our\nalgorithm is in O(|A|n) even if $k \\le n$ is part of the input. This is\nsurprising since the number of possible subwords grows exponentially in k. The\ncase $k > n$ is not interesting since then, the equivalence class of w is a\nsingleton. If the alphabet is fixed, the running time of our algorithm is\nlinear in the size of the input word. Moreover, for fixed alphabet, we show\nthat the computation of shortlex normal forms for $\\sim_k$ is possible in\ndeterministic logarithmic space. One of the consequences of our algorithm is\nthat one can check with the same complexity whether two words are\n$\\sim_k$-equivalent (with k being part of the input).\n",
        "pdf_link": "http://arxiv.org/pdf/1804.10459v1"
    },
    {
        "title": "Site-Directed Insertion: Decision Problems, Maximality and Minimality",
        "authors": [
            "Da-Jung Cho",
            "Yo-Sub Han",
            "Kai Salomaa",
            "Taylor J. Smith"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Site-directed insertion is an overlapping insertion operation that can be\nviewed as analogous to the overlap assembly or chop operations that concatenate\nstrings by overlapping a suffix and a prefix of the argument strings. We\nconsider decision problems and language equations involving site-directed\ninsertion. By relying on the tools provided by semantic shuffle on trajectories\nwe show that one variable equations involving site-directed insertion and\nregular constants can be solved. We consider also maximal and minimal variants\nof the site-directed insertion operation.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.11017v1"
    },
    {
        "title": "Counting Subwords and Regular Languages",
        "authors": [
            "Charles J. Colbourn",
            "Ryan E. Dougherty",
            "Thomas F. Lidbetter",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Let $x$ and $y$ be words. We consider the languages whose words $z$ are those\nfor which the numbers of occurrences of $x$ and $y$, as subwords of $z$, are\nthe same (resp., the number of $x$'s is less than the number of $y$'s, resp.,\nis less than or equal). We give a necessary and sufficient condition on $x$ and\n$y$ for these languages to be regular, and we show how to check this condition\nefficiently.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.11175v2"
    },
    {
        "title": "Control strategies for off-line testing of timed systems",
        "authors": [
            "Léo Henry",
            "Thierry Jéron",
            "Nicolas Markey"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Partial observability and controllability are two well-known issues in\ntest-case synthesis for interactive systems. We address the problem of partial\ncontrol in the synthesis of test cases from timed-automata specifications.\nBuilding on the tioco timed testing framework, we extend a previous game\ninterpretation of the test-synthesis problem from the untimed to the timed\nsetting. This extension requires a deep reworking of the models, game\ninterpretation and test-synthesis algorithms. We exhibit strategies of a game\nthat tries to minimize both control losses and distance to the satisfaction of\na test purpose, and prove they are winning under some fairness assumptions.\nThis entails that when turning those strategies into test cases, we get\nproperties such as soundness and exhaustiveness of the test synthesis method.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.11234v2"
    },
    {
        "title": "Efficient Membership Testing for Pseudovarieties of Finite Semigroups",
        "authors": [
            "Lukas Fleischer"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider the complexity of deciding membership of a given finite semigroup\nto a fixed pseudovariety. While it is known that there exist pseudovarieties\nwith NP-complete or even undecidable membership problems, for many well-known\npseudovarieties the problem is known to be decidable in polynomial time. We\nshow that for many of these pseudovarieties, the membership problem is actually\nin AC^0. To this end, we show that these pseudovarieties can be characterized\nby first-order sentences with multiplication as the only predicate. We prove\nclosure properties of the class of pseudovarieties with such first-order\ndescriptions under various well-known operations; in particular, if V can be\ndescribed by a first-order sentence, then DV, LV, and the Mal'cev products of\nK, D, N, LI, and LG with V are first-order definable as well. Moreover, if H is\na first-order definable pseudovariety of finite groups, then the pseudovariety\nof all finite semigroups whose subgroups are in H is first-order definable. Our\nformalism is also powerful enough to capture all pseudovarieties characterized\nby finite sets of omega-identities. In view of lower bounds from circuit\ncomplexity, we obtain a new technique to prove that a pseudovariety V cannot be\ndefined by such a set: if membership in V is hard for PARITY, it cannot be\ndefined in this logic and thus cannot be described by finitely many\nomega-identities. We show that membership to EA is L-complete, thereby\nimproving previous complexity results and obtaining a new proof that the\npseudovariety cannot be described by finitely many omega-identities at the same\ntime.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.00650v2"
    },
    {
        "title": "Regular Expressions and Transducers over Alphabet-invariant and\n  User-defined Labels",
        "authors": [
            "Stavros Konstantinidis",
            "Nelma Moreira",
            "Rogerio Reis",
            "Joshua Young"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We are interested in regular expressions and transducers that represent word\nrelations in an alphabet-invariant way---for example, the set of all word pairs\nu,v where v is a prefix of u independently of what the alphabet is. Current\nsoftware systems of formal language objects do not have a mechanism to define\nsuch objects. We define transducers in which transition labels involve what we\ncall set specifications, some of which are alphabet invariant. In fact, we give\na more broad definition of automata-type objects, called labelled graphs, where\neach transition label can be any string, as long as that string represents a\nsubset of a certain monoid. Then, the behaviour of the labelled graph is a\nsubset of that monoid. We do the same for regular expressions. We obtain\nextensions of a few classic algorithmic constructions on ordinary regular\nexpressions and transducers at the broad level of labelled graphs and in such a\nway that the computational efficiency of the extended constructions is not\nsacrificed. For regular expressions with set specs we obtain the corresponding\npartial derivative automata. For transducers with set specs we obtain further\nalgorithms that can be applied to questions about independent regular\nlanguages, in particular the witness version of the independent property\nsatisfaction question.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.01829v1"
    },
    {
        "title": "Synchronizing Random Almost-Group Automata",
        "authors": [
            "Mikhail V. Berlinkov",
            "Cyril Nicaud"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper we address the question of synchronizing random automata in the\ncritical settings of almost-group automata. Group automata are automata where\nall letters act as permutations on the set of states, and they are not\nsynchronizing (unless they have one state). In almost-group automata, one of\nthe letters acts as a permutation on $n-1$ states, and the others as\npermutations. We prove that this small change is enough for automata to become\nsynchronizing with high probability. More precisely, we establish that the\nprobability that a strongly connected almost-group automaton is not\nsynchronizing is $\\frac{2^{k-1}-1}{n^{2(k-1)}}(1+o(1))$, for a $k$-letter\nalphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.02154v1"
    },
    {
        "title": "Uniformization Problems for Synchronizations of Automatic Relations on\n  Words",
        "authors": [
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A uniformization of a binary relation is a function that is contained in the\nrelation and has the same domain as the relation. The synthesis problem asks\nfor effective uniformization for classes of relations and functions that can be\nimplemented in a specific way.\n  We consider the synthesis problem for automatic relations over finite words\n(also called regular or synchronized rational relations) by functions\nimplemented by specific classes of sequential transducers.\n  It is known that the problem \"Given an automatic relation, does it have a\nuniformization by a subsequential transducer?\" is decidable in the two variants\nwhere the uniformization can either be implemented by an arbitrary\nsubsequential transducer or it has to be implemented by a synchronous\ntransducer. We introduce a new variant of this problem in which the allowed\ninput/output behavior of the subsequential transducer is specified by a set of\nsynchronizations and prove decidability for a specific class of\nsynchronizations.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.02444v1"
    },
    {
        "title": "On Completely Reachable Automata and Subset Reachability",
        "authors": [
            "François Gonze",
            "Raphaël M. Jungers"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This article focuses on subset reachability in synchronizing automata. First,\nwe provide families of synchronizing automata with subsets which cannot be\nreached with short words. These families do not fulfil Don's Conjecture about\nsubset reachability. Moreover, they show that some subsets need exponentially\nlong words to be reached, and that the restriction of the conjecture to\nincluded subsets also does not hold. Second, we analyze completely reachable\nautomata and provide a counterexample to the conjecture of Bondar and Volkov\nabout the so-called $\\Gamma_1$-graph. We finally prove an alternative version\nof this conjecture.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.02540v1"
    },
    {
        "title": "A Characterization of Completely Reachable Automata",
        "authors": [
            "Eugenija Bondar",
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A complete deterministic finite automaton in which every non-empty subset of\nthe state set occurs as the image of the whole state set under the action of a\nsuitable input word is called completely reachable. We characterize completely\nreachable automata in terms of certain directed graphs.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.02879v1"
    },
    {
        "title": "Complexity of Proper Suffix-Convex Regular Languages",
        "authors": [
            "Corwin Sinnamon"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A language L is suffix-convex if for any words u, v,w, whenever w and uvw are\nin L, vw is in L as well. Suffix-convex languages include left ideals,\nsuffix-closed languages, and suffix-free languages, which were studied\npreviously. In this paper, we concentrate on suffix-convex languages that do\nnot belong to any one of these classes; we call such languages proper. In order\nto study this language class, we define a structure called a suffix-convex\ntriple system that characterizes the automata recognizing suffix-convex\nlanguages. We find tight upper bounds for reversal, star, product, and boolean\noperations of proper suffix-convex languages, and we conjecture on the size of\nthe largest syntactic semigroup. We also prove that three witness streams are\nrequired to meet all these bounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.03375v2"
    },
    {
        "title": "Non-erasing Chomsky-Sch{ü}tzenberger theorem with grammar-independent\n  alphabet",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Pierluigi San Pietro"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The famous theorem by Chomsky and Sch\\\"utzenberger (CST) says that every\ncontext-free language $L$ over an alphabet $\\Sigma$ is representable as $h(D\n\\cap R)$, where $D$ is a Dyck language over a set $\\Omega$ of brackets, $R$ is\na local language and $h$ is an alphabetic homomorphism that erases unboundedly\nmany symbols. Berstel found that the number of erasures can be linearly limited\nif the grammar is in Greibach normal form; Berstel and Boasson (and later,\nindependently, Okhotin) proved a non-erasing variant of CST for grammars in\nDouble Greibach Normal Form. In all these CST statements, however, the size of\nthe Dyck alphabet $\\Omega$ depends on the grammar size for $L$. In the Stanley\nvariant of the CST, $|\\Omega|$ only depends on $|\\Sigma|$ and not on the\ngrammar, but the homomorphism erases many more symbols than in the other\nversions of CST; also, the regular language $R$ is strictly locally testable\nbut not local. We prove a new version of CST which combines both features of\nbeing non-erasing and of using a grammar-independent alphabet. In our\nconstruction, $|\\Omega|$ is polynomial in $|\\Sigma|$, namely\n$O(|\\Sigma|^{46})$, and the regular language $R$ is strictly locally testable.\nUsing a recent generalization of Medvedev's homomorphic characterization of\nregular languages, we prove that the degree in the polynomial dependence of\n$|\\Omega|$ on $|\\Sigma|$ may be reduced to just 2 in the case of linear\ngrammars in Double Greibach Normal Form.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.04003v1"
    },
    {
        "title": "Branching Temporal Logic of Calls and Returns for Pushdown Systems",
        "authors": [
            "Huu-Vu Nguyen",
            "Tayssir Touili"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Pushdown Systems (PDSs) are a natural model for sequential programs with\n(recursive) procedure calls. In this work, we define the Branching temporal\nlogic of CAlls and RETurns (BCARET) that allows to write branching temporal\nformulas while taking into account the matching between calls and returns. We\nconsider the model-checking problem of PDSs against BCARET formulas with\n\"standard\" valuations (where an atomic proposition holds at a configuration c\nor not depends only on the control state of c, not on its stack) as well as\nregular valuations (where the set of configurations in which an atomic\nproposition holds is regular). We show that these problems can be effectively\nsolved by a reduction to the emptiness problem of Alternating B\\\"uchi Pushdown\nSystems. We show that our results can be applied for malware detection.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.04580v1"
    },
    {
        "title": "The Bottom-Up Position Tree Automaton, the Father Automaton and their\n  Compact Versions",
        "authors": [
            "Samira Attou",
            "Ludovic Mignot",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The conversion of a given regular tree expression into a tree automaton has\nbeen widely studied. However, classical interpretations are based upon a\nTop-Down interpretation of tree automata. In this paper, we propose new\nconstructions based on the Gluskov's one and on the one of Ilie and Yu one\nusing a Bottom-Up interpretation. One of the main goals of this technique is to\nconsider as a next step the links with deterministic recognizers, consideration\nthat cannot be performed with classical Top-Down approaches. Furthermore, we\nexhibit a method to factorize transitions of tree automata and show that this\ntechnique is particularly interesting for these constructions, by considering\nnatural factorizations due to the structure of regular expression.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.08584v1"
    },
    {
        "title": "Emptiness of Stack Automata is NEXPTIME-complete: A Correction",
        "authors": [
            "Christopher Broadbent",
            "Arnaud Carayol",
            "Matthew Hague",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A saturation algorithm for collapsible pushdown systems was published in\nICALP 2012. This work introduced a class of stack automata used to recognised\nregular sets of collapsible pushdown configurations. It was shown that these\nautomata form an effective boolean algebra, have a linear time membership\nproblem, and are equivalent to an alternative automata representation appearing\nin LICS 2010. It was also claimed that the emptiness problem for stack automata\nis PSPACE-complete. Unfortunately, this claim is not true. We show that the\nproblem is in fact NEXPTIME-complete when the stacks being accepted are\ncollapsible pushdown stacks, rather than the annotated stacks used in ICALP\n2012.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.11873v1"
    },
    {
        "title": "The Parikh Property for Weighted Context-Free Grammars",
        "authors": [
            "Pierre Ganty",
            "Elena Gutiérrez"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Parikh's Theorem states that every context-free grammar (CFG) is equivalent\nto some regular CFG when the ordering of symbols in the words is ignored. The\nsame is not true for the so-called weighted CFGs, which additionally assign a\nweight to each grammar rule. If the result holds for a given weighted CFG $G$,\nwe say that $G$ satisfies the Parikh property. We prove constructively that the\nParikh property holds for every weighted nonexpansive CFG. We also give a\ndecision procedure for the property when the weights are over the rationals.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.01351v3"
    },
    {
        "title": "On shuffle products, acyclic automata and piecewise-testable languages",
        "authors": [
            "Simon Halfon",
            "Philippe Schnoebelen"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We show that the shuffle $L \\unicode{x29E2} F$ of a piecewise-testable\nlanguage $L$ and a finite language $F$ is piecewise-testable. The proof relies\non a classic but little-used automata-theoretic characterization of\npiecewise-testable languages. We also discuss some mild generalizations of the\nmain result, and provide bounds on the piecewise complexity of $L\n\\unicode{x29E2} F$.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.02953v2"
    },
    {
        "title": "A Pattern Logic for Automata with Outputs",
        "authors": [
            "Emmanuel Filiot",
            "Nicolas Mazzocchi",
            "Jean-François Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a logic to express structural properties of automata with string\ninputs and, possibly, outputs in some monoid. In this logic, the set of\npredicates talking about the output values is parametric, and we provide\nsufficient conditions on the predicates under which the model-checking problem\nis decidable. We then consider three particular automata models (finite\nautomata, transducers and automata weighted by integers -- sum-automata --) and\ninstantiate the generic logic for each of them. We give tight complexity\nresults for the three logics and the model-checking problem, depending on\nwhether the formula is fixed or not. We study the expressiveness of our logics\nby expressing classical structural patterns characterising for instance finite\nambiguity and polynomial ambiguity in the case of finite automata,\ndeterminisability and finite-valuedness in the case of transducers and\nsum-automata. Consequently to our complexity results, we directly obtain that\nthese classical properties can be decided in PTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.03515v1"
    },
    {
        "title": "Unambiguous Forest Factorization",
        "authors": [
            "Paul Gastin",
            "Shankara Narayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we look at an unambiguous version of Simon's forest\nfactorization theorem, a very deep result which has wide connections in\nalgebra, logic and automata. Given a morphism $\\varphi$ from $\\Sigma^+$ to a\nfinite semigroup $S$, we construct a universal, unambiguous automaton A which\nis \"good\" for $\\varphi$. The goodness of $\\Aa$ gives a very easy proof for the\nforest factorization theorem, providing a Ramsey split for any word in\n$\\Sigma^{\\infty}$ such that the height of the Ramsey split is bounded by the\nnumber of states of A. An important application of synthesizing good automata\nfrom the morphim $\\varphi$ is in the construction of regular transducer\nexpressions (RTE) corresponding to deterministic two way transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.07285v1"
    },
    {
        "title": "Polyregular Functions",
        "authors": [
            "Mikołaj Bojańczyk"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper is about certain string-to-string functions, called the\npolyregular functions. These are like the regular string-to-string functions,\nexcept that they can have polynomial (and not just linear) growth. The class\nhas four equivalent definitions: 1. deterministic two-way transducers with\npebbles; 2 the smallest class of string-to-string functions that is closed\nunder composition, contains all sequential functions as well as two extra\nfunctions called squaring and iterated reverse 3. a fragment of the\nlambda-calculus, which has a list type constructor and limited forms of\niteration such as map but not fold; 4. an imperative programming language,\nwhich has for loops that range over input positions.\n  The first definition comes from [milo2003typechecking], while the remaining\nthree are new to the author's best knowledge. The class of polyregular\nfunctions contains known classes of string-to-string transducers, such as the\nsequential, rational, or regular ones, but goes beyond them because of\nsuper-linear growth. Polyregular functions have good algorithmic properties,\nsuch as: - the output can be computed in linear time (in terms of combined\ninput and output size); - the inverse image of a regular word language is\n(effectively) regular.\n  We also identify a fragment of polyregular functions, called the first-order\npolyregular functions, which has additional good properties, e.g. the output\ncan be computed by an AC0 circuit.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.08760v1"
    },
    {
        "title": "The complexity of separation for levels in concatenation hierarchies",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the complexity of the separation problem associated to classes\nof regular languages. For a class C, C-separation takes two regular languages\nas input and asks whether there exists a third language in C which includes the\nfirst and is disjoint from the second. First, in contrast with the situation\nfor the classical membership problem, we prove that for most classes C, the\ncomplexity of C-separation does not depend on how the input languages are\nrepresented: it is the same for nondeterministic finite automata and monoid\nmorphisms. Then, we investigate specific classes belonging to finitely based\nconcatenation hierarchies. It was recently proved that the problem is always\ndecidable for levels 1/2 and 1 of any such hierarchy (with inefficient\nalgorithms). Here, we build on these results to show that when the alphabet is\nfixed, there are polynomial time algorithms for both levels. Finally, we\ninvestigate levels 3/2 and 2 of the famous Straubing-Th\\'erien hierarchy. We\nshow that separation is PSPACE-complete for level 3/2 and between PSPACE-hard\nand EXPTIME for level 2.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.09287v1"
    },
    {
        "title": "MONAA: A Tool for Timed Pattern Matching with Automata-Based\n  Acceleration",
        "authors": [
            "Masaki Waga",
            "Ichiro Hasuo",
            "Kohei Suenaga"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We present monaa, a monitoring tool over a real-time property specified by\neither a timed automaton or a timed regular expression. It implements a timed\npattern matching algorithm that combines 1) features suited for online\nmonitoring, and 2) acceleration by automata-based skipping. Our experiments\ndemonstrate monaa's performance advantage, especially in online usage.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.09351v1"
    },
    {
        "title": "Moore-Machine Filtering for Timed and Untimed Pattern Matching",
        "authors": [
            "Masaki Waga",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Monitoring is an important body of techniques in runtime verification of\nreal-time, embedded, and cyber-physical systems. Mathematically, the monitoring\nproblem can be formalized as a pattern matching problem against a pattern\nautomaton. Motivated by the needs in embedded applications---especially the\nlimited channel capacity between a sensor unit and a processor that\nmonitors---we pursue the idea of filtering as preprocessing for monitoring.\nTechnically, for a given pattern automaton, we present a construction of a\nMoore machine that works as a filter. The construction is automata-theoretic,\nand we find the use of Moore machines particularly suited for embedded\napplications, not only because their sequential operation is relatively cheap\nbut also because they are amenable to hardware acceleration by dedicated\ncircuits. We prove soundness (i.e., absence of lost matches), too. We work in\ntwo settings: in the untimed one, a pattern is an NFA; in the timed one, a\npattern is a timed automaton. The extension of our untimed construction to the\ntimed setting is technically involved, but our experiments demonstrate its\npractical benefits.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.09633v2"
    },
    {
        "title": "A Faster-Than Relation for Semi-Markov Decision Processes",
        "authors": [
            "Mathias Ruggaard Pedersen",
            "Giorgio Bacci",
            "Kim Guldstrand Larsen"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  When modeling concurrent or cyber-physical systems, non-functional\nrequirements such as time are important to consider. In order to improve the\ntiming aspects of a model, it is necessary to have some notion of what it means\nfor a process to be faster than another, which can guide the stepwise\nrefinement of the model. To this end we study a faster-than relation for\nsemi-Markov decision processes and compare it to standard notions for relating\nsystems. We consider the compositional aspects of this relation, and show that\nthe faster-than relation is not a precongruence with respect to parallel\ncomposition, hence giving rise to so-called parallel timing anomalies. We take\nthe first steps toward understanding this problem by identifying decidable\nconditions sufficient to avoid parallel timing anomalies in the absence of\nnon-determinism.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.11243v2"
    },
    {
        "title": "Language Classes Associated With Automata Over Matrix Groups",
        "authors": [
            "Özlem Salehi",
            "Flavio D'Alessandro",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the language classes recognized by group automata over matrix\ngroups. For the case of $2 \\times 2 $ matrices, we prove that the corresponding\ngroup automata for rational matrix groups are more powerful than the\ncorresponding group automata for integer matrix groups. Finite automata over\nsome special matrix groups, such as the discrete Heisenberg group and the\nBaumslag-Solitar group are also examined. We also introduce the notion of time\ncomplexity for group automata and demonstrate some separations among related\nclasses. The case of linear-time bounds is examined in detail throughout our\nrepertory of matrix group automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.12415v2"
    },
    {
        "title": "Visibly Pushdown Languages and Free Profinite Algebras",
        "authors": [
            "Silke Czarnetzki",
            "Andreas Krebs",
            "Klaus-Jörn Lange"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We build a notion of algebraic recognition for visibly pushdown languages by\nfinite algebraic objects. These come with a typical Eilenberg relationship, now\nbetween classes of visibly pushdown languages and classes of finite algebras.\nBuilding on that algebraic foundation, we further construct a topological\nobject with one purpose being the possibility to derive a notion of equations,\nthrough which it is possible to prove that some given visibly pushdown language\nis not part of a certain class (or to even show decidability of the\nmembership-problem of the class in some cases). In particular, we obtain a\nspecial instance of Reiterman's theorem for pseudo-varieties. These findings\nare then employed on two subclasses of the visibly pushdown languages, for\nwhich we derive concrete sets of equations. For some showcase languages, these\nequations are utilised to prove non-membership to the previously described\nclasses.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.12731v1"
    },
    {
        "title": "Note on the Infiniteness and Equivalence Problems for Word-MIX Languages",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this note we provide a (decidable) graph-structural characterisation of\nthe infiniteness of $L(w_1, ..., w_k)$, where $L(w_1, ..., w_k) = \\{w \\in A^* |\n|w|_{w_1} = \\cdots = |w|_{w_k}\\}$ is the set of all words that contain the same\nnumber of subword occurrences of parameter words $w_1, ..., w_k$. We also\nprovide the decidable characterisation of the equivalence for those languages.\nAlthough those two decidability results are also obtained from more general\nknown decidability results on unambiguous constrained automata, this note tries\nto give a self-contained (without the knowledge about constrained automata)\nproof of the decidability.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.02600v3"
    },
    {
        "title": "On Series-Parallel Pomset Languages: Rationality, Context-Freeness and\n  Automata",
        "authors": [
            "Tobias Kappé",
            "Paul Brunet",
            "Bas Luttik",
            "Alexandra Silva",
            "Fabio Zanasi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Concurrent Kleene Algebra (CKA) is a formalism to study concurrent programs.\nLike previous Kleene Algebra extensions, developing a correspondence between\ndenotational and operational perspectives is important, for both foundations\nand applications. This paper takes an important step towards such a\ncorrespondence, by precisely relating bi-Kleene Algebra (BKA), a fragment of\nCKA, to a novel type of automata, pomset automata (PAs). We show that PAs can\nimplement the BKA semantics of series-parallel rational expressions, and that a\nclass of PAs can be translated back to these expressions. We also characterise\nthe behavior of general PAs in terms of context-free pomset grammars;\nconsequently, universality, equivalence and series-parallel rationality of\ngeneral PAs are undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.03058v2"
    },
    {
        "title": "Counting symbol switches in synchronizing automata",
        "authors": [
            "Henk Don",
            "Hans Zantema"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Instead of looking at the lengths of synchronizing words as in \\v{C}ern\\'y's\nconjecture, we look at the switch count of such words, that is, we only count\nthe switches from one letter to another. Where the synchronizing words of the\n\\v{C}ern\\'y automata $\\mathcal{C}_n$ have switch count linear in $n$, we wonder\nwhether synchronizing automata exist for which every synchronizing word has\nquadratic switch count. The answer is positive: we prove that switch count has\nthe same complexity as synchronizing word length. We give some series of\nsynchronizing automata yielding quadratic switch count, the best one reaching\n$\\frac{2}{3} n^2 + O(n)$ as switch count.\n  We investigate all binary automata on at most 9 states and determine the\nmaximal possible switch count. For all $3\\leq n\\leq 9$, a strictly higher\nswitch count can be reached by allowing more symbols. This behaviour differs\nfrom length, where for every $n$, no automata are known with higher\nsynchronization length than $\\mathcal{C}_n$, which has only two symbols. It is\nnot clear if this pattern extends to larger $n$. For $n\\geq 12$, our best\nconstruction only has two symbols.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.04050v1"
    },
    {
        "title": "Optimal Regular Expressions for Permutations",
        "authors": [
            "Antonio Molina Lovett",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The permutation language $P_n$ consists of all words that are permutations of\na fixed alphabet of size $n$. Using divide-and-conquer, we construct a regular\nexpression $R_n$ that specifies $P_n$. We then give explicit bounds for the\nlength of $R_n$, which we find to be $4^n n^{-(\\lg n)/4+\\Theta(1)}$, and use\nthese bounds to show that $R_n$ has minimum size over all regular expressions\nspecifying $P_n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.06347v1"
    },
    {
        "title": "Monotone Precision and Recall Measures for Comparing Executions and\n  Specifications of Dynamic Systems",
        "authors": [
            "Artem Polyvyanyy",
            "Andreas Solti",
            "Matthias Weidlich",
            "Claudio Di Ciccio",
            "Jan Mendling"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The behavioural comparison of systems is an important concern of software\nengineering research. For example, the areas of specification discovery and\nspecification mining are concerned with measuring the consistency between a\ncollection of execution traces and a program specification. This problem is\nalso tackled in process mining with the help of measures that describe the\nquality of a process specification automatically discovered from execution\nlogs. Though various measures have been proposed, it was recently demonstrated\nthat they neither fulfil essential properties, such as monotonicity, nor can\nthey handle infinite behaviour. In this paper, we address this research problem\nby introducing a new framework for the definition of behavioural quotients. We\nproof that corresponding quotients guarantee desired properties that existing\nmeasures have failed to support. We demonstrate the application of the\nquotients for capturing precision and recall measures between a collection of\nrecorded executions and a system specification. We use a prototypical\nimplementation of these measures to contrast their monotonic assessment with\nmeasures that have been defined in prior research.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.07334v2"
    },
    {
        "title": "Learning Unions of k-Testable Languages",
        "authors": [
            "Alexis Linard",
            "Colin de la Higuera",
            "Frits Vaandrager"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A classical problem in grammatical inference is to identify a language from a\nset of examples. In this paper, we address the problem of identifying a union\nof languages from examples that belong to several different unknown languages.\nIndeed, decomposing a language into smaller pieces that are easier to represent\nshould make learning easier than aiming for a too generalized language. In\nparticular, we consider k-testable languages in the strict sense (k-TSS). These\nare defined by a set of allowed prefixes, infixes (sub-strings) and suffixes\nthat words in the language may contain. We establish a Galois connection\nbetween the lattice of all languages over alphabet {\\Sigma}, and the lattice of\nk-TSS languages over {\\Sigma}. We also define a simple metric on k-TSS\nlanguages. The Galois connection and the metric allow us to derive an efficient\nalgorithm to learn the union of k-TSS languages. We evaluate our algorithm on\nan industrial dataset and thus demonstrate the relevance of our approach.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.08269v1"
    },
    {
        "title": "The language preservation problem is undecidable for parametric\n  event-recording automata",
        "authors": [
            "Étienne André",
            "Shang-Wei Lin"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Parametric timed automata (PTA) extend timed automata with unknown constants\n(\"parameters\"), at the price of undecidability of most interesting problems.\nThe (untimed) language preservation problem (\"given a parameter valuation, can\nwe find at least one other valuation with the same untimed language?\") is\nundecidable for PTAs. We prove that this problem remains undecidable for\nparametric event-recording automata (PERAs), a subclass of PTAs that\nconsiderably restrains the way the language can be used; we also show it\nremains undecidable even for slightly different definitions of the language,\ni.e., finite sequences of actions ending in or passing infinitely often through\naccepting locations, or just all finite untimed words (without accepting\nlocations).\n",
        "pdf_link": "http://arxiv.org/pdf/1812.08948v1"
    },
    {
        "title": "Visibly Pushdown Languages over Sliding Windows",
        "authors": [
            "Moses Ganardi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the class of visibly pushdown languages in the sliding window\nmodel. A sliding window algorithm for a language $L$ receives a stream of\nsymbols and has to decide at each time step whether the suffix of length $n$\nbelongs to $L$ or not. The window size $n$ is either a fixed number (in the\nfixed-size model) or can be controlled by an adversary in a limited way (in the\nvariable-size model). The main result of this paper states that for every\nvisibly pushdown language the space complexity in the variable-size sliding\nwindow model is either constant, logarithmic or linear in the window size. This\nextends previous results for regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.11549v1"
    },
    {
        "title": "Formalization and Correctness of Predictive Shift-Reduce Parsers for\n  Graph Grammars based on Hyperedge Replacement",
        "authors": [
            "Frank Drewes",
            "Berthold Hoffmann",
            "Mark Minas"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Hyperedge replacement (HR) grammars can generate NP-complete graph languages,\nwhich makes parsing hard even for fixed HR languages. Therefore, we study\npredictive shift-reduce (PSR) parsing that yields efficient parsers for a\nsubclass of HR grammars, by generalizing the concepts of SLR(1) string parsing\nto graphs. We formalize the construction of PSR parsers and show that it is\ncorrect. PSR parsers run in linear space and time, and are more efficient than\nthe predictive top-down (PTD) parsers recently developed by the authors.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.11927v2"
    },
    {
        "title": "Monadic Decomposability of Regular Relations",
        "authors": [
            "Pablo Barcelo",
            "Chih-Duo Hong",
            "Xuan-Bach Le",
            "Anthony W. Lin",
            "Reino Niskanen"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Monadic decomposibility --- the ability to determine whether a formula in a\ngiven logical theory can be decomposed into a boolean combination of monadic\nformulas --- is a powerful tool for devising a decision procedure for a given\nlogical theory. In this paper, we revisit a classical decision problem in\nautomata theory: given a regular (a.k.a. synchronized rational) relation,\ndetermine whether it is recognizable, i.e., it has a monadic decomposition\n(that is, a representation as a boolean combination of cartesian products of\nregular languages). Regular relations are expressive formalisms which, using an\nappropriate string encoding, can capture relations definable in Presburger\nArithmetic. In fact, their expressive power coincide with relations definable\nin a universal automatic structure; equivalently, those definable by finite set\ninterpretations in WS1S (Weak Second Order Theory of One Successor).\nDetermining whether a regular relation admits a recognizable relation was known\nto be decidable (and in exponential time for binary relations), but its precise\ncomplexity still hitherto remains open. Our main contribution is to fully\nsettle the complexity of this decision problem by developing new techniques\nemploying infinite Ramsey theory. The complexity for DFA (resp. NFA)\nrepresentations of regular relations is shown to be NLOGSPACE-complete (resp.\n\\PSPACE-complete).\n",
        "pdf_link": "http://arxiv.org/pdf/1903.00728v3"
    },
    {
        "title": "Nonlinear Craig Interpolant Generation",
        "authors": [
            "Ting Gan",
            "Bican Xia",
            "Bai Xue",
            "Naijun Zhan",
            "Liyun Dai"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Interpolation-based techniques have become popularized in recent years\nbecause of their inherently modular and local reasoning, which can scale up\nexisting formal verification techniques like theorem proving, model-checking,\nabstraction interpretation, and so on, while the scalability is the bottleneck\nof these techniques. Craig interpolant generation plays a central role in\ninterpolation-based techniques, and therefore has drawn increasing attentions.\nIn the literature, there are various works done on how to automatically\nsynthesize interpolants for decidable fragments of first-order logic, linear\narithmetic, array logic, equality logic with uninterpreted functions (EUF),\netc., and their combinations. But Craig interpolant generation for non-linear\ntheory and its combination with the aforementioned theories are still in\ninfancy, although some attempts have been done. In this paper, we first prove\nthat a polynomial interpolant of the form $h(\\mathbf{x})>0$ exists for two\nmutually contradictory polynomial formulas $\\phi(\\mathbf{x},\\mathbf{y})$ and\n$\\psi(\\mathbf{x},\\mathbf{z})$, with the form $f_1\\ge0\\wedge\\cdots\\wedge\nf_n\\ge0$, where $f_i$ are polynomials in $\\mathbf{x},\\mathbf{y}$ or\n$\\mathbf{x},\\mathbf{z}$, and the quadratic module generated by $f_i$ is\nArchimedean. Then, we show that synthesizing such interpolant can be reduced to\nsolving a semi-definite programming problem (${\\rm SDP}$). In addition, we\npropose a verification approach to assure the validity of the synthesized\ninterpolant and consequently avoid the unsoundness caused by numerical error in\n${\\rm SDP}$ solving. Finally, we discuss how to generalize our approach to\ngeneral semi-algebraic formulas.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.01297v3"
    },
    {
        "title": "On the Density of Context-Free and Counter Languages",
        "authors": [
            "Joey Eremondi",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A language $L$ is said to be dense if every word in the universe is an infix\nof some word in $L$. This notion has been generalized from the infix operation\nto arbitrary word operations $\\varrho$ in place of the infix operation\n($\\varrho$-dense, with infix-dense being the standard notion of dense). It is\nshown here that it is decidable, for a language $L$ accepted by a one-way\nnondeterministic reversal-bounded pushdown automaton, whether $L$ is\ninfix-dense. However, it becomes undecidable for both deterministic pushdown\nautomata (with no reversal-bound), and for nondeterministic one-counter\nautomata. When examining suffix-density, it is undecidable for more restricted\nfamilies such as deterministic one-counter automata that make three reversals\non the counter, but it is decidable with less reversals. Other decidability\nresults are also presented on dense languages, and contrasted with a marked\nversion called $\\varrho$-marked-density. Also, new languages are demonstrated\nto be outside various deterministic language families after applying different\ndeletion operations from smaller families. Lastly, bounded-dense languages are\ndefined and examined.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.03001v1"
    },
    {
        "title": "On the Density of Languages Accepted by Turing Machines and Other\n  Machine Models",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A language is dense if the set of all infixes (or subwords) of the language\nis the set of all words. Here, it is shown that it is decidable whether the\nlanguage accepted by a nondeterministic Turing machine with a one-way read-only\ninput and a reversal-bounded read/write worktape (the read/write head changes\ndirection at most some fixed number of times) is dense. From this, it is\nimplied that it is also decidable for one-way reversal-bounded queue automata,\none-way reversal-bounded stack automata, and one-way reversal-bounded $k$-flip\npushdown automata (machines that can \"flip\" their pushdowns up to $k$ times).\nHowever, it is undecidable for deterministic Turing machines with two\n1-reversal-bounded worktapes (even when the two tapes are restricted to operate\nas 1-reversal-bounded pushdown stacks).\n",
        "pdf_link": "http://arxiv.org/pdf/1903.03018v1"
    },
    {
        "title": "On counting functions and slenderness of languages",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan",
            "Bala Ravikumar"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study counting-regular languages -- these are languages $L$ for which\nthere is a regular language $L'$ such that the number of strings of length $n$\nin $L$ and $L'$ are the same for all $n$. We show that the languages accepted\nby unambiguous nondeterministic Turing machines with a one-way read-only input\ntape and a reversal-bounded worktape are counting-regular. Many one-way\nacceptors are a special case of this model, such as reversal-bounded\ndeterministic pushdown automata, reversal-bounded deterministic queue automata,\nand many others, and therefore all languages accepted by these models are\ncounting-regular. This result is the best possible in the sense that the claim\ndoes not hold for either $2$-ambiguous PDA's, unambiguous PDA's with no\nreversal-bound, and other models.\n  We also study closure properties of counting-regular languages, and we study\ndecidability problems in regards to counting-regularity. For example, it is\nshown that the counting-regularity of even some restricted subclasses of PDA's\nis undecidable. Lastly, $k$-slender languages -- where there are at most $k$\nwords of any length -- are also studied. Amongst other results, it is shown\nthat it is decidable whether a language in any semilinear full trio is\n$k$-slender.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.03504v1"
    },
    {
        "title": "Insertion Operations on Deterministic Reversal-Bounded Counter Machines",
        "authors": [
            "Joey Eremondi",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Several insertion operations are studied applied to languages accepted by\none-way and two-way deterministic reversal-bounded multicounter machines. These\noperations are defined by the ideals obtained from relations such as the\nprefix, infix, suffix, and outfix relations, as well as operations defined from\ninverses of a type of deterministic transducer with reversal-bounded counters\nattached. The question of whether the resulting languages can always be\naccepted by deterministic machines with the same number (or larger number) of\ninput-turns (resp., counters, counter-reversals, etc.) is investigated.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.03518v1"
    },
    {
        "title": "On Finite $1$-Dimensional Cellular Automata: Reversibility and\n  Semi-reversibility",
        "authors": [
            "Kamalika Bhattacharjee",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Reversibility of a one-dimensional finite cellular automaton (CA) is\ndependent on lattice size. A finite CA can be reversible for a set of lattice\nsizes. On the other hand, reversibility of an infinite CA, which is decided by\nexploring the rule only, is different in its kind from that of finite CA. Can\nwe, however, link the reversibility of finite CA to that of infinite CA? In\norder to address this issue, we introduce a new notion, named\nsemi-reversibility. We classify the CAs into three types with respect to\nreversibility property -- reversible, semi-reversible and strictly\nirreversible. A tool, reachability tree, has been used to decide the\nreversibility class of any CA. Finally, relation among the existing cases of\nreversibility is established.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.06011v1"
    },
    {
        "title": "Extensions of Abelian Automata Groups",
        "authors": [
            "Chris Grossack"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A theorem of Nekrashevych and Sidki shows the Mealy Automata structures one\ncan place on Z^m are parametrized by a family of matrices (called\n\"1/2-integral\") and a choice of residuation vector e in Z^m. While the impact\nof the chosen matrix is well understood, the impact of the residuation vector\non the resulting structure is seemingly sporadic. In this paper we characterize\nthe impact of the residuation vector e by recognizing an initial structure when\ne is the first standard basis vector. All other choices of e extend this\ninitial structure by adding \"fractional elements\" in a way we make precise.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.06997v2"
    },
    {
        "title": "Parametric Timed Pattern Matching",
        "authors": [
            "Masaki Waga",
            "Étienne André",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Given a log and a specification, timed pattern matching aims at exhibiting\nfor which start and end dates a specification holds on that log. For example,\n\"a given action is always followed by another action before a given deadline\".\nThis problem has strong connections with monitoring real-time systems. We\naddress here timed pattern matching in the presence of an uncertain\nspecification, i.e., that may contain timing parameters (e.g., the deadline can\nbe uncertain or unknown). We want to know for which start and end dates, and\nfor what values of the timing parameters, a property holds. For instance, we\nlook for the minimum or maximum deadline (together with the corresponding start\nand end dates) for which the property holds. We propose two frameworks for\nparametric timed pattern matching. The first one is based on parametric timed\nmodel checking. In contrast to most parametric timed problems, the solution is\neffectively computable. The second one is a dedicated method; not only we\nlargely improve the efficiency compared to the first method, but we further\npropose optimizations with skipping. Our experiment results suggest that our\nalgorithms, especially the second one, are efficient and practically relevant.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.07328v2"
    },
    {
        "title": "Varieties of Data Languages",
        "authors": [
            "Henning Urbat",
            "Stefan Milius"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We establish an Eilenberg-type correspondence for data languages, i.e.\nlanguages over an infinite alphabet. More precisely, we prove that there is a\nbijective correspondence between varieties of languages recognized by\norbit-finite nominal monoids and pseudovarieties of such monoids. This is the\nfirst result of this kind for data languages. Our approach makes use of nominal\nStone duality and a recent category theoretic generalization of Birkhoff-type\nHSP theorems that we instantiate here for the category of nominal sets. In\naddition, we prove an axiomatic characterization of weak pseudovarieties as\nthose classes of orbit-finite monoids that can be specified by sequences of\nnominal equations, which provides a nominal version of a classical theorem of\nEilenberg and Sch\\\"utzenberger.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.08053v2"
    },
    {
        "title": "Effective Definability of the Reachability Relation in Timed Automata",
        "authors": [
            "Martin Fränzle",
            "Karin Quaas",
            "Mahsa Shirmohammadi",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We give a new proof of the result of Comon and Jurski that the binary\nreachability relation of a timed automaton is definable in linear arithmetic.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.09773v1"
    },
    {
        "title": "A Characterization of Morphic Words with Polynomial Growth",
        "authors": [
            "Tim Smith"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A morphic word is obtained by iterating a morphism to generate an infinite\nword, and then applying a coding. We characterize morphic words with polynomial\ngrowth in terms of a new type of infinite word called a $\\textit{zigzag word}$.\nA zigzag word is represented by an initial string, followed by a finite list of\nterms, each of which repeats for each $n \\geq 1$ in one of three ways: it grows\nforward [$t(1)\\ t(2)\\ \\dotsm\\ t(n)]$, backward [$t(n)\\ \\dotsm\\ t(2)\\ t(1)$], or\njust occurs once [$t$]. Each term can recursively contain subterms with their\nown forward and backward repetitions. We show that an infinite word is morphic\nwith growth $\\Theta(n^k)$ iff it is a zigzag word of depth $k$. As corollaries,\nwe obtain that the morphic words with growth $O(n)$ are exactly the ultimately\nperiodic words, and the morphic words with growth $O(n^2)$ are exactly the\nmultilinear words.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.09905v4"
    },
    {
        "title": "Parallel communicating one-way reversible finite automata system",
        "authors": [
            "Debayan Ganguly",
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper, we discuss the computational power of parallel communicating\nfinite automata system with 1-way reversible finite automaton as components. We\nshow that unlike the multi-head one way reversible finite automata model (where\nwe are still not sure whether it accepts all the regular languages) parallel\ncommunicating one-way reversible finite automata systems can accept all the\nregular languages. Moreover for every multi-head one way reversible finite\nautomaton there exist a parallel communicating one-way reversible finite\nautomata system which accepts the same language. We also make an interesting\nobservation that although the components of the system are reversible the\nsystem as a whole is not reversible. On the basis of which we conjecture that\nparallel communicating one-way reversible finite automata systems may accept\nlanguages not accepted by multi-head one way reversible finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.10428v1"
    },
    {
        "title": "Using Sat solvers for synchronization issues in partial deterministic\n  automata",
        "authors": [
            "Hanan Shabana",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We approach the task of computing a carefully synchronizing word of minimum\nlength for a given partial deterministic automaton, encoding the problem as an\ninstance of SAT and invoking a SAT solver. Our experimental results demonstrate\nthat this approach gives satisfactory results for automata with up to 100\nstates even if very modest computational resources are used.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.10549v1"
    },
    {
        "title": "Partitioning a Symmetric Rational Relation into Two Asymmetric Rational\n  Relations",
        "authors": [
            "Stavros Konstantinidis",
            "Mitja Mastnak",
            "Juraj Sebej"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider the problem of partitioning effectively a given symmetric (and\nirreflexive) rational relation R into two asymmetric rational relations. This\nproblem is motivated by a recent method of embedding an R-independent language\ninto one that is maximal R-independent, where the method requires to use an\nasymmetric partition of R. We solve the problem when R is realized by a\nzero-avoiding transducer (with some bound k): if the absolute value of the\ninput-output length discrepancy of a computation exceeds k then the length\ndiscrepancy of the computation cannot become zero. This class of relations\nproperly contains all recognizable, all left synchronous, and all right\nsynchronous relations. We leave the asymmetric partition problem open when R is\nnot realized by a zero-avoiding transducer. We also show examples of total\nwordorderings for which there is a relation R that cannot be partitioned into\ntwo asymmetric rational relations such that one of them is decreasing with\nrespect to the given word-ordering.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.10740v1"
    },
    {
        "title": "Alternating Weak Automata from Universal Trees",
        "authors": [
            "Laure Daviaud",
            "Marcin Jurdziński",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  An improved translation from alternating parity automata on infinite words to\nalternating weak automata is given. The blow-up of the number of states is\nrelated to the size of the smallest universal ordered trees and hence it is\nquasi-polynomial, and only polynomial if the asymptotic number of priorities is\nlogarithmic in the number of states. This is an exponential improvement on the\ntranslation of Kupferman and Vardi (2001) and a quasi-polynomial improvement on\nthe translation of Boker and Lehtinen (2018). Any slightly better such\ntranslation would (if---like all presently known such translations---it is\nefficiently constructive) lead to algorithms for solving parity games that are\nasymptotically faster in the worst case than the current state of the art\n(Calude, Jain, Khoussainov, Li, and Stephan, 2017; Jurdzi\\'nski and Lazi\\'c,\n2017; and Fearnley, Jain, Schewe, Stephan, and Wojtczak, 2017), and hence it\nwould yield a significant breakthrough.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.12620v2"
    },
    {
        "title": "On the Expressive Power of Higher-Order Pushdown Systems",
        "authors": [
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that deterministic collapsible pushdown automata of second order can\nrecognize a language that is not recognizable by any deterministic higher-order\npushdown automaton (without collapse) of any order. This implies that there\nexists a tree generated by a second order collapsible pushdown system\n(equivalently, by a recursion scheme of second order) that is not generated by\nany deterministic higher-order pushdown system (without collapse) of any order\n(equivalently, by any safe recursion scheme of any order). As a side effect, we\npresent a pumping lemma for deterministic higher-order pushdown automata, which\npotentially can be useful for other applications.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.00650v2"
    },
    {
        "title": "Asymptotic Approximation by Regular Languages",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This paper investigates a new property of formal languages called\nREG-measurability where REG is the class of regular languages. Intuitively, a\nlanguage \\(L\\) is REG-measurable if there exists an infinite sequence of\nregular languages that \"converges\" to \\(L\\). A language without\nREG-measurability has a complex shape in some sense so that it can not be\n(asymptotically) approximated by regular languages. We show that several\ncontext-free languages are REG-measurable (including languages with\ntranscendental generating function and transcendental density, in particular),\nwhile a certain simple deterministic context-free language and the set of\nprimitive words are REG-immeasurable in a strong sense.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.01413v2"
    },
    {
        "title": "Blocksequences of k-local Words",
        "authors": [
            "Pamela Fleischmann",
            "Lukas Haschke",
            "Florin Manea",
            "Dirk Nowotka",
            "Cedric Tsatia Tsida",
            "Judith Wiedenbeck"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The locality of words is a relatively young structural complexity measure,\nintroduced by Day et al. in 2017 in order to define classes of patterns with\nvariables which can be matched in polynomial time. The main tool used to\ncompute the locality of a word is called marking sequence: an ordering of the\ndistinct letters occurring in the respective order. Once a marking sequence is\ndefined, the letters of the word are marked in steps: in the ith marking step,\nall occurrences of the ith letter of the marking sequence are marked. As such,\nafter each marking step, the word can be seen as a sequence of blocks of marked\nletters separated by blocks of non-marked letters. By keeping track of the\nevolution of the marked blocks of the word through the marking defined by a\nmarking sequence, one defines the blocksequence of the respective marking\nsequence. We first show that the words sharing the same blocksequence are only\nloosely connected, so we consider the stronger notion of extended\nblocksequence, which stores additional information on the form of each single\nmarked block. In this context, we present a series of combinatorial results for\nwords sharing the extended blocksequence.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.03516v2"
    },
    {
        "title": "Verifying Safety Properties of Inductively Defined Parameterized Systems",
        "authors": [
            "Marius Bozga",
            "Radu Iosif"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We introduce a term algebra as a new formal specification language for the\ncoordinating architectures of distributed systems consisting of a finite yet\nunbounded number of components. The language allows to describe infinite sets\nof systems whose coordination between components share the same pattern, using\ninductive definitions similar to the ones used to describe algebraic data types\nor recursive data structures. Further, we give a verification method for the\nparametric systems described in this language, relying on the automatic\nsynthesis of structural invariants that enable proving general safety\nproperties (mutual exclusion, absence of deadlocks). The invariants are defined\nusing the WSkS fragment of the monadic second order logic, known to be\ndecidable by a classical automata-logic connection. This reduces the safety\nverification problem to checking satisfiability of a WSkS formula.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.04160v3"
    },
    {
        "title": "On the Complexity of the Universality and Inclusion Problems for\n  Unambiguous Context-Free Grammars",
        "authors": [
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the computational complexity of universality and inclusion problems\nfor unambiguous finite automata and context-free grammars. We observe that\nseveral such problems can be reduced to the universality problem for\nunambiguous context-free grammars. The latter problem has long been known to be\ndecidable and we propose a PSPACE algorithm that works by reduction to the\nzeroness problem of recurrence equations with convolution. We are not aware of\nany non-trivial complexity lower bounds. However, we show that computing the\ncoin-flip measure of an unambiguous context-free language, a quantitative\ngeneralisation of universality, is hard for the long-standing open problem\nSQRTSUM.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.04667v1"
    },
    {
        "title": "On the number of useful objects in P systems with active membranes",
        "authors": [
            "Zsolt Gazdag",
            "Károly Hajagos",
            "Szabolcs Iván"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper we investigate the number of objects actually used in the\nterminating computations of a certain variant of polarizationless P systems\nwith active membranes. The P systems we consider here have no in-communication\nrules and have no different rules triggered by the same object to manipulate\nthe same membrane. We show that if we consider such a P system $\\Pi$ and its\nterminating computation $\\cal C$, then we can compute the result of $\\cal C$ by\nsetting a polynomial upper bound on the content of each region in $\\cal C$.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.04993v1"
    },
    {
        "title": "The Commutative Closure of Shuffle Expressions over Group Languages is\n  Regular",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that the commutative closure combined with the iterated shuffle is a\nregularity-preserving operation on group languages. In particular, for\ncommutative group languages, the iterated shuffle is a regularity-preserving\noperation. We also give bounds for the size of minimal recognizing automata.\nThen, we use these results to deduce that the commutative closure of any\nshuffle expression over group languages, i.e., expressions involving shuffle,\niterated shuffle, concatenation, Kleene star and union in any order, starting\nwith the group languages, always yields a regular language.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.05420v3"
    },
    {
        "title": "On the Power of Automata Minimization in Reactive Synthesis",
        "authors": [
            "Shufang Zhu",
            "Lucas M. Tabajara",
            "Geguang Pu",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Temporal logic is often used to describe temporal properties in AI\napplications. The most popular language for doing so is Linear Temporal Logic\n(LTL). Recently, LTL on finite traces, LTLf, has been investigated in several\ncontexts. In order to reason about LTLf, formulas are typically compiled into\ndeterministic finite automata (DFA), as the intermediate semantic\nrepresentation. Moreover, due to the fact that DFAs have canonical\nrepresentation, efficient minimization algorithms can be applied to maximally\nreduce DFA size, helping to speed up subsequent computations. Here, we present\na thorough investigation on two classical minimization algorithms, namely, the\nHopcroft and Brzozowski algorithms. More specifically, we show how to apply\nthese algorithms to semi-symbolic (explicit states, symbolic transition\nfunctions) automata representation. We then compare the two algorithms in the\ncontext of an LTLf-synthesis framework, starting from LTLf formulas. While\nearlier studies on comparing the two algorithms starting from\nrandomly-generated automata concluded that neither algorithm dominates, our\nresults suggest that starting from LTLf formulas, Hopcroft's algorithm is the\nbest choice in the context of reactive synthesis. Deeper analysis explains why\nthe supposed advantage of Brzozowski's algorithm does not materialize in\npractice.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.06790v2"
    },
    {
        "title": "On the Use of Quasiorders in Formal Language Theory",
        "authors": [
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this thesis we use quasiorders on words to offer a new perspective on two\nwell-studied problems from Formal Language Theory: deciding language inclusion\nand manipulating the finite automata representations of regular languages.\nFirst, we present a generic quasiorder-based framework that, when instantiated\nwith different quasiorders, yields different algorithms (some of them new) for\ndeciding language inclusion. We then instantiate this framework to devise an\nefficient algorithm for searching with regular expressions on\ngrammar-compressed text. Finally, we define a framework of quasiorder-based\nautomata constructions to offer a new perspective on residual automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.08828v1"
    },
    {
        "title": "Concatenation Operations and Restricted Variants of Two-Dimensional\n  Automata",
        "authors": [
            "Taylor J. Smith",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A two-dimensional automaton operates on arrays of symbols. While a standard\n(four-way) two-dimensional automaton can move its input head in four\ndirections, restricted two-dimensional automata are only permitted to move\ntheir input heads in three or two directions; these models are called three-way\nand two-way two-dimensional automata, respectively.\n  In two dimensions, we may extend the notion of concatenation in multiple\nways, depending on the words to be concatenated. We may row-concatenate (resp.,\ncolumn-concatenate) a pair of two-dimensional words when they have the same\nnumber of columns (resp., rows). In addition, the diagonal concatenation\noperation combines two words at their lower-right and upper-left corners, and\nis not dimension-dependent.\n  In this paper, we investigate closure properties of restricted models of\ntwo-dimensional automata under various concatenation operations. We give\nnon-closure results for two-way two-dimensional automata under row and column\nconcatenation in both the deterministic and nondeterministic cases. We further\ngive positive closure results for the same concatenation operations on unary\nnondeterministic two-way two-dimensional automata. Finally, we study closure\nproperties of diagonal concatenation on both two- and three-way two-dimensional\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.11164v1"
    },
    {
        "title": "Languages recognised by finite semigroups, and their generalisations to\n  objects such as trees and graphs, with an emphasis on definability in monadic\n  second-order logic",
        "authors": [
            "Mikołaj Bojańczyk"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  These are lecture notes on the algebraic approach to regular languages. The\nclassical algebraic approach is for finite words; it uses semigroups instead of\nautomata. However, the algebraic approach can be extended to structures beyond\nwords, e.g.~infinite words, or trees or graphs. The purpose of this book is to\ndescribe the algebraic approach in a way that covers these extensions.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.11635v1"
    },
    {
        "title": "Computability by Monadic Second-Order Logic",
        "authors": [
            "Joost Engelfriet"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A binary relation on graphs is recursively enumerable if and only if it can\nbe computed by a formula in monadic second-order logic. The latter means that\nthe formula defines a set of graphs, in the usual way, such that each\n\"computation graph\" in that set determines a pair consisting of an input graph\nand an output graph.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.12151v3"
    },
    {
        "title": "Weak and Nested Class Memory Automata",
        "authors": [
            "Conrad Cotton-Barratt",
            "Andrzej Murawski",
            "Luke Ong"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Automata over infinite alphabets have recently come to be studied extensively\nas potentially useful tools for solving problems in verification and database\ntheory. One popular model of automata studied is the Class Memory Automata\n(CMA), for which the emptiness problem is equivalent to Petri Net Reachability.\nWe identify a restriction - which we call weakness - of CMA, and show that\ntheir emptiness problem is equivalent to Petri Net Coverability. Further, we\nshow that in the deterministic case they are closed under all Boolean\noperations. We clarify the connections between weak CMA and existing automata\nover data languages. We also extend CMA to operate over multiple levels of\nnested data values, and show that while these have undecidable emptiness in\ngeneral, adding the weakness constraint recovers decidability of emptiness, via\nreduction to coverability in well-structured transition systems. We also\nexamine connections with existing automata over nested data.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.1136v2"
    },
    {
        "title": "Complexity of a Problem Concerning Reset Words for Eulerian Binary\n  Automata",
        "authors": [
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A word is called a reset word for a deterministic finite automaton if it maps\nall the states of the automaton to a unique state. Deciding about the existence\nof a reset word of a given maximum length for a given automaton is known to be\nan NP-complete problem. We prove that it remains NP-complete even if restricted\nto Eulerian automata with binary alphabets, as it has been conjectured by\nMartyugin (2011).\n",
        "pdf_link": "http://arxiv.org/pdf/1409.2003v1"
    },
    {
        "title": "Alternating Towers and Piecewise Testable Separators",
        "authors": [
            "Štěpán Holub",
            "Tomáš Masopust",
            "Michaël Thomazo"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Two languages are separable by a piecewise testable language if and only if\nthere exists no infinite tower between them. An infinite tower is an infinite\nsequence of strings alternating between the two languages such that every\nstring is a subsequence (scattered substring) of all the strings that follow.\nFor regular languages represented by nondeterministic finite automata, the\nexistence of an infinite tower is decidable in polynomial time. In this paper,\nwe investigate the complexity of a particular method to compute a piecewise\ntestable separator. We show that it is closely related to the height of maximal\nfinite towers, and provide the upper and lower bounds with respect to the size\nof the given nondeterministic automata. Specifically, we show that the upper\nbound is polynomial with respect to the number of states with the cardinality\nof the alphabet in the exponent. Concerning the lower bound, we show that\ntowers of exponential height with respect to the cardinality of the alphabet\nexist. Since these towers mostly turn out to be sequences of prefixes, we also\nprovide a comparison with towers of prefixes.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.3943v2"
    },
    {
        "title": "Finite Automata With Restricted Two-Way Motion",
        "authors": [
            "David Damanik"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider finite two-way automata and measure the use of two-way motion by\ncounting the number of left moves in accepting computations. Restriction of the\nautomata according to this measure allows us to study in detail the use of\ntwo-way motion for the acceptance of regular languages in terms of state\ncomplexity. The two-way spectrum of a given regular language is introduced.\nThis quantity reflects the change of size of minimal accepting devices if the\nuse of two-way motion is increased incrementally. We give examples for spectra,\nprove uniform upper and lower bounds and study their sharpness. We also have\nstate complexity results for two-way automata with uniformly bounded use of\ntwo-way motion.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.5909v1"
    },
    {
        "title": "Dyck-based characterizations of Indexed Languages",
        "authors": [
            "Severine Fratani",
            "El Makki Voundy"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Indexed languages are a generalization of context-free languages and form a\nproper subset of context-sensitive languages. We propose to generalize to\nindexed languages several well known characterizations of context-free\nlanguages: namely, the characterization by rational transductions defined by\nNivat, the Chomsky-Sch\\\"utzenberger theorem, and the logical characterization\nproved by Lautemann et al.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.6112v4"
    },
    {
        "title": "Learning Algorithm for Relation-Substitutable Context-Free Languages",
        "authors": [
            "Takayuki Kuriyama"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We generalized the class of $k,l$-substitutable languages (Yoshinala, 2008).\nEach language in the generalized class is closed under a good substitutability.\nThe substitutability is defined by a recognizable equivalence relation. We show\nthe convergence of our generalized learning algorithm. The size of the\ncharacteristic sample is smaller than Yoshinaka's.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.6247v3"
    },
    {
        "title": "Church-Rosser Systems, Codes with Bounded Synchronization Delay and\n  Local Rees Extensions",
        "authors": [
            "Volker Diekert",
            "Lukas Fleischer"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  What is the common link, if there is any, between Church-Rosser systems,\nprefix codes with bounded synchronization delay, and local Rees extensions? The\nfirst obvious answer is that each of these notions relates to topics of\ninterest for WORDS: Church-Rosser systems are certain rewriting systems over\nwords, codes are given by sets of words which form a basis of a free submonoid\nin the free monoid of all words (over a given alphabet) and local Rees\nextensions provide structural insight into regular languages over words. So, it\nseems to be a legitimate title for an extended abstract presented at the\nconference WORDS 2017. However, this work is more ambitious, it outlines some\nless obvious but much more interesting link between these topics. This link is\nbased on a structure theory of finite monoids with varieties of groups and the\nconcept of local divisors playing a prominent role. Parts of this work appeared\nin a similar form in conference proceedings where proofs and further material\ncan be found.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.00101v1"
    },
    {
        "title": "Streamability of nested word transductions",
        "authors": [
            "Emmanuel Filiot",
            "Olivier Gauwin",
            "Pierre-Alain Reynier",
            "Frédéric Servais"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider the problem of evaluating in streaming (i.e., in a single\nleft-to-right pass) a nested word transduction with a limited amount of memory.\nA transduction T is said to be height bounded memory (HBM) if it can be\nevaluated with a memory that depends only on the size of T and on the height of\nthe input word. We show that it is decidable in coNPTime for a nested word\ntransduction defined by a visibly pushdown transducer (VPT), if it is HBM. In\nthis case, the required amount of memory may depend exponentially on the height\nof the word. We exhibit a sufficient, decidable condition for a VPT to be\nevaluated with a memory that depends quadratically on the height of the word.\nThis condition defines a class of transductions that strictly contains all\ndeterminizable VPTs.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.00527v3"
    },
    {
        "title": "Linear Parsing Expression Grammars",
        "authors": [
            "Nariyoshi Chida",
            "Kimio Kuramitsu"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  PEGs were formalized by Ford in 2004, and have several pragmatic operators\n(such as ordered choice and unlimited lookahead) for better expressing modern\nprogramming language syntax. Since these operators are not explicitly defined\nin the classic formal language theory, it is significant and still challenging\nto argue PEGs' expressiveness in the context of formal language theory.Since\nPEGs are relatively new, there are several unsolved problems.One of the\nproblems is revealing a subclass of PEGs that is equivalent to DFAs. This\nallows application of some techniques from the theory of regular grammar to\nPEGs. In this paper, we define Linear PEGs (LPEGs), a subclass of PEGs that is\nequivalent to DFAs. Surprisingly, LPEGs are formalized by only excluding some\npatterns of recursive nonterminal in PEGs, and include the full set of ordered\nchoice, unlimited lookahead, and greedy repetition, which are characteristic of\nPEGs. Although the conversion judgement of parsing expressions into DFAs is\nundecidable in general, the formalism of LPEGs allows for a syntactical\njudgement of parsing expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.01814v2"
    },
    {
        "title": "State complexity of catenation combined with boolean operations",
        "authors": [
            "Pascal Caron",
            "Jean-Gabriel Luque",
            "Bruno Patrou"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We exhaustively investigate possible combinations of a boolean operation\ntogether with a catenation. In many cases we prove and improve some conjectures\nby Brzozowski. For each family of operation, we endeavour to provide a common\nwitness with a small size alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.03174v1"
    },
    {
        "title": "Two-Dimensional Pattern Languages",
        "authors": [
            "Henning Fernau",
            "Markus L. Schmid",
            "K. G. Subramanian"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce several classes of array languages obtained by generalising\nAngluin's pattern languages to the two-dimensional case. These classes of\ntwo-dimensional pattern languages are compared with respect to their expressive\npower and their closure properties are investigated.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04083v1"
    },
    {
        "title": "A Polynomial Time Match Test for Large Classes of Extended Regular\n  Expressions",
        "authors": [
            "Daniel Reidenbach",
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In the present paper, we study the match test for extended regular\nexpressions. We approach this NP-complete problem by introducing a novel\nvariant of two-way multihead automata, which reveals that the complexity of the\nmatch test is determined by a hidden combinatorial property of extended regular\nexpressions, and it shows that a restriction of the corresponding parameter\nleads to rich classes with a polynomial time match test. For presentational\nreasons, we use the concept of pattern languages in order to specify extended\nregular expressions. While this decision, formally, slightly narrows the scope\nof our results, an extension of our concepts and results to more general\nnotions of extended regular expressions is straightforward.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04097v1"
    },
    {
        "title": "PAWS: A Tool for the Analysis of Weighted Systems",
        "authors": [
            "Barbara König",
            "Sebastian Küpper",
            "Christina Mika"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  PAWS is a tool to analyse the behaviour of weighted automata and conditional\ntransition systems. At its core PAWS is based on a generic implementation of\nalgorithms for checking language equivalence in weighted automata and\nbisimulation in conditional transition systems. This architecture allows for\nthe use of arbitrary user-defined semirings. New semirings can be generated\nduring run-time and the user can rely on numerous automatisation techniques to\ncreate new semiring structures for PAWS' algorithms. Basic semirings such as\ndistributive complete lattices and fields of fractions can be defined by\nspecifying few parameters, more exotic semirings can be generated from other\nsemirings or defined from scratch using a built-in semiring generator. In the\nmost general case, users can define new semirings by programming (in C#) the\nbase operations of the semiring and a procedure to solve linear equations and\nuse their newly generated semiring in the analysis tools that PAWS offers.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04125v1"
    },
    {
        "title": "Automatic Randomness Tests",
        "authors": [
            "Birzhan Moldagaliyev"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we define a notion of automatic randomness tests (ART) which\ncapture measure theoretic typicalness of infinite binary sequences within the\nframework of automata theory. An individual ART is found to be equivalent to a\ndeterministic B\\\"{u}chi automaton recognizing $\\omega$-language of (Lebesgue)\nmeasure zero. A collection of ART's induce a notion of automatic random\nsequence. We provide a purely combinatorial characterization of an automatic\nrandom sequence in the form of a disjunctive property for sequences. At last,\nwe compare two kinds of automatic randomness tests presented in this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04160v2"
    },
    {
        "title": "Outfix-guided insertion",
        "authors": [
            "Da-Jung Cho",
            "Yo-Sub Han",
            "Timothy Ng",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Motivated by work on bio-operations on DNA strings, we consider an\noutfix-guided insertion operation that can be viewed as a generalization of the\noverlap assembly operation on strings studied previously. As the main result we\nconstruct a finite language $L$ such that the outfix-guided insertion closure\nof $L$ is non-regular. We consider also the closure properties of regular and\n(deterministic) context-free languages under the outfix-guided insertion\noperation and decision problems related to outfix-guided insertion. Deciding\nwhether a language recognized by a deterministic finite automaton is closed\nunder outfix-guided insertion can be done in polynomial time. The complexity of\nthe corresponding question for nondeterministic finite automata remains open.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04651v1"
    },
    {
        "title": "Language Approximation With One-Counter Automata",
        "authors": [
            "Alexander Sakharov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present a method for approximating context-free languages with one-counter\nautomata. This approximation allows the reconstruction of parse trees of the\noriginal grammar. We identify a decidable superset of regular languages whose\nelements, i.e. languages, are recognized by one-counter automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.07670v1"
    },
    {
        "title": "Generalized Results on Monoids as Memory",
        "authors": [
            "Özlem Salehi",
            "Flavio D'Alessandro",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We show that some results from the theory of group automata and monoid\nautomata still hold for more general classes of monoids and models. Extending\nprevious work for finite automata over commutative groups, we demonstrate a\ncontext-free language that can not be recognized by any rational monoid\nautomaton over a finitely generated permutable monoid. We show that the class\nof languages recognized by rational monoid automata over finitely generated\ncompletely simple or completely 0-simple permutable monoids is a semi-linear\nfull trio. Furthermore, we investigate valence pushdown automata, and prove\nthat they are only as powerful as (finite) valence automata. We observe that\ncertain results proven for monoid automata can be easily lifted to the case of\ncontext-free valence grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.09793v2"
    },
    {
        "title": "Careful synchronization of partial deterministic finite automata",
        "authors": [
            "Hanan Shabana",
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We approach the task of computing a carefully synchronizing word of optimum\nlength for a given partial deterministic automaton, encoding the problem as an\ninstance of SAT and invoking a SAT solver. Our experiments demonstrate that\nthis approach gives satisfactory results for automata with up to 100 states\neven if very modest computational resources are used. We compare our results\nwith the ones obtained by the first author for exact synchronization, which is\nanother version of synchronization studied in the literature, and draw some\ntheoretical conclusions.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.01045v2"
    },
    {
        "title": "Polynomial time algorithms for inclusion and equivalence of\n  deterministic omega acceptors",
        "authors": [
            "Dana Angluin",
            "Dana Fisman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The class of omega languages recognized by deterministic parity acceptors\n(DPAs) or deterministic Muller acceptors (DMAs) is exactly the regular omega\nlanguages. The inclusion problem is the following: given two acceptors A1 and\nA2, determine whether the language recognized by A1 is a subset of the language\nrecognized by A2, and if not, return an ultimately periodic omega word accepted\nby A1 but not A2. We describe polynomial time algorithms to solve this problem\nfor two DPAs and for two DMAs. Corollaries include polynomial time algorithms\nto solve the equivalence problem for DPAs and DMAs, and also the inclusion and\nequivalence problems for deterministic Buechi and coBuechi acceptors.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.03191v3"
    },
    {
        "title": "Revisiting Underapproximate Reachability for Multipushdown Systems",
        "authors": [
            "S. Akshay",
            "Paul Gastin",
            "S Krishna",
            "Sparsa Roychowdhury"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Boolean programs with multiple recursive threads can be captured as pushdown\nautomata with multiple stacks. This model is Turing complete, and hence, one is\noften interested in analyzing a restricted class that still captures useful\nbehaviors. In this paper, we propose a new class of bounded under\napproximations for multi-pushdown systems, which subsumes most existing\nclasses. We develop an efficient algorithm for solving the under-approximate\nreachability problem, which is based on efficient fix-point computations. We\nimplement it in our tool BHIM and illustrate its applicability by generating a\nset of relevant benchmarks and examining its performance. As an additional\ntakeaway, BHIM solves the binary reachability problem in pushdown automata. To\nshow the versatility of our approach, we then extend our algorithm to the timed\nsetting and provide the first implementation that can handle timed\nmulti-pushdown automata with closed guards.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.05950v2"
    },
    {
        "title": "The monitoring problem for timed automata",
        "authors": [
            "Alejandro Grez",
            "Filip Mazowiecki",
            "Michał Pilipczuk",
            "Gabriele Puppis",
            "Cristian Riveros"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study a variant of the classical membership problem in automata theory,\nwhich consists of deciding whether a given input word is accepted by a given\nautomaton. We do so under a different perspective, that is, we consider a\ndynamic version of the problem, called monitoring problem, where the automaton\nis fixed and the input is revealed as in a stream, one symbol at a time\nfollowing the natural order on positions. The goal here is to design a dynamic\ndata structure that can be queried about whether the word consisting of symbols\nrevealed so far is accepted by the automaton, and that can be efficiently\nupdated when the next symbol is revealed. We provide complexity bounds for this\nmonitoring problem, by considering timed automata that process symbols\ninterleaved with timestamps. The main contribution is that monitoring of a\none-clock timed automaton, with all its components but the clock constants\nfixed, can be done in amortised constant time per input symbol.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07049v1"
    },
    {
        "title": "The upper density of an automatic set is rational",
        "authors": [
            "Jason P. Bell"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Given a natural number $k\\ge 2$ and a $k$-automatic set $S$ of natural\nnumbers, we show that the lower density and upper density of $S$ are\nrecursively computable rational numbers and we provide an algorithm for\ncomputing these quantities. In addition, we show that for every natural number\n$k\\ge 2$ and every pair of rational numbers $(\\alpha,\\beta)$ with\n$0<\\alpha<\\beta<1$ or with $(\\alpha,\\beta)\\in \\{(0,0),(1,1)\\}$ there is a\n$k$-automatic subset of the natural numbers whose lower density and upper\ndensity are $\\alpha$ and $\\beta$ respectively, and we show that these are\nprecisely the values that can occur as the lower and upper densities of an\nautomatic set.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07256v2"
    },
    {
        "title": "Playing Against Opponents With Limited Memory",
        "authors": [
            "Dhananjay Raju",
            "Rüdiger Ehlers",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study \\emph{partial-information} two-player turn-based games on graphs\nwith omega-regular objectives, when the partial-information player has\n\\emph{limited memory}. Such games are a natural formalization for reactive\nsynthesis when the environment player is not genuinely adversarial to the\nsystem player. The environment player has goals of its own, but the exact goal\nof the environment player is unknown to the system player. We prove that the\nproblem of determining the existence of a winning strategy for the system\nplayer is PSPACE-hard for reachability, safety, and parity objectives.\nMoreover, when the environment player is memoryless, the problem is\nPSPACE-complete. However, it is simpler to decide if the environment player has\na winning strategy; it is only NP-complete. Additionally, we construct a game\nwhere the the partial-information player needs at least $\\mathcal{O}(\\sqrt{n})$\nbits of memory to retain winning strategies in a game of size $\\mathcal{O}(n)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07274v1"
    },
    {
        "title": "On Succinctness and Recognisability of Alternating Good-for-Games\n  Automata",
        "authors": [
            "Udi Boker",
            "Denis Kuperberg",
            "Karoliina Lehtinen",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study alternating good-for-games (GFG) automata, i.e., alternating\nautomata where both conjunctive and disjunctive choices can be resolved in an\nonline manner, without knowledge of the suffix of the input word still to be\nread. We show that they can be exponentially more succinct than both their\nnondeterministic and universal counterparts. Furthermore, we lift many results\nfrom nondeterministic parity GFG automata to alternating ones: a single\nexponential determinisation procedure, an Exptime upper bound to the GFGness\nproblem, a PTime algorithm for the GFGness problem of weak automata, and a\nreduction from a positive solution to the $G_2$ conjecture to a PTime algorithm\nfor the GFGness problem of parity automata with a fixed index. The $G_2$\nconjecture states that a nondeterministic parity automaton A is GFG if and only\nif a token game, known as the $G_2$ game, played on A is won by the first\nplayer. So far, it had only been proved for B\\\"uchi automata; we provide\nfurther evidence for it by proving it for coB\\\"uchi automata. We also study the\ncomplexity of deciding \"half-GFGness\", a property specific to alternating\nautomata that only requires nondeterministic choices to be resolved in an\nonline manner. We show that this problem is strictly more difficult than\nGFGness check, already for alternating automata on finite words.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07278v1"
    },
    {
        "title": "Regular resynchronizability of origin transducers is undecidable",
        "authors": [
            "Denis Kuperberg",
            "Jan Martens"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the relation of containment up to unknown regular resynchronization\nbetween two-way non-deterministic transducers. We show that it constitutes a\npreorder, and that the corresponding equivalence relation is properly\nintermediate between origin equivalence and classical equivalence. We give a\nsyntactical characterization for containment of two transducers up to\nresynchronization, and use it to show that this containment relation is\nundecidable already for one-way non-deterministic transducers, and for simple\nclasses of resynchronizations. This answers the open problem stated in recent\nworks, asking whether this relation is decidable for two-way non-deterministic\ntransducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07558v3"
    },
    {
        "title": "Better Automata through Process Algebra",
        "authors": [
            "Rance Cleaveland"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This paper shows how the use of Structural Operational Semantics (SOS) in the\nstyle popularized by the process-algebra community can lead to a more succinct\nand useful construction for building finite automata from regular expressions.\nSuch constructions have been known for decades, and form the basis for the\nproofs of one direction of Kleene's Theorem. The purpose of the new\nconstruction is, on the one hand, to show students how small automata can be\nconstructed, without the need for empty transitions, and on the other hand to\nshow how the construction method admits closure proofs of regular languages\nwith respect to other operators as well. These results, while not theoretically\nsurprising, point to an additional influence of process-algebraic research: in\naddition to providing fundamental insights into the nature of concurrent\ncomputation, it also sheds new light on old, well-known constructions in\nautomata theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07562v1"
    },
    {
        "title": "On polynomial recursive sequences",
        "authors": [
            "Michaël Cadilhac",
            "Filip Mazowiecki",
            "Charles Paperman",
            "Michał Pilipczuk",
            "Géraud Sénizergues"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the expressive power of polynomial recursive sequences, a nonlinear\nextension of the well-known class of linear recursive sequences. These\nsequences arise naturally in the study of nonlinear extensions of weighted\nautomata, where (non)expressiveness results translate to class separations. A\ntypical example of a polynomial recursive sequence is b_n=n!. Our main result\nis that the sequence u_n=n^n is not polynomial recursive.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.08630v1"
    },
    {
        "title": "Equivalence Testing of Weighted Automata over Partially Commutative\n  Monoids",
        "authors": [
            "V. Arvind",
            "Abhranil Chatterjee",
            "Rajit Datta",
            "Partha Mukhopadhyay"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study \\emph{multiplicity equivalence} testing of automata over partially\ncommutative monoids (pc monoids) and show efficient algorithms in special\ncases, exploiting the structure of the underlying non-commutation graph of the\nmonoid.\n  Specifically, if the clique cover number of the non-commutation graph (the\nminimum number of cliques covering the graph) of the pc monoid is a constant,\nwe obtain a deterministic quasi-polynomial time algorithm. As a consequence, we\nalso obtain the first deterministic quasi-polynomial time algorithms for\nmultiplicity equivalence testing of $k$-tape automata and for equivalence\ntesting of deterministic $k$-tape automata for constant $k$. Prior to this, a\nrandomized polynomial-time algorithm for the above problems was shown by\nWorrell [ICALP 2013].\n  We also consider pc monoids for which the non-commutation graphs have cover\nconsisting of at most $k$ cliques and star graphs for any constant $k$. We\nobtain randomized polynomial-time algorithm for multiplicity equivalence\ntesting of automata over such monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.08633v2"
    },
    {
        "title": "Combining Partial Specifications using Alternating Interface Automata",
        "authors": [
            "Ramon Janssen"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  To model real-world software systems, modelling paradigms should support a\nform of compositionality. In interface theory and model-based testing with\ninputs and outputs, conjunctive operators have been introduced: the behaviour\nallowed by composed specification s1 $\\wedge$ s2 is the behaviour allowed by\nboth partial models s1 and s2. The models at hand are non-deterministic\ninterface automata, but the interaction between non-determinism and conjunction\nis not yet well understood. On the other hand, in the theory of alternating\nautomata, conjunction and non-determinism are core aspects. Alternating\nautomata have not been considered in the context of inputs and outputs, making\nthem less suitable for modelling software interfaces. In this paper, we combine\nthe two modelling paradigms to define alternating interface automata (AIA). We\nequip these automata with an observational, trace-based semantics, and define\ntesters, to establish correctness of black-box interfaces with respect to an\nAIA specification.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.08754v1"
    },
    {
        "title": "First-order tree-to-tree functions",
        "authors": [
            "Mikołaj Bojańczyk",
            "Amina Doumane"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study tree-to-tree transformations that can be defined in first-order\nlogic or monadic second-order logic. We prove a decomposition theorem, which\nshows that every transformation can be obtained from prime transformations,\nsuch as tree-to-tree homomorphisms or pre-order traversal, by using combinators\nsuch as function composition.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.09307v2"
    },
    {
        "title": "Wheeler Languages",
        "authors": [
            "Jarno Alanko",
            "Giovanna D'Agostino",
            "Alberto Policriti",
            "Nicola Prezza"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The recently introduced class of Wheeler graphs, inspired by the\nBurrows-Wheeler Transform (BWT) of a given string, admits an efficient index\ndata structure for searching for subpaths with a given path label, and lifts\nthe applicability of the Burrows-Wheeler transform from strings to languages.\nIn this paper we study the regular languages accepted by automata having a\nWheeler graph as transition function, and prove results on determination,\nMyhill_Nerode characterization, decidability, and closure properties for this\nclass of languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.10303v1"
    },
    {
        "title": "Connector algebras for C/E and P/T nets' interactions",
        "authors": [
            "Roberto Bruni",
            "Hernan Melgratti",
            "Ugo Montanari",
            "Pawel Sobocinski"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A quite flourishing research thread in the recent literature on\ncomponent-based systems is concerned with the algebraic properties of different\nclasses of connectors. In a recent paper, an algebra of stateless connectors\nwas presented that consists of five kinds of basic connectors, namely symmetry,\nsynchronization, mutual exclusion, hiding and inaction, plus their duals, and\nit was shown how they can be freely composed in series and in parallel to model\nsophisticated 'glues'. In this paper we explore the expressiveness of stateful\nconnectors obtained by adding one-place buffers or unbounded buffers to the\nstateless connectors. The main results are: i) we show how different classes of\nconnectors exactly correspond to suitable classes of Petri nets equipped with\ncompositional interfaces, called nets with boundaries; ii) we show that the\ndifference between strong and weak semantics in stateful connectors is\nreflected in the semantics of nets with boundaries by moving from the classic\nstep semantics (strong case) to a novel banking semantics (weak case), where a\nstep can be executed by taking some 'debit' tokens to be given back during the\nsame step; iii) we show that the corresponding bisimilarities are congruences\n(w.r.t. composition of connectors in series and in parallel); iv) we show that\nsuitable monoidality laws, like those arising when representing stateful\nconnectors in the tile model, can nicely capture concurrency (in the sense of\nstep semantics) aspects; and v) as a side result, we provide a basic algebra,\nwith a finite set of symbols, out of which we can compose all P/T nets with\nboundaries, fulfilling a long standing quest.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.0204v2"
    },
    {
        "title": "Conway and iteration hemirings",
        "authors": [
            "M. Droste",
            "Z. Esik",
            "W. Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Conway hemirings are Conway semirings without a multiplicative unit. We also\ndefine iteration hemirings as Conway hemirings satisfying certain identities\nassociated with the finite groups. Iteration hemirings are iteration semirings\nwithout a multiplicative unit. We provide an analysis of the relationship\nbetween Conway hemirings and (partial) Conway semirings and describe several\nfree constructions. In the second part of the paper we define and study\nhemimodules of Conway and iteration hemirings, and show their applicability in\nthe analysis of quantitative aspects of the infinitary behavior of weighted\ntransition systems. These include discounted and average computations of\nweights.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.0725v2"
    },
    {
        "title": "Single-tape and Multi-tape Turing machines through the lens of the\n  Grossone methodology",
        "authors": [
            "Yaroslav D. Sergeyev",
            "Alfredo Garro"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The paper investigates how the mathematical languages used to describe and to\nobserve automatic computations influence the accuracy of the obtained results.\nIn particular, we focus our attention on Single and Multi-tape Turing machines\nwhich are described and observed through the lens of a new mathematical\nlanguage which is strongly based on three methodological ideas borrowed from\nPhysics and applied to Mathematics, namely: the distinction between the object\n(we speak here about a mathematical object) of an observation and the\ninstrument used for this observation; interrelations holding between the object\nand the tool used for the observation; the accuracy of the observation\ndetermined by the tool. Results of the observation executed by the traditional\nand new languages are compared and discussed.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.3976v1"
    },
    {
        "title": "An Intensional Concurrent Faithful Encoding of Turing Machines",
        "authors": [
            "Thomas Given-Wilson"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The benchmark for computation is typically given as Turing computability; the\nability for a computation to be performed by a Turing Machine. Many languages\nexploit (indirect) encodings of Turing Machines to demonstrate their ability to\nsupport arbitrary computation. However, these encodings are usually by\nsimulating the entire Turing Machine within the language, or by encoding a\nlanguage that does an encoding or simulation itself. This second category is\ntypical for process calculi that show an encoding of lambda-calculus (often\nwith restrictions) that in turn simulates a Turing Machine. Such approaches\nlead to indirect encodings of Turing Machines that are complex, unclear, and\nonly weakly equivalent after computation. This paper presents an approach to\nencoding Turing Machines into intensional process calculi that is faithful,\nreduction preserving, and structurally equivalent. The encoding is demonstrated\nin a simple asymmetric concurrent pattern calculus before generalised to\nsimplify infinite terms, and to show encodings into Concurrent Pattern Calculus\nand Psi Calculi.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.0545v4"
    },
    {
        "title": "Breadth-first serialisation of trees and rational languages",
        "authors": [
            "Victor Marsault",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present here the notion of breadth-first signature and its relationship\nwith numeration system theory. It is the serialisation into an infinite word of\nan ordered infinite tree of finite degree. We study which class of languages\ncorresponds to which class of words and,more specifically, using a known\nconstruction from numeration system theory, we prove that the signature of\nrational languages are substitutive sequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.0798v1"
    },
    {
        "title": "Buchi Determinization Made Tighter",
        "authors": [
            "Cong Tian",
            "Zhenhua Duan"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  By separating the principal acceptance mechanism from the concrete acceptance\ncondition of a given B\\\"{u}chi automaton with $n$ states,Schewe presented the\nconstruction of an equivalent deterministic Rabin transition automaton with\n$o((1.65n)^n)$ states via \\emph{history trees}, which can be simply translated\nto a standard Rabin automaton with $o((2.26n)^n)$ states. Apart from the\ninherent simplicity, Schewe's construction improved Safra's construction (which\nrequires $12^nn^{2n}$ states). However, the price that is paid is the use of\n$2^{n-1}$ Rabin pairs (instead of $n$ in Safra's construction). Further, by\nintroducing the \\emph{later introduction record} as a record tailored for\nordered trees, deterministic automata with Parity acceptance condition is\nconstructed which exactly resembles Piterman's determinization with Parity\nacceptance condition where the state complexity is $O((n!)^2)$ and the index\ncomplexity is $2n$.In this paper, we improve Schewe's construction to\n$2^{\\lceil (n-1)/2\\rceil}$ Rabin pairs with the same state complexity.\nMeanwhile, we give a new determinization construction of Parity automata with\nthe state complexity being $o(n^2(0.69n\\sqrt{n})^n)$ and index complexity being\n$n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.1436v2"
    },
    {
        "title": "Learning cover context-free grammars from structural data",
        "authors": [
            "Mircea Marin",
            "Gabriel Istrate"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the problem of learning an unknown context-free grammar when the\nonly knowledge available and of interest to the learner is about its structural\ndescriptions with depth at most $\\ell.$ The goal is to learn a cover\ncontext-free grammar (CCFG) with respect to $\\ell$, that is, a CFG whose\nstructural descriptions with depth at most $\\ell$ agree with those of the\nunknown CFG. We propose an algorithm, called $LA^\\ell$, that efficiently learns\na CCFG using two types of queries: structural equivalence and structural\nmembership. We show that $LA^\\ell$ runs in time polynomial in the number of\nstates of a minimal deterministic finite cover tree automaton (DCTA) with\nrespect to $\\ell$. This number is often much smaller than the number of states\nof a minimum deterministic finite tree automaton for the structural\ndescriptions of the unknown grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.2409v1"
    },
    {
        "title": "Reset Complexity of Ideal Languages",
        "authors": [
            "Marina Maslennikova"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present a new characteristic of a regular ideal language called reset\ncomplexity. We find some bounds on the reset complexity in terms of the state\ncomplexity of a given language. We also compare the reset complexity and the\nstate complexity for languages related to slowly synchronizing automata and\nstudy uniqueness question for automata yielding the minimum of reset\ncomplexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.2816v1"
    },
    {
        "title": "Generating Synchronizing Automata with Large Reset Lengths",
        "authors": [
            "Andrzej Kisielewicz",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study synchronizing automata with the shortest reset words of relatively\nlarge length. First, we refine the Frankl-Pin result on the length of the\nshortest words of rank $m$, and the B\\'eal, Berlinkov, Perrin, and Steinberg\nresults on the length of the shortest reset words in one-cluster automata. The\nobtained results are useful in computation aimed in extending the class of\nsmall automata for which the \\v{C}ern\\'y conjecture is verified and discovering\nnew automata with special properties regarding synchronization.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.3311v4"
    },
    {
        "title": "On Upper and Lower Bounds on the Length of Alternating Towers",
        "authors": [
            "Štěpán Holub",
            "Galina Jirásková",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A tower between two regular languages is a sequence of strings such that all\nstrings on odd positions belong to one of the languages, all strings on even\npositions belong to the other language, and each string can be embedded into\nthe next string in the sequence. It is known that if there are towers of any\nlength, then there also exists an infinite tower. We investigate upper and\nlower bounds on the length of finite towers between two regular languages with\nrespect to the size of the automata representing the languages in the case\nthere is no infinite tower. This problem is relevant to the separation problem\nof regular languages by piecewise testable languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.4495v2"
    },
    {
        "title": "Cooperating distributed context-free hexagonal array grammar systems\n  with permitting contexts",
        "authors": [
            "Sujathakumari K",
            "Dersanambika K. S"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we associate permitting symbols with rules of Grammars in the\ncomponents of cooperating distributed context free hexagonal array grammar\nsystems as a control mechanism and investigating the generative power of the\nresulting systems in the terminal mode. This feature of associating permitting\nsymbols with rules when extended to patterns in the form of connected arrays\nalso requires checking of symbols, but this is simpler than usual pattern\nmatching. The benefit of allowing permitting symbols is that it enables us to\nreduce the number of components required in a cooperating distributed hexagonal\narray grammar system for generating a set of picture arrays.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.5393v1"
    },
    {
        "title": "Lipschitz Robustness of Finite-state Transducers",
        "authors": [
            "Thomas A. Henzinger",
            "Jan Otop",
            "Roopsha Samanta"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We investigate the problem of checking if a finite-state transducer is robust\nto uncertainty in its input. Our notion of robustness is based on the analytic\nnotion of Lipschitz continuity --- a transducer is K-(Lipschitz) robust if the\nperturbation in its output is at most K times the perturbation in its input. We\nquantify input and output perturbation using similarity functions. We show that\nK-robustness is undecidable even for deterministic transducers. We identify a\nclass of functional transducers, which admits a polynomial time\nautomata-theoretic decision procedure for K-robustness. This class includes\nMealy machines and functional letter-to-letter transducers. We also study\nK-robustness of nondeterministic transducers. Since a nondeterministic\ntransducer generates a set of output words for each input word, we quantify\noutput perturbation using set-similarity functions. We show that K-robustness\nof nondeterministic transducers is undecidable, even for letter-to-letter\ntransducers. We identify a class of set-similarity functions which admit\ndecidable K-robustness of letter-to-letter transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6452v2"
    },
    {
        "title": "Complexity of Atoms, Combinatorially",
        "authors": [
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Atoms of a (regular) language $L$ were introduced by Brzozowski and Tamm in\n2011 as intersections of complemented and uncomplemented quotients of $L$. They\nderived tight upper bounds on the complexity of atoms in 2013. In 2014,\nBrzozowski and Davies characterized the regular languages meeting these bounds.\nTo achieve these results, they used the so-called \"atomaton\" of a language,\nintroduced by Brzozowski and Tamm in 2011. In this note we give an alternative\nproof of their characterization, via a purely combinatorial approach.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6632v3"
    },
    {
        "title": "Stability and Complexity of Minimising Probabilistic Automata",
        "authors": [
            "Stefan Kiefer",
            "Björn Wachter"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the state-minimisation problem for weighted and probabilistic\nautomata. We provide a numerically stable polynomial-time minimisation\nalgorithm for weighted automata, with guaranteed bounds on the numerical error\nwhen run with floating-point arithmetic. Our algorithm can also be used for\n\"lossy\" minimisation with bounded error. We show an application in image\ncompression. In the second part of the paper we study the complexity of the\nminimisation problem for probabilistic automata. We prove that the problem is\nNP-hard and in PSPACE, improving a recent EXPTIME-result.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6673v2"
    },
    {
        "title": "Synchronizing automata with random inputs",
        "authors": [
            "Vladimir V. Gusev"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the problem of synchronization of automata with random inputs. We\npresent a series of automata such that the expected number of steps until\nsynchronization is exponential in the number of states. At the same time, we\nshow that the expected number of letters to synchronize any pair of the famous\nCerny automata is at most cubic in the number of states.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6731v1"
    },
    {
        "title": "SReach: A Bounded Model Checker for Stochastic Hybrid Systems",
        "authors": [
            "Qinsi Wang",
            "Paolo Zuliani",
            "Soonho Kong",
            "Sicun Gao",
            "Edmund M. Clarke"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we describe a new tool, SReach, which solves probabilistic\nbounded reachability problems for two classes of stochastic hybrid systems. The\nfirst one is (nonlinear) hybrid automata with parametric uncertainty. The\nsecond one is probabilistic hybrid automata with additional randomness for both\ntransition probabilities and variable resets. Standard approaches to\nreachability problems for linear hybrid systems require numerical solutions for\nlarge optimization problems, and become infeasible for systems involving both\nnonlinear dynamics over the reals and stochasticity. Our approach encodes\nstochastic information by using random variables, and combines the randomized\nsampling, a $\\delta$-complete decision procedure, and statistical tests. SReach\nutilizes the $\\delta$-complete decision procedure to solve reachability\nproblems in a sound manner, i.e., it always decides correctly if, for a given\nassignment to all random variables, the system actually reaches the unsafe\nregion. The statistical tests adapted guarantee arbitrary small error bounds\nbetween probabilities estimated by SReach and real ones. Compared to standard\nsimulation-based methods, our approach supports non-deterministic branching,\nincreases the coverage of simulation, and avoids the zero-crossing problem. We\ndemonstrate our method's feasibility by applying SReach to three representative\nbiological models and to additional benchmarks for nonlinear hybrid systems\nwith multiple probabilistic system parameters.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.7206v2"
    },
    {
        "title": "The Degree of Squares is an Atom (Extended Version)",
        "authors": [
            "Jörg Endrullis",
            "Clemens Grabmayer",
            "Dimitri Hendriks",
            "Hans Zantema"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We answer an open question in the theory of degrees of infinite sequences\nwith respect to transducibility by finite-state transducers. An initial study\nof this partial order of degrees was carried out in (Endrullis, Hendriks, Klop,\n2011), but many basic questions remain unanswered. One of the central questions\nconcerns the existence of atom degrees, other than the degree of the `identity\nsequence' 1 0^0 1 0^1 1 0^2 1 0^3 .... A degree is called an `atom' if below it\nthere is only the bottom degree 0, which consists of the ultimately periodic\nsequences. We show that also the degree of the `squares sequence' 1 0^0 1 0^1 1\n0^4 1 0^9 1 0^{16} ... is an atom. As the main tool for this result we\ncharacterise the transducts of `spiralling' sequences and their degrees. We use\nthis to show that every transduct of a `polynomial sequence' either is in 0 or\ncan be transduced back to a polynomial sequence for a polynomial of the same\norder.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.00884v1"
    },
    {
        "title": "Lipschitz Robustness of Timed I/O Systems",
        "authors": [
            "Thomas A. Henzinger",
            "Jan Otop",
            "Roopsha Samanta"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We present the first study of robustness of systems that are both timed as\nwell as reactive (I/O). We study the behavior of such timed I/O systems in the\npresence of \"uncertain inputs\" and formalize their robustness using the\nanalytic notion of Lipschitz continuity. Thus, a timed I/O system is\nK-(Lipschitz) robust if the perturbation in its output is at most K times the\nperturbation in its input. We quantify input and output perturbation using\n\"similarity functions\" over timed words such as the timed version of the\nManhattan distance and the Skorokhod distance. We consider two models of timed\nI/O systems --- timed transducers and asynchronous sequential circuits. While\nK-robustness is undecidable even for discrete transducers, we identify a class\nof timed transducers which admits a polynomial space decision procedure for\nK-robustness. For asynchronous sequential circuits, we reduce K-robustness\nw.r.t. timed Manhattan distances to K-robusness of discrete letter-to-letter\ntransducers and show PSPACE-compeleteness of the problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.01233v1"
    },
    {
        "title": "Index problems for game automata",
        "authors": [
            "Alessandro Facchini",
            "Filip Murlak",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  For a given regular language of infinite trees, one can ask about the minimal\nnumber of priorities needed to recognize this language with a\nnon-deterministic, alternating, or weak alternating parity automaton. These\nquestions are known as, respectively, the non-deterministic, alternating, and\nweak Rabin-Mostowski index problems. Whether they can be answered effectively\nis a long-standing open problem, solved so far only for languages recognizable\nby deterministic automata (the alternating variant trivializes).\n  We investigate a wider class of regular languages, recognizable by so-called\ngame automata, which can be seen as the closure of deterministic ones under\ncomplementation and composition. Game automata are known to recognize languages\narbitrarily high in the alternating Rabin-Mostowski index hierarchy; that is,\nthe alternating index problem does not trivialize any more.\n  Our main contribution is that all three index problems are decidable for\nlanguages recognizable by game automata. Additionally, we show that it is\ndecidable whether a given regular language can be recognized by a game\nautomaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02153v2"
    },
    {
        "title": "Uniform generation in trace monoids",
        "authors": [
            "Samy Abbes",
            "Jean Mairesse"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider the problem of random uniform generation of traces (the elements\nof a free partially commutative monoid) in light of the uniform measure on the\nboundary at infinity of the associated monoid. We obtain a product\ndecomposition of the uniform measure at infinity if the trace monoid has\nseveral irreducible components-a case where other notions such as Parry\nmeasures, are not defined. Random generation algorithms are then examined.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02455v1"
    },
    {
        "title": "Bottom Up Quotients and Residuals for Tree Languages",
        "authors": [
            "Jean-Marc Champarnaud",
            "Ludovic Mignot",
            "Nadia Ouali-Sebti",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper, we extend the notion of tree language quotients to bottom-up\nquotients. Instead of computing the residual of a tree language from top to\nbottom and producing a list of tree languages, we show how to compute a set of\nk-ary trees, where k is an arbitrary integer. We define the quotient formula\nfor different combinations of tree languages: union, symbol products,\ncompositions, iterated symbol products and iterated composition. These\ncomputations lead to the definition of the bottom-up quotient tree automaton,\nthat turns out to be the minimal deterministic tree automaton associated with a\nregular tree language in the case of the 0-ary trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02863v1"
    },
    {
        "title": "Syntactic semigroup problem for the semigroup reducts of Affine\n  Near-semirings over Brandt Semigroups",
        "authors": [
            "Jitender Kumar",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The syntactic semigroup problem is to decide whether a given finite semigroup\nis syntactic or not. This work investigates the syntactic semigroup problem for\nboth the semigroup reducts of $A^+(B_n)$, the affine near-semiring over a\nBrandt semigroup $B_n$. It is ascertained that both the semigroup reducts of\n$A^+(B_n)$ are syntactic semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02972v1"
    },
    {
        "title": "Formalization of closure properties for context-free grammars",
        "authors": [
            "Marcus V. M. Ramos",
            "Ruy J. G. B. de Queiroz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Context-free language theory is a well-established area of mathematics,\nrelevant to computer science foundations and technology. This paper presents\nthe preliminary results of an ongoing formalization project using context-free\ngrammars and the Coq proof assistant. The results obtained so far include the\nrepresentation of context-free grammars, the description of algorithms for some\noperations on them (union, concatenation and closure) and the proof of related\ntheorems (e.g. the correctness of these algorithms). A brief survey of related\nworks is presented, as well as plans for further development.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.03428v1"
    },
    {
        "title": "Algebraic Characterization of Forest Logics",
        "authors": [
            "Kitti Gelle",
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we define future-time branching temporal logics evaluated over\nforests, that is, ordered tuples of ordered, but unranked, finite trees. We\nassociate a rich class FL[$\\mathcal{L}$] of temporal logics to each set L of\n(regular) modalities. Then, we define an algebraic product operation which we\ncall the Moore product, which operates on forest automata, algebraic devices\nrecognizing forest languages. We show a lattice isomorphism between the\npseudovarieties of finite forest automata, closed under the Moore product, and\nthe classes of languages of the form FL[$\\mathcal{L}$]. We demonstrate the\nusefulness of the algebraic approach by showing the decidability of the\nmembership problem of a specific pseudovariety of finite forest automata,\nimplying the decidability of the definability problem of the FL[EF] fragment of\nthe logic CTL. Then, using the same approach, we also formulate a conjecture\nregarding a decidable characterization of the FL[AF] fragment which has\ncurrently an unknown decidability status (also in the setting of ranked trees).\n",
        "pdf_link": "http://arxiv.org/pdf/1506.03843v3"
    },
    {
        "title": "Aperiodic String Transducers",
        "authors": [
            "Luc Dartois",
            "Ismaël Jecker",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Regular string-to-string functions enjoy a nice triple characterization\nthrough deterministic two-way transducers (2DFT), streaming string transducers\n(SST) and MSO definable functions. This result has recently been lifted to FO\ndefinable functions, with equivalent representations by means of aperiodic 2DFT\nand aperiodic 1-bounded SST, extending a well-known result on regular\nlanguages. In this paper, we give three direct transformations: i) from\n1-bounded SST to 2DFT, ii) from 2DFT to copyless SST, and iii) from k-bounded\nto 1-bounded SST. We give the complexity of each construction and also prove\nthat they preserve the aperiodicity of transducers. As corollaries, we obtain\nthat FO definable string-to-string functions are equivalent to SST whose\ntransition monoid is finite and aperiodic, and to aperiodic copyless SST.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.04059v2"
    },
    {
        "title": "Self-assembling interactive modules: A research programme",
        "authors": [
            "Gheorghe Stefanescu"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we propose a research programme for getting structural\ncharacterisations for 2-dimensional languages generated by self-assembling\ntiles. This is part of a larger programme on getting a formal foundation of\nparallel, interactive, distributed systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.05499v1"
    },
    {
        "title": "Fluid Model Checking of Timed Properties",
        "authors": [
            "Luca Bortolussi",
            "Roberta Lanciani"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We address the problem of verifying timed properties of Markovian models of\nlarge populations of interacting agents, modelled as finite state automata. In\nparticular, we focus on time-bounded properties of (random) individual agents\nspecified by Deterministic Timed Automata (DTA) endowed with a single clock.\nExploiting ideas from fluid approximation, we estimate the satisfaction\nprobability of the DTA properties by reducing it to the computation of the\ntransient probability of a subclass of Time-Inhomogeneous Markov Renewal\nProcesses with exponentially and deterministically-timed transitions, and a\nsmall state space. For this subclass of models, we show how to derive a set of\nDelay Differential Equations (DDE), whose numerical solution provides a fast\nand accurate estimate of the satisfaction probability. In the paper, we also\nprove the asymptotic convergence of the approach, and exemplify the method on a\nsimple epidemic spreading model. Finally, we also show how to construct a\nsystem of DDEs to efficiently approximate the average number of agents that\nsatisfy the DTA specification.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.05909v1"
    },
    {
        "title": "A Nivat Theorem for Weighted Timed Automata and Weighted Relative\n  Distance Logic",
        "authors": [
            "Manfred Droste",
            "Vitaly Perevoshchikov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Weighted timed automata (WTA) model quantitative aspects of real-time systems\nlike continuous consumption of memory, power or financial resources. They\naccept quantitative timed languages where every timed word is mapped to a\nvalue, e.g., a real number. In this paper, we prove a Nivat theorem for WTA\nwhich states that recognizable quantitative timed languages are exactly those\nwhich can be obtained from recognizable boolean timed languages with the help\nof several simple operations. We also introduce a weighted extension of\nrelative distance logic developed by Wilke, and we show that our weighted\nrelative distance logic and WTA are equally expressive. The proof of this\nresult can be derived from our Nivat theorem and Wilke's theorem for relative\ndistance logic. Since the proof of our Nivat theorem is constructive, the\ntranslation process from logic to automata and vice versa is also constructive.\nThis leads to decidability results for weighted relative distance logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.06038v1"
    },
    {
        "title": "Towards an algebraic characterization of rational word functions",
        "authors": [
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In formal language theory, several different models characterize regular\nlanguages, such as finite automata, congruences of finite index, or monadic\nsecond-order logic (MSO). Moreover, several fragments of MSO have effective\ncharacterizations based on algebraic properties. When we consider transducers\ninstead of automata, such characterizations are much more challenging, because\nmany of the properties of regular languages do not generalize to regular word\nfunctions.\n  In this paper we consider word functions that are definable by one-way\ntransducers (rational functions). We show that the canonical bimachine of\nReutenauer and Sch\\\"utzenberger preserves certain algebraic properties of\nrational functions, similar to the case of word languages. In particular, we\ngive an effective characterization of functions that can be defined by an\naperiodic one-way transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.06497v1"
    },
    {
        "title": "Dipole Codes Attractively Encode Glue Functions",
        "authors": [
            "Dhananjay Ipparthi",
            "Massimo Mastrangeli",
            "Andrew Winslow"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Dipole words are sequences of magnetic dipoles, in which alike elements repel\nand opposite elements attract. Magnetic dipoles contrast with more general sets\nof bonding types, called glues, in which pairwise bonding strength is specified\nby a glue function. We prove that every glue function $g$ has a set of dipole\nwords, called a dipole code, that attractively encodes $g$: the pairwise\nattractions (positive or non-positive bond strength) between the words are\nidentical to those of $g$. Moreover, we give such word sets of asymptotically\noptimal length. Similar results are obtained for a commonly used subclass of\nglue functions.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.00779v1"
    },
    {
        "title": "On the State Complexity of the Shuffle of Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Galina Jirásková",
            "Bo Liu",
            "Aayush Rajasekaran",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate the shuffle operation on regular languages represented by\ncomplete deterministic finite automata. We prove that $f(m,n)=2^{mn-1} +\n2^{(m-1)(n-1)}(2^{m-1}-1)(2^{n-1}-1)$ is an upper bound on the state complexity\nof the shuffle of two regular languages having state complexities $m$ and $n$,\nrespectively. We also state partial results about the tightness of this bound.\nWe show that there exist witness languages meeting the bound if $2\\le m\\le 5$\nand $n\\ge2$, and also if $m=n=6$. Moreover, we prove that in the subset\nautomaton of the NFA accepting the shuffle, all $2^{mn}$ states can be\ndistinguishable, and an alphabet of size three suffices for that. It follows\nthat the bound can be met if all $f(m,n)$ states are reachable. We know that an\nalphabet of size at least $mn$ is required provided that $m,n \\ge 2$. The\nquestion of reachability, and hence also of the tightness of the bound $f(m,n)$\nin general, remains open.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.01187v3"
    },
    {
        "title": "Hankel Matrices for Weighted Visibly Pushdown Automata",
        "authors": [
            "Nadia Labai",
            "Johann A. Makowsky"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Hankel matrices (aka connection matrices) of word functions and graph\nparameters have wide applications in automata theory, graph theory, and machine\nlearning. We give a characterization of real-valued functions on nested words\nrecognized by weighted visibly pushdown automata in terms of Hankel matrices on\nnested words. This complements C. Mathissen's characterization in terms of\nweighted monadic second order logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.02430v2"
    },
    {
        "title": "On the Uniform Random Generation of Non Deterministic Automata Up to\n  Isomorphism",
        "authors": [
            "Pierre-Cyrille Heam",
            "Jean-Luc Joly"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we address the problem of the uniform random generation of non\ndeterministic automata (NFA) up to isomorphism. First, we show how to use a\nMonte-Carlo approach to uniformly sample a NFA. Secondly, we show how to use\nthe Metropolis-Hastings Algorithm to uniformly generate NFAs up to isomorphism.\nUsing labeling techniques, we show that in practice it is possible to move into\nthe modified Markov Chain efficiently, allowing the random generation of NFAs\nup to isomorphism with dozens of states. This general approach is also applied\nto several interesting subclasses of NFAs (up to isomorphism), such as NFAs\nhaving a unique initial states and a bounded output degree. Finally, we prove\nthat for these interesting subclasses of NFAs, moving into the Metropolis\nMarkov chain can be done in polynomial time. Promising experimental results\nconstitute a practical contribution.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.02797v1"
    },
    {
        "title": "Distribution-based Bisimulation and Bisimulation Metric in Probabilistic\n  Automata",
        "authors": [
            "Yuan Feng",
            "Lei Song",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Probabilistic automata were introduced by Rabin in 1963 as language\nacceptors. Two automata are equivalent if and only if they accept each word\nwith the same probability. On the other side, in the process algebra community,\nprobabilistic automata were re-proposed by Segala in 1995 which are more\ngeneral than Rabin's automata. Bisimulations have been proposed for Segala's\nautomata to characterize the equivalence between them. So far the two notions\nof equivalences and their characteristics have been studied mostly\nindependently. In this paper, we consider Segala's automata, and propose a\nnovel notion of distribution-based bisimulation by joining the existing\nequivalence and bisimilarities. We demonstrate the utility of our definition by\nstudying distribution-based bisimulation metrics, which gives rise to a robust\nnotion of equivalence for Rabin's automata. We compare our notions of\nbisimulation to some existing distribution-based bisimulations and discuss\ntheir compositionality and relations to trace equivalence. Finally, we show the\ndecidability and complexity of all relations.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.05027v1"
    },
    {
        "title": "On the Hierarchy of Block Deterministic Languages",
        "authors": [
            "Pascal Caron",
            "Ludovic Mignot",
            "Clément Miklarz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A regular language is $k$-lookahead deterministic (resp. $k$-block\ndeterministic) if it is specified by a $k$-lookahead deterministic (resp.\n$k$-block deterministic) regular expression. These two subclasses of regular\nlanguages have been respectively introduced by Han and Wood ($k$-lookahead\ndeterminism) and by Giammarresi et al. ($k$-block determinism) as a possible\nextension of one-unambiguous languages defined and characterized by\nBr\\\"uggemann-Klein and Wood. In this paper, we study the hierarchy and the\ninclusion links of these families. We first show that each $k$-block\ndeterministic language is the alphabetic image of some one-unambiguous\nlanguage. Moreover, we show that the conversion from a minimal DFA of a\n$k$-block deterministic regular language to a $k$-block deterministic automaton\nnot only requires state elimination, and that the proof given by Han and Wood\nof a proper hierarchy in $k$-block deterministic languages based on this result\nis erroneous. Despite these results, we show by giving a parameterized family\nthat there is a proper hierarchy in $k$-block deterministic regular languages.\nWe also prove that there is a proper hierarchy in $k$-lookahead deterministic\nregular languages by studying particular properties of unary regular\nexpressions. Finally, using our valid results, we confirm that the family of\n$k$-block deterministic regular languages is strictly included into the one of\n$k$-lookahead deterministic regular languages by showing that any $k$-block\ndeterministic unary language is one-unambiguous.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.05475v1"
    },
    {
        "title": "Random Generation and Enumeration of Accessible Determinisitic Real-time\n  Pushdown Automata",
        "authors": [
            "Pierre-Cyrille Héam",
            "Jean-Luc Joly"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This papers presents a general framework for the uniform random generation of\ndeterministic real-time accessible pushdown automata. A polynomial time\nalgorithm to randomly generate a pushdown automaton having a fixed stack\noperations total size is proposed. The influence of the accepting condition\n(empty stack, final state) on the reachability of the generated automata is\ninvestigated.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.05881v1"
    },
    {
        "title": "State machines for large scale computer software and systems",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This paper introduces techniques for specifying behavior, architecture, and\nabstract properties of large scale computer software and hardware purely in\nterms of ordinary deterministic state machines. The goal is to be able to work\nwith specifications ranging from operating systems to databases and real-time\ncontrol. State machines with output are represented as maps from finite\nsequences of events to outputs so that f(s) is the output in the state reached\nby following s from a initial state. Composite sequence maps correspond to\nstate machine products. The methods used here can specify or constrain both\nsystem behavior and system design. Motivating examples presented range from\nsimple counters to distributed consensus algorithms and real-time circuits. The\napproach is intended to facilitate \"back of the envelope\" descriptions of\ndevices and software and also to allow for detailed hierarchical specifications\nof behavior and architecture.\n  The mathematical approach is based on both primitive recursion on sequences\n\\cite{PeterComputer} and automata products with feedback \\cite{Gecseg}, adapted\nto Moore type state machines. No formal methods or other metamathematical\ntechniques are employed and although parallel and concurrent composite systems\nare easy to specify, it is not necessary to make any particular communication\nscheme primitive. State machines are not augmented or extended - even the most\ncomplex composite systems are modeled by ordinary deterministic state machines\nwhich have a rich mathematical theory related to semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.06788v4"
    },
    {
        "title": "Quick Brown Fox in Formal Languages",
        "authors": [
            "Kazuhiro Inaba"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Given a finite alphabet $\\Sigma$ and a deterministic finite automaton on\n$\\Sigma$, the problem of determining whether the language recognized by the\nautomaton contains any pangram is \\NP-complete. Various other language classes\nand problems around pangrams are analyzed.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.08168v5"
    },
    {
        "title": "Reduction of Nondeterministic Tree Automata",
        "authors": [
            "Ricardo Almeida",
            "Lukáš Holík",
            "Richard Mayr"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We present an efficient algorithm to reduce the size of nondeterministic tree\nautomata, while retaining their language. It is based on new transition pruning\ntechniques, and quotienting of the state space w.r.t. suitable equivalences. It\nuses criteria based on combinations of downward and upward simulation preorder\non trees, and the more general downward and upward language inclusions. Since\ntree-language inclusion is EXPTIME-complete, we describe methods to compute\ngood approximations in polynomial time. We implemented our algorithm as a\nmodule of the well-known libvata tree automata library, and tested its\nperformance on a given collection of tree automata from various applications of\nlibvata in regular model checking and shape analysis, as well as on various\nclasses of randomly generated tree automata. Our algorithm yields substantially\nsmaller and sparser automata than all previously known reduction techniques,\nand it is still fast enough to handle large instances.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.08823v2"
    },
    {
        "title": "Around Context-Free Grammars -- a Normal Form, a Representation Theorem,\n  and a Regular Approximation",
        "authors": [
            "Liliana Cojocaru"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We introduce a normal form for context-free grammars, called Dyck normal\nform. This is a syntactical restriction of the Chomsky normal form, in which\nthe two nonterminals occurring on the right-hand side of a rule are paired\nnonterminals. This pairwise property allows to define a homomorphism from Dyck\nwords to words generated by a grammar in Dyck normal form. We prove that for\neach context-free language L, there exist an integer K and a homomorphism h\nsuch that L=h(D'_K), where D'_K is a subset of the one-sided Dyck language over\nK letters. Through a transition-like diagram for a context-free grammar in Dyck\nnormal form, we effectively build a regular language R that satisfies the\nChomsky-Schutzenberger theorem. Using graphical approaches we refine R such\nthat the Chomsky-Schutzenberger theorem still holds. Based on this readjustment\nwe sketch a transition diagram for a regular grammar that generates a regular\nsuperset approximation for the initial context-free language.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.09207v1"
    },
    {
        "title": "On the number of gapped repeats with arbitrary gap",
        "authors": [
            "Roman Kolpakov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  For any functions $f(x)$, $g(x)$ from $\\mathbb {N}$ to $\\mathbb {R}$ we call\nrepeats $uvu$ such that $g(|u|)\\le |v|\\le f(|u|)$ as {\\it $f,g$-gapped\nrepeats}. We study the possible number of $f,g$-gapped repeats in words of\nfixed length~$n$. For quite weak conditions on $f(x)$, $g(x)$ we obtain an\nupper bound on this number which is linear to~$n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.01190v1"
    },
    {
        "title": "Backward deterministic and weak alternating $ω$-automata",
        "authors": [
            "Sebastian Preugschat",
            "Thomas Wilke"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present a direct transformation of weak alternating $\\omega$-automata into\nequivalent backward deterministic $\\omega$-automata and show (1) how it can be\nused to obtain a transformation of non-deterministic B\\\"uchi automata into\nequivalent backward deterministic automata and (2) that it yields optimal\nequivalent backward deterministic automata when applied to linear-time temporal\nlogic formulas. (1) uses the alternation-free fragment of the linear-time\n$\\mu$-calculus as an intermediate step; (2) is based on the straightforward\ntranslation of linear-time temporal logic into weak alternating\n$\\omega$-automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.01971v1"
    },
    {
        "title": "Untwisting two-way transducers in elementary time",
        "authors": [
            "Félix Baschenis",
            "Olivier Gauwin",
            "Anca Muscholl",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Functional transductions realized by two-way transducers (equivalently, by\nstreaming transducers and by MSO transductions) are the natural and standard\nnotion of \"regular\" mappings from words to words. It was shown recently\n(LICS'13) that it is decidable if such a transduction can be implemented by\nsome one-way transducer, but the given algorithm has non-elementary complexity.\nWe provide an algorithm of different flavor solving the above question, that\nhas double exponential space complexity. We further apply our technique to\ndecide whether the transduction realized by a two-way transducer can be\nimplemented by a sweeping transducer, with either known or unknown number of\npasses.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.02502v1"
    },
    {
        "title": "Regular Separability of One Counter Automata",
        "authors": [
            "Wojciech Czerwiński",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The regular separability problem asks, for two given languages, if there\nexists a regular language including one of them but disjoint from the other.\nOur main result is decidability, and PSpace-completeness, of the regular\nseparability problem for languages of one counter automata without zero tests\n(also known as one counter nets). This contrasts with undecidability of the\nregularity problem for one counter nets, and with undecidability of the regular\nseparability problem for one counter automata, which is our second result.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.02808v5"
    },
    {
        "title": "Complexity of regular bifix-free languages",
        "authors": [
            "Robert Ferens",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study descriptive complexity properties of the class of regular bifix-free\nlanguages, which is the intersection of prefix-free and suffix-free regular\nlanguages. We show that there exist a single ternary universal (stream of)\nbifix-free languages that meet all the bounds for the state complexity basic\noperations (Boolean operations, product, star, and reversal). This is in\ncontrast with suffix-free languages, where it is known that there does not\nexist such a stream. Then we present a stream of bifix-free languages that is\nmost complex in terms of all basic operations, syntactic complexity, and the\nnumber of atoms and their complexities, which requires a superexponential\nalphabet.\n  We also complete the previous results by characterizing state complexity of\nproduct, star, and reversal, and establishing tight upper bounds for atom\ncomplexities of bifix-free languages. We show that to meet the bound for\nreversal we require at least 3 letters and to meet the bound for atom\ncomplexities $n+1$ letters are sufficient and necessary. For the cases of\nproduct, star, and reversal we show that there are no gaps (magic numbers) in\nthe interval of possible state complexities of the languages resulted from an\noperation; in particular, the state complexity of the product $L_m L_n$ is\nalways $m+n-2$, while of the star is either $n-1$ or $n-2$.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.03768v1"
    },
    {
        "title": "Most Complex Non-Returning Regular Languages",
        "authors": [
            "Janusz A. Brzozowski",
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A regular language $L$ is non-returning if in the minimal deterministic\nfinite automaton accepting it there are no transitions into the initial state.\nEom, Han and Jir\\'askov\\'a derived upper bounds on the state complexity of\nboolean operations and Kleene star, and proved that these bounds are tight\nusing two different binary witnesses. They derived upper bounds for\nconcatenation and reversal using three different ternary witnesses. These five\nwitnesses use a total of six different transformations. We show that for each\n$n\\ge 4$ there exists a ternary witness of state complexity $n$ that meets the\nbound for reversal and that at least three letters are needed to meet this\nbound. Moreover, the restrictions of this witness to binary alphabets meet the\nbounds for product, star, and boolean operations. We also derive tight upper\nbounds on the state complexity of binary operations that take arguments with\ndifferent alphabets. We prove that the maximal syntactic semigroup of a\nnon-returning language has $(n-1)^n$ elements and requires at least\n$\\binom{n}{2}$ generators. We find the maximal state complexities of atoms of\nnon-returning languages. Finally, we show that there exists a most complex\nnon-returning language that meets the bounds for all these complexity measures.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.03944v1"
    },
    {
        "title": "Polynomial-Time Proactive Synthesis of Tree-to-String Functions from\n  Examples",
        "authors": [
            "Mikaël Mayer",
            "Jad Hamza",
            "Viktor Kuncak"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Synthesis from examples enables non-expert users to generate programs by\nspecifying examples of their behavior. A domain-specific form of such synthesis\nhas been recently deployed in a widely used spreadsheet software product. In\nthis paper we contribute to foundations of such techniques and present a\ncomplete algorithm for synthesis of a class of recursive functions defined by\nstructural recursion over a given algebraic data type definition. The functions\nwe consider map an algebraic data type to a string; they are useful for, e.g.,\npretty printing and serialization of programs and data. We formalize our\nproblem as learning deterministic sequential top-down tree-to-string\ntransducers with a single state.\n  The first problem we consider is learning a tree-to-string transducer from\nany set of input/output examples provided by the user. We show that this\nproblem is NP-complete in general, but can be solved in polynomial time under a\n(practically useful) closure condition that each subtree of a tree in the\ninput/output example set is also part of the input/output examples.\n  Because coming up with relevant input/output examples may be difficult for\nthe user while creating hard constraint problems for the synthesizer, we also\nstudy a more automated active learning scenario in which the algorithm chooses\nthe inputs for which the user provides the outputs. Our algorithm asks a\nworst-case linear number of queries as a function of the size of the algebraic\ndata type definition to determine a unique transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.04288v2"
    },
    {
        "title": "Degree of sequentiality of weighted automata",
        "authors": [
            "Laure Daviaud",
            "Ismael Jecker",
            "Pierre-Alain Reynier",
            "Didier Villevalois"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Weighted automata (WA) are an important formalism to describe quantitative\nproperties. Obtaining equivalent deterministic machines is a longstanding\nresearch problem. In this paper we consider WA with a set semantics, meaning\nthat the semantics is given by the set of weights of accepting runs. We focus\non multi-sequential WA that are defined as finite unions of sequential WA. The\nproblem we address is to minimize the size of this union. We call this minimum\nthe degree of sequentiality of (the relation realized by) the WA. For a given\npositive integer k, we provide multiple characterizations of relations realized\nby a union of k sequential WA over an infinitary finitely generated group: a\nLipschitz-like machine independent property, a pattern on the automaton (a new\ntwinning property) and a subclass of cost register automata. When possible, we\neffectively translate a WA into an equivalent union of k sequential WA. We also\nprovide a decision procedure for our twinning property for commutative\ncomputable groups thus allowing to compute the degree of sequentiality. Last,\nwe show that these results also hold for word transducers and that the\nassociated decision problem is Pspace-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.04632v1"
    },
    {
        "title": "Up-To Techniques for Weighted Systems (Extended Version)",
        "authors": [
            "Filippo Bonchi",
            "Barbara König",
            "Sebastian Küpper"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We show how up-to techniques for (bi-)similarity can be used in the setting\nof weighted systems. The problems we consider are language equivalence,\nlanguage inclusion and the threshold problem (also known as universality\nproblem) for weighted automata. We build a bisimulation relation on the fly and\nwork up-to congruence and up-to similarity. This requires to determine whether\na pair of vectors (over a semiring) is in the congruence closure of a given\nrelation of vectors. This problem is considered for rings and l-monoids, for\nthe latter we provide a rewriting algorithm and show its confluence and\ntermination. We then explain how to apply these up-to techniques to weighted\nautomata and provide runtime results.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.05001v2"
    },
    {
        "title": "Minimization of Visibly Pushdown Automata Using Partial Max-SAT",
        "authors": [
            "Matthias Heizmann",
            "Christian Schilling",
            "Daniel Tischner"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider the problem of state-space reduction for nondeterministic\nweakly-hierarchical visibly pushdown automata (VPA). VPA recognize a robust and\nalgorithmically tractable fragment of context-free languages that is natural\nfor modeling programs.\n  We define an equivalence relation that is sufficient for language-preserving\nquotienting of VPA. Our definition allows to merge states that have different\nbehavior, as long as they show the same behavior for reachable equivalent\nstacks. We encode the existence of such a relation as a Boolean partial maximum\nsatisfiability (PMax-SAT) problem and present an algorithm that quickly finds\nsatisfying assignments. These assignments are sub-optimal solutions to the\nPMax-SAT problem but can still lead to a significant reduction of states.\n  We integrated our method in the automata-based software verifier Ultimate\nAutomizer and show performance improvements on benchmarks from the software\nverification competition SV-COMP.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.05160v2"
    },
    {
        "title": "A new lower bound for reset threshold of synchronizing automata with\n  sink state",
        "authors": [
            "Dmitry Ananichev"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present a new series of examples of binary slowly synchronizing automata\nwith sink state. The reset threshold of the $n$-state automaton in this series\nis $\\frac{n^2}{4}+2n-9$. This improves on the previously known lower bound for\nthe maximum reset threshold of binary synchronizing $n$-state automata with\nsink state.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.07954v1"
    },
    {
        "title": "Weighted omega-Restricted One Counter Automata",
        "authors": [
            "Manfred Droste",
            "Werner Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Let $S$ be a complete star-omega semiring and $\\Sigma$ be an alphabet. For a\nweighted $\\omega$-restricted one-counter automaton $\\mathcal{C}$ with set of\nstates $\\{1, \\dots, n\\}$, $n \\geq 1$, we show that there exists a mixed\nalgebraic system over a complete semiring-semimodule pair ${((S \\ll \\Sigma^*\n\\gg)^{n\\times n}, (S \\ll \\Sigma^{\\omega}\\gg)^n)}$ such that the behavior\n$\\Vert\\mathcal{C} \\Vert$ of $\\mathcal{C}$ is a component of a solution of this\nsystem. In case the basic semiring is $\\mathbb{B}$ or $\\mathbb{N}^{\\infty}$ we\nshow that there exists a mixed context-free grammar that generates\n$\\Vert\\mathcal{C} \\Vert$. The construction of the mixed context-free grammar\nfrom $\\mathcal{C}$ is a generalization of the well-known triple construction in\ncase of restricted one-counter automata and is called now triple-pair\nconstruction for $\\omega$-restricted one-counter automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.08703v4"
    },
    {
        "title": "Pushing for weighted tree automata",
        "authors": [
            "Thomas Hanneforth",
            "Andreas Maletti",
            "Daniel Quernheim"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A weight normalization procedure, commonly called pushing, is introduced for\nweighted tree automata (wta) over commutative semifields. The normalization\npreserves the recognized weighted tree language even for nondeterministic wta,\nbut it is most useful for bottom-up deterministic wta, where it can be used for\nminimization and equivalence testing. In both applications a careful selection\nof the weights to be redistributed followed by normalization allows a reduction\nof the general problem to the corresponding problem for bottom-up deterministic\nunweighted tree automata. This approach was already successfully used by Mohri\nand Eisner for the minimization of deterministic weighted string automata.\nMoreover, the new equivalence test for two wta $M$ and $M'$ runs in time\n$\\mathcal O((\\lvert M \\rvert + \\lvert M'\\rvert) \\cdot \\log {(\\lvert Q\\rvert +\n\\lvert Q'\\rvert)})$, where $Q$ and $Q'$ are the states of $M$ and $M'$,\nrespectively, which improves the previously best run-time $\\mathcal O(\\lvert M\n\\rvert \\cdot \\lvert M'\\rvert)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.00304v3"
    },
    {
        "title": "Undecidability and Finite Automata",
        "authors": [
            "Jörg Endrullis",
            "Jeffrey Shallit",
            "Tim Smith"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Using a novel rewriting problem, we show that several natural decision\nproblems about finite automata are undecidable (i.e., recursively unsolvable).\nIn contrast, we also prove three related problems are decidable. We apply one\nresult to prove the undecidability of a related problem about k-automatic sets\nof rational numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.01394v2"
    },
    {
        "title": "A novel type of Automata for dynamic, heterogeneous and random\n  architectures",
        "authors": [
            "Weijun Zhu"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper, the author aims to establish a mathematical model for a mimic\ncomputer. To this end, a novel automaton is proposed. First, a one-dimensional\ncellular automaton is used for expressing some dynamic changes in the structure\nof a computing unit, a sequential automaton is employed to describe some state\ntransitions, a hierarchical automaton is employed to express the different\ngranularities of some computing units, and a probabilistic automaton is used to\ndepict some random changes of a computing unit. Second, the new automaton is\nobtained by combining the various types of automata mentioned above in the\ncertain logical relationship. To the best of our knowledge, the new automaton\nmodel is the first automaton which can portray the operation semantics for a\nmimic computing system, and it can directly describe some behaviors of a mimic\ncomputer.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.02240v3"
    },
    {
        "title": "Existential length universality",
        "authors": [
            "Paweł Gawrychowski",
            "Martin Lange",
            "Narad Rampersad",
            "Jeffrey Shallit",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the following natural variation on the classical universality\nproblem: given a language $L(M)$ represented by $M$ (e.g., a DFA/RE/NFA/PDA),\ndoes there exist an integer $\\ell \\geq 0$ such that $\\Sigma^\\ell \\subseteq\nL(M)$? In the case of an NFA, we show that this problem is NEXPTIME-complete,\nand the smallest such $\\ell$ can be doubly exponential in the number of states.\nThis particular case was formulated as an open problem in 2009, and our\nsolution uses a novel and involved construction. In the case of a PDA, we show\nthat it is recursively unsolvable, while the smallest such $\\ell$ is not\nbounded by any computable function of the number of states. In the case of a\nDFA, we show that the problem is NP-complete, and $e^{\\sqrt{n \\log n}\n(1+o(1))}$ is an asymptotically tight upper bound for the smallest such $\\ell$,\nwhere $n$ is the number of states. Finally, we prove that in all these cases,\nthe problem becomes computationally easier when the length $\\ell$ is also given\nin binary in the input: it is polynomially solvable for a DFA, PSPACE-complete\nfor an NFA, and co-NEXPTIME-complete for a PDA.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.03961v5"
    },
    {
        "title": "Weighted Operator Precedence Languages",
        "authors": [
            "Manfred Droste",
            "Stefan Dück",
            "Dino Mandrioli",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In the last years renewed investigation of operator precedence languages\n(OPL) led to discover important properties thereof: OPL are closed with respect\nto all major operations, are characterized, besides the original grammar\nfamily, in terms of an automata family and an MSO logic; furthermore they\nsignificantly generalize the well-known visibly pushdown languages (VPL). In\nanother area of research, quantitative models of systems are also greatly in\ndemand. In this paper, we lay the foundation to marry these two research\nfields. We introduce weighted operator precedence automata and show how they\nare both strict extensions of OPA and weighted visibly pushdown automata. We\nprove a Nivat-like result which shows that quantitative OPL can be described by\nunweighted OPA and very particular weighted OPA. In a B\\\"uchi-like theorem, we\nshow that weighted OPA are expressively equivalent to a weighted MSO-logic for\nOPL.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.04597v1"
    },
    {
        "title": "Towards a Theory of Complexity of Regular Languages",
        "authors": [
            "Janusz A. Brzozowski"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We survey recent results concerning the complexity of regular languages\nrepresented by their minimal deterministic finite automata. In addition to the\nquotient complexity of the language -- which is the number of its (left)\nquotients, and is the same as its state complexity -- we also consider the size\nof its syntactic semigroup and the quotient complexity of its atoms -- basic\ncomponents of every regular language. We then turn to the study of the\nquotient/state complexity of common operations on regular languages: reversal,\n(Kleene) star, product (concatenation) and boolean operations. We examine\nrelations among these complexity measures. We discuss several subclasses of\nregular languages defined by convexity. In many, but not all, cases there exist\n\"most complex\" languages, languages satisfying all these complexity measures.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.05024v1"
    },
    {
        "title": "Regular Separability of Well Structured Transition Systems",
        "authors": [
            "Wojciech Czerwiński",
            "Sławomir Lasota",
            "Roland Meyer",
            "Sebastian Muskalla",
            "K Narayan Kumar",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the languages recognized by well-structured transition systems\n(WSTS) with upward and downward compatibility. Our first result shows that,\nunder very mild assumptions, every two disjoint WSTS languages are regular\nseparable: There is a regular language containing one of them and being\ndisjoint from the other. As a consequence, if a language as well as its\ncomplement are both recognized by WSTS, then they are necessarily regular. In\nparticular, no subclass of WSTS languages beyond the regular languages is\nclosed under complement. Our second result shows that for Petri nets, the\ncomplexity of the backwards coverability algorithm yields a bound on the size\nof the regular separator. We complement it by a lower bound construction.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.05334v4"
    },
    {
        "title": "Improving the upper bound on the length of the shortest reset words",
        "authors": [
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We improve the best known upper bound on the length of the shortest reset\nwords of synchronizing automata. The new bound is slightly better than $114 n^3\n/ 685 + O(n^2)$. The \\v{C}ern\\'y conjecture states that $(n-1)^2$ is an upper\nbound. So far, the best general upper bound was $(n^3-n)/6-1$ obtained by\nJ.-E.~Pin and P.~Frankl in 1982. Despite a number of efforts, it remained\nunchanged for about 35 years.\n  To obtain the new upper bound we utilize avoiding words. A word is avoiding\nfor a state $q$ if after reading the word the automaton cannot be in $q$. We\nobtain upper bounds on the length of the shortest avoiding words, and using the\napproach of Trahtman from 2011 combined with the well known Frankl theorem from\n1982, we improve the general upper bound on the length of the shortest reset\nwords. For all the bounds, there exist polynomial algorithms finding a word of\nlength not exceeding the bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.05455v5"
    },
    {
        "title": "On the Comparison of Context-Free Grammars",
        "authors": [
            "J. Joao Almeida",
            "Eliana Grande",
            "Georgi Smirnov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper we consider the problem of context-free grammars comparison\nfrom the analysis point of view. We show that the problem can be reduced to\nnumerical solution of systems of nonlinear matrix equations. The approach\npresented here forms a basis for probabilistic comparison algorithms oriented\nto automatic assessment of of student's answers in computer science.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.05945v2"
    },
    {
        "title": "Computing the longest common prefix of a context-free language in\n  polynomial time",
        "authors": [
            "Michael Luttenberger",
            "Raphaela Palenta",
            "Helmut Seidl"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present two structural results concerning longest common prefixes of\nnon-empty languages. First, we show that the longest common prefix of the\nlanguage generated by a context-free grammar of size $N$ equals the longest\ncommon prefix of the same grammar where the heights of the derivation trees are\nbounded by $4N$. Second, we show that each nonempty language $L$ has a\nrepresentative subset of at most three elements which behaves like $L$ w.r.t.\nthe longest common prefix as well as w.r.t. longest common prefixes of $L$\nafter unions or concatenations with arbitrary other languages. From that, we\nconclude that the longest common prefix, and thus the longest common suffix, of\na context-free language can be computed in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.06698v2"
    },
    {
        "title": "On Reversible Transducers",
        "authors": [
            "Luc Dartois",
            "Paulin Fournier",
            "Ismaël Jecker",
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Deterministic two-way transducers define the robust class of regular\nfunctions which is, among other good properties, closed under composition.\nHowever, the best known algorithms for composing two-way transducers cause a\ndouble exponential blow-up in the size of the inputs. In this paper, we\nintroduce a class of transducers for which the composition has polynomial\ncomplexity. It is the class of reversible transducers, for which the\ncomputation steps can be reversed deterministically. While in the one-way\nsetting this class is not very expressive, we prove that any two-way transducer\ncan be made reversible through a single exponential blow-up. As a consequence,\nwe prove that the composition of two-way transducers can be done with a single\nexponential blow-up in the number of states. A uniformization of a relation is\na function with the same domain and which is included in the original relation.\nOur main result actually states that we can uniformize any non-deterministic\ntwo-way transducer by a reversible transducer with a single exponential\nblow-up, improving the known result by de Souza which has a quadruple\nexponential complexity. As a side result, our construction also gives a\nquadratic transformation from copyless streaming string transducers to two-way\ntransducers, improving the exponential previous bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.07157v1"
    },
    {
        "title": "On Store Languages of Language Acceptors",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  It is well known that the \"store language\" of every pushdown automaton -- the\nset of store configurations (state and stack contents) that can appear as an\nintermediate step in accepting computations -- is a regular language. Here many\nmodels of language acceptors with various data structures are examined, along\nwith a study of their store languages. For each model, an attempt is made to\nfind the simplest model that accepts their store languages. Some connections\nbetween store languages of one-way and two-way machines generally are\ndemonstrated, as with connections between nondeterministic and deterministic\nmachines. A nice application of these store language results is also presented,\nshowing a general technique for proving families accepted by many deterministic\nmodels are closed under right quotient with regular languages, resolving some\nopen questions (and significantly simplifying proofs for others that are known)\nin the literature. Lower bounds on the space complexity for recognizing store\nlanguages for the languages to be non-regular are obtained.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.07388v2"
    },
    {
        "title": "The Hardness of Solving Simple Word Equations",
        "authors": [
            "Joel D. Day",
            "Florin Manea",
            "Dirk Nowotka"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the class of regular-ordered word equations. In such\nequations, each variable occurs at most once in each side and the order of the\nvariables occurring in both sides is the preserved (the variables can be,\nhowever, separated by potentially distinct constant factors). Surprisingly, we\nobtain that solving such simple equations, even when the sides contain exactly\nthe same variables, is NP-hard. By considerations regarding the combinatorial\nstructure of the minimal solutions of the more general quadratic equations we\nobtain that the satisfiability problem for regular-ordered equations is in NP.\nFinally, we also show that a related class of simple word equations, that\ngeneralises one-variable equations, is in P.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.07922v2"
    },
    {
        "title": "Bisimulation Metrics for Weighted Automata",
        "authors": [
            "Borja Balle",
            "Pascale Gourdeau",
            "Prakash Panangaden"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We develop a new bisimulation (pseudo)metric for weighted finite automata\n(WFA) that generalizes Boreale's linear bisimulation relation. Our metrics are\ninduced by seminorms on the state space of WFA. Our development is based on\nspectral properties of sets of linear operators. In particular, the joint\nspectral radius of the transition matrices of WFA plays a central role. We also\nstudy continuity properties of the bisimulation pseudometric, establish an\nundecidability result for computing the metric, and give a preliminary account\nof applications to spectral learning of weighted automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.08017v2"
    },
    {
        "title": "A survey on difference hierarchies of regular languages",
        "authors": [
            "Olivier Carton",
            "Dominique Perrin",
            "Jean-Éric Pin"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Difference hierarchies were originally introduced by Hausdorff and they play\nan important role in descriptive set theory. In this survey paper, we study\ndifference hierarchies of regular languages. The first sections describe\nstandard techniques on difference hierarchies, mostly due to Hausdorff. We\nillustrate these techniques by giving decidability results on the difference\nhierarchies based on shuffle ideals, strongly cyclic regular languages and the\npolynomial closure of group languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.08023v6"
    },
    {
        "title": "Two-way Two-tape Automata",
        "authors": [
            "Olivier Carton",
            "Léo Exibard",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this article we consider two-way two-tape (alternating) automata accepting\npairs of words and we study some closure properties of this model. Our main\nresult is that such alternating automata are not closed under complementation\nfor non-unary alphabets. This improves a similar result of Kari and Moore for\npicture languages. We also show that these deterministic, non-deterministic and\nalternating automata are not closed under composition.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.00213v1"
    },
    {
        "title": "Implementation of the algorithm for testing an automaton for\n  synchronization in linear expected time",
        "authors": [
            "Pavel Ageev"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Berlinkov has suggested an algorithm that, given a deterministic finite\nautomaton $\\mathcal{A}$, verifies whether or not $\\mathcal{A}$ is synchronizing\nin linear (of the number of states and letters) expected time. We present a\nmodification of Berlinkov's algorithm which we have implemented and tested. Our\nexperiments show that the implementation outperforms the standard quadratic\nalgorithm even for automata of modest size and allow us to give a statistically\naccurate approximation of the ratio of non-synchronizing automata amongst all\nautomata with a given number of states.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.00258v1"
    },
    {
        "title": "Synchronizing Data Words for Register Automata",
        "authors": [
            "Karin Quaas",
            "Mahsa Shirmohammadi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Register automata (RAs) are finite automata extended with a finite set of\nregisters to store and compare data from an infinite domain. We study the\nconcept of synchronizing data words in RAs: does there exist a data word that\nsends all states of the RA to a single state?\n  For deterministic RAs with k registers (k-DRAs), we prove that inputting data\nwords with 2k+1 distinct data from the infinite data domain is sufficient to\nsynchronize. We show that the synchronization problem for DRAs is in general\nPSPACE-complete, and it is NLOGSPACE-complete for 1-DRAs. For nondeterministic\nRAs (NRAs), we show that Ackermann(n) distinct data (where n is the size of the\nRA) might be necessary to synchronize. The synchronization problem for NRAs is\nin general undecidable, however, we establish Ackermann-completeness of the\nproblem for 1-NRAs.\n  Another main result is the NEXPTIME-completeness of the length-bounded\nsynchronization problem for NRAs, where a bound on the length of the\nsynchronizing data word, written in binary, is given. A variant of this last\nconstruction allows to prove that the length-bounded universality problem for\nNRAs is co-NEXPTIME-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.02329v2"
    },
    {
        "title": "Concurrent Kleene Algebra: Free Model and Completeness",
        "authors": [
            "Tobias Kappé",
            "Paul Brunet",
            "Alexandra Silva",
            "Fabio Zanasi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Concurrent Kleene Algebra (CKA) was introduced by Hoare, Moeller, Struth and\nWehrman in 2009 as a framework to reason about concurrent programs. We prove\nthat the axioms for CKA with bounded parallelism are complete for the semantics\nproposed in the original paper; consequently, these semantics are the free\nmodel for this fragment. This result settles a conjecture of Hoare and\ncollaborators. Moreover, the techniques developed along the way are reusable;\nin particular, they allow us to establish pomset automata as an operational\nmodel for CKA.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.02787v3"
    },
    {
        "title": "How Deterministic are Good-For-Games Automata?",
        "authors": [
            "Udi Boker",
            "Orna Kupferman",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In GFG automata, it is possible to resolve nondeterminism in a way that only\ndepends on the past and still accepts all the words in the language. The\nmotivation for GFG automata comes from their adequacy for games and synthesis,\nwherein general nondeterminism is inappropriate. We continue the ongoing effort\nof studying the power of nondeterminism in GFG automata. Initial indications\nhave hinted that every GFG automaton embodies a deterministic one. Today we\nknow that this is not the case, and in fact GFG automata may be exponentially\nmore succinct than deterministic ones.\n  We focus on the typeness question, namely the question of whether a GFG\nautomaton with a certain acceptance condition has an equivalent GFG automaton\nwith a weaker acceptance condition on the same structure. Beyond the\ntheoretical interest in studying typeness, its existence implies efficient\ntranslations among different acceptance conditions. This practical issue is of\nspecial interest in the context of games, where the Buchi and co-Buchi\nconditions admit memoryless strategies for both players. Typeness is known to\nhold for deterministic automata and not to hold for general nondeterministic\nautomata.\n  We show that GFG automata enjoy the benefits of typeness, similarly to the\ncase of deterministic automata. In particular, when Rabin or Streett GFG\nautomata have equivalent Buchi or co-Buchi GFG automata, respectively, then\nsuch equivalent automata can be defined on a substructure of the original\nautomata. Using our typeness results, we further study the place of GFG\nautomata in between deterministic and nondeterministic ones. Specifically,\nconsidering automata complementation, we show that GFG automata lean toward\nnondeterministic ones, admitting an exponential state blow-up in the\ncomplementation of a Streett automaton into a Rabin automaton, as opposed to\nthe constant blow-up in the deterministic case.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.04115v1"
    },
    {
        "title": "Generic Results for Concatenation Hierarchies",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In the theory of formal languages, the understanding of concatenation\nhierarchies of regular languages is one of the most fundamental and challenging\ntopic. In this paper, we survey progress made in the comprehension of this\nproblem since 1971, and we establish new generic statements regarding this\nproblem.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.04313v1"
    },
    {
        "title": "Average Stack Cost of Buechi Pushdown Automata",
        "authors": [
            "Jakub Michaliszyn",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the average stack cost of Buechi pushdown automata (Buechi PDA). We\nassociate a non-negative price with each stack symbol and define the cost of a\nstack as the sum of costs of all its elements. We introduce and study the\naverage stack cost problem (ASC), which asks whether there exists an accepting\nrun of a given Buechi PDA such that the long-run average of stack costs is\nbelow some given threshold. The ASC problem generalizes mean-payoff objective\nand can be used to express quantitative properties of pushdown systems. In\nparticular, we can compute the average response time using the ASC problem. We\nshow that the ASC problem can be solved in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.04490v1"
    },
    {
        "title": "A New Technique for Reachability of States in Concatenation Automata",
        "authors": [
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present a new technique for demonstrating the reachability of states in\ndeterministic finite automata representing the concatenation of two languages.\nSuch demonstrations are a necessary step in establishing the state complexity\nof the concatenation of two languages, and thus in establishing the state\ncomplexity of concatenation as an operation. Typically, ad-hoc induction\narguments are used to show particular states are reachable in concatenation\nautomata. We prove some results that seem to capture the essence of many of\nthese induction arguments. Using these results, reachability proofs in\nconcatenation automata can often be done more simply and without using\ninduction directly.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.05061v2"
    },
    {
        "title": "State Complexity of Overlap Assembly",
        "authors": [
            "Janusz Brzozowski",
            "Lila Kari",
            "Bai Li",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The \\emph{state complexity} of a regular language $L_m$ is the number $m$ of\nstates in a minimal deterministic finite automaton (DFA) accepting $L_m$. The\nstate complexity of a regularity-preserving binary operation on regular\nlanguages is defined as the maximal state complexity of the result of the\noperation where the two operands range over all languages of state complexities\n$\\le m$ and $\\le n$, respectively. We find a tight upper bound on the state\ncomplexity of the binary operation \\emph{overlap assembly} on regular\nlanguages. This operation was introduced by Csuhaj-Varj\\'u, Petre, and Vaszil\nto model the process of self-assembly of two linear DNA strands into a longer\nDNA strand, provided that their ends \"overlap\". We prove that the state\ncomplexity of the overlap assembly of languages $L_m$ and $L_n$, where $m\\ge 2$\nand $n\\ge1$, is at most $2 (m-1) 3^{n-1} + 2^n$. Moreover, for $m \\ge 2$ and $n\n\\ge 3$ there exist languages $L_m$ and $L_n$ over an alphabet of size $n$ whose\noverlap assembly meets the upper bound and this bound cannot be met with\nsmaller alphabets. Finally, we prove that $m+n$ is a tight upper bound on the\noverlap assembly of unary languages, and that there are binary languages whose\noverlap assembly has exponential state complexity at least $m(2^{n-1}-2)+2$.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.06000v4"
    },
    {
        "title": "LTL Semantic Tableaux and Alternating $ω$-automata via Linear\n  Factors",
        "authors": [
            "Martin Sulzmann",
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Linear Temporal Logic (LTL) is a widely used specification framework for\nlinear time properties of systems. The standard approach for verifying such\nproperties is by transforming LTL formulae to suitable $\\omega$-automata and\nthen applying model checking.\n  We revisit Vardi's transformation of an LTL formula to an alternating\n$\\omega$-automaton and Wolper's LTL tableau method for satisfiability checking.\nWe observe that both constructions effectively rely on a decomposition of\nformulae into linear factors.\n  Linear factors have been introduced previously by Antimirov in the context of\nregular expressions.\n  We establish the notion of linear factors for LTL and verify essential\nproperties such as expansion and finiteness.\n  Our results shed new insights on the connection between the construction of\nalternating $\\omega$-automata and semantic tableaux.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.06678v1"
    },
    {
        "title": "Minimal Synthesis of String To String Functions From Examples",
        "authors": [
            "Jad Hamza",
            "Viktor Kunčak"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the problem of synthesizing string to string transformations from a\nset of input/output examples. The transformations we consider are expressed\nusing deterministic finite automata (DFA) that read pairs of letters, one\nletter from the input and one from the output. The DFA corresponding to these\ntransformations have additional constraints, ensuring that each input string is\nmapped to exactly one output string.\n  We suggest that, given a set of input/output examples, the smallest DFA\nconsistent with the examples is a good candidate for the transformation the\nuser was expecting. We therefore study the problem of, given a set of examples,\nfinding a minimal DFA consistent with the examples and satisfying the\nfunctionality and totality constraints mentioned above.\n  We prove that, in general, this problem (the corresponding decision problem)\nis NP-complete. This is unlike the standard DFA minimization problem which can\nbe solved in polynomial time. We provide several NP-hardness proofs that show\nthe hardness of multiple (independent) variants of the problem.\n  Finally, we propose an algorithm for finding the minimal DFA consistent with\ninput/output examples, that uses a reduction to SMT solvers. We implemented the\nalgorithm, and used it to evaluate the likelihood that the minimal DFA indeed\ncorresponds to the DFA expected by the user.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.09208v2"
    },
    {
        "title": "Sturmian numeration systems and decompositions to palindromes",
        "authors": [
            "Anna Frid"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We extend the classical Ostrowski numeration systems, closely related to\nSturmian words, by allowing a wider range of coefficients, so that possible\nrepresentations of a number $n$ better reflect the structure of the associated\nSturmian word. In particular, this extended numeration system helps to catch\noccurrences of palindromes in a characteristic Sturmian word and thus to prove\nfor Sturmian words the following conjecture stated in 2013 by Puzynina, Zamboni\nand the author: If a word is not periodic, then for every $Q>0$ it has a prefix\nwhich cannot be decomposed to a concatenation of at most $Q$ palindromes.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.11553v2"
    },
    {
        "title": "Consistency in Parametric Interval Probabilistic Timed Automata",
        "authors": [
            "Étienne André",
            "Benoît Delahaye",
            "Paulin Fournier"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose a new abstract formalism for probabilistic timed systems,\nParametric Interval Probabilistic Timed Automata, based on an extension of\nParametric Timed Automata and Interval Markov Chains. In this context, we\nconsider the consistency problem that amounts to deciding whether a given\nspecification admits at least one implementation. In the context of Interval\nProbabilistic Timed Automata (with no timing parameters), we show that this\nproblem is decidable and propose a constructive algorithm for its resolution.\nWe show that the existence of timing parameter valuations ensuring consistency\nis undecidable in the general context, but still exhibit a syntactic condition\non parameters to ensure decidability. We also propose procedures that resolve\nboth the consistency and the consistent reachability problems when the\nparametric probabilistic zone graph is finite.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.04982v1"
    },
    {
        "title": "A Congruence-based Perspective on Automata Minimization Algorithms",
        "authors": [
            "Pierre Ganty",
            "Elena Gutiérrez",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this work we use a framework of finite-state automata constructions based\non equivalences over words to provide new insights on the relation between\nwell-known methods for computing the minimal deterministic automaton of a\nlanguage.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.06194v2"
    },
    {
        "title": "Coverability is Undecidable in One-dimensional Pushdown Vector Addition\n  Systems with Resets",
        "authors": [
            "Sylvain Schmitz",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider the model of pushdown vector addition systems with resets. These\nconsist of vector addition systems that have access to a pushdown stack and\nhave instructions to reset counters. For this model, we study the coverability\nproblem. In the absence of resets, this problem is known to be decidable for\none-dimensional pushdown vector addition systems, but decidability is open for\ngeneral pushdown vector addition systems. Moreover, coverability is known to be\ndecidable for reset vector addition systems without a pushdown stack. We show\nin this note that the problem is undecidable for one-dimensional pushdown\nvector addition systems with resets.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.07069v1"
    },
    {
        "title": "From Decidability to Undecidability by Considering Regular Sets of\n  Instances",
        "authors": [
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We are lifting classical problems from single instances to regular sets of\ninstances. The task of finding a positive instance of the combinatorial problem\n$P$ in a potentially infinite given regular set is equivalent to the so called\nintreg-problem of $P$, which asks for a given DFA $A$, whether the intersection\nof $P$ with $L(A)$ is non-empty. The intreg-problem generalizes the idea of\nconsidering multiple instances at once and connects classical combinatorial\nproblems with the field of automata theory. While the question of the\ndecidability of the intreg-problem has been answered positively for several NP-\nand even PSPACE-complete problems, we are presenting natural problems even from\nL with an undecidable intreg-problem. We also discuss alphabet sizes and\ndifferent encoding-schemes elaborating the boundary between problem-variants\nwith a decidable respectively undecidable intreg-problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.08027v2"
    },
    {
        "title": "On Synthesis of Resynchronizers for Transducers",
        "authors": [
            "Sougata Bose",
            "Shankara Narayanan Krishna",
            "Anca Muscholl",
            "Vincent Penelle",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study two formalisms that allow to compare transducers over words under\norigin semantics: rational and regular resynchronizers, and show that the\nformer are captured by the latter. We then consider some instances of the\nfollowing synthesis problem: given transducers T1, T2, construct a rational\n(resp. regular) resynchronizer R, if it exists, such that T1 is contained in\nR(T2) under the origin semantics. We show that synthesis of rational\nresynchronizers is decidable for functional, and even finite-valued, one-way\ntransducers, and undecidable for relational one-way transducers. In the two-way\nsetting, synthesis of regular resynchronizers is shown to be decidable for\nunambiguous two-way transducers. For larger classes of two-way transducers, the\ndecidability status is open.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.08688v2"
    },
    {
        "title": "Efficient Analysis of Unambiguous Automata Using Matrix Semigroup\n  Techniques",
        "authors": [
            "Stefan Kiefer",
            "Cas Widdershoven"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce a novel technique to analyse unambiguous B\\\"uchi automata\nquantitatively, and apply this to the model checking problem. It is based on\nlinear-algebra arguments that originate from the analysis of matrix semigroups\nwith constant spectral radius. This method can replace a combinatorial\nprocedure that dominates the computational complexity of the existing procedure\nby Baier et al. We analyse the complexity in detail, showing that, in terms of\nthe set $Q$ of states of the automaton, the new algorithm runs in time\n$O(|Q|^4)$, improving on an efficient implementation of the combinatorial\nalgorithm by a factor of $|Q|$.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.10093v2"
    },
    {
        "title": "New Pumping Technique for 2-dimensional VASS",
        "authors": [
            "Wojciech Czerwiński",
            "Sławomir Lasota",
            "Christof Löding",
            "Radosław Piórkowski"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose a new pumping technique for 2-dimensional vector addition systems\nwith states (2-VASS) building on natural geometric properties of runs. We\nillustrate its applicability by reproving an exponential bound on the length of\nthe shortest accepting run, and by proving a new pumping lemma for languages of\n2-VASS. The technique is expected to be useful for settling questions\nconcerning languages of 2-VASS, e.g., for establishing decidability status of\nthe regular separability problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.10494v1"
    },
    {
        "title": "Approximate Learning of Limit-Average Automata",
        "authors": [
            "Jakub Michaliszyn",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Limit-average automata are weighted automata on infinite words that use\naverage to aggregate the weights seen in infinite runs. We study approximate\nlearning problems for limit-average automata in two settings: passive and\nactive. In the passive learning case, we show that limit-average automata are\nnot PAC-learnable as samples must be of exponential-size to provide (with good\nprobability) enough details to learn an automaton. We also show that the\nproblem of finding an automaton that fits a given sample is NP-complete. In the\nactive learning case, we show that limit-average automata can be learned\nalmost-exactly, i.e., we can learn in polynomial time an automaton that is\nconsistent with the target automaton on almost all words. On the other hand, we\nshow that the problem of learning an automaton that approximates the target\nautomaton (with perhaps fewer states) is NP-complete. The abovementioned\nresults are shown for the uniform distribution on words. We briefly discuss\nlearning over different distributions.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.11104v1"
    },
    {
        "title": "Good for Games Automata: From Nondeterminism to Alternation",
        "authors": [
            "Udi Boker",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A word automaton recognizing a language $L$ is good for games (GFG) if its\ncomposition with any game with winning condition $L$ preserves the game's\nwinner. While all deterministic automata are GFG, some nondeterministic\nautomata are not. There are various other properties that are used in the\nliterature for defining that a nondeterministic automaton is GFG, including\n\"history-deterministic\", \"compliant with some letter game\", \"good for trees\",\nand \"good for composition with other automata\". The equivalence of these\nproperties has not been formally shown.\n  We generalize all of these definitions to alternating automata and show their\nequivalence. We further show that alternating GFG automata are as expressive as\ndeterministic automata with the same acceptance conditions and indices. We then\nshow that alternating GFG automata over finite words, and weak automata over\ninfinite words, are not more succinct than deterministic automata, and that\ndeterminizing B\\\"uchi and co-B\\\"uchi alternating GFG automata involves a\n$2^{\\Theta(n)}$ state blow-up. We leave open the question of whether\nalternating GFG automata of stronger acceptance conditions allow for\ndoubly-exponential succinctness compared to deterministic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.11624v2"
    },
    {
        "title": "On Solving Word Equations Using SAT",
        "authors": [
            "Joel D. Day",
            "Thorsten Ehlers",
            "Mitja Kulczynski",
            "Florin Manea",
            "Dirk Nowotka",
            "Danny Bøgsted Poulsen"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present Woorpje, a string solver for bounded word equations (i.e.,\nequations where the length of each variable is upper bounded by a given\ninteger). Our algorithm works by reformulating the satisfiability of bounded\nword equations as a reachability problem for nondeterministic finite automata,\nand then carefully encoding this as a propositional satisfiability problem,\nwhich we then solve using the well-known Glucose SAT-solver. This approach has\nthe advantage of allowing for the natural inclusion of additional linear length\nconstraints. Our solver obtains reliable and competitive results and,\nremarkably, discovered several cases where state-of-the-art solvers exhibit a\nfaulty behaviour.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.11718v1"
    },
    {
        "title": "Online Quantitative Timed Pattern Matching with Semiring-Valued Weighted\n  Automata",
        "authors": [
            "Masaki Waga"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Monitoring of a signal plays an essential role in the runtime verification of\ncyber-physical systems. Qualitative timed pattern matching is one of the\nmathematical formulations of monitoring, which gives a Boolean verdict for each\nsub-signal according to the satisfaction of the given specification. There are\ntwo orthogonal directions of extension of the qualitative timed pattern\nmatching. One direction on the result is quantitative: what engineers want is\noften not a qualitative verdict but the quantitative measurement of the\nsatisfaction of the specification. The other direction on the algorithm is\nonline checking: the monitor returns some verdicts before obtaining the entire\nsignal, which enables to monitor a running system. It is desired from\napplication viewpoints. In this paper, we conduct these two extensions, taking\nan automata-based approach. This is the first quantitative and online timed\npattern matching algorithm to the best of our knowledge. More specifically, we\nemploy what we call timed symbolic weighted automata to specify quantitative\nspecifications to be monitored, and we obtain an online algorithm using the\nshortest distance of a weighted variant of the zone graph and dynamic\nprogramming. Moreover, our problem setting is semiring-based and therefore,\ngeneral. Our experimental results confirm the scalability of our algorithm for\nspecifications with a time-bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.12133v1"
    },
    {
        "title": "Recognition and Complexity Results for Projection Languages of\n  Two-Dimensional Automata",
        "authors": [
            "Taylor J. Smith",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The row projection (resp., column projection) of a two-dimensional language\n$L$ is the one-dimensional language consisting of all first rows (resp., first\ncolumns) of each two-dimensional word in $L$. The operation of row projection\nhas previously been studied under the name \"frontier language\", and previous\nwork has focused on one- and two-dimensional language classes.\n  In this paper, we study projections of languages recognized by various\ntwo-dimensional automaton classes. We show that both the row and column\nprojections of languages recognized by (four-way) two-dimensional automata are\nexactly context-sensitive. We also show that the column projections of\nlanguages recognized by unary three-way two-dimensional automata can be\nrecognized using nondeterministic logspace. Finally, we study the state\ncomplexity of projection languages for two-way two-dimensional automata,\nfocusing on the language operations of union and diagonal concatenation.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.00602v1"
    },
    {
        "title": "Notes on Equivalence and Minimization of Weighted Automata",
        "authors": [
            "Stefan Kiefer"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This set of notes re-proves known results on weighted automata (over a field,\nalso known as multiplicity automata). The text offers a unified view on\ntheorems and proofs that have appeared in the literature over decades and were\nwritten in different styles and contexts. None of the results reported here are\nclaimed to be new. The content centres around fundamentals of equivalence and\nminimization, with an emphasis on algorithmic aspects. The presentation is\nminimalistic. No attempt has been made to motivate the material. Weighted\nautomata are viewed from a linear-algebra angle. As a consequence, the proofs,\nwhich are meant to be succinct, but complete and almost self-contained, rely\nmainly on elementary linear algebra.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.01217v1"
    },
    {
        "title": "Higher-Order Nonemptiness Step by Step",
        "authors": [
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show a new simple algorithm that checks whether a given higher-order\ngrammar generates a nonempty language of trees. The algorithm amounts to a\nprocedure that transforms a grammar of order n to a grammar of order n-1,\npreserving nonemptiness, and increasing the size only exponentially. After\nrepeating the procedure n times, we obtain a grammar of order 0, whose\nnonemptiness can be easily checked. Since the size grows exponentially at each\nstep, the overall complexity is n-EXPTIME, which is known to be optimal. More\nprecisely, the transformation (and hence the whole algorithm) is linear in the\nsize of the grammar, assuming that the arity of employed nonterminals is\nbounded by a constant. The same algorithm allows to check whether an infinite\ntree generated by a higher-order recursion scheme is accepted by an alternating\nsafety (or reachability) automaton, because this question can be reduced to the\nnonemptiness problem by taking a product of the recursion scheme with the\nautomaton.\n  A proof of correctness of the algorithm is formalised in the proof assistant\nCoq. Our transformation is motivated by a similar transformation of Asada and\nKobayashi (2020) changing a word grammar of order n to a tree grammar of order\nn-1. The step-by-step approach can be opposed to previous algorithms solving\nthe nonemptiness problem \"in one step\", being compulsorily more complicated.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.08174v1"
    },
    {
        "title": "Grey-Box Learning of Register Automata",
        "authors": [
            "Bharat Garhewal",
            "Frits Vaandrager",
            "Falk Howar",
            "Timo Schrijvers",
            "Toon Lenaerts",
            "Rob Smits"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Model learning (a.k.a. active automata learning) is a highly effective\ntechnique for obtaining black-box finite state models of software components.\nThus far, generalisation to infinite state systems with inputs/outputs that\ncarry data parameters has been challenging. Existing model learning tools for\ninfinite state systems face scalability problems and can only be applied to\nrestricted classes of systems (register automata with equality/inequality). In\nthis article, we show how we can boost the performance of model learning\ntechniques by extracting the constraints on input and output parameters from a\nrun, and making this grey-box information available to the learner. More\nspecifically, we provide new implementations of the tree oracle and equivalence\noracle from RALib, which use the derived constraints. We extract the\nconstraints from runs of Python programs using an existing tainting library for\nPython, and compare our grey-box version of RALib with the existing black-box\nversion on several benchmarks, including some data structures from Python's\nstandard library. Our proof-of-principle implementation results in almost two\norders of magnitude improvement in terms of numbers of inputs sent to the\nsoftware system. Our approach, which can be generalised to richer model\nclasses, also enables RALib to learn models that are out of reach of black-box\ntechniques, such as combination locks.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.09975v1"
    },
    {
        "title": "Canonicity in GFG and Transition-Based Automata",
        "authors": [
            "Bader Abu Radi",
            "Orna Kupferman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Minimization of deterministic automata on finite words results in a {\\em\ncanonical\\/} automaton. For deterministic automata on infinite words, no\ncanonical minimal automaton exists, and a language may have different minimal\ndeterministic B\\\"uchi (DBW) or co-B\\\"uchi (DCW) automata. In recent years,\nresearchers have studied {\\em good-for-games\\/} (GFG) automata --\nnondeterministic automata that can resolve their nondeterministic choices in a\nway that only depends on the past. Several applications of automata in formal\nmethods, most notably synthesis, that are traditionally based on deterministic\nautomata, can instead be based on GFG automata. The {\\em minimization\\/}\nproblem for DBW and DCW is NP-complete, and it stays NP-complete for GFG\nB\\\"uchi and co-B\\\"uchi automata. On the other hand, minimization of GFG\nco-B\\\"uchi automata with {\\em transition-based\\/} acceptance (GFG-tNCWs) can be\nsolved in polynomial time. In these automata, acceptance is defined by a set\n$\\alpha$ of transitions, and a run is accepting if it traverses transitions in\n$\\alpha$ only finitely often. This raises the question of canonicity of minimal\ndeterministic and GFG automata with transition-based acceptance. In this paper\nwe study this problem. We start with GFG-tNCWs and show that the safe\ncomponents (that is, these obtained by restricting the transitions to these not\nin $\\alpha$) of all minimal GFG-tNCWs are isomorphic, and that by saturating\nthe automaton with transitions in $\\alpha$ we get isomorphism among all minimal\nGFG-tNCWs. Thus, a canonical form for minimal GFG-tNCWs can be obtained in\npolynomial time. We continue to DCWs with transition-based acceptance (tDCWs),\nand their dual tDBWs. We show that here, while no canonical form for minimal\nautomata exists, restricting attention to the safe components is useful, and\nimplies that the only minimal tDCWs that have no canonical form are these for\nwhich the transition to the GFG model results in strictly smaller automaton,\nwhich do have a canonical minimal form.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.10885v1"
    },
    {
        "title": "Comparing Labelled Markov Decision Processes",
        "authors": [
            "Stefan Kiefer",
            "Qiyi Tang"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A labelled Markov decision process is a labelled Markov chain with\nnondeterminism, i.e., together with a strategy a labelled MDP induces a\nlabelled Markov chain. The model is related to interval Markov chains.\nMotivated by applications of equivalence checking for the verification of\nanonymity, we study the algorithmic comparison of two labelled MDPs, in\nparticular, whether there exist strategies such that the MDPs become\nequivalent/inequivalent, both in terms of trace equivalence and in terms of\nprobabilistic bisimilarity. We provide the first polynomial-time algorithms for\ncomputing memoryless strategies to make the two labelled MDPs inequivalent if\nsuch strategies exist. We also study the computational complexity of\nqualitative problems about making the total variation distance and the\nprobabilistic bisimilarity distance less than one or equal to one.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.11643v1"
    },
    {
        "title": "On the Succinctness of Alternating Parity Good-for-Games Automata",
        "authors": [
            "Udi Boker",
            "Denis Kuperberg",
            "Karoliina Lehtinen",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study alternating parity good-for-games (GFG) automata, i.e., alternating\nparity automata where both conjunctive and disjunctive choices can be resolved\nin an online manner, without knowledge of the suffix of the input word still to\nbe read.\n  We show that they can be exponentially more succinct than both their\nnondeterministic and universal counterparts. Furthermore, we present a single\nexponential determinisation procedure and an Exptime upper bound to the problem\nof recognising whether an alternating automaton is GFG. We also study the\ncomplexity of deciding \"half-GFGness\", a property specific to alternating\nautomata that only requires nondeterministic choices to be resolved in an\nonline manner. We show that this problem is PSpace-hard already for alternating\nautomata on finite words.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.14437v1"
    },
    {
        "title": "Weighted Tiling Systems for Graphs: Evaluation Complexity",
        "authors": [
            "C. Aiswarya",
            "Paul Gastin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider weighted tiling systems to represent functions from graphs to a\ncommutative semiring such as the Natural semiring or the Tropical semiring. The\nsystem labels the nodes of a graph by its states, and checks if the\nneighbourhood of every node belongs to a set of permissible tiles, and assigns\na weight accordingly. The weight of a labeling is the semiring-product of the\nweights assigned to the nodes, and the weight of the graph is the semiring-sum\nof the weights of labelings. We show that we can model interesting algorithmic\nquestions using this formalism - like computing the clique number of a graph or\ncomputing the permanent of a matrix. The evaluation problem is, given a\nweighted tiling system and a graph, to compute the weight of the graph. We\nstudy the complexity of the evaluation problem and give tight upper and lower\nbounds for several commutative semirings. Further we provide an efficient\nevaluation algorithm if the input graph is of bounded tree-width.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.14542v1"
    },
    {
        "title": "Finitely generated ideal languages and synchronizing automata",
        "authors": [
            "Vladimir V. Gusev",
            "Marina I. Maslennikova",
            "Elena V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study representations of ideal languages by means of strongly connected\nsynchronizing automata. For every finitely generated ideal language L we\nconstruct such an automaton with at most 2^n states, where n is the maximal\nlength of words in L. Our constructions are based on the De Bruijn graph.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.0336v1"
    },
    {
        "title": "A Comment on Budach's Mouse-in-an-Octant Problem",
        "authors": [
            "Amir M. Ben-Amram"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Budach's Mouse-in-an-Octant Problem (attributed to Lothar Budach in a 1980\narticle by van Emde Boas and Karpinski) concerns the behaviour of a very simple\nfinite-state machine (\"the mouse\") moving on the integer two-dimensional grid.\nIts decidability is apparently still open. This note sketches a proof that an\nextended version of the problem (a super-mouse) is undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.0911v2"
    },
    {
        "title": "Decidability of minimization of fuzzy automata",
        "authors": [
            "Lvzhou Li",
            "Daowen Qiu"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  State minimization is a fundamental problem in automata theory. The problem\nis also of great importance in the study of fuzzy automata. However, most work\nin the literature considered only state reduction of fuzzy automata, whereas\nthe state minimization problem is almost untouched for fuzzy automata. Thus in\nthis paper we focus on the latter problem. Formally, the decision version of\nthe minimization problem of fuzzy automata is as follows: \\begin{itemize}\n  \\item Given a fuzzy automaton $\\mathcal{A}$ and a natural number $k$, that\nis, a pair $\\langle \\mathcal{A}, k\\rangle$, is there a $k$-state fuzzy\nautomaton equivalent to $\\mathcal{A}$? \\end{itemize} We prove for the first\ntime that the above problem is decidable for fuzzy automata over totally\nordered lattices. To this end, we first give the concept of systems of fuzzy\npolynomial equations and then present a procedure to solve these systems.\nAfterwards, we apply the solvability of a system of fuzzy polynomial equations\nto the minimization problem mentioned above, obtaining the decidability.\nFinally, we point out that the above problem is at least as hard as\nPSAPCE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.4255v1"
    },
    {
        "title": "On the Structure and Complexity of Rational Sets of Regular Languages",
        "authors": [
            "Andreas Holzer",
            "Christian Schallhart",
            "Michael Tautschnig",
            "Helmut Veith"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In a recent thread of papers, we have introduced FQL, a precise specification\nlanguage for test coverage, and developed the test case generation engine\nFShell for ANSI C. In essence, an FQL test specification amounts to a set of\nregular languages, each of which has to be matched by at least one test\nexecution. To describe such sets of regular languages, the FQL semantics uses\nan automata-theoretic concept known as rational sets of regular languages\n(RSRLs). RSRLs are automata whose alphabet consists of regular expressions.\nThus, the language accepted by the automaton is a set of regular expressions.\n  In this paper, we study RSRLs from a theoretic point of view. More\nspecifically, we analyze RSRL closure properties under common set theoretic\noperations, and the complexity of membership checking, i.e., whether a regular\nlanguage is an element of a RSRL. For all questions we investigate both the\ngeneral case and the case of finite sets of regular languages. Although a few\nproperties are left as open problems, the paper provides a systematic semantic\nfoundation for the test specification language FQL.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.6074v1"
    },
    {
        "title": "Auto-similarity in rational base number systems",
        "authors": [
            "Shigeki Akiyama",
            "Victor Marsault",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This work is a contribution to the study of set of the representations of\nintegers in a rational base number system. This prefix-closed subset of the\nfree monoid is naturally represented as a highly non regular tree whose nodes\nare the integers and whose subtrees are all distinct. With every node of that\ntree is then associated a minimal infinite word. The main result is that a\nsequential transducer which computes for all n the minimal word associated with\nn+1 from the one associated with n, has essentially the same underlying graph\nas the tree itself. These infinite words are then interpreted as\nrepresentations of real numbers; the difference between the numbers represented\nby these two consecutive minimal words is the called the span of a node of the\ntree. The preceding construction allows to characterise the topological closure\nof the set of spans.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.6757v1"
    },
    {
        "title": "A representation of context-free grammars with the help of finite\n  digraphs",
        "authors": [
            "Krasimir Yordzhev"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  For any context-free grammar, we build a transition diagram, that is, a\nfinite directed graph with labeled arcs, which describes the work of the\ngrammar. This approach is new, and it is different from previously known graph\nmodels. We define the concept of proper walk in this transition diagram and we\nprove that a word belongs to a given context-free language if and only if this\nword can be obtained with the help of a proper walk.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.6803v1"
    },
    {
        "title": "Marciani Normal Form of context-free grammars",
        "authors": [
            "Giacomo Marciani"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper, we prove the semidecidability of the problem of saying whether\nor not a context-free grammar generates a regular language. We introduce the\nnotion of context-free grammar in Marciani Normal Form. We prove that a\ncontext-free grammar in Marciani Normal Form always generates a regular\nlanguage.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.01866v1"
    },
    {
        "title": "Generalized LR parsing and the shuffle operator",
        "authors": [
            "John Maraist"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We adapt Tomita's Generalized LR algorithm to languages generated by\ncontext-free grammars enriched with a shuffle operator. The change involves\nextensions to the underlying handle-finding finite automaton, construction of\nparser tables, and the necessary optimizations in constructing a deterministic\nparser. Our system is motivated by an application from artificial intelligence\nplan recognition. We argue for the correctness of the system, and discuss\nfuture extensions of this work.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.05831v1"
    },
    {
        "title": "Optimal Test Sets for Context-Free Languages",
        "authors": [
            "Mikaël Mayer",
            "Jad Hamza"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A test set for a formal language (set of strings) L is a subset T of L such\nthat for any two string homomorphisms f and g defined on L, if the restrictions\nof f and g on T are identical functions, then f and g are identical on the\nentire L. Previously, it was shown that there are context-free grammars for\nwhich smallest test sets are cubic in the size of the grammar, which gives a\nlower bound on tests set size. Existing upper bounds were higher degree\npolynomials; we here give the first algorithm to compute test sets of cubic\nsize for all context-free grammars, settling the gap between the upper and\nlower bound.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.06703v1"
    },
    {
        "title": "Minimal and Reduced Reversible Automata",
        "authors": [
            "Giovanna J. Lavado",
            "Giovanni Pighizzini",
            "Luca Prigioniero"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A condition characterizing the class of regular languages which have several\nnonisomorphic minimal reversible automata is presented. The condition concerns\nthe structure of the minimum automaton accepting the language under\nconsideration. It is also observed that there exist reduced reversible automata\nwhich are not minimal, in the sense that all the automata obtained by merging\nsome of their equivalent states are irreversible. Furthermore, a sufficient\ncondition for the existence of infinitely many reduced reversible automata\naccepting a same language is given. It is also proved that, when the language\nis accepted by a unique minimal reversible automaton (that does not necessarily\ncoincide with the minimum deterministic automaton), then no other reduced\nreversible automata accepting it can exist.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.06840v1"
    },
    {
        "title": "Some Subclasses of Linear Languages based on Nondeterministic Linear\n  Automata",
        "authors": [
            "Benjamín Bedregal"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper we consider the class of lambda-nondeterministic linear\nautomata as a model of the class of linear languages. As usual in other\nautomata models, lambda-moves do not increase the acceptance power. The main\ncontribution of this paper is to introduce the deterministic linear automata\nand even linear automata, i.e. the natural restriction of nondeterministic\nlinear automata for the deterministic and even linear language classes,\nrespectively. In particular, there are different, but not equivalents,\nproposals for the class of \"deterministic\" linear languages. We proved here\nthat the class of languages accepted by the deterministic linear automata are\nnot contained in any of the these classes and in fact they properly contain\nthese classes. Another, contribution is the generation of an infinite hierarchy\nof formal languages, going from the class of languages accepted by\ndeterministic linear automata and achieved, in the limit, the class of linear\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.10276v1"
    },
    {
        "title": "On the computational power of affine automata",
        "authors": [
            "Mika Hirvensalo",
            "Etienne Moutot",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We investigate the computational power of affine automata (AfAs) introduced\nin [4]. In particular, we present a simpler proof for how to change the\ncutpoint for any affine language and a method how to reduce error in bounded\nerror case. Moreover, we address to the question of [4] by showing that any\naffine language can be recognized by an AfA with certain limitation on the\nentries of affine states and transition matrices. Lastly, we present the first\nlanguages shown to be not recognized by AfAs with bounded-error.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.01870v1"
    },
    {
        "title": "Comparison of max-plus automata and joint spectral radius of tropical\n  matrices",
        "authors": [
            "Laure Daviaud",
            "Pierre Guillon",
            "Glenn Merlet"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Weighted automata over the max-plus semiring S are closely related to\nfinitely generated semigroups of matrices over S. In this paper, we use results\nin automata theory to study two quantities associated with sets of matrices:\nthe joint spectral radius and the ultimate rank. We prove that these two\nquantities are not computable over the tropical semiring, i.e. there is no\nalgorithm that takes as input a finite set of matrices M and provides as output\nthe joint spectral radius (resp. the ultimate rank) of M. On the other hand, we\nprove that the joint spectral radius is nevertheless approximable and we\nexhibit restricted cases in which the joint spectral radius and the ultimate\nrank are computable. To reach this aim, we study the problem of comparing\nfunctions computed by weighted automata over the tropical semiring. This\nproblem is known to be undecidable and we prove that it remains undecidable in\nsome specific subclasses of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.02647v2"
    },
    {
        "title": "On the synchronization of planar automata",
        "authors": [
            "J. Andres Montoya",
            "Christian Nolasco"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Planar automata seems to be representative of the synchronizing behavior of\ndeterministic finite state automata. We conjecture that \\v{C}erny's conjecture\nholds true, if and only if, it holds true for planar automata. In this paper we\nhave gathered some evidence concerning this conjecture. This evidence amounts\nto show that the class of planar automata is representative of the algorithmic\nhardness of synchronization\n",
        "pdf_link": "http://arxiv.org/pdf/1612.04462v1"
    },
    {
        "title": "Reducing Nondeterministic Tree Automata by Adding Transitions",
        "authors": [
            "Ricardo Manuel de Oliveira Almeida"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce saturation of nondeterministic tree automata, a technique that\nconsists of adding new transitions to an automaton while preserving its\nlanguage. We implemented our algorithm on minotaut - a module of the tree\nautomata library libvata that reduces the size of automata by merging states\nand removing superfluous transitions - and we show how saturation can make\nsubsequent merge and transition-removal operations more effective. Thus we\nobtain a Ptime algorithm that reduces the size of tree automata even more than\nbefore. Additionally, we explore how minotaut alone can play an important role\nwhen performing hard operations like complementation, allowing to both obtain\nsmaller complement automata and lower computation times. We then show how\nsaturation can extend this contribution even further. We tested our algorithms\non a large collection of automata from applications of libvata in shape\nanalysis, and on different classes of randomly generated automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.04981v1"
    },
    {
        "title": "Regular Separability of Parikh Automata",
        "authors": [
            "Lorenzo Clemente",
            "Wojciech Czerwiński",
            "Sławomir Lasota",
            "Charles Paperman"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We investigate a subclass of languages recognized by vector addition systems,\nnamely languages of nondeterministic Parikh automata. While the regularity\nproblem (is the language of a given automaton regular?) is undecidable for this\nmodel, we show surprising decidability of the regular separability problem:\ngiven two Parikh automata, is there a regular language that contains one of\nthem and is disjoint from the other?\n",
        "pdf_link": "http://arxiv.org/pdf/1612.06233v1"
    },
    {
        "title": "Syntactic Structures of Regular Languages",
        "authors": [
            "Ondřej Klíma",
            "Libor Polák"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce here the notion of syntactic lattice algebra which is an analogy\nof the syntactic monoid and of the syntactic semiring. We present a unified\napproach to get those three structures.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.06247v2"
    },
    {
        "title": "On incomplete and synchronizing finite sets",
        "authors": [
            "Arturo Carpi",
            "Flavio D'Alessandro"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper situates itself in the theory of variable length codes and of\nfinite automata where the concepts of completeness and synchronization play a\ncentral role. In this theoretical setting, we investigate the problem of\nfinding upper bounds to the minimal length of synchronizing words and\nincompletable words of a finite language X in terms of the length of the words\nof X. This problem is related to two well-known conjectures formulated by Cerny\nand Restivo, respectively. In particular, if Restivo's conjecture is true, our\nmain result provides a quadratic bound for the minimal length of a\nsynchronizing pair of any finite synchronizing complete code with respect to\nthe maximal length of its words.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.07881v1"
    },
    {
        "title": "Families of DFAs as Acceptors of $ω$-Regular Languages",
        "authors": [
            "Dana Angluin",
            "Udi Boker",
            "Dana Fisman"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Families of DFAs (FDFAs) provide an alternative formalism for recognizing\n$\\omega$-regular languages. The motivation for introducing them was a desired\ncorrelation between the automaton states and right congruence relations, in a\nmanner similar to the Myhill-Nerode theorem for regular languages. This\ncorrelation is beneficial for learning algorithms, and indeed it was recently\nshown that $\\omega$-regular languages can be learned from membership and\nequivalence queries, using FDFAs as the acceptors.\n  In this paper, we look into the question of how suitable FDFAs are for\ndefining omega-regular languages. Specifically, we look into the complexity of\nperforming Boolean operations, such as complementation and intersection, on\nFDFAs, the complexity of solving decision problems, such as emptiness and\nlanguage containment, and the succinctness of FDFAs compared to standard\ndeterministic and nondeterministic $\\omega$-automata.\n  We show that FDFAs enjoy the benefits of deterministic automata with respect\nto Boolean operations and decision problems. Namely, they can all be performed\nin nondeterministic logarithmic space. We provide polynomial translations of\ndeterministic B\\\"uchi and co-B\\\"uchi automata to FDFAs and of FDFAs to\nnondeterministic B\\\"uchi automata (NBAs). We show that translation of an NBA to\nan FDFA may involve an exponential blowup. Last, we show that FDFAs are more\nsuccinct than deterministic parity automata (DPAs) in the sense that\ntranslating a DPA to an FDFA can always be done with only a polynomial\nincrease, yet the other direction involves an inevitable exponential blowup in\nthe worst case.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.08154v3"
    },
    {
        "title": "On the Metric-based Approximate Minimization of Markov Chains",
        "authors": [
            "Giovanni Bacci",
            "Giorgio Bacci",
            "Kim G. Larsen",
            "Radu Mardare"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we address the approximate minimization problem of Markov\nChains (MCs) from a behavioral metric-based perspective. Specifically, given a\nfinite MC and a positive integer k, we are looking for an MC with at most k\nstates having minimal distance to the original. The metric considered in this\nwork is the bisimilarity distance of Desharnais et al.. For this metric we show\nthat (1) optimal approximations always exist; (2) the problem has a bilinear\nprogram characterization; and (3) prove that its threshold problem is in PSPACE\nand NP-hard. In addition to the bilinear program solution, we present an\napproach inspired by expectation maximization techniques for computing\nsuboptimal solutions to the problem. Experiments suggest that our method gives\na practical approach that outperforms the bilinear program implementation run\non state-of-the-art bilinear solvers.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.00528v1"
    },
    {
        "title": "Learning Several Languages from Labeled Strings: State Merging and\n  Evolutionary Approaches",
        "authors": [
            "Alexis Linard"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The problem of learning pairwise disjoint deterministic finite automata (DFA)\nfrom positive examples has been recently addressed. In this paper, we address\nthe problem of identifying a set of DFAs from labeled strings and come up with\ntwo methods. The first is based on state merging and a heuristic related to the\nsize of each state merging iteration. State merging operations involving a\nlarge number of states are extracted, to provide sub-DFAs. The second method is\nbased on a multi-objective evolutionary algorithm whose fitness function takes\ninto account the accuracy of the DFA w.r.t. the learning sample, as well as the\ndesired number of DFAs. We evaluate our methods on a dataset originated from\nindustry.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.01630v2"
    },
    {
        "title": "Regular tree languages in low levels of the Wadge Hierarchy",
        "authors": [
            "Mikołaj Bojańczyk",
            "Filippo Cavallari",
            "Thomas Place",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this article we provide effective characterisations of regular languages\nof infinite trees that belong to the low levels of the Wadge hierarchy. More\nprecisely we prove decidability for each of the finite levels of the hierarchy;\nfor the class of the Boolean combinations of open sets $BC(\\Sigma_1^0)$ (i.e.\nthe union of the first $\\omega$ levels); and for the Borel class $\\Delta_2^0$\n(i.e. for the union of the first $\\omega_1$ levels).\n",
        "pdf_link": "http://arxiv.org/pdf/1806.02041v4"
    },
    {
        "title": "Algorithms and Training for Weighted Multiset Automata and Regular\n  Expressions",
        "authors": [
            "Justin DeBenedetto",
            "David Chiang"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Multiset automata are a class of automata for which the symbols can be read\nin any order and obtain the same result. We investigate weighted multiset\nautomata and show how to construct them from weighted regular expressions. We\npresent training methods to learn the weights for weighted regular expressions\nand for general multiset automata from data. Finally, we examine situations in\nwhich inside weights can be computed more efficiently.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.03315v1"
    },
    {
        "title": "Reducing Transducer Equivalence to Register Automata Problems Solved by\n  \"Hilbert Method\"",
        "authors": [
            "Adrien Boiret",
            "Radosław Piórkowski",
            "Janusz Schmude"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In the past decades, classical results from algebra, including Hilbert's\nBasis Theorem, had various applications in formal languages, including a proof\nof the Ehrenfeucht Conjecture, decidability of HDT0L sequence equivalence, and\ndecidability of the equivalence problem for functional tree-to-string\ntransducers. In this paper, we study the scope of the algebraic methods\nmentioned above, particularily as applied to the equivalence problem for\nregister automata. We provide two results, one positive, one negative. The\npositive result is that equivalence is decidable for MSO transformations on\nunordered forests. The negative result comes from a try to extend this method\nto decide equivalence on macro tree transducers. We reduce macro tree\ntransducers equivalence to an equivalence problem for some class of register\nautomata naturally relevant to our method. We then prove this latter problem to\nbe undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.04361v2"
    },
    {
        "title": "State Complexity of Pattern Matching in Regular Languages",
        "authors": [
            "Janusz A. Brzozowski",
            "Sylvie Davies",
            "Abhishek Madan"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In a simple pattern matching problem one has a pattern $w$ and a text $t$,\nwhich are words over a finite alphabet $\\Sigma$. One may ask whether $w$ occurs\nin $t$, and if so, where? More generally, we may have a set $P$ of patterns and\na set $T$ of texts, where $P$ and $T$ are regular languages. We are interested\nwhether any word of $T$ begins with a word of $P$, ends with a word of $P$, has\na word of $P$ as a factor, or has a word of $P$ as a subsequence. Thus we are\ninterested in the languages $(P\\Sigma^*)\\cap T$, $(\\Sigma^*P)\\cap T$,\n$(\\Sigma^* P\\Sigma^*)\\cap T$, and $(\\Sigma^* \\mathbin{\\operatorname{shu}}\nP)\\cap T$, where $\\operatorname{shu}$ is the shuffle operation. The state\ncomplexity $\\kappa(L)$ of a regular language $L$ is the number of states in the\nminimal deterministic finite automaton recognizing $L$. We derive the following\nupper bounds on the state complexities of our pattern-matching languages, where\n$\\kappa(P)\\le m$, and $\\kappa(T)\\le n$: $\\kappa((P\\Sigma^*)\\cap T) \\le mn$;\n$\\kappa((\\Sigma^*P)\\cap T) \\le 2^{m-1}n$; $\\kappa((\\Sigma^*P\\Sigma^*)\\cap T)\n\\le (2^{m-2}+1)n$; and $\\kappa((\\Sigma^*\\mathbin{\\operatorname{shu}} P)\\cap T)\n\\le (2^{m-2}+1)n$. We prove that these bounds are tight, and that to meet them,\nthe alphabet must have at least two letters in the first three cases, and at\nleast $m-1$ letters in the last case. We also consider the special case where\n$P$ is a single word $w$, and obtain the following tight upper bounds:\n$\\kappa((w\\Sigma^*)\\cap T_n) \\le m+n-1$; $\\kappa((\\Sigma^*w)\\cap T_n) \\le\n(m-1)n-(m-2)$; $\\kappa((\\Sigma^*w\\Sigma^*)\\cap T_n) \\le (m-1)n$; and\n$\\kappa((\\Sigma^*\\mathbin{\\operatorname{shu}} w)\\cap T_n) \\le (m-1)n$. For\nunary languages, we have a tight upper bound of $m+n-2$ in all eight of the\naforementioned cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.04645v2"
    },
    {
        "title": "The Intersection Problem for Finite Semigroups",
        "authors": [
            "Lukas Fleischer"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the intersection problem for finite semigroups, which asks for\na given set of regular languages, represented by recognizing morphisms to\nfinite semigroups, whether there exists a word contained in their intersection.\nWe introduce compressibility measures as a useful tool to classify the\nintersection problem for certain classes of finite semigroups into circuit\ncomplexity classes and Turing machine complexity classes. Using this framework,\nwe obtain a new and simple proof that for groups and commutative semigroups,\nthe problem is contained in NP. We uncover certain structural and\nnon-structural properties determining the complexity of the intersection\nproblem for varieties of semigroups containing only trivial submonoids. More\nspecifically, we prove NP-hardness for classes of semigroups having a property\ncalled unbounded order and for the class of all nilpotent semigroups of bounded\norder. On the contrary, we show that bounded order and commutativity imply\ncontainment in the circuit complexity class qAC^k (for some k) and decidability\nin quasi-polynomial time. We also establish connections to the monoid variant\nof the problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.04996v1"
    },
    {
        "title": "Deque languages, automata and planar graphs",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Pierluigi San Pietro"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The memory of a deque (double ended queue) automaton is more general than a\nqueue or two stacks; to avoid overgeneralization, we consider quasi-real-time\noperation. Normal forms of such automata are given. Deque languages form an AFL\nbut not a full one. We define the characteristic deque language, CDL, which\ncombines Dyck and AntiDyck (or FIFO) languages, and homomorphically\ncharacterizes the deque languages. The notion of deque graph, from graph\ntheory, well represents deque computation by means of a planar hamiltonian\ngraph on a cylinder, with edges visualizing producer-consumer relations for\ndeque symbols. We give equivalent definitions of CDL by labelled deque graphs,\nby cancellation rules, and by means of shuffle and intersection of simpler\nlanguages. The labeled deque graph of a sentence generalizes traditional syntax\ntrees. The layout of deque computations on a cylinder is remindful of 3D models\nused in theoretical (bio)chemistry.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.06562v1"
    },
    {
        "title": "A General Approach to State Complexity of Operations: Formalization and\n  Limitations",
        "authors": [
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The state complexity of the result of a regular operation is often positively\ncorrelated with the number of distinct transformations induced by letters in\nthe minimal deterministic finite automaton of the input languages. That is,\nmore transformations in the inputs means higher state complexity in the output.\nWhen this correlation holds, the state complexity of a unary operation can be\nmaximized using languages in which there is one letter corresponding to each\npossible transformation; for operations of higher arity, we can use $m$-tuples\nof languages in which there is one letter corresponding to each possible\n$m$-tuple of transformations. In this way, a small set of languages can be used\nas witnesses for many common regular operations, eliminating the need to search\nfor witnesses -- though at the expense of using very large alphabets. We\nformalize this approach and examine its limitations. We define a class of\n\"uniform\" operations for which this approach works; the class is closed under\ncomposition and includes common operations such as star, concatenation,\nreversal, union, and complement. Our main result is that the worst-case state\ncomplexity of a uniform operation can be determined by considering a finite set\nof witnesses, and this set depends only on the arity of the operation and the\nstate complexities of the inputs.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.08476v2"
    },
    {
        "title": "Determinization of Büchi Automata: Unifying the Approaches of Safra\n  and Muller-Schupp",
        "authors": [
            "Christof Löding",
            "Anton Pirogov"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Determinization of B\\\"uchi automata is a long-known difficult problem and\nafter the seminal result of Safra, who developed the first asymptotically\noptimal construction from B\\\"uchi into Rabin automata, much work went into\nimproving, simplifying or avoiding Safra's construction. A different, less\nknown determinization construction was derived by Muller and Schupp and appears\nto be unrelated to Safra's construction on the first sight. In this paper we\npropose a new meta-construction from nondeterministic B\\\"uchi to deterministic\nparity automata which strictly subsumes both the construction of Safra and the\nconstruction of Muller and Schupp. It is based on a correspondence between\nstructures that are encoded in the macrostates of the determinization\nprocedures - Safra trees on one hand, and levels of the split-tree, which\nunderlies the Muller and Schupp construction, on the other. Our construction\nallows for combining the mentioned constructions and opens up new directions\nfor the development of heuristics.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.02139v2"
    },
    {
        "title": "Walking on SR-automata to detect grammar ambiguity",
        "authors": [
            "Paola Quaglia"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We exploit the nondeterminism of LR parsing tables to reason about grammar\nambiguity after a conflict-driven strategy. First, from parsing tables we\ndefine specialized structures, called SR-automata. Next, we search for\nambiguous words along the paths of SR-automata that reach a conflict state and\nthen diverge along the branches corresponding to distinct resolutions of the\nconflict.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.02439v1"
    },
    {
        "title": "Structural Invariants for Parametric Verification of Systems with Almost\n  Linear Architectures",
        "authors": [
            "Marius Bozga",
            "Radu Iosif",
            "Joseph Sifakis"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider concurrent systems consisting of a finite but unknown number of\ncomponents, that are replicated instances of a given set of finite state\nautomata. The components communicate by executing interactions which are\nsimultaneous atomic state changes of a set of components. We specify both the\ntype of interactions (e.g.\\ rendez-vous, broadcast) and the topology (i.e.\\\narchitecture) of the system (e.g.\\ pipeline, ring) via a decidable interaction\nlogic, which is embedded in the classical weak sequential calculus of one\nsuccessor (WS1S). Proving correctness of such system for safety properties,\nsuch as deadlock freedom or mutual exclusion, requires the inference of an\ninductive invariant that subsumes the set of reachable states and avoids the\nunsafe states. Our method synthesizes such invariants directly from the formula\ndescribing the interactions, without costly fixed point iterations. We applied\nour technique to the verification of several textbook examples, such as dining\nphilosophers, mutual exclusion protocols and concurrent systems with preemption\nand priorities.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.02696v1"
    },
    {
        "title": "Deciding Equivalence of Separated Non-Nested Attribute Systems in\n  Polynomial Time",
        "authors": [
            "Helmut Seidl",
            "Raphaela Palenta",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In 1982, Courcelle and Franchi-Zannettacci showed that the equivalence\nproblem of separated non-nested attribute systems can be reduced to the\nequivalence problem of total deterministic separated basic macro tree\ntransducers. They also gave a procedure for deciding equivalence of transducer\nin the latter class. Here, we reconsider this equivalence problem. We present a\nnew alternative decision procedure and prove that it runs in polynomial time.\nWe also consider extensions of this result to partial transducers and to the\ncase where parameters of transducers accumulate strings instead of trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.03858v1"
    },
    {
        "title": "Separation and covering for group based concatenation hierarchies",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Concatenation hierarchies are classifications of regular languages. All such\nhierarchies are built through the same construction process: start from an\ninitial class of languages and build new levels using two generic operations.\nConcatenation hierarchies have gathered a lot of interest since the 70s, thanks\nto an alternate logical definition: each concatenation hierarchy is the\nquantification alternation hierarchy within a variant of first-order logic over\nwords.\n  Our goal is to understand such hierarchies. We look at two decision problems:\nmembership and separation. For a class of languages C, C-separation takes two\nregular languages as input and asks whether there exists a third one in C\nincluding the first one and disjoint from the second one. Settling whether\nseparation is decidable for the levels within a given concatenation hierarchy\nis among the most fundamental and challenging questions in formal language\ntheory. In all prominent cases, it is open, or answered positively for low\nlevels only. Recently, a breakthrough was made using a generic approach for a\nspecific kind of hierarchy: those with a finite basis. In this case, separation\nis always decidable for levels 1/2, 1 and 3/2.\n  Our main theorem is similar but independent: we consider hierarchies with\npossibly infinite bases, but that may only contain group languages. An example\nis the quantifier alternation hierarchy of first-order logic with modular\npredicates: its basis consists of languages counting the length of words modulo\nsome number. Using a generic approach, we show that for any such hierarchy, if\nseparation is decidable for the basis, then it is decidable for levels up to\n3/2. This complements the aforementioned result nicely: all bases considered in\nthe literature are either finite or made of group languages. Thus, one may\nhandle the lower levels of any prominent hierarchy in a generic way.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.04957v1"
    },
    {
        "title": "Slowly synchronizing DFAs of 7 states and maximal slowly synchronizing\n  DFAs",
        "authors": [
            "Michiel de Bondt"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We compute all synchronizing DFAs with 7 states and synchronization length >=\n29.\n  Furthermore, we compute alphabet size ranges for maximal, minimal and\nsemi-minimal synchronizing DFAs with up to 7 states.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.05331v1"
    },
    {
        "title": "Continuous Reachability for Unordered Data Petri nets is in PTime",
        "authors": [
            "Utkarsh Gupta",
            "Preey Shah",
            "S. Akshay",
            "Piotr Hofman"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Unordered data Petri nets (UDPN) are an extension of classical Petri nets\nwith tokens that carry data from an infinite domain and where transitions may\ncheck equality and disequality of tokens. UDPN are well-structured, so the\ncoverability and termination problems are decidable, but with higher complexity\nthan for Petri nets. On the other hand, the problem of reachability for UDPN is\nsurprisingly complex, and its decidability status remains open. In this paper,\nwe consider the continuous reachability problem for UDPN, which can be seen as\nan over-approximation of the reachability problem. Our main result is a\ncharacterization of continuous reachability for UDPN and polynomial time\nalgorithm for solving it. This is a consequence of a combinatorial argument,\nwhich shows that if continuous reachability holds then there exists a run using\nonly polynomially many data values.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.05604v1"
    },
    {
        "title": "Finite test sets for morphisms which are square-free on some of Thue's\n  square-free ternary words",
        "authors": [
            "James D. Currie"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Let $S$ be one of $\\{aba,bcb\\}$ and $\\{aba, aca\\}$, and let $w$ be an\ninfinite square-free word over $\\Sigma=\\{a,b,c\\}$ with no factor in $S$.\nSuppose that $f:\\Sigma\\rightarrow T^*$ is a non-erasing morphism. Word $f(w)$\nis square-free if and only if $f$ is square-free on factors of $w$ of length 8\nor less.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.05651v1"
    },
    {
        "title": "A Lower Bound for Primality of Finite Languages",
        "authors": [
            "Philip Sieder"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A regular language $L$ is said to be prime, if it is not the product of two\nnon-trivial languages. Martens et al. settled the exact complexity of deciding\nprimality for deterministic finite automata in 2010. For finite languages,\nMateescu et al. and Wieczorek suspect the $\\mathrm{NP}\\text{ - }completeness$\nof primality, but no actual bounds are given. Using techniques of Martens et\nal., we prove the $\\mathrm{NP}$ lower bound and give a $\\Pi_{2}^{\\mathrm{P}}$\nupper bound for deciding primality of finite languages given as deterministic\nfinite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.06253v1"
    },
    {
        "title": "Relational parsing: a clean, fast parsing strategy for all context-free\n  languages",
        "authors": [
            "Grzegorz Herman"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present a novel parsing algorithm for all context-free languages, based on\ncomputing the relation between configurations and reaching transitions in a\nrecursive transition network. Parsing complexity w.r.t. input length matches\nthe state of the art: it is worst-case cubic, quadratic for unambiguous\ngrammars, and linear for LR-regular ones. What distinguishes our algorithm is\nits clean mathematical formulation: parsing is expressed as a composition of\nsimple operations on languages and relations, and can therefore be implemented\nusing only immutable data structures. With a proper choice of these structures,\na vast majority of operations performed during parsing typical programming\nlanguages can be memoized, which allows our proof-of-concept implementation to\noutperform common generalized parsing algorithms, in some cases by orders of\nmagnitude.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.06591v1"
    },
    {
        "title": "The Frobenius and factor universality problems of the Kleene star of a\n  finite set of words",
        "authors": [
            "Maksymilian Mika",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We solve open problems concerning the Kleene star $L^*$ of a finite set $L$\nof words over an alphabet $\\Sigma$. The \\emph{Frobenius monoid} problem is the\nquestion for a given finite set of words $L$, whether the language $L^*$ is\ncofinite. We show that it is PSPACE-complete. We also exhibit an infinite\nfamily of sets $L$ such that the length of the longest words not in $L^*$ (when\n$L^*$ is cofinite) is exponential in the length of the longest words in $L$ and\nsubexponential in the sum of the lengths of words in $L$. The \\emph{factor\nuniversality} problem is the question for a given finite set of words $L$,\nwhether every word over $\\Sigma$ is a factor (substring) of some word from\n$L^*$. We show that it is also PSPACE-complete. Besides that, we exhibit an\ninfinite family of sets $L$ such that the length of the shortest words not\nbeing a factor of any word in $L^*$ is exponential in the length of the longest\nwords in $L$ and subexponential in the sum of the lengths of words in $L$. This\nessentially settles in the negative the longstanding Restivo's conjecture\n(1981) and its weak variations. All our solutions base on one shared\nconstruction, and as an auxiliary general tool, we introduce the concept of\n\\emph{set rewriting systems}. Finally, we complement the results with upper\nbounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.06702v5"
    },
    {
        "title": "Equivalence of finite-valued streaming string transducers is decidable",
        "authors": [
            "Anca Muscholl",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we provide a positive answer to a question left open by Alur\nand and Deshmukh in 2011 by showing that equivalence of finite-valued copyless\nstreaming string transducers is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.06973v2"
    },
    {
        "title": "The computational power of parsing expression grammars",
        "authors": [
            "Bruno Loff",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study the computational power of parsing expression grammars (PEGs). We\nbegin by constructing PEGs with unexpected behaviour, and surprising new\nexamples of languages with PEGs, including the language of palindromes whose\nlength is a power of two, and a binary-counting language. We then propose a new\ncomputational model, the scaffolding automaton, and prove that it exactly\ncharacterises the computational power of parsing expression grammars (PEGs).\n  Using this characterisation we show that:\n  (*) PEGs have unexpected power and semantics. We present several PEGs with\nsurprising behaviour, and languages which, unexpectedly, have PEGs, including a\nPEG for the language of palindromes whose length is a power of two.\n  (*) PEGs are computationally `universal', in the following sense: take any\ncomputable function $f:\\{0,1\\}^\\ast\\to \\{0,1\\}^\\ast$; then there exists a\ncomputable function $g: \\{0,1\\}^\\ast \\to \\mathbb{N}$ such that $\\{ f(x)\n\\#^{g(x)} x \\mid x \\in \\{0,1\\}^\\ast \\}$ has a PEG.\n  (*) There can be no pumping lemma for PEGs. There is no total computable\nfunction $A$ with the following property: for every well-formed PEG $G$, there\nexists $n_0$ such that for every string $x \\in \\mathcal{L}(G)$ of size $|x| \\ge\nn_0$, the output $y = A(G, x)$ is in $\\mathcal{L}(G)$ and has $|y| > |x|$.\n  (*) PEGs are strongly non real-time for Turing machines. There exists a\nlanguage with a PEG, such that neither it nor its reverse can be recognised by\nany multi-tape online Turing machine which is allowed to do only $o(n/\\log n)$\nsteps after reading each input symbol.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.08272v2"
    },
    {
        "title": "Register Games",
        "authors": [
            "Karoliina Lehtinen",
            "Udi Boker"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The complexity of parity games is a long standing open problem that saw a\nmajor breakthrough in 2017 when two quasi-polynomial algorithms were published.\nThis article presents a third, independent approach to solving parity games in\nquasi-polynomial time, based on the notion of register game, a parameterised\nvariant of a parity game. The analysis of register games leads to a\nquasi-polynomial algorithm for parity games, a polynomial algorithm for\nrestricted classes of parity games and a novel measure of complexity, the\nregister index, which aims to capture the combined complexity of the priority\nassignement and the underlying game graph.\n  We further present a translation of alternating parity word automata into\nalternating weak automata with only a quasi-polynomial increase in size, based\non register games; this improves on the previous exponential translation.\n  We also use register games to investigate the parity index hierarchy: while\nfor words the index hierarchy of alternating parity automata collapses to the\nweak level, and for trees it is strict, for structures between trees and words,\nit collapses logarithmically, in the sense that any parity tree automaton of\nsize n is equivalent, on these particular classes of structures, to an\nautomaton with a number of priorities logarithmic in n.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.10654v7"
    },
    {
        "title": "A Büchi-Elgot-Trakhtenbrot theorem for automata with MSO graph storage",
        "authors": [
            "Joost Engelfriet",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce MSO graph storage types, and call a storage type MSO-expressible\nif it is isomorphic to some MSO graph storage type. An MSO graph storage type\nhas MSO-definable sets of graphs as storage configurations and as storage\ntransformations. We consider sequential automata with MSO graph storage and\nassociate with each such automaton a string language (in the usual way) and a\ngraph language; a graph is accepted by the automaton if it represents a correct\nsequence of storage configurations for a given input string. For each MSO graph\nstorage type, we define an MSO logic which is a subset of the usual MSO logic\non graphs. We prove a B\\\"uchi-Elgot-Trakhtenbrot theorem, both for the string\ncase and the graph case. Moreover, we prove that (i) each MSO graph\ntransduction can be used as storage transformation in an MSO graph storage\ntype, (ii) every automatic storage type is MSO-expressible, and (iii) the\npushdown operator on storage types preserves the property of\nMSO-expressibility. Thus, the iterated pushdown storage types are\nMSO-expressible.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.00559v4"
    },
    {
        "title": "Synthesis of Data Word Transducers",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In reactive synthesis, the goal is to automatically generate an\nimplementation from a specification of the reactive and non-terminating\ninput/output behaviours of a system. Specifications are usually modelled as\nlogical formulae or automata over infinite sequences of signals\n($\\omega$-words), while implementations are represented as transducers. In the\nclassical setting, the set of signals is assumed to be finite. In this paper,\nwe consider data $\\omega$-words instead, i.e., words over an infinite alphabet.\nIn this context, we study specifications and implementations respectively given\nas automata and transducers extended with a finite set of registers. We\nconsider different instances, depending on whether the specification is\nnondeterministic, universal or deterministic, and depending on whether the\nnumber of registers of the implementation is given or not.\n  In the unbounded setting, we show undecidability for both universal and\nnondeterministic specifications, while decidability is recovered in the\ndeterministic case. In the bounded setting, undecidability still holds for\nnondeterministic specifications, but can be recovered by disallowing tests over\ninput data. The generic technique we use to show the latter result allows us to\nreprove some known result, namely decidability of bounded synthesis for\nuniversal specifications.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.03538v5"
    },
    {
        "title": "The Complexity of Transducer Synthesis from Multi-Sequential\n  Specifications",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Ismaël Jecker"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The transducer synthesis problem on finite words asks, given a specification\n$S \\subseteq I \\times O$, where $I$ and $O$ are sets of finite words, whether\nthere exists an implementation $f: I \\rightarrow O$ which (1) fulfils the\nspecification, i.e., $(i,f(i))\\in S$ for all $i\\in I$, and (2) can be defined\nby some input-deterministic (aka sequential) transducer $\\mathcal{T}_f$. If\nsuch an implementation $f$ exists, the procedure should also output\n$\\mathcal{T}_f$. The realisability problem is the corresponding decision\nproblem.\n  For specifications given by synchronous transducers (which read and write\nalternately one symbol), this is the finite variant of the classical synthesis\nproblem on $\\omega$-words, solved by B\\\"uchi and Landweber in 1969, and the\nrealisability problem is known to be ExpTime-c in both finite and $\\omega$-word\nsettings. For specifications given by asynchronous transducers (which can write\na batch of symbols, or none, in a single step), the realisability problem is\nknown to be undecidable.\n  We consider here the class of multi-sequential specifications, defined as\nfinite unions of sequential transducers over possibly incomparable domains. We\nprovide optimal decision procedures for the realisability problem in both the\nsynchronous and asynchronous setting, showing that it is PSpace-c. Moreover,\nwhenever the specification is realisable, we expose the construction of a\nsequential transducer that realises it and has a size that is doubly\nexponential, which we prove to be optimal.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.03560v1"
    },
    {
        "title": "A (co)algebraic theory of succinct automata",
        "authors": [
            "Gerco van Heerdt",
            "Joshua Moerman",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The classical subset construction for non-deterministic automata can be\ngeneralized to other side-effects captured by a monad. The key insight is that\nboth the state space of the determinized automaton and its\nsemantics---languages over an alphabet---have a common algebraic structure:\nthey are Eilenberg-Moore algebras for the powerset monad. In this paper we\nstudy the reverse question to determinization. We will present a construction\nto associate succinct automata to languages based on different algebraic\nstructures. For instance, for classical regular languages the construction will\ntransform a deterministic automaton into a non-deterministic one, where the\nstates represent the join-irreducibles of the language accepted by a\n(potentially) larger deterministic automaton. Other examples will yield\nalternating automata, automata with symmetries, CABA-structured automata, and\nweighted automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.05519v1"
    },
    {
        "title": "Long-Run Average Behavior of Vector Addition Systems with States",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A vector addition system with states (VASS) consists of a finite set of\nstates and counters. A configuration is a state and a value for each counter; a\ntransition changes the state and each counter is incremented, decremented, or\nleft unchanged. While qualitative properties such as state and configuration\nreachability have been studied for VASS, we consider the long-run average cost\nof infinite computations of VASS. The cost of a configuration is for each\nstate, a linear combination of the counter values. In the special case of\nuniform cost functions, the linear combination is the same for all states. The\n(regular) long-run emptiness problem is, given a VASS, a cost function, and a\nthreshold value, if there is a (lasso-shaped) computation such that the\nlong-run average value of the cost function does not exceed the threshold. For\nuniform cost functions, we show that the regular long-run emptiness problem is\n(a)~decidable in polynomial time for integer-valued VASS, and (b)~decidable but\nnonelementarily hard for natural-valued VASS (i.e., nonnegative counters). For\ngeneral cost functions, we show that the problem is (c)~NP-complete for\ninteger-valued VASS, and (d)~undecidable for natural-valued VASS. Our most\ninteresting result is for (c) integer-valued VASS with general cost functions,\nwhere we establish a connection between the regular long-run emptiness problem\nand quadratic Diophantine inequalities. The general (nonregular) long-run\nemptiness problem is equally hard as the regular problem in all cases except\n(c), where it remains open.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.05537v1"
    },
    {
        "title": "Abstraction Refinement Algorithms for Timed Automata",
        "authors": [
            "Victor Roussanaly",
            "Ocan Sankur",
            "Nicolas Markey"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present abstraction-refinement algorithms for model checking safety\nproperties of timed automata. The abstraction domain we consider abstracts away\nzones by restricting the set of clock constraints that can be used to define\nthem, while the refinement procedure computes the set of constraints that must\nbe taken into consideration in the abstraction so as to exclude a given\nspurious counterexample. We implement this idea in two ways: an enumerative\nalgorithm where a lazy abstraction approach is adopted, meaning that possibly\ndifferent abstract domains are assigned to each exploration node; and a\nsymbolic algorithm where the abstract transition system is encoded with Boolean\nformulas.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.07365v3"
    },
    {
        "title": "The teaching complexity of erasing pattern languages with bounded\n  variable frequency",
        "authors": [
            "Ziyuan Gao"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Patterns provide a concise, syntactic way of describing a set of strings, but\ntheir expressive power comes at a price: a number of fundamental decision\nproblems concerning (erasing) pattern languages, such as the membership problem\nand inclusion problem, are known to be NP-complete or even undecidable, while\nthe decidability of the equivalence problem is still open; in learning theory,\nthe class of pattern languages is unlearnable in models such as the\ndistribution-free (PAC) framework (if $\\mathcal{P}/poly \\neq\n\\mathcal{NP}/poly$). Much work on the algorithmic learning of pattern languages\nhas thus focussed on interesting subclasses of patterns for which positive\nlearnability results may be achieved. A natural restriction on a pattern is a\nbound on its variable frequency -- the maximum number $m$ such that some\nvariable occurs exactly $m$ times in the pattern. This paper examines the\neffect of limiting the variable frequency of all patterns belonging to a class\n$\\Pi$ on the worst-case minimum number of labelled examples needed to uniquely\nidentify any pattern of $\\Pi$ in cooperative teaching-learning models. Two such\nmodels, the teaching dimension model as well as the preference-based teaching\nmodel, will be considered.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.07737v1"
    },
    {
        "title": "A combinatorial approach for the state complexity of the Shuffle product",
        "authors": [
            "Pascal Caron",
            "Jean-Gabriel Luque",
            "Bruno Patrou"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We investigate the state complexity of the shuffle operation on regular\nlanguages initiated by Campeanu et al. and studied subsequently by Brzozowski\net al. We shift the problem into the combinatorics domain by turning the\nproblem of state accessibility into a problem of intersection of partitions.\nThis allows us to develop new tools and to reformulate the conjecture of\nBrzozowski et al. about the above-mentionned state complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.08120v1"
    },
    {
        "title": "On Timed Scope-bounded Context-sensitive Languages",
        "authors": [
            "Devendra. Bhave",
            "S. N. Krishna",
            "Ramchandra Phawade",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In (DLT 2016) we studied timed context sensitive languages characterized by\nmultiple stack push down automata (MPA), with an explicit bound on number of\nstages where in each stage at most one stack is used (k-round MPA).\n  In this paper, we continue our work on timed MPA and study a subclass in\nwhich a symbol corresponding to a stack being pushed in it must be popped\nwithin fixed number of contexts of that stack---scope-bounded push-down\nautomata with multiple stacks (k-scope MPA). We use Visibly Push-down Alphabet\nand Event Clocks to show that timed k-scope MPA have decidable reachability\nproblem; are closed under Boolean operations; and have an equivalent logical\ncharacterization.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.11125v1"
    },
    {
        "title": "New Results on Vector and Homing Vector Automata",
        "authors": [
            "Özlem Salehi",
            "Abuzer Yakaryılmaz",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present several new results and connections between various extensions of\nfinite automata through the study of vector automata and homing vector\nautomata. We show that homing vector automata outperform extended finite\nautomata when both are defined over $ 2 \\times 2 $ integer matrices. We study\nthe string separation problem for vector automata and demonstrate that\ngeneralized finite automata with rational entries can separate any pair of\nstrings using only two states. Investigating stateless homing vector automata,\nwe prove that a language is recognized by stateless blind deterministic\nreal-time version of finite automata with multiplication iff it is commutative\nand its Parikh image is the set of nonnegative integer solutions to a system of\nlinear homogeneous Diophantine equations.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.11857v1"
    },
    {
        "title": "On the Containment Problem for Unambiguous Single-Register Automata with\n  Guessing",
        "authors": [
            "Antoine Mottet",
            "Karin Quaas"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Register automata extend classical finite automata with a finite set of\nregisters that can store data from an infinite data domain for later equality\ncomparisons with data from an input data word. While the registers in the\noriginal model of register automata, introduced in 1994 by Kaminski and\nFrancez, can only store data occurring in the data word processed so far, we\nstudy here the more expressive class of register automata with guessing, where\nregisters can nondeterministically take any value from the infinite data\ndomain, even if this data does not occur in the input data word. It is well\nknown that the containment problem, i.e., the problem of deciding for two given\nregister automata with guessing A and B, whether the language L(A) accepted by\nA is contained in the language L(B) accepted by B, is undecidable, even if B\nonly uses a single register. We prove that the problem is decidable if B is\nunambiguous and uses a single register.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.12445v1"
    },
    {
        "title": "Distribution of Behaviour into Parallel Communicating Subsystems",
        "authors": [
            "Omar al Duhaiby",
            "Jan Friso Groote"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The process of decomposing a complex system into simpler subsystems has been\nof interest to computer scientists over many decades, for instance, for the\nfield of distributed computing. In this paper, motivated by the desire to\ndistribute the process of active automata learning onto multiple subsystems, we\nstudy the equivalence between a system and the total behaviour of its\ndecomposition which comprises subsystems with communication between them. We\nshow synchronously- and asynchronously-communicating decompositions that\nmaintain branching bisimilarity, and we prove that there is no decomposition\noperator that maintains divergence-preserving branching bisimilarity over all\nLTSs.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.12963v3"
    },
    {
        "title": "Crisp-determinization of weighted tree automata over strong bimonoids",
        "authors": [
            "Zoltán Fülöp",
            "Dávid Kószó",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider weighted tree automata (wta) over strong bimonoids and their\ninitial algebra semantics and their run semantics. There are wta for which\nthese semantics are different; however, for bottom-up deterministic wta and for\nwta over semirings, the difference vanishes. A wta is crisp-deterministic if it\nis bottom-up deterministic and each transition is weighted by one of the unit\nelements of the strong bimonoid. We prove that the class of weighted tree\nlanguages recognized by crisp-deterministic wta is the same as the class of\nrecognizable step mappings. Moreover, we investigate the following two\ncrisp-determinization problems: for a given wta ${\\cal A}$, (a) does there\nexist a crisp-deterministic wta which computes the initial algebra semantics of\n${\\cal A}$ and (b) does there exist a crisp-deterministic wta which computes\nthe run semantics of ${\\cal A}$? We show that the finiteness of the Nerode\nalgebra ${\\cal N}({\\cal A})$ of ${\\cal A}$ implies a positive answer for (a),\nand that the finite order property of ${\\cal A}$ implies a positive answer for\n(b). We show a sufficient condition which guarantees the finiteness of ${\\cal\nN}({\\cal A})$ and a sufficient condition which guarantees the finite order\nproperty of ${\\cal A}$. Also, we provide an algorithm for the construction of\nthe crisp-deterministic wta according to (a) if ${\\cal N}({\\cal A})$ is finite,\nand similarly for (b) if ${\\cal A}$ has finite order property. We prove that it\nis undecidable whether an arbitrary wta ${\\cal A}$ is crisp-determinizable. We\nalso prove that both, the finiteness of ${\\cal N}({\\cal A})$ and the finite\norder property of ${\\cal A}$ are undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.02660v3"
    },
    {
        "title": "Transformation of Turing Machines into Context-Dependent Fusion Grammars",
        "authors": [
            "Aaron Lye"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Context-dependent fusion grammars were recently introduced as devices for the\ngeneration of hypergraph languages. In this paper, we show that this new type\nof hypergraph grammars, where the application of fusion rules is restricted by\npositive and negative context conditions, is a universal computation model. Our\nmain result is that Turing machines can be transformed into these grammars such\nthat the recognized language of the Turing machine and the generated language\nof the corresponding context-dependent fusion grammar coincide up to\nrepresentation of strings as graphs. As a corollary we get that\ncontext-dependent fusion grammars can generate all recursively enumerable\nstring languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.09608v1"
    },
    {
        "title": "Extended Models of Finite Automata",
        "authors": [
            "Özlem Salehi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Many of the numerous automaton models proposed in the literature can be\nregarded as a finite automaton equipped with an additional storage mechanism.\nIn this thesis, we focus on two such models, namely the finite automata over\ngroups and the homing vector automata.\n  A finite automaton over a group $ G $ is a nondeterministic finite automaton\nequipped with a register that holds an element of the group $ G $. The register\nis initialized to the identity element of the group and a computation is\nsuccessful if the register is equal to the identity element at the end of the\ncomputation after being multiplied with a group element at every step. We\ninvestigate the language recognition power of finite automata over integer and\nrational matrix groups and reveal new relationships between the language\nclasses corresponding to these models. We examine the effect of various\nparameters on the language recognition power. We establish a link between the\ndecision problems of matrix semigroups and the corresponding automata. We\npresent some new results about valence pushdown automata and context-free\nvalence grammars.\n  We also propose the new homing vector automaton model, which is a finite\nautomaton equipped with a vector that can be multiplied with a matrix at each\nstep. The vector can be checked for equivalence to the initial vector and the\nacceptance criterion is ending up in an accept state with the value of the\nvector being equal to the initial vector. We examine the effect of various\nrestrictions on the model by confining the matrices to a particular set and\nallowing the equivalence test only at the end of the computation. We define the\ndifferent variants of the model and compare their language recognition power\nwith that of the classical models.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.11699v1"
    },
    {
        "title": "Bounded languages described by GF(2)-grammars",
        "authors": [
            "Vladislav Makarov"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  GF(2)-grammars are a recently introduced grammar family with some unusual\nalgebraic properties. They are closely connected to unambiguous grammars. By\nusing the method of formal power series, we establish strong conditions that\nare necessary for subsets of a^* b^* and a^* b^* c^* to be described by some\nGF(2)-grammar. By further applying the established results, we settle the\nlong-standing open question of proving inherent ambiguity of the language {a^n\nb^m c^k | n != m or m != k}$, as well as give a new purely algebraic proof of\nthe inherent ambiguity of the language {a^n b^m c^k}{n = m or m = k}.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.13401v4"
    },
    {
        "title": "Equivalence of Linear Tree Transducers with Output in the Free Group",
        "authors": [
            "Raphaela Löbel",
            "Michael Luttenberger",
            "Helmut Seidl"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that equivalence of deterministic linear tree transducers can be\ndecided in polynomial time when their outputs are interpreted over the free\ngroup. Due to the cancellation properties offered by the free group, the\nrequired constructions are not only more general, but also simpler than the\ncorresponding constructions for proving equivalence of deterministic linear\ntree-to-word transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.03480v2"
    },
    {
        "title": "Reachability in fixed dimension vector addition systems with states",
        "authors": [
            "Wojciech Czerwiński",
            "Sławomir Lasota",
            "Ranko Lazić",
            "Jérôme Leroux",
            "Filip Mazowiecki"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The reachability problem is a central decision problem for formal\nverification based on vector addition systems with states (VASS), which are\nequivalent to Petri nets and form one of the most studied and applied models of\nconcurrency. Reachability for VASS is also inter-reducible with a plethora of\nproblems from a number of areas of computer science. In spite of recent\nprogress, the complexity of the reachability problem remains unsettled, and it\nis closely related to the lengths of shortest VASS runs that witness\nreachability.\n  We consider VASS of fixed dimension, and obtain three main results. For the\nfirst two, we assume that the integers in the input are given in unary, and\nthat the control graph of the given VASS is flat (i.e., without nested cycles).\nWe obtain a family of VASS in dimension 3 whose shortest reachability\nwitnessing runs are exponential, and we show that the reachability problem is\nNP-hard in dimension 7. These results resolve negatively questions that had\nbeen posed by the works of Blondin et al. in LICS 2015 and Englert et al. in\nLICS 2016, and contribute a first construction that distinguishes 3-dimensional\nflat VASS from 2-dimensional VASS.\n  Our third result, by means of a novel family of products of integer\nfractions, shows that 4-dimensional VASS can have doubly exponentially long\nshortest reachability witnessing runs. The smallest dimension for which this\nwas previously known is 14.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.04327v3"
    },
    {
        "title": "A Categorical Framework for Learning Generalised Tree Automata",
        "authors": [
            "Gerco van Heerdt",
            "Tobias Kappé",
            "Jurriaan Rot",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Automata learning is a popular technique used to automatically construct an\nautomaton model from queries. Much research went into devising ad hoc\nadaptations of algorithms for different types of automata. The CALF project\nseeks to unify these using category theory in order to ease correctness proofs\nand guide the design of new algorithms. In this paper, we extend CALF to cover\nlearning of algebraic structures that may not have a coalgebraic presentation.\nFurthermore, we provide a detailed algorithmic account of an abstract version\nof the popular L* algorithm, which was missing from CALF. We instantiate the\nabstract theory to a large class of Set functors, by which we recover for the\nfirst time practical tree automata learning algorithms from an abstract\nframework and at the same time obtain new algorithms to learn algebras of\nquotiented polynomial functors.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.05786v2"
    },
    {
        "title": "Nonregularity via Ordinal Extensions",
        "authors": [
            "Jack H. Lutz",
            "Giora Slutzki"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We present a simple new method for proving that languages are not regular. We\nprove the correctness of the method, illustrate the ease of using the method on\nwell-known examples of nonregular languages, and prove two additional theorems\non the power and limitations of the method.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.08846v1"
    },
    {
        "title": "Provenance for Regular Path Queries",
        "authors": [
            "Gosta Grahne",
            "Alex Thomo"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Regular path queries (RPQs) the ubiquitous mechanism for querying data graphs\nof partially known structure. RPQs are in essence regular expressions over the\nedge symbols. The answer to an RPQ on a given graph (database) is the set of\npairs of objects, which are connected by paths spelling words in the language\nof the regular path query. Often the database edges come with a weights\nassoaciated to them. Such weights can distances, levels of discomfort,\nmultiplicities, etc. We model weights using semiring frameworks.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.09864v2"
    },
    {
        "title": "The Uniform Measure of Simple Regular Sets of Infinite Trees",
        "authors": [
            "Marcin Przybyłko",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider the problem of computing the measure of a regular set of infinite\nbinary trees. While the general case remains unsolved, we show that the measure\nof a language can be computed when the set is given in one of the following\nthree formalisms: a first-order formula with no descendant relation; a Boolean\ncombination of conjunctive queries (with descendant relation); or by a\nnon-deterministic safety tree automaton. Additionally, in the first two cases\nthe measure of the set is always rational, while in the third it is an\nalgebraic number. Moreover, we provide an example of a first-order formula that\nuses descendant relation and defines a language of infinite trees having an\nirrational (but algebraic) measure.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.11576v1"
    },
    {
        "title": "Register transducers are marble transducers",
        "authors": [
            "Gaëtan Douéneau-Tabot",
            "Emmanuel Filiot",
            "Paul Gastin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Deterministic two-way transducers define the class of regular functions from\nwords to words. Alur and Cern\\'y introduced an equivalent model of transducers\nwith registers called copyless streaming string transducers. In this paper, we\ndrop the \"copyless\" restriction on these machines and show that they are\nequivalent to two-way transducers enhanced with the ability to drop marks,\nnamed \"marbles\", on the input. We relate the maximal number of marbles used\nwith the amount of register copies performed by the streaming string\ntransducer. Finally, we show that the class membership problems associated with\nthese models are decidable. Our results can be interpreted in terms of program\noptimization for simple recursive and iterative programs.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.01342v1"
    },
    {
        "title": "Automata Tutor v3",
        "authors": [
            "Loris D'Antoni",
            "Martin Helfrich",
            "Jan Kretinsky",
            "Emanuel Ramneantu",
            "Maximilian Weininger"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Computer science class enrollments have rapidly risen in the past decade.\nWith current class sizes, standard approaches to grading and providing\npersonalized feedback are no longer possible and new techniques become both\nfeasible and necessary. In this paper, we present the third version of Automata\nTutor, a tool for helping teachers and students in large courses on automata\nand formal languages. The second version of Automata Tutor supported automatic\ngrading and feedback for finite-automata constructions and has already been\nused by thousands of users in dozens of countries. This new version of Automata\nTutor supports automated grading and feedback generation for a greatly extended\nvariety of new problems, including problems that ask students to create regular\nexpressions, context-free grammars, pushdown automata and Turing machines\ncorresponding to a given description, and problems about converting between\nequivalent models - e.g., from regular expressions to nondeterministic finite\nautomata. Moreover, for several problems, this new version also enables\nteachers and students to automatically generate new problem instances. We also\npresent the results of a survey run on a class of 950 students, which shows\nvery positive results about the usability and usefulness of the tool.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.01419v4"
    },
    {
        "title": "What You Must Remember When Transforming Datawords",
        "authors": [
            "M. Praveen"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Streaming Data String Transducers (SDSTs) were introduced to model a class of\nimperative and a class of functional programs, manipulating lists of data\nitems. These can be used to write commonly used routines such as insert, delete\nand reverse. SDSTs can handle data values from a potentially infinite data\ndomain. The model of Streaming String Transducers (SSTs) is the fragment of\nSDSTs where the infinite data domain is dropped and only finite alphabets are\nconsidered. SSTs have been much studied from a language theoretical point of\nview. We introduce data back into SSTs, just like data was introduced to finite\nstate automata to get register automata. The result is Streaming String\nRegister Transducers (SSRTs), which is a subclass of SDSTs. SDSTs can compare\ndata values using a linear order on the data domain, which can not be done by\nSSRTs.\n  We give a machine independent characterization of SSRTs with origin\nsemantics, along the lines of Myhill-Nerode theorem. Machine independent\ncharacterizations for similar models have formed the basis of learning\nalgorithms and enabled us to understand fragments of the models. Origin\nsemantics of transducers track which positions of the output originate from\nwhich positions of the input. Although a restriction, using origin semantics is\nwell justified and known to simplify many problems related to transducers. We\nuse origin semantics as a technical building block, in addition to\ncharacterizations of deterministic register automata. However, we need to build\nmore on top of these to overcome some challenges unique to SSRTs.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.02596v2"
    },
    {
        "title": "Parametrized Universality Problems for One-Counter Nets",
        "authors": [
            "Shaull Almagor",
            "Udi Boker",
            "Piotr Hofman",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the language universality problem for One-Counter Nets, also known\nas 1-dimensional Vector Addition Systems with States (1-VASS), parameterized\neither with an initial counter value, or with an upper bound on the allowed\ncounter value during runs. The language accepted by an OCN (defined by reaching\na final control state) is monotone in both parameters. This yields two natural\nquestions: 1) Does there exist an initial counter value that makes the language\nuniversal? 2) Does there exist a sufficiently high ceiling so that the bounded\nlanguage is universal? Although the ordinary universality problem is decidable\n(and Ackermann-complete) and these parameterized problems seem to reduce to\nchecking basic structural properties of the underlying automaton, we show that\nin fact both problems are undecidable. We also look into the complexities of\nthe problems for several decidable subclasses, namely for unambiguous, and\ndeterministic systems, and for those over a single-letter alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.03435v2"
    },
    {
        "title": "Two-way Nanoscale automata",
        "authors": [
            "Debayan Ganguly",
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we show the all final subclass of two-way Watson-Crick\nautomata have the same computational power as the classical two-way\nWatson-Crick automata. Here we compare the computational power of two-way\nWatson-Crick automata and two-way Quantum finite automata and we observe that\ntwo-way Watson-Crick automata can accept a language which two-way quantum\nfinite automata cannot accept.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.07569v1"
    },
    {
        "title": "State Complexity of Reversible Watson-Crick Automata",
        "authors": [
            "Kingshuk Chatterjee",
            "Debayan Ganguly",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Reversible Watson-Crick automata introduced by Chatterjee et.al. is a\nreversible variant of an Watson-Crick automata. It has already been shown that\nthe addition of DNA properties to reversible automata significantly increases\nthe computational power of the model. In this paper, we analyze the state\ncomplexity of Reversible Watson-Crick automata with respect to\nnon-deterministic finite automata. We show that Reversible Watson-Crick\nautomata in spite of being reversible in nature enjoy state complexity\nadvantage over non deterministic finite automata. The result is interesting\nbecause conversion from non deterministic to deterministic automata results in\nexponential blow up of the number of states and classically increase in number\nof heads of the automata cannot compensate for non-determinism in deterministic\nand reversible models.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.10126v1"
    },
    {
        "title": "Multi-head Watson-Crick quantum finite automata",
        "authors": [
            "Debayan Ganguly",
            "Kingshuk Chatterjee",
            "Kumar Sankar Ray"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Watson-Crick quantum finite automata were introduced by Ganguly et.al. by\ncombining properties of DNA and Quantum automata. In this paper we introduce a\nmulti-head version of the above automaton. We further show that the multi-head\nvariant is computationally more powerful than one-way multi-head reversible\nfinite automata. In fact we also show that the multi-head variant accepts a\nlanguage which is not accepted by any one-way multi-head deterministic finite\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.10127v1"
    },
    {
        "title": "Timed Automata Benchmark Description",
        "authors": [
            "Peter Fontana",
            "Rance Cleaveland"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This report contains the descriptions of the timed automata (models) and the\nproperties (specifications) that are used as the \"benchmark examples in Data\nstructure choices for on-the-fly model checking of real-time systems\" and \"The\npower of proofs: New algorithms for timed automata model checking.\" The four\nmodels from those sources are: CSMA, FISCHER, LEADER, and GRC. Additionally we\ninclude in this report two additional models: FDDI and PATHOS. These six models\nare often used to benchmark timed automata model checker speed throughout timed\nautomata model checking papers.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.13151v1"
    },
    {
        "title": "Syntactic Complexity of Star-Free Languages",
        "authors": [
            "Janusz Brzozowski",
            "Baiyu Li"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The syntactic complexity of a regular language is the cardinality of its\nsyntactic semigroup. The syntactic complexity of a subclass of regular\nlanguages is the maximal syntactic complexity of languages in that subclass,\ntaken as a function of the state complexity of these languages. We study the\nsyntactic complexity of star-free regular languages, that is, languages that\ncan be constructed from finite languages using union, complement and\nconcatenation. We find tight upper bounds on the syntactic complexity of\nlanguages accepted by monotonic and partially monotonic automata. We introduce\n\"nearly monotonic\" automata, which accept star-free languages, and find a tight\nupper bound on the syntactic complexity of languages accepted by such automata.\nWe conjecture that this bound is also an upper bound on the syntactic\ncomplexity of star-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1109.3381v1"
    },
    {
        "title": "A decidable characterization of locally testable tree languages",
        "authors": [
            "Thomas Place",
            "Luc Segoufin"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A regular tree language L is locally testable if membership of a tree in L\ndepends only on the presence or absence of some fix set of neighborhoods in the\ntree. In this paper we show that it is decidable whether a regular tree\nlanguage is locally testable. The decidability is shown for ranked trees and\nfor unranked unordered trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1109.5851v2"
    },
    {
        "title": "Parameterised Pushdown Systems with Non-Atomic Writes",
        "authors": [
            "Matthew Hague"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We consider the master/slave parameterised reachability problem for networks\nof pushdown systems, where communication is via a global store using only\nnon-atomic reads and writes. We show that the control-state reachability\nproblem is decidable. As part of the result, we provide a constructive\nextension of a theorem by Ehrenfeucht and Rozenberg to produce an NFA\nequivalent to certain kinds of CFG. Finally, we show that the non-parameterised\nversion is undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1109.6264v1"
    },
    {
        "title": "Degrees of Lookahead in Regular Infinite Games",
        "authors": [
            "Michael Holtmann",
            "Lukasz Kaiser",
            "Wolfgang Thomas"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study variants of regular infinite games where the strict alternation of\nmoves between the two players is subject to modifications. The second player\nmay postpone a move for a finite number of steps, or, in other words, exploit\nin his strategy some lookahead on the moves of the opponent. This captures\nsituations in distributed systems, e.g. when buffers are present in\ncommunication or when signal transmission between components is deferred. We\ndistinguish strategies with different degrees of lookahead, among them being\nthe continuous and the bounded lookahead strategies. In the first case the\nlookahead is of finite possibly unbounded size, whereas in the second case it\nis of bounded size. We show that for regular infinite games the solvability by\ncontinuous strategies is decidable, and that a continuous strategy can always\nbe reduced to one of bounded lookahead. Moreover, this lookahead is at most\ndoubly exponential in the size of a given parity automaton recognizing the\nwinning condition. We also show that the result fails for non-regular\ngamesxwhere the winning condition is given by a context-free omega-language.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.0800v3"
    },
    {
        "title": "Automatic Unbounded Verification of Alloy Specifications with Prover9",
        "authors": [
            "Nuno Macedo",
            "Alcino Cunha"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Alloy is an increasingly popular lightweight specification language based on\nrelational logic. Alloy models can be automatically verified within a bounded\nscope using off-the-shelf SAT solvers. Since false assertions can usually be\ndisproved using small counter-examples, this approach suffices for most\napplications. Unfortunately, it can sometimes lead to a false sense of\nsecurity, and in critical applications a more traditional unbounded proof may\nbe required. The automatic theorem prover Prover9 has been shown to be\nparticularly effective for proving theorems of relation algebras [7], a\nquantifier-free (or point-free) axiomatization of a fragment of relational\nlogic. In this paper we propose a translation from Alloy specifications to fork\nalgebras (an extension of relation algebras with the same expressive power as\nrelational logic) which enables their unbounded verification in Prover9. This\ntranslation covers not only logic assertions, but also the structural aspects\n(namely type declarations), and was successfully implemented and applied to\nseveral examples.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.5773v1"
    },
    {
        "title": "Most Complex Regular Ideal Languages",
        "authors": [
            "Janusz Brzozowski",
            "Sylvie Davies",
            "Bo Yang Victor Liu"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A right ideal (left ideal, two-sided ideal) is a non-empty language $L$ over\nan alphabet $\\Sigma$ such that $L=L\\Sigma^*$ ($L=\\Sigma^*L$,\n$L=\\Sigma^*L\\Sigma^*$). Let $k=3$ for right ideals, 4 for left ideals and 5 for\ntwo-sided ideals. We show that there exist sequences ($L_n \\mid n \\ge k $) of\nright, left, and two-sided regular ideals, where $L_n$ has quotient complexity\n(state complexity) $n$, such that $L_n$ is most complex in its class under the\nfollowing measures of complexity: the size of the syntactic semigroup, the\nquotient complexities of the left quotients of $L_n$, the number of atoms\n(intersections of complemented and uncomplemented left quotients), the quotient\ncomplexities of the atoms, and the quotient complexities of reversal, star,\nproduct (concatenation), and all binary boolean operations. In that sense,\nthese ideals are \"most complex\" languages in their classes, or \"universal\nwitnesses\" to the complexity of the various operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.00157v3"
    },
    {
        "title": "Invisible pushdown languages",
        "authors": [
            "Eryk Kopczynski"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Context free languages allow one to express data with hierarchical structure,\nat the cost of losing some of the useful properties of languages recognized by\nfinite automata on words. However, it is possible to restore some of these\nproperties by making the structure of the tree visible, such as is done by\nvisibly pushdown languages, or finite automata on trees. In this paper, we show\nthat the structure given by such approaches remains invisible when it is read\nby a finite automaton (on word). In particular, we show that separability with\na regular language is undecidable for visibly pushdown languages, just as it is\nundecidable for general context free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.00289v1"
    },
    {
        "title": "Data Language Specification via Terminal Attribution",
        "authors": [
            "Alexander Sakharov",
            "Timothy Sakharov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Unstructured data have to be parsed in order to become usable. The complexity\nof grammar notations and the difficulty of grammar debugging limit the use of\nparsers for data preprocessing. We introduce a notation in which grammars are\ndefined by simply dividing terminals into predefined classes and then splitting\nelements of some classes into multiple layered sub-groups. These LL(1) grammars\nare designed for data languages. They simplify the task of developing data\nparsers.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.00909v1"
    },
    {
        "title": "Optimised determinisation and completion of finite tree automata",
        "authors": [
            "John P. Gallagher",
            "Mai Ajspur",
            "Bishoksan Kafle"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Determinisation and completion of finite tree automata are important\noperations with applications in program analysis and verification. However, the\ncomplexity of the classical procedures for determinisation and completion is\nhigh. They are not practical procedures for manipulating tree automata beyond\nvery small ones. In this paper we develop an algorithm for determinisation and\ncompletion of finite tree automata, whose worst-case complexity remains\nunchanged, but which performs far better than existing algorithms in practice.\nThe critical aspect of the algorithm is that the transitions of the\ndeterminised (and possibly completed) automaton are generated in a potentially\nvery compact form called product form, which can reduce the size of the\nrepresentation dramatically. Furthermore, the representation can often be used\ndirectly when manipulating the determinised automaton. The paper contains an\nexperimental evaluation of the algorithm on a large set of tree automata\nexamples.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.03595v2"
    },
    {
        "title": "Context-Free Commutative Grammars with Integer Counters and Resets",
        "authors": [
            "Dmitry Chistikov",
            "Christoph Haase",
            "Simon Halfon"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study the computational complexity of reachability, coverability and\ninclusion for extensions of context-free commutative grammars with integer\ncounters and reset operations on them. Those grammars can alternatively be\nviewed as an extension of communication-free Petri nets. Our main results are\nthat reachability and coverability are inter-reducible and both NP-complete. In\nparticular, this class of commutative grammars enjoys semi-linear reachability\nsets. We also show that the inclusion problem is, in general, coNEXP-complete\nand already $\\Pi_2^\\text{P}$-complete for grammars with only one non-terminal\nsymbol. Showing the lower bound for the latter result requires us to develop a\nnovel $\\Pi_2^\\text{P}$-complete variant of the classic subset sum problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.04893v2"
    },
    {
        "title": "Joining Transition Systems of Records: Some Congruency and\n  Language-Theoretic Results",
        "authors": [
            "Mohammad Izadi",
            "Saeed Masoudian",
            "Sahand Mozaffari"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  B\\\"uchi automaton of records (BAR) has been proposed as a basic operational\nsemantics for Reo coordination language. It is an extension of B\\\"uchi\nautomaton by using a set of records as its alphabet or transition labels.\nRecords are used to express the synchrony between the externally visible\nactions of coordinated components modeled by BARs. The main composition\noperator on the set of BARs is called as join which is the semantics of its\ncounterpart in Reo. In this paper, we define the notion of labeled transition\nsystems of records as a generalization of the notion of BAR, abstracting away\nfrom acceptance or rejection of strings. Then, we consider four equivalence\nrelations (semantics) over the set of labeled transition systems of records and\ninvestigate their congruency with respect to the join composition operator. In\nfact, we prove that the finite-traces-based, infinite-traces-based, and\nnondeterministic finite automata (NFA)-based equivalence relations all are\ncongruence relations over the set of all labeled transition systems of records\nwith respect to the join operation. However, the equivalence relation using\nB\\\"uchi acceptance condition is not so. In addition, using these results, we\nintroduce the language-theoretic definitions of the join operation considering\nboth finite and infinite strings notions. Also, we show that there is no\nlanguage-based and structure-independent definition of the join operation on\nB\\\"uchi automata of records.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.05070v1"
    },
    {
        "title": "On LR(k)-parsers of polynomial size",
        "authors": [
            "Norbert Blum"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Usually, a parser for an $LR(k)$-grammar $G$ is a deterministic pushdown\ntransducer which produces backwards the unique rightmost derivation for a given\ninput string $x \\in L(G)$. The best known upper bound for the size of such a\nparser is $O(2^{|G||\\Sigma|^k+k\\log |\\Sigma| + \\log |G|})$ where $|G|$ and\n$|\\Sigma|$ are the sizes of the grammar $G$ and the terminal alphabet $\\Sigma$,\nrespectively. If we add to a parser the possibility to manipulate a directed\ngraph of size $O(|G|n)$ where $n$ is the length of the input then we obtain an\nextended parser. The graph is used for an efficient parallel simulation of all\npotential leftmost derivations of the current right sentential form such that\nthe unique rightmost derivation of the input can be computed. Given an\narbitrary $LR(k)$-grammar $G$, we show how to construct an extended parser of\n$O(|G| + \\#LA |N|2^k k \\log k)$ size where $|N|$ is the number of nonterminal\nsymbols and $\\#LA$ is the number of relevant lookaheads with respect to the\ngrammar $G$. As the usual parser, this extended parser uses only tables as data\nstructure. Using some ingenious data structures and increasing the parsing time\nby a small constant factor, the size of the extended parser can be reduced to\n$O(|G| + \\#LA|N|k^2)$. The parsing time is $O(ld(input) + k|G|n)$ where\n$ld(input)$ is the length of the derivation of the input. Moreover, we have\nconstructed a one pass parser.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.05770v1"
    },
    {
        "title": "On Basic Properties of Jumping Finite Automata",
        "authors": [
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We complete the initial study of jumping finite automata, which was started\nin a former article of Meduna and Zemek \\citep{athMED1}. The open questions\nabout basic closure properties are solved. Besides this, we correct erroneous\nresults presented in the article. Finally, we point out important relations\nbetween jumping finite automata and some other models studied in the\nliterature.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.08396v2"
    },
    {
        "title": "Two Results on Discontinuous Input Processing",
        "authors": [
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  First, we show that universality and other properties of general jumping\nfinite automata are undecidable, which answers a question asked by Meduna and\nZemek in 2012. Second, we close the study raised by \\v{C}erno and Mr\\'{a}z in\n2010 by proving that clearing restarting automata using contexts of size two\ncan accept binary non-context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.08642v1"
    },
    {
        "title": "Quantifier Alternation for Infinite Words",
        "authors": [
            "Théo Pierron",
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate the expressive power of quantifier alternation hierarchy of\nfirst-order logic over words. This hierarchy includes the classes ${\\Sigma}_i$\n(sentences having at most $i$ blocks of quantifiers starting with an $\\exists$)\nand $\\mathcal{B}{\\Sigma}_i$ (Boolean combinations of ${\\Sigma}_i$ sentences).\nSo far, this expressive power has been effectively characterized for the lower\nlevels only. Recently, a breakthrough was made over finite words, and decidable\ncharacterizations were obtained for $\\mathcal{B}{\\Sigma}_2$ and ${\\Sigma}_3$,\nby relying on a decision problem called separation, and solving it for\n${\\Sigma}_2$. The contribution of this paper is a generalization of these\nresults to the setting of infinite words: we solve separation for ${\\Sigma}_2$\nand ${\\Sigma}_3$, and obtain decidable characterizations of\n$\\mathcal{B}{\\Sigma}_2$ and ${\\Sigma}_3$ as consequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.09011v1"
    },
    {
        "title": "Synchronizing automata and principal eigenvectors of the underlying\n  digraphs",
        "authors": [
            "Vladimir V. Gusev",
            "Elena V. Pribavkina"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A coloring of a digraph with a fixed out-degree k is a distribution of k\nlabels over the edges resulting in a deterministic finite automaton. An\nautomaton is called synchronizing if there exists a word which sends all states\nof the automaton to a single state. In the present paper we study connections\nbetween spectral and synchronizing properties of digraphs. We show that if a\ncoloring of a digraph is not synchronizing, then the stationary distribution of\nan associated Markov chain has a partition of coordinates into blocks of equal\nsum. Moreover, if there exists such a partition, then there exists a\nnon-synchronizing automaton with such stationary distribution. We extend these\nresults to bound the number of non-synchronizing colorings for digraphs with\nparticular eigenvectors. We also demonstrate that the length of the shortest\nsynchronizing word of any coloring is at most $w^2 - 3w + 3$, where $w$ is the\nsum of the coordinates of the integer principal eigenvector of the digraph.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.09079v1"
    },
    {
        "title": "Degrees of Infinite Words, Polynomials, and Atoms (Extended Version)",
        "authors": [
            "Jörg Endrullis",
            "Juhani Karhumäki Jan Willem Klop",
            "Aleksi Saarela"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study finite-state transducers and their power for transforming infinite\nwords. Infinite sequences of symbols are of paramount importance in a wide\nrange of fields, from formal languages to pure mathematics and physics. While\nfinite automata for recognising and transforming languages are well-understood,\nvery little is known about the power of automata to transform infinite words.\n  The word transformation realised by finite-state transducers gives rise to a\ncomplexity comparison of words and thereby induces equivalence classes, called\n(transducer) degrees, and a partial order on these degrees. The ensuing\nhierarchy of degrees is analogous to the recursion-theoretic degrees of\nunsolvability, also known as Turing degrees, where the transformational devices\nare Turing machines. However, as a complexity measure, Turing machines are too\nstrong: they trivialise the classification problem by identifying all\ncomputable words. Finite-state transducers give rise to a much more\nfine-grained, discriminating hierarchy. In contrast to Turing degrees, hardly\nanything is known about transducer degrees, in spite of their naturality.\n  We use methods from linear algebra and analysis to show that there are\ninfinitely many atoms in the transducer degrees, that is, minimal non-trivial\ndegrees.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.03158v1"
    },
    {
        "title": "Space-Efficient Bimachine Construction Based on the Equalizer\n  Accumulation Principle",
        "authors": [
            "Stefan Gerdjikov",
            "Stoyan Mihov",
            "Klaus U. Schulz"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Algorithms for building bimachines from functional transducers found in the\nliterature in a run of the bimachine imitate one successful path of the input\ntransducer. Each single bimachine output exactly corresponds to the output of a\nsingle transducer transition. Here we introduce an alternative construction\nprinciple where bimachine steps take alternative parallel transducer paths into\naccount, maximizing the possible output at each step using a joint view. The\nsize of both the deterministic left and right automaton of the bimachine is\nrestricted by $2^{\\vert Q\\vert}$ where $\\vert Q\\vert$ is the number of\ntransducer states. Other bimachine constructions lead to larger subautomata. As\na concrete example we present a class of real-time functional transducers with\n$n+2$ states for which the standard bimachine construction generates a\nbimachine with at least $\\Theta(n!)$ states whereas the construction based on\nthe equalizer accumulation principle leads to $2^n + n +3$ states. Our\nconstruction can be applied to rational functions from free monoids to \"mge\nmonoids\", a large class of monoids including free monoids, groups, and others\nthat is closed under Cartesian products.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.04312v1"
    },
    {
        "title": "Decision Problems for Subclasses of Rational Relations over Finite and\n  Infinite Words",
        "authors": [
            "Christof Löding",
            "Christopher Spinrath"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider decision problems for relations over finite and infinite words\ndefined by finite automata. We prove that the equivalence problem for binary\ndeterministic rational relations over infinite words is undecidable in contrast\nto the case of finite words, where the problem is decidable. Furthermore, we\nshow that it is decidable in doubly exponential time for an automatic relation\nover infinite words whether it is a recognizable relation. We also revisit this\nproblem in the context of finite words and improve the complexity of the\ndecision procedure to single exponential time. The procedure is based on a\npolynomial time regularity test for deterministic visibly pushdown automata,\nwhich is a result of independent interest.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.06140v5"
    },
    {
        "title": "Unambiguous languages exhaust the index hierarchy",
        "authors": [
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This work is a study of the expressive power of unambiguity in the case of\nautomata over infinite trees. An automaton is called unambiguous if it has at\nmost one accepting run on every input, the language of such an automaton is\ncalled an unambiguous language. It is known that not every regular language of\ninfinite trees is unambiguous. Except that, very little is known about which\nregular tree languages are unambiguous.\n  This paper answers the question whether unambiguous languages are of bounded\ncomplexity among all regular tree languages. The notion of complexity is the\ncanonical one, called the (parity or Rabin-Mostowski) index hierarchy. The\nanswer is negative, as exhibited by a family of examples of unambiguous\nlanguages that cannot be recognised by any alternating parity tree automata of\nbounded range of priorities.\n  Hardness of the given examples is based on the theory of signatures in parity\ngames, previously studied by Walukiewicz. This theory is further developed here\nto construct canonical signatures. The technical core of the article is a\nparity game that compares signatures of a given pair of parity games (without\nan increase in the index).\n",
        "pdf_link": "http://arxiv.org/pdf/1803.06163v4"
    },
    {
        "title": "Regular and First Order List Functions",
        "authors": [
            "Mikolaj Bojanczyk",
            "Laure Daviaud",
            "Krishna Shankara Narayanan"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We define two classes of functions, called regular (respectively,\nfirst-order) list functions, which manipulate objects such as lists, lists of\nlists, pairs of lists, lists of pairs of lists, etc. The definition is in the\nstyle of regular expressions: the functions are constructed by starting with\nsome basic functions (e.g. projections from pairs, or head and tail operations\non lists) and putting them together using four combinators (most importantly,\ncomposition of functions). Our main results are that first-order list functions\nare exactly the same as first-order transductions, under a suitable encoding of\nthe inputs; and the regular list functions are exactly the same as\nMSO-transductions.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.06168v1"
    },
    {
        "title": "The Density of Linear-time Properties",
        "authors": [
            "Bernd Finkbeiner",
            "Hazem Torfah"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Finding models for linear-time properties is a central problem in\nverification and planning. We study the distribution of linear-time models by\ninvestigating the density of linear-time properties over the space of\nultimately periodic words. The density of a property over a bound n is the\nratio of the number of lasso-shaped words of length n that satisfy the property\nto the total number of lasso-shaped words of length n. We investigate the\nproblem of computing the density for both linear-time properties in general and\nfor the important special case of omega-regular properties. For general\nlinear-time properties, the density is not necessarily convergent and can\noscillate indefinitely for certain properties. However, we show the oscillation\ncan be bounded by the growth of the sets of bad- and good-prefix of the\nproperty. For omega-regular properties, we show that the density is always\nconvergent and provide a general algorithm for computing the density of\nomega-regular properties as well as more specialized algorithms for certain\nsub-classes and their combinations.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.08890v1"
    },
    {
        "title": "New tools for state complexity",
        "authors": [
            "Pascal Caron",
            "Edwin Hamel-De le court",
            "Jean-Gabriel Luque",
            "Bruno Patrou"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A monster is an automaton in which every function from states to states is\nrepresented by at least one letter. A modifier is a set of functions allowing\none to transform a set of automata into one automaton. We revisit some language\ntransformation algorithms in terms of modifier and monster. These new\ntheoretical concepts allow one to find easily some state complexities. We\nillustrate this by retrieving the state complexity of the Star of Intersection\nand the one of the Square root operation.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.00663v6"
    },
    {
        "title": "Equivalence checking for weak bi-Kleene algebra",
        "authors": [
            "Tobias Kappé",
            "Paul Brunet",
            "Bas Luttik",
            "Alexandra Silva",
            "Fabio Zanasi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Pomset automata are an operational model of weak bi-Kleene algebra, which\ndescribes programs that can fork an execution into parallel threads, upon\ncompletion of which execution can join to resume as a single thread. We\ncharacterize a fragment of pomset automata that admits a decision procedure for\nlanguage equivalence. Furthermore, we prove that this fragment corresponds\nprecisely to series-rational expressions, i.e., rational expressions with an\nadditional operator for bounded parallelism. As a consequence, we obtain a new\nproof that equivalence of series-rational expressions is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.02102v5"
    },
    {
        "title": "Branch-Continuous Tree Algebras",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study a class of algebras that can be used as recognisers for regular\nlanguages of infinite trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.04568v1"
    },
    {
        "title": "Subset synchronization of DFAs and PFAs, and some other results",
        "authors": [
            "Michiel de Bondt"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper contains results which arose from the research which led to\narXiv:1801.10436, but which did not fit in arXiv:1801.10436. So\narXiv:1801.10436 contains the highlight results, but there are more results\nwhich are interesting enough to be shared.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.04661v1"
    },
    {
        "title": "Extended finite automata and decision problems for matrix semigroups",
        "authors": [
            "Özlem Salehi",
            "Ahmet Celal Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We make a connection between the subgroup membership and identity problems\nfor matrix groups and extended finite automata. We provide an alternative proof\nfor the decidability of the subgroup membership problem for $ 2 \\times 2 $\ninteger matrices. We show that the emptiness problem for extended finite\nautomata over $ 4 \\times 4 $ integer matrix semigroups is undecidable. We prove\nthat the decidability of the universe problem for extended finite automata is a\nsufficient condition for the decidability of the subgroup membership and\nidentity problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.05516v1"
    },
    {
        "title": "Briefly on Bottom-up",
        "authors": [
            "Paola Quaglia"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  These short notes are meant as a quick reference for the construction of\nSLR(1), of LR(1), and of LALR(1) parsing tables.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.05555v2"
    },
    {
        "title": "Slowly Synchronizing Automata with Idempotent Letters of Low Rank",
        "authors": [
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We use a semigroup-theoretic construction by Peter Higgins in order to\nproduce, for each even $n$, an $n$-state and 3-letter synchronizing automaton\nwith the following two features: 1) all its input letters act as idempotent\nselfmaps of rank $\\dfrac{n}2$; 2) its reset threshold is asymptotically equal\nto $\\dfrac{n^2}2$.\n  In the revised version a few inaccuracies (spotted by the anonymous referees\nof the previous version) have been removed and several relevant references have\nbeen added.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.07048v2"
    },
    {
        "title": "On normality in shifts of finite type",
        "authors": [
            "Nicolás Álvarez",
            "Olivier Carton"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper we consider the notion of normality of sequences in shifts of\nfinite type. A sequence is normal if the frequency of each block exists and is\nequal to the Parry measure of the block. We give a characterization of\nnormality in terms of incompressibility by lossless transducers. The result was\nalready known in the case of the full shift.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.07208v2"
    },
    {
        "title": "Origin-equivalence of two-way word transducers is in PSPACE",
        "authors": [
            "Sougata Bose",
            "Anca Muscholl",
            "Vincent Penelle",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider equivalence and containment problems for word transductions.\nThese problems are known to be undecidable when the transductions are relations\nbetween words realized by non-deterministic transducers, and become decidable\nwhen restricting to functions from words to words. Here we prove that\ndecidability can be equally recovered by adopting a slightly different, but\nnatural semantics, called origin semantics and introduced by Bojanczyk in 2014.\nSpecifically, we prove that the equivalence and containment problems for\ntwo-way word transducers in the origin semantics are PSPACE-complete. We also\nconsider a variant of the containment problem where two-way transducers are\ncompared under the origin semantics, but in a more relaxed way, by allowing\ndistortions of the origins. The possible distortions are described by means of\na resynchronization relation. We propose a logical formalism for describing a\nbroad class of resynchronizations, while preserving the decidability of the\nvariant of the containment problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.08053v3"
    },
    {
        "title": "Liveness in Broadcast Networks",
        "authors": [
            "Peter Chini",
            "Roland Meyer",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study liveness and model checking problems for broadcast networks, a\nsystem model of identical clients communicating via message passing. The first\nproblem that we consider is Liveness Verification. It asks whether there is a\ncomputation such that one of the clients visits a final state infinitely often.\nThe complexity of the problem has been open since 2010 when it was shown to be\nP-hard and solvable in EXPSPACE. We close the gap by a polynomial-time\nalgorithm. The algorithm relies on a characterization of live computations in\nterms of paths in a suitable graph, combined with a fixed-point iteration to\nefficiently check the existence of such paths. The second problem is Fair\nLiveness Verification. It asks for a computation where all participating\nclients visit a final state infinitely often. We adjust the algorithm to also\nsolve fair liveness in polynomial time.\n  Both problems can be instrumented to answer model checking questions for\nbroadcast networks against linear time temporal logic specifications. The first\nproblem in this context is Fair Model Checking. It demands that for all\ncomputations of a broadcast network, all participating clients satisfy the\nspecification. We solve the problem via the Vardi-Wolper construction and a\nreduction to Liveness Verification. The second problem is Sparse Model\nChecking. It asks whether each computation has a participating client that\nsatisfies the specification. We reduce the problem to Fair Liveness\nVerification.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.00833v3"
    },
    {
        "title": "Complete Abstractions for Checking Language Inclusion",
        "authors": [
            "Pierre Ganty",
            "Francesco Ranzato",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study the language inclusion problem $L_1 \\subseteq L_2$ where $L_1$ is\nregular or context-free. Our approach relies on abstract interpretation and\nchecks whether an overapproximating abstraction of $L_1$, obtained by\noverapproximating the Kleene iterates of its least fixpoint characterization,\nis included in $L_2$. We show that a language inclusion problem is decidable\nwhenever this overapproximating abstraction satisfies a completeness condition\n(i.e., its loss of precision causes no false alarm) and prevents infinite\nascending chains (i.e., it guarantees termination of least fixpoint\ncomputations). This overapproximating abstraction of languages can be defined\nusing quasiorder relations on words, where the abstraction gives the language\nof all the words \"greater than or equal to\" a given input word for that\nquasiorder. We put forward a range of such quasiorders that allow us to\nsystematically design decision procedures for different language inclusion\nproblems such as regular languages into regular languages or into trace sets of\none-counter nets, and context-free languages into regular languages. In the\ncase of inclusion between regular languages, some of the induced inclusion\nchecking procedures correspond to well-known state-of-the-art algorithms like\nthe so-called antichain algorithms. Finally, we provide an equivalent language\ninclusion checking algorithm based on a greatest fixpoint computation that\nrelies on quotients of languages and, to the best of our knowledge, was not\npreviously known.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.01388v2"
    },
    {
        "title": "On the Formalization of Importance Measures using HOL Theorem Proving",
        "authors": [
            "Waqar Ahmed",
            "Shahid Ali Murtza",
            "Osman Hasan",
            "Sofiene Tahar"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Importance measures provide a systematic approach to scrutinize critical\nsystem components, which are extremely beneficial in making important\ndecisions, such as prioritizing reliability improvement activities, identifying\nweak-links and effective usage of given resources. The importance measures are\nthen in turn used to obtain a criticality value for each system component and\nto rank the components in descending manner. Simulations tools are generally\nused to perform importance measure based analysis, but they require expensive\ncomputations and thus they are not suitable for large systems. A more scalable\napproach is to utilize the importance measures to obtain all the necessary\nconditions by proving a generic relationship describing the relative importance\nbetween any pair of components in a system. In this paper, we propose to use\nhigher-order-logic (HOL) theorem proving to verify such relationships and thus\nmaking sure that all the essential conditions are accompanied by the proven\nproperty. In particular, we formalize the commonly used importance measures,\nsuch as Birnbaum and Fussell-Vesely, and conduct a formal importance measure\nanalysis of a railway signaling system at a Moroccan level crossing as an\napplication for illustration purpose.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.01605v1"
    },
    {
        "title": "Computational Limitations of Affine Automata",
        "authors": [
            "Mika Hirvensalo",
            "Etienne Moutot",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present two new results on the computational limitations of affine\nautomata. First, we show that the computation of bounded-error rational-values\naffine automata is simulated in logarithmic space. Second, we give an\nimpossibility result for algebraic-valued affine automata. As a result, we\nidentify some unary languages (in logarithmic space) that are not recognized by\nalgebraic-valued affine automata with cutpoints.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.02428v1"
    },
    {
        "title": "Matrix approach to synchronizing automata",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A word $w$ of letters on edges of underlying graph $\\Gamma$ of deterministic\nfinite automaton (DFA) is called synchronizing if $w$ sends all states of the\nautomaton to a unique state. J. \\v{C}erny discovered in 1964 a sequence of\n$n$-state complete DFA possessing a minimal synchronizing word of length\n$(n-1)^2$. The hypothesis, well known today as \\v{C}erny conjecture, claims\nthat $(n-1)^2$ is a precise upper bound on the length of such a word over\nalphabet $\\Sigma$ of letters on edges of $\\Gamma$ for every complete $n$-state\nDFA. The hypothesis was formulated distinctly in 1966 by Starke. A special\nclasses of matrices induced by words in the alphabet of labels on edges of the\nunderlying graph of DFA are used for the study of synchronizing automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.07694v4"
    },
    {
        "title": "Tree Automata as Algebras: Minimisation and Determinisation",
        "authors": [
            "Gerco van Heerdt",
            "Tobias Kappé",
            "Jurriaan Rot",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study a categorical generalisation of tree automata, as $\\Sigma$-algebras\nfor a fixed endofunctor $\\Sigma$ endowed with initial and final states. Under\nmild assumptions about the base category, we present a general minimisation\nalgorithm for these automata. We then build upon and extend an existing\ngeneralisation of the Nerode equivalence to a categorical setting and relate it\nto the existence of minimal automata. Finally, we show that generalised types\nof side-effects, such as non-determinism, can be captured by this categorical\nframework, leading to a general determinisation procedure.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.08802v2"
    },
    {
        "title": "Parametric updates in parametric timed automata",
        "authors": [
            "Étienne André",
            "Didier Lime",
            "Mathias Ramparison"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce a new class of Parametric Timed Automata (PTAs) where we allow\nclocks to be compared to parameters in guards, as in classic PTAs, but also to\nbe updated to parameters. We focus here on the EF-emptiness problem: \"is the\nset of parameter valuations for which some given location is reachable in the\ninstantiated timed automaton empty?\". This problem is well-known to be\nundecidable for PTAs, and so it is for our extension. Nonetheless, if we update\nall clocks each time we compare a clock with a parameter and each time we\nupdate a clock to a parameter, we obtain a syntactic subclass for which we can\ndecide the EF-emptiness problem and even perform the exact synthesis of the set\nof rational valuations such that a given location is reachable. To the best of\nour knowledge, this is the first non-trivial subclass of PTAs, actually even\nextended with parametric updates, for which this is possible.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.08824v6"
    },
    {
        "title": "Preservation of normality by transducers",
        "authors": [
            "Olivier Carton",
            "Elisa Orduna"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider input-deterministic finite state transducers with infinite inputs\nand infinite outputs, and we consider the property of Borel normality on\ninfinite words. When these transducers are given by a strongly connected set of\nstates, and when the input is a Borel normal sequence, the output is an\ninfinite word such that every word has a frequency given by a weighted\nautomaton over the rationals. We prove that there is an algorithm that decides\nin cubic time whether an input-deterministic transducer preserves normality.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.09133v1"
    },
    {
        "title": "Undecidability of future timeline-based planning over dense temporal\n  domains",
        "authors": [
            "Laura Bozzelli",
            "Alberto Molinari",
            "Angelo Montanari",
            "Adriano Peron"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Planning is one of the most studied problems in computer science. In this\npaper, we consider the timeline-based approach, where the domain is modeled by\na set of independent, but interacting, components, identified by a set of state\nvariables, whose behavior over time (timelines) is governed by a set of\ntemporal constraints (synchronization rules). Timeline-based planning in the\ndense-time setting has been recently shown to be undecidable in the general\ncase, and undecidability relies on the high expressiveness of the trigger\nsynchronization rules. In this paper, we strengthen the previous negative\nresult by showing that undecidability already holds under the future semantics\nof the trigger rules which limits the comparison to temporal contexts in the\nfuture with respect to the trigger.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.09184v1"
    },
    {
        "title": "Linear Bounded Composition of Tree-Walking Tree Transducers: Linear Size\n  Increase and Complexity",
        "authors": [
            "Joost Engelfriet",
            "Kazuhiro Inaba",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Compositions of tree-walking tree transducers form a hierarchy with respect\nto the number of transducers in the composition. As main technical result it is\nproved that any such composition can be realized as a linear bounded\ncomposition, which means that the sizes of the intermediate results can be\nchosen to be at most linear in the size of the output tree. This has\nconsequences for the expressiveness and complexity of the translations in the\nhierarchy. First, if the computed translation is a function of linear size\nincrease, i.e., the size of the output tree is at most linear in the size of\nthe input tree, then it can be realized by just one, deterministic,\ntree-walking tree transducer. For compositions of deterministic transducers it\nis decidable whether or not the translation is of linear size increase. Second,\nevery composition of deterministic transducers can be computed in deterministic\nlinear time on a RAM and in deterministic linear space on a Turing machine,\nmeasured in the sum of the sizes of the input and output tree. Similarly, every\ncomposition of nondeterministic transducers can be computed in simultaneous\npolynomial time and linear space on a nondeterministic Turing machine. Their\noutput tree languages are deterministic context-sensitive, i.e., can be\nrecognized in deterministic linear space on a Turing machine. The membership\nproblem for compositions of nondeterministic translations is nondeterministic\npolynomial time and deterministic linear space. The membership problem for the\ncomposition of a nondeterministic and a deterministic tree-walking tree\ntranslation (for a nondeterministic IO macro tree translation) is log-space\nreducible to a context-free language, whereas the membership problem for the\ncomposition of a deterministic and a nondeterministic tree-walking tree\ntranslation (for a nondeterministic OI macro tree translation) is possibly\nNP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.09203v3"
    },
    {
        "title": "Reachability for Bounded Branching VASS",
        "authors": [
            "Filip Mazowiecki",
            "Michał Pilipczuk"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we consider the reachability problem for bounded branching\nVASS. Bounded VASS are a variant of the classic VASS model where all values in\nall configurations are upper bounded by a fixed natural number, encoded in\nbinary in the input. This model gained a lot of attention in 2012 when Haase et\nal. showed its connections with timed automata. Later in 2013 Fearnley and\nJurdzi\\'{n}ski proved that the reachability problem in this model is\nPSPACE-complete even in dimension 1. Here, we investigate the complexity of the\nreachability problem when the model is extended with branching transitions, and\nwe prove that the problem is EXPTIME-complete when the dimension is 2 or\nlarger.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.10226v2"
    },
    {
        "title": "Decision Problems for Restricted Variants of Two-Dimensional Automata",
        "authors": [
            "Taylor J. Smith",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A two-dimensional finite automaton has a read-only input head that moves in\nfour directions on a finite array of cells labelled by symbols of the input\nalphabet. A three-way two-dimensional automaton is prohibited from making\nupward moves, while a two-way two-dimensional automaton can only move downward\nand rightward.\n  We show that the language emptiness problem for unary three-way\nnondeterministic two-dimensional automata is NP-complete, and is in P for\ngeneral-alphabet two-way nondeterministic two-dimensional automata. We show\nthat the language equivalence problem for two-way deterministic two-dimensional\nautomata is decidable, while both the equivalence and universality problems for\ntwo-way nondeterministic two-dimensional automata are undecidable. The\ndeterministic case is the first known positive decidability result for the\nequivalence problem on two-dimensional automata over a general alphabet. We\nshow that there exists a unary three-way deterministic two-dimensional\nautomaton with a nonregular column projection, and we show that the row\nprojection of a unary three-way nondeterministic two-dimensional automaton is\nalways regular.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.11100v1"
    },
    {
        "title": "On all things star-free",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We investigate the star-free closure, which associates to a class of\nlanguages its closure under Boolean operations and marked concatenation. We\nprove that the star-free closure of any finite class and of any class of groups\nlanguages with decidable separation (plus mild additional properties) has\ndecidable separation. We actually show decidability of a stronger property,\ncalled covering. This generalizes many results on the subject in a unified\nframework. A key ingredient is that star-free closure coincides with another\nclosure operator where Kleene stars are also allowed in restricted contexts.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.11863v1"
    },
    {
        "title": "Parity Games: Zielonka's Algorithm in Quasi-Polynomial Time",
        "authors": [
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Calude, Jain, Khoussainov, Li, and Stephan (2017) proposed a\nquasi-polynomial-time algorithm solving parity games. After this breakthrough\nresult, a few other quasi-polynomial-time algorithms were introduced; none of\nthem is easy to understand. Moreover, it turns out that in practice they\noperate very slowly. On the other side there is the Zielonka's recursive\nalgorithm, which is very simple, exponential in the worst case, and the fastest\nin practice. We combine these two approaches: we propose a small modification\nof the Zielonka's algorithm, which ensures that the running time is at most\nquasi-polynomial. In effect, we obtain a simple algorithm that solves parity\ngames in quasi-polynomial time. We also hope that our algorithm, after further\noptimizations, can lead to an algorithm that shares the good performance of the\nZielonka's algorithm on typical inputs, while reducing the worst-case\ncomplexity on difficult inputs.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.12446v1"
    },
    {
        "title": "Modular Descriptions of Regular Functions",
        "authors": [
            "Paul Gastin"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We discuss various formalisms to describe string-to-string transformations.\nMany are based on automata and can be seen as operational descriptions,\nallowing direct implementations when the input scanner is deterministic.\nAlternatively, one may use more human friendly descriptions based on some\nsimple basic transformations (e.g., copy, duplicate, erase, reverse) and\nvarious combinators such as function composition or extensions of regular\noperations.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.01137v1"
    },
    {
        "title": "Reordering Derivatives of Trace Closures of Regular Languages (Full\n  Version)",
        "authors": [
            "Hendrik Maarand",
            "Tarmo Uustalu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We provide syntactic derivative-like operations, defined by recursion on\nregular expressions, in the styles of both Brzozowski and Antimirov, for trace\nclosures of regular languages. Just as the Brzozowski and Antimirov derivative\noperations for regular languages, these syntactic reordering derivative\noperations yield deterministic and nondeterministic automata respectively. But\ntrace closures of regular languages are in general not regular, hence these\nautomata cannot generally be finite. Still, as we show, for star-connected\nexpressions, the Antimirov and Brzozowski automata, suitably quotiented, are\nfinite. We also define a refined version of the Antimirov reordering derivative\noperation where parts-of-derivatives (states of the automaton) are nonempty\nlists of regular expressions rather than single regular expressions. We define\nthe uniform scattering rank of a language and show that, for a regexp whose\nlanguage has finite uniform scattering rank, the truncation of the (generally\ninfinite) refined Antimirov automaton, obtained by removing long states, is\nfinite without any quotienting, but still accepts the trace closure. We also\nshow that star-connected languages have finite uniform scattering rank.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.03551v1"
    },
    {
        "title": "Solving of Regular Equations Revisited (extended version)",
        "authors": [
            "Martin Sulzmann",
            "Kenny Zhuo Ming Lu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Solving of regular equations via Arden's Lemma is folklore knowledge.\n  We first give a concise algorithmic specification of all elementary solving\nsteps.\n  We then discuss a computational interpretation of solving in terms of\ncoercions that transform parse trees of regular equations into parse trees of\nsolutions.\n  Thus, we can identify some conditions on the shape of regular equations under\nwhich resulting solutions are unambiguous.\n  We apply our result to convert a DFA to an unambiguous regular expression.\n  In addition, we show that operations such as subtraction and shuffling can be\nexpressed via some appropriate set of regular equations.\n  Thus, we obtain direct (algebraic) methods without having to convert to and\nfrom finite automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.03710v1"
    },
    {
        "title": "A Robust Class of Linear Recurrence Sequences",
        "authors": [
            "Corentin Barloy",
            "Nathanaël Fijalkow",
            "Nathan Lhote",
            "Filip Mazowiecki"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce a subclass of linear recurrence sequences which we call\npoly-rational sequences because they are denoted by rational expressions closed\nunder sum and product. We show that this class is robust by giving several\ncharacterisations: polynomially ambiguous weighted automata, copyless\ncost-register automata, rational formal series, and linear recurrence sequences\nwhose eigenvalues are roots of rational numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.03890v1"
    },
    {
        "title": "Non-deterministic weighted automata evaluated over Markov chains",
        "authors": [
            "Jakub Michaliszyn",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present the first study of non-deterministic weighted automata under\nprobabilistic semantics. In this semantics words are random events, generated\nby a Markov chain, and functions computed by weighted automata are random\nvariables. We consider the probabilistic questions of computing the expected\nvalue and the cumulative distribution for such random variables.\n  The exact answers to the probabilistic questions for non-deterministic\nautomata can be irrational and are uncomputable in general. To overcome this\nlimitation, we propose approximation algorithms for the probabilistic\nquestions, which work in exponential time in the size of the automaton and\npolynomial time in the size of the Markov chain and the given precision. We\napply this result to show that non-deterministic automata can be effectively\ndeterminised with respect to the standard deviation metric.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.04625v2"
    },
    {
        "title": "LTL to Smaller Self-Loop Alternating Automata and Back",
        "authors": [
            "František Blahoudek",
            "Juraj Major",
            "Jan Strejček"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Self-loop alternating automata (SLAA) with B\\\"uchi or co-B\\\"uchi acceptance\nare popular intermediate formalisms in translations of LTL to deterministic or\nnondeterministic automata. This paper considers SLAA with generic\ntransition-based Emerson-Lei acceptance and presents translations of LTL to\nthese automata and back. Importantly, the translation of LTL to SLAA with\ngeneric acceptance produces considerably smaller automata than previous\ntranslations of LTL to B\\\"uchi or co-B\\\"uchi SLAA. Our translation is already\nimplemented in the tool LTL3TELA, where it helps to produce small deterministic\nor nondeterministic automata for given LTL formulae.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.04645v2"
    },
    {
        "title": "An Operational Semantics of Graph Transformation Systems Using Symmetric\n  Nets",
        "authors": [
            "Lorenzo Capra"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Graph transformation systems (GTS) have been successfully proposed as a\ngeneral, theoretically sound model for concurrency. Petri nets (PN), on the\nother side, are a central and intuitive formalism for concurrent or distributed\nsystems, well supported by a number of analysis techniques/tools. Some PN\nclasses have been shown to be instances of GTS. In this paper, we change\nperspective presenting an operational semantics of GTS in terms of Symmetric\nNets, a well-known class of Coloured Petri nets featuring a structured syntax\nthat outlines model symmetries. Some practical exploitations of the proposed\noperational semantics are discussed. In particular, a recently developed\nstructural calculus for SN is used to validate graph rewriting rules in a\nsymbolic way.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.01750v1"
    },
    {
        "title": "Descriptional Complexity of Semi-Simple Splicing Systems",
        "authors": [
            "Lila Kari",
            "Timothy Ng"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Splicing systems are generative mechanisms introduced by Tom Head in 1987 to\nmodel the biological process of DNA recombination. The computational engine of\na splicing system is the \"splicing operation\", a cut-and-paste binary string\noperation defined by a set of \"splicing rules\" $r = (\\alpha_1, \\alpha_2 ;\n\\alpha_3, \\alpha_4)$ where $\\alpha_1, \\alpha_2, \\alpha_3, \\alpha_4$ are words\nover an alphabet $\\Sigma$. For two strings $x = x_1 \\alpha_1 \\alpha_2 x_2$ and\n$y = y_1 \\alpha_3 \\alpha_4 y_2$, applying the splicing rule $r$ produces the\nstring $z = x_1 \\alpha_1 \\alpha_4 y_2$.\n  In this paper we focus on a particular type of splicing systems, called $(i,\nj)$ semi-simple splicing systems, $i = 1,2$ and $j = 3, 4$, wherein all\nsplicing rules have the property that the two strings in positions $i$ and $j$\nare singleton letters, while the other two strings are empty. The language\ngenerated by such a system consists of the set of words that are obtained\nstarting from an initial set called \"axiom set\", by iteratively applying the\nsplicing rules to strings in the axiom set as well as to intermediately\nproduced strings. We consider semi-simple splicing systems where the axiom set\nis a regular language, and investigate the descriptional complexity of such\nsystems in terms of the size of the minimal deterministic finite automata that\nrecognize the languages they generate.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.02512v1"
    },
    {
        "title": "{Networks of Uniform Splicing Processors",
        "authors": [
            "Victor Mitrana",
            "Mihaela Păun",
            "Jose Angel Sanchez Martin",
            "Jose Ramon Sanchez Couso"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this note we consider a new variant of network of splicing processors\nwhich simplifies the general model such that filters remain associated with\nnodes but the input and output filters of every node coincide. This variant is\ncalled {\\it network of uniform splicing processors}. Although the communication\nin the new variant seems less powerful, being based on simpler filters, the new\nvariant is sufficiently powerful to be computationally complete. The main\nresult is that nondeterministic Turing machines can be simulated by networks of\nuniform splicing processors. Furthermore, the simulation is time efficient.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.03246v1"
    },
    {
        "title": "Good-for-MDPs Automata for Probabilistic Analysis and Reinforcement\n  Learning",
        "authors": [
            "Ernst Moritz Hahn",
            "Mateo Perez",
            "Fabio Somenzi",
            "Ashutosh Trivedi",
            "Sven Schewe",
            "Dominik Wojtczak"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We characterize the class of nondeterministic ${\\omega}$-automata that can be\nused for the analysis of finite Markov decision processes (MDPs). We call these\nautomata `good-for-MDPs' (GFM). We show that GFM automata are closed under\nclassic simulation as well as under more powerful simulation relations that\nleverage properties of optimal control strategies for MDPs. This closure\nenables us to exploit state-space reduction techniques, such as those based on\ndirect and delayed simulation, that guarantee simulation equivalence. We\ndemonstrate the promise of GFM automata by defining a new class of automata\nwith favorable properties - they are B\\\"uchi automata with low branching degree\nobtained through a simple construction - and show that going beyond\nlimit-deterministic automata may significantly benefit reinforcement learning.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.05081v2"
    },
    {
        "title": "Interface Automata for Choreographies",
        "authors": [
            "Hao Zeng",
            "Alexander Kurz",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Choreographic approaches to message-passing applications can be regarded as\nan instance of the model-driven development principles. Choreographies specify\ninteractions among distributed participants coordinating among themselves with\nmessage-passing at two levels of abstractions. A global view of the application\nis specified with a model that abstracts away from asynchrony while a local\nview of the application specifies the communication pattern of each\nparticipant. Noteworthy, the latter view can typically be algorithmically\nobtained by projection of the global view. A crucial element of this approach\nis to verify the so-called well-formed conditions on global views so that its\nprojections realise a sound communication protocol. We introduce a novel local\nmodel, group interface automata, to represent the local view of choreographies\nand propose a new method to verify the well-formedness of global\nchoreographies. We rely on a recently proposed semantics of global views\nformalised in terms of pomsets.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.05967v1"
    },
    {
        "title": "Algebraic and Combinatorial Tools for State Complexity : Application to\n  the Star-Xor Problem",
        "authors": [
            "Pascal Caron",
            "Edwin Hamel-de le Court",
            "Jean-Gabriel Luque"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We investigate the state complexity of the star of symmetrical differences\nusing modifiers and monsters. A monster is an automaton in which every function\nfrom states to states is represented by at least one letter. A modifier is a\nset of functions allowing one to transform a set of automata into one\nautomaton. These recent theoretical concepts allow one to find easily the\ndesired state complexity. We then exhibit a witness with a constant size\nalphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.07663v1"
    },
    {
        "title": "State Complexity of the Multiples of the Thue-Morse Set",
        "authors": [
            "Émilie Charlier",
            "Célia Cisternino",
            "Adeline Massuir"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The Thue-Morse set T is the set of those non-negative integers whose binary\nexpansions have an even number of 1. The name of this set comes from the fact\nthat its characteristic sequence is given by the famous Thue-Morse word\nabbabaabbaababba..., which is the fixed point starting with a of the word\nmorphism sending a to ab and b to ba. The numbers in T are sometimes called the\nevil numbers. We obtain an exact formula for the state complexity (i.e. the\nnumber of states of its minimal automaton) of the multiplication by a constant\nof the Thue-Morse set with respect to any integer base b which is a power of 2.\nOur proof is constructive and we are able to explicitly provide the minimal\nautomaton of the language of all 2^p-expansions of the set mT for any positive\nintegers m and p. The used method is general for any b-recognizable set of\nintegers. As an application, we obtain a decision procedure running in\nquadratic time for the problem of deciding whether a given 2^p-recognizable set\nis equal to some multiple of the Thue-Morse set.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.07676v1"
    },
    {
        "title": "On the Order Type of Scattered Context-Free Orderings",
        "authors": [
            "Kitti Gelle",
            "Szabolcs Iván"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that if a context-free grammar generates a language whose\nlexicographic ordering is well-ordered of type less than $\\omega^2$, then its\norder type is effectively computable.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.08543v1"
    },
    {
        "title": "Simple proof of Parikh's theorem a la Takahashi",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this report we describe a simple proof of Parikh's theorem a la Takahashi,\nbased on a decomposition of derivation trees. The idea of decomposition is\nappeared in her master's thesis written in 1970.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.09393v1"
    },
    {
        "title": "Nonexistence of minimal-time solutions for some variations of the firing\n  squad synchronization problem having simple geometric configurations",
        "authors": [
            "Kojiro Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We prove nonexistence of minimal-time solutions for three variations of the\nfiring squad synchronization problem (FSSP, for short). Configurations of these\nvariations are paths in the two-dimensional grid space having simple geometric\nshapes. In the first variation a configuration is an L-shaped path such that\nthe ratio of the length of horizontal line to that of the vertical line is\nfixed. The general may be at any position. In the second and the third\nvariations a configuration is a rectangular wall such that the ratio of the\nlength of the two horizontal walls to that of the two vertical walls is fixed.\nThe general is at the left down corner in the second variation and may be at\nany position in the third variation. We use the idea used in the proof of\nYamashita et al's recent similar result for variations of FSSP with\nsub-generals.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.10125v1"
    },
    {
        "title": "On the Distance between Timed Automata",
        "authors": [
            "Amnon Rosenmann"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The problem of inclusion of the language accepted by timed automaton $A$\n(e.g., the implementation) in the language accepted by $B$ (e.g., the\nspecification) is, in general, undecidable in the class of non-deterministic\ntimed automata. In order to tackle this disturbing problem we show how to\neffectively construct deterministic timed automata $A_d$ and $B_d$ that are\ndiscretizations (digitizations) of the non-deterministic timed automata $A$ and\n$B$ and differ from the original automata by at most $\\frac{1}{6}$ time units\non each occurrence of an event. Language inclusion in the discretized timed\nautomata is decidable and it is also decidable when instead of\n$\\mathfrak{L}(B)$ we consider $\\overline{\\mathfrak{L}(B)}$, the closure of\n${\\mathfrak{L}(B)}$ in the Euclidean topology: if $\\mathfrak{L}(A_d) \\nsubseteq\n\\mathfrak{L}(B_d)$ then $\\mathfrak{L}(A) \\nsubseteq \\mathfrak{L}(B)$ and if\n$\\mathfrak{L}(A_d) \\subseteq \\mathfrak{L}(B_d)$ then $\\mathfrak{L}(A) \\subseteq\n\\overline{\\mathfrak{L}(B)}$.\n  Moreover, if $\\mathfrak{L}(A_d) \\nsubseteq \\mathfrak{L}(B_d)$ we would like\nto know how far away is $\\mathfrak{L}(A_d)$ from being included in\n$\\mathfrak{L}(B_d)$. For that matter we define the distance between the\nlanguages of timed automata as the limit on how far away a timed trace of one\ntimed automaton can be from the closest timed trace of the other timed\nautomaton. We then show how one can decide under some restriction whether the\ndistance between two timed automata is finite or infinite.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.10489v1"
    },
    {
        "title": "Efficient Automata-based Planning and Control under Spatio-Temporal\n  Logic Specifications",
        "authors": [
            "Lars Lindemann",
            "Dimos V. Dimarogonas"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The use of spatio-temporal logics in control is motivated by the need to\nimpose complex spatial and temporal behavior on dynamical systems, and to\ncontrol these systems accordingly. Synthesizing correct-by-design control laws\nis a challenging task resulting in computationally demanding methods. We\nconsider efficient automata-based planning for continuous-time systems under\nsignal interval temporal logic specifications, an expressive fragment of signal\ntemporal logic. The planning is based on recent results for automata-based\nverification of metric interval temporal logic. A timed signal transducer is\nobtained accepting all Boolean signals that satisfy a metric interval temporal\nlogic specification, which is abstracted from the signal interval temporal\nlogic specification at hand. This transducer is modified to account for the\nspatial properties of the signal interval temporal logic specification,\ncharacterizing all real-valued signals that satisfy this specification. Using\nlogic-based feedback control laws, such as the ones we have presented in\nearlier works, we then provide an abstraction of the system that, in a suitable\nway, aligns with the modified timed signal transducer. This allows to avoid the\nstate space explosion that is typically induced by forming a product automaton\nbetween an abstraction of the system and the specification.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.11159v2"
    },
    {
        "title": "Reachability Analysis of Self Modifying Code",
        "authors": [
            "Tayssir Touili",
            "Xin Ye"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A Self modifying code is code that modifies its own instructions during\nexecution time. It is nowadays widely used, especially in malware to make the\ncode hard to analyse and to detect by anti-viruses. Thus, the analysis of such\nself modifying programs is a big challenge. Pushdown systems (PDSs) is a\nnatural model that is extensively used for the analysis of sequential programs\nbecause they allow to accurately model procedure calls and mimic the program's\nstack. In this work, we propose to extend the PushDown System model with\nself-modifying rules. We call the new model Self-Modifying PushDown System\n(SM-PDS). A SM-PDS is a PDS that can modify its own set of transitions during\nexecution. We show how SM-PDSs can be used to naturally represent\nself-modifying programs and provide efficient algorithms to compute the\nbackward and forward reachable configurations of SM-PDSs. We implemented our\ntechniques in a tool and obtained encouraging results. In particular, we\nsuccessfully applied our tool for the detection of self-modifying malware.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.12626v1"
    },
    {
        "title": "Relating Alternating Relations for Conformance and Refinement",
        "authors": [
            "Ramon Janssen",
            "Frits Vaandrager",
            "Jan Tretmans"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Various relations have been defined to express refinement and conformance for\nstate-transition systems with inputs and outputs, such as ioco and uioco in the\narea of model-based testing, and alternating simulation and alternating-trace\ncontainment originating from game theory and formal verification. Several\npapers have compared these independently developed relations, but these\ncomparisons make assumptions (e.g., input-enabledness), pose restrictions\n(e.g., determinism - then they all coincide), use different models (e.g.,\ninterface automata and Kripke structures), or do not deal with the concept of\nquiescence. In this paper, we present the integration of the ioco/uioco theory\nof model-based testing and the theory of alternating refinements, within the\ndomain of non-deterministic, non-input-enabled interface automata. A standing\nconjecture is that ioco and alternating-trace containment coincide. Our main\nresult is that this conjecture does not hold, but that uioco coincides with a\nvariant of alternating-trace containment, for image finite interface automata\nand with explicit treatment of quiescence. From the comparison between ioco\ntheory and alternating refinements, we conclude that ioco and the original\nrelation of alternating-trace containment are too strong for realistic\nblack-box scenarios. We present a refinement relation which can express both\nuioco and refinement in game theory, while being simpler and having a clearer\nobservational interpretation.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.13604v1"
    },
    {
        "title": "Synthesis of Weighted Marked Graphs from Constrained Labelled Transition\n  Systems: A Geometric Approach",
        "authors": [
            "Raymond Devillers",
            "Evgeny Erofeev",
            "Thomas Hujsa"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Recent studies investigated the problems of analysing Petri nets and\nsynthesising them from labelled transition systems (LTS) with two labels\n(transitions) only. In this paper, we extend these works by providing new\nconditions for the synthesis of Weighted Marked Graphs (WMGs), a well-known and\nuseful class of weighted Petri nets in which each place has at most one input\nand one output. Some of these new conditions do not restrict the number of\nlabels; the other ones consider up to 3 labels. Additional constraints are\ninvestigated: when the LTS is either finite or infinite, and either cyclic or\nacyclic. We show that one of these conditions, developed for 3 labels, does not\nextend to 4 nor to 5 labels. Also, we tackle geometrically the WMG-solvability\nof finite, acyclic LTS with any number of labels.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.00474v1"
    },
    {
        "title": "New Optimizations and Heuristics for Determinization of Büchi Automata",
        "authors": [
            "Christof Löding",
            "Anton Pirogov"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this work, we present multiple new optimizations and heuristics for the\ndeterminization of B\\\"uchi automata that exploit a number of semantic and\nstructural properties, most of which may be applied together with any\ndeterminization procedure. We built a prototype implementation where all the\npresented heuristics can be freely combined and evaluated them, comparing our\nimplementation with the state-of-the-art tool spot on multiple data sets with\ndifferent characteristics. Our results show that the proposed optimizations and\nheuristics can in some cases significantly decrease the size of the resulting\ndeterministic automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.01759v1"
    },
    {
        "title": "Wreath Products of Distributive Forest Algebras",
        "authors": [
            "Michael Hahn",
            "Andreas Krebs",
            "Howard Straubing"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  It is an open problem whether definability in Propositional Dynamic Logic\n(PDL) on forests is decidable. Based on an algebraic characterization by\nBoja\\'nczyk, et. al.,(2012) in terms of forest algebras, Straubing (2013)\ndescribed an approach to PDL based on a k-fold iterated distributive law. A\nproof that all languages satisfying such a k-fold iterated distributive law are\nin PDL would settle decidability of PDL. We solve this problem in the case k=2:\nAll languages recognized by forest algebras satisfying a 2-fold iterated\ndistributive law are in PDL. Furthermore, we show that this class is decidable.\nThis provides a novel nontrivial decidable subclass of PDL, and demonstrates\nthe viability of the proposed approach to deciding PDL in general.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.03493v1"
    },
    {
        "title": "Cellular Automata: Reversibility, Semi-reversibility and Randomness",
        "authors": [
            "Kamalika Bhattacharjee"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this dissertation, we study two of the global properties of 1-dimensional\ncellular automata (CAs) under periodic boundary condition, namely,\nreversibility and randomness. To address reversibility of finite CAs, we\ndevelop a mathematical tool, named reachability tree, which can efficiently\ncharacterize those CAs. A decision algorithm is proposed using minimized\nreachability tree which takes a CA rule and size n as input and verifies\nwhether the CA is reversible for that n. To decide reversibility of a finite\nCA, we need to know both the rule and the CA size. However, for infinite CAs,\nreversibility is decided based on the local rule only. Therefore, apparently,\nthese two cases seem to be divergent. This dissertation targets to construct a\nbridge between these two cases. To do so, reversibility of CAs is redefined and\nthe notion of semi-reversible CAs is introduced. Hence, we propose a new\nclassification of finite CAs -(1) reversible CAs, (2) semi-reversible CAs and\n(3) strictly irreversible CAs. Finally, relation between reversibility of\nfinite and infinite CAs is established. This dissertation also explores CAs as\nsource of randomness and build pseudo-random number generators (PRNGs) based on\nCAs. We identify a list of properties for a CA to be a good source of\nrandomness. Two heuristic algorithms are proposed to synthesize candidate\n(decimal) CAs which have great potentiality as PRNGs. Two schemes tare\ndeveloped o use these CAs as window-based PRNGs - (1) as decimal number\ngenerators and as (2) binary number generators. We empirically observe that in\ncomparison to the best PRNG SFMT19937-64, average performance of our proposed\nPRNGs are slightly better. Hence, our decimal CAs based PRNGs are one of the\nbest PRNGs today.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.03609v1"
    },
    {
        "title": "Learning Weighted Automata over Principal Ideal Domains",
        "authors": [
            "Gerco van Heerdt",
            "Clemens Kupke",
            "Jurriaan Rot",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper, we study active learning algorithms for weighted automata over\na semiring. We show that a variant of Angluin's seminal \\LStar\\ algorithm works\nwhen the semiring is a principal ideal domain, but not for general semirings\nsuch as the natural numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.04404v2"
    },
    {
        "title": "Resolvable Ambiguity",
        "authors": [
            "Viktor Palmkvist",
            "Elias Castegren",
            "Philipp Haller",
            "David Broman"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A common standpoint when designing the syntax of programming languages is\nthat the grammar definition has to be unambiguous. However, requiring up front\nunambiguous grammars can force language designers to make more or less\narbitrary choices to disambiguate the language. In this paper, we depart from\nthe traditional view of unambiguous grammar design, and enable the detection of\nambiguities to be delayed until parse time, allowing the user of the language\nto perform the disambiguation. A natural decision problem follows: given a\nlanguage definition, can a user always disambiguate an ambiguous program? We\nintroduce and formalize this fundamental problem - called the resolvable\nambiguity problem - and divide it into separate static and dynamic\nresolvability problems. We provide solutions to the static problem for a\nrestricted language class and sketch proofs of soundness and completeness. We\nalso provide a sound and complete solution to the dynamic problem for a much\nless restricted class of languages. The approach is evaluated through two\nseparate case studies, covering both a large existing programming language, and\nthe composability of domain-specific languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.05672v2"
    },
    {
        "title": "Iterative method of generating artificial context-free grammars",
        "authors": [
            "Olgierd Unold",
            "Agnieszka Kaczmarek",
            "Łukasz Culer"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Grammatical inference is a machine learning area, whose fundamentals are\nbuilt around learning sets. At present, real-life data and examples from\nmanually crafted grammars are used to test their learning performance. This\npaper aims to present a method of generating artificial context-free grammars\nwith their optimal learning sets, which could be successfully applied as a\nbenchmarking tool for empirical grammar inference methods.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.05801v1"
    },
    {
        "title": "Witnessing Secure Compilation",
        "authors": [
            "Kedar S. Namjoshi",
            "Lucas M. Tabajara"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Compiler optimizations are designed to improve run-time performance while\npreserving input-output behavior. Correctness in this sense does not\nnecessarily preserve security: it is known that standard optimizations may\nbreak or weaken security properties that hold of the source program. This work\ndevelops a translation validation method for secure compilation. Security\n(hyper-)properties are expressed using automata operating over a bundle of\nprogram traces. A flexible, automaton-based refinement scheme, generalizing\nexisting refinement methods, guarantees that the associated security property\nis preserved by a program transformation. In practice, the refinement relations\n(\"security witnesses\") can be generated during compilation and validated\nindependently with a refinement checker. This process is illustrated for common\noptimizations. Crucially, it is not necessary to verify the compiler\nimplementation itself, which is infeasible in practice for production\ncompilers.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.05866v1"
    },
    {
        "title": "Language Inclusion for Finite Prime Event Structures",
        "authors": [
            "Andreas Fellner",
            "Thorsten Tarrach",
            "Georg Weissenbacher"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study the problem of language inclusion between finite, labeled prime\nevent structures. Prime event structures are a formalism to compactly represent\nconcurrent behavior of discrete systems. A labeled prime event structure\ninduces a language of sequences of labels produced by the represented system.\nWe study the problem of deciding inclusion and membership for languages encoded\nby finite prime event structures and provide complexity results for both\nproblems. We provide a family of examples where prime event structures are\nexponentially more succinct than formalisms that do not take concurrency into\naccount. We provide a decision algorithm for language inclusion that exploits\nthis succinctness. Furthermore, we provide an implementation of the algorithm\nand an evaluation on a series of benchmarks. Finally, we demonstrate how our\nresults can be applied to mutation-based test case generation.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.06355v1"
    },
    {
        "title": "Weighted Parsing for Grammar-Based Language Models over Multioperator\n  Monoids",
        "authors": [
            "Richard Mörbitz",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We develop a general framework for weighted parsing which is built on top of\ngrammar-based language models and employs multioperator monoids as weight\nalgebras. It generalizes previous work in that area (semiring parsing, weighted\ndeductive parsing) and also covers applications outside the classical scope of\nparsing, e.g., algebraic dynamic programming. We show an algorithm for weighted\nparsing and, for a large class of weighted grammar-based language models, we\nprove formally that it terminates and is correct.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.06585v1"
    },
    {
        "title": "Fuzzy Deterministic Top-down Tree Automata",
        "authors": [
            "Eija Jurvanen",
            "Magnus Steinby"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we introduce and study fuzzy deterministic top-down (DT) tree\nautomata over a lattice L. The L-fuzzy tree languages recognized by these\nautomata are said to be DT-recognizable, and they form a proper subfamily\n$DRec_L$ of the family of $Rec_L$ of all regular L-fuzzy tree languages. We\nprove a Pumping Lemma for $DRec_L$ from which several decidability results\nfollow. The closure properties of $DRec_L$ under various operations are\nestablished. We also characterize DT-recognizability in terms of L-fuzzy path\nlanguages, and prove that the path closure of any regular L-fuzzy tree language\nis DT-recognizable, and that it is decidable whether a regular L-fuzzy tree\nlanguage is DT-recognizable. In most of the paper, L is just any nontrivial\nbounded lattice, but sometimes it is assumed to be distributive or even a\nbounded chain.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.11529v1"
    },
    {
        "title": "On the Balancedness of Tree-to-word Transducers",
        "authors": [
            "Raphaela Löbel",
            "Michael Luttenberger",
            "Helmut Seidl"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A language over an alphabet $B = A \\cup \\overline{A}$ of opening ($A$) and\nclosing ($\\overline{A}$) brackets, is balanced if it is a subset of the Dyck\nlanguage $D_B$ over $B$, and it is well-formed if all words are prefixes of\nwords in $D_B$. We show that well-formedness of a context-free language is\ndecidable in polynomial time, and that the longest common reduced suffix can be\ncomputed in polynomial time. With this at a hand we decide for the class 2-TWs\nof non-linear tree transducers with output alphabet $B^*$ whether or not the\noutput language is balanced.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.13054v2"
    },
    {
        "title": "Preservation of normality by unambiguous transducers",
        "authors": [
            "Olivier Carton"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider finite state non-deterministic but unambiguous transducers with\ninfinite inputs and infinite outputs, and we consider the property of Borel\nnormality of sequences of symbols. When these transducers are strongly\nconnected, and when the input is a Borel normal sequence, the output is a\nsequence in which every block has a frequency given by a weighted automaton\nover the rationals. We provide an algorithm that decides in cubic time whether\na unambiguous transducer preserves normality.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.00891v3"
    },
    {
        "title": "On the complexity of the universality and inclusion problems for\n  unambiguous context-free grammars (technical report)",
        "authors": [
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the computational complexity of universality and inclusion problems\nfor unambiguous finite automata and context-free grammars. We observe that\nseveral such problems can be reduced to the universality problem for\nunambiguous context-free grammars. The latter problem has long been known to be\ndecidable and we propose a PSPACE algorithm that works by reduction to the\nzeroness problem of recurrence equations with convolution. We are not aware of\nany non-trivial complexity lower bounds. However, we show that computing the\ncoin-flip measure of an unambiguous context-free language, a quantitative\ngeneralisation of universality, is hard for the long-standing open problem\nSQRTSUM.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.05275v2"
    },
    {
        "title": "Avoiding abelian powers cyclically",
        "authors": [
            "Jarkko Peltomäki",
            "Markus A. Whiteland"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study a new notion of cyclic avoidance of abelian powers. A finite word\n$w$ avoids abelian $N$-powers cyclically if for each abelian $N$-power of\nperiod $m$ occurring in the infinite word $w^\\omega$, we have $m \\geq |w|$. Let\n$\\mathcal{A}(k)$ be the least integer $N$ such that for all $n$ there exists a\nword of length $n$ over a $k$-letter alphabet that avoids abelian $N$-powers\ncyclically. Let $\\mathcal{A}_\\infty(k)$ be the least integer $N$ such that\nthere exist arbitrarily long words over a $k$-letter alphabet that avoid\nabelian $N$-powers cyclically.\n  We prove that $5 \\leq \\mathcal{A}(2) \\leq 8$, $3 \\leq \\mathcal{A}(3) \\leq 4$,\n$2 \\leq \\mathcal{A}(4) \\leq 3$, and $\\mathcal{A}(k) = 2$ for $k \\geq 5$.\nMoreover, we show that $\\mathcal{A}_\\infty(2) = 4$, $\\mathcal{A}_\\infty(3) =\n3$, and $\\mathcal{A}_\\infty(4) = 2$.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.06307v2"
    },
    {
        "title": "Algebraic Language Theory for Eilenberg--Moore Algebras",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We develop an algebraic language theory based on the notion of an\nEilenberg--Moore algebra. In comparison to previous such frameworks the main\ncontribution is the support for algebras with infinitely many sorts and the\nconnection to logic in form of so-called `definable algebras'.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.08316v4"
    },
    {
        "title": "State Complexity of Permutation and Related Decision Problems on\n  Alphabetical Pattern Constraints",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We investigate the state complexity of the permutation operation, or the\ncommutative closure, on Alphabetical Pattern Constraints (APC). This class\ncorresponds to level $3/2$ of the Straubing-Th{\\'e}rien Hierarchy and includes\nthe finite, the piecewise-testable, or $\\mathcal J$-trivial, and the $\\mathcal\nR$-trivial and $\\mathcal L$-trivial languages. We give a sharp state complexity\nbound expressed in terms of the longest strings in the unary projection\nlanguages of an associated finite language and which is already sharp for the\nsubclass of finite languages. Additionally, for two subclasses, we give sharp\nbounds expressed in terms of the size of a recognizing input automaton and the\nsize of the alphabet. Lastly, we investigate the inclusion and universality\nproblem on APCs up to permutational equivalence, two problems known to be\nPSPACE-complete on APCs even for fixed alphabets in general, and show them to\nbe decidable in polynomial time for fixed alphabets in this case.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.15178v3"
    },
    {
        "title": "Making Streett Determinization Tight",
        "authors": [
            "Cong Tian",
            "Wensheng Wang",
            "Zhenhua Duan"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Optimal determinization construction of Streett automata is an important\nresearch problem because it is indispensable in numerous applications such as\ndecision problems for tree temporal logics, logic games and system synthesis.\nThis paper presents a transformation from nondeterministic Streett automata\n(NSA) with $n$ states and $k$ Streett pairs to equivalent deterministic Rabin\ntransition automata (DRTA) with $n^{5n}(n!)^{n}$ states, $O(n^{n^2})$ Rabin\npairs for $k=\\omega(n)$ and $n^{5n}k^{nk}$ states, $O(k^{nk})$ Rabin pairs for\n$k=O(n)$. This improves the state of the art Streett determinization\nconstruction with $n^{5n}(n!)^{n+1}$ states, $O(n^2)$ Rabin pairs and\n$n^{5n}k^{nk}n!$ states, $O(nk)$ Rabin pairs, respectively. Moreover,\ndeterministic parity transition automata (DPTA) are obtained with\n$3(n(n+1)-1)!(n!)^{n+1}$ states, $2n(n+1)$ priorities for $k=\\omega(n)$ and\n$3(n(k+1)-1)!n!k^{nk}$ states, $2n(k+1)$ priorities for $k=O(n)$, which\nimproves the best construction with $n^{n}(k+1)^{n(k+1)}(n(k+1)-1)!$ states,\n$2n(k+1)$ priorities. Further, we prove a lower bound state complexity for\ndeterminization construction from NSA to deterministic Rabin (transition)\nautomata i.e. $n^{5n}(n!)^{n}$ for $k=\\omega(n)$ and $n^{5n}k^{nk}$ for\n$k=O(n)$, which matches the state complexity of the proposed determinization\nconstruction. Besides, we put forward a lower bound state complexity for\ndeterminization construction from NSA to deterministic parity (transition)\nautomata i.e. $2^{\\Omega(n^2 \\log n)}$ for $k=\\omega(n)$ and $2^{\\Omega(nk \\log\nnk)}$ for $k=O(n)$, which is the same as the state complexity of the proposed\ndeterminization construction in the exponent.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.16476v1"
    },
    {
        "title": "Pebble Minimization of Polyregular Functions",
        "authors": [
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that a polyregular word-to-word function is regular if and only if\nits output size is at most linear in its input size. Moreover a polyregular\nfunction can be realized by: a transducer with two pebbles if and only if its\noutput has quadratic size in its input, a transducer with three pebbles if and\nonly if its output has cubic size in its input, etc. Moreover the\ncharacterization is decidable and, given a polyregular function, one can\ncompute a transducer realizing it with the minimal number of pebbles. We apply\nthe result to mso interpretations from words to words. We show that mso\ninterpretations of dimension k exactly coincide with k-pebble transductions.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.16645v2"
    },
    {
        "title": "Weak Greibach Normal Form for Hyperedge Replacement Grammars",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  It is known that hyperedge replacement grammars are similar to string\ncontext-free grammars in the sense of definitions and properties. Therefore, we\nexpect that there is a generalization of the well-known Greibach normal form\nfrom string grammars to hypergraph grammars. Such generalized normal forms are\npresented in several papers; however, they do not cover a large class of\nhypergraph languages (e.g. languages consisting of star graphs). In this paper,\nwe introduce a weak Greibach normal form, whose definition corresponds to the\nlexicalized normal form for string grammars, and prove that every context-free\nhypergraph language (with nonsubstantial exceptions) can be generated by a\ngrammar in this normal form. The proof presented in this paper generalizes a\ncorresponding one for string grammars with a few more technicalities.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.01660v1"
    },
    {
        "title": "Input-driven automata on well-nested infinite strings:\n  automata-theoretic and topological properties",
        "authors": [
            "Alexander Okhotin",
            "Victor L. Selivanov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Automata operating on strings of nested brackets, known as input-driven\npushdown automata, and as visibly pushdown automata, have been studied since\nthe 1980s. They were extended to the case of infinite strings by Alur and\nMadhusudan (\"Visibly pushdown languages\", STOC 2004). This paper investigates\nthe properties of these automata under the assumption that a given infinite\nstring is always well-nested. This restriction enables a complete\ncharacterization of the corresponding $\\omega$-languages in terms of classical\n$\\omega$-regular languages and input-driven automata on finite strings. This\ncharacterization leads to a determinization result for these automata, as well\nas to the first results on their Wadge degrees.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.03395v1"
    },
    {
        "title": "Rational index of bounded-oscillation languages",
        "authors": [
            "Ekaterina Shemetova",
            "Alexander Okhotin",
            "Semyon Grigorev"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The rational index of a context-free language $L$ is a function $f(n)$, such\nthat for each regular language $R$ recognized by an automaton with $n$ states,\nthe intersection of $L$ and $R$ is either empty or contains a word shorter than\n$f(n)$. It is known that the context-free language (CFL-)reachability problem\nand Datalog query evaluation for context-free languages (queries) with the\npolynomial rational index is in NC, while these problems is P-complete in the\ngeneral case. We investigate the rational index of bounded-oscillation\nlanguages and show that it is of polynomial order. We obtain upper bounds on\nthe values of the rational index for general bounded-oscillation languages and\nfor some of its previously studied subclasses.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.03567v1"
    },
    {
        "title": "The hardest language for grammars with context operators",
        "authors": [
            "Mikhail Mrykhin",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In 1973, Greibach (\"The hardest context-free language\", SIAM J. Comp., 1973)\nconstructed a context-free language $L_0$ with the property that every\ncontext-free language can be reduced to $L_0$ by a homomorphism, thus\nrepresenting it as an inverse homomorphic image $h^{-1}(L_0)$. In this paper, a\nsimilar characterization is established for a family of grammars equipped with\noperators for referring to the left context of any substring, recently defined\nby Barash and Okhotin (\"An extension of context-free grammars with one-sided\ncontext specifications\", Inform. Comput., 2014). An essential step of the\nargument is a new normal form for grammars with context operators, in which\nevery nonterminal symbol defines only strings of odd length in left contexts of\neven length: the even-odd normal form. The characterization is completed by\nshowing that the language family defined by grammars with context operators is\nclosed under inverse homomorphisms; actually, it is closed under injective\nnondeterministic finite transductions.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.03596v2"
    },
    {
        "title": "On probabilistic stable event structures",
        "authors": [
            "Nargess Ghahremani",
            "Julian Bradfield"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Concurrency and probability are both much studied extensions of sequential\ncomputation. Within concurrency theory, there is a broad divide between\ninterleaving models and logics, which model concurrency by non-determinism, and\n`truly concurrent' models, in which concurrency (and/or causality) are directly\nrepresented. True concurrency gives much richer models and logics, but is also\nharder to work with, as the interactions of causality and concurrency can\nbecome complex.\n  In probabilistic computation, we have by now many well understood\nprobabilistic models and logics on interleaving models, developed over the last\nthirty years or so. However, for true concurrency, adding probability has been\nmuch harder, owing to the interactions between probabilistic independence and\ncausal/concurrent independence, piling both conceptual and technical\ndifficulties upon an already complex model. Various notions of, e.g.,\nprobabilistic Petri net have been introduced, but for simpler cases such as\nfree-choice nets.\n  A significant contribution in the last decade was Abbes and Benveniste 2006,\nwhich gave a rigorous foundation for probabilistic concurrency in terms of\nWinskel's event structures, which can be seen as the lowest level of\nconcurrent/causal modelling. However, event structures are themselves not ideal\nfor representing richer high-level models such as (arbitrary) Petri nets, as\nthe concurrency is derived from a binary conflict relation.\n  Here we develop an extension of the theory of Abbes and Benveniste to a more\ngeneral class of models, a certain subclass of `stable event structures'. This\nclass is sufficient to give a semantics to probabilistic Petri nets (including\nthe notoriously awkward notion of confusion, which is forbidden by free-choice\nnets), and thereby allows the definition of general probabilistic logics for\nPetri nets.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.10188v1"
    },
    {
        "title": "$O_n$ is an $n$-MCFL",
        "authors": [
            "Kilian Gebhardt",
            "Frédéric Meunier",
            "Sylvain Salvati"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Commutative properties in formal languages pose problems at the frontier of\ncomputer science, computational linguistics and computational group theory. A\nprominent problem of this kind is the position of the language $O_n$, the\nlanguage that contains the same number of letters $a_i$ and $\\bar a_i$ with\n$1\\leq i\\leq n$, in the known classes of formal languages. It has recently been\nshown that $O_n$ is a Multiple Context-Free Language (MCFL). However the more\nprecise conjecture of Nederhof that $O_n$ is an MCFL of dimension $n$ was left\nopen. We present two proofs of this conjecture, both relying on tools from\nalgebraic topology. On our way, we prove a variant of the necklace splitting\ntheorem.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.12100v1"
    },
    {
        "title": "Regular expression length via arithmetic formula complexity",
        "authors": [
            "Ehud Cseresnyes",
            "Hannes Seiwert"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We prove lower bounds on the length of regular expressions for finite\nlanguages by methods from arithmetic circuit complexity. First, we show a\nreduction: the length of a regular expression for a language $L\\subseteq\n\\{0,1\\}^n$ is bounded from below by the minimum size of a monotone arithmetic\nformula computing a polynomial that has $L$ as its set of exponent vectors,\nviewing words as vectors. This result yields lower bounds for the binomial\nlanguage of all words with exactly $k$ ones and $n-k$ zeros and for the\nlanguage of all Dyck words of length $2n$. We also determine the blow-up of\nlanguage operations (intersection and shuffle) of regular expressions for\nfinite languages. Second, we adapt a lower bound method for multilinear\narithmetic formulas by so-called log-product polynomials to regular\nexpressions. With this method we show almost tight lower bounds for the\nlanguage of all binary numbers with $n$ bits that are divisible by a given odd\ninteger $p$, for the language of all words of length $n$ over a $k$ letter\nalphabet with an even number of occurrences of each letter and for the language\nof all permutations of $\\{1,\\dots, n\\}$.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.15617v1"
    },
    {
        "title": "Recognizability of languages via deterministic finite automata with\n  values on a monoid: General Myhill-Nerode Theorem",
        "authors": [
            "José Ramón González de Mendívil",
            "Federico Fariña"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This paper deals with the problem of recognizability of functions l: Sigma*\n--> M that map words to values in the support set M of a monoid (M,.,1). These\nfunctions are called M-languages. M-languages are studied from the aspect of\ntheir recognition by deterministic finite automata whose components take values\non M (M-DFAs). The characterization of an M-language l is based on providing a\nright congruence on Sigma* that is defined through l and a factorization on the\nset of all M-languages, L(Sigma*,M) (in sort L). A factorization on L is a pair\nof functions (g,f) such that, for each l in L, g(l). f(l)= l, where g(l) in M\nand f(l) in L. In essence, a factorization is a form of common factor\nextraction. A general Myhill-Nerode theorem, which is valid for any L(Sigma*,\nM), is provided. Basically, l is recognized by an M-DFA if and only if there\nexists a factorization on L, (g,f), such that the right congruence on Sigma*\ninduced by the factorization (g,f) and f(l), has finite index. This paper shows\nthat the existence of M-DFAs guarantees the existence of natural non-trivial\nfactorizations on L without taking account any additional property on the\nmonoid.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.05968v1"
    },
    {
        "title": "Optimal Spectral-Norm Approximate Minimization of Weighted Finite\n  Automata",
        "authors": [
            "Borja Balle",
            "Clara Lacroce",
            "Prakash Panangaden",
            "Doina Precup",
            "Guillaume Rabusseau"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We address the approximate minimization problem for weighted finite automata\n(WFAs) with weights in $\\mathbb{R}$, over a one-letter alphabet: to compute the\nbest possible approximation of a WFA given a bound on the number of states.\nThis work is grounded in Adamyan-Arov-Krein Approximation theory, a remarkable\ncollection of results on the approximation of Hankel operators. In addition to\nits intrinsic mathematical relevance, this theory has proven to be very\neffective for model reduction. We adapt these results to the framework of\nweighted automata over a one-letter alphabet. We provide theoretical guarantees\nand bounds on the quality of the approximation in the spectral and $\\ell^2$\nnorm. We develop an algorithm that, based on the properties of Hankel\noperators, returns the optimal approximation in the spectral norm.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.06860v3"
    },
    {
        "title": "Adaptive Synchronisation of Pushdown Automata",
        "authors": [
            "A. R. Balasubramanian",
            "K. S. Thejaswini"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce the notion of adaptive synchronisation for pushdown automata, in\nwhich there is an external observer who has no knowledge about the current\nstate of the pushdown automaton, but can observe the contents of the stack. The\nobserver would then like to decide if it is possible to bring the automaton\nfrom any state into some predetermined state by giving inputs to it in an\n\\emph{adaptive} manner, i.e., the next input letter to be given can depend on\nhow the contents of the stack changed after the current input letter. We show\nthat for non-deterministic pushdown automata, this problem is\n2-EXPTIME-complete and for deterministic pushdown automata, we show\nEXPTIME-completeness.\n  To prove the lower bounds, we first introduce (different variants of)\nsubset-synchronisation and show that these problems are polynomial-time\nequivalent with the adaptive synchronisation problem. We then prove hardness\nresults for the subset-synchronisation problems. For proving the upper bounds,\nwe consider the problem of deciding if a given alternating pushdown system has\nan accepting run with at most $k$ leaves and we provide an $n^{O(k^2)}$ time\nalgorithm for this problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.06897v1"
    },
    {
        "title": "Learning Pomset Automata",
        "authors": [
            "Gerco van Heerdt",
            "Tobias Kappé",
            "Jurriaan Rot",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We extend the L* algorithm to learn bimonoids recognising pomset languages.\nWe then identify a class of pomset automata that accepts precisely the class of\npomset languages recognised by bimonoids and show how to convert between\nbimonoids and automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.07504v1"
    },
    {
        "title": "Locality and Centrality: The Variety ZG",
        "authors": [
            "Antoine Amarilli",
            "Charles Paperman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the variety ZG of monoids where the elements that belong to a group\nare central, i.e., commute with all other elements. We show that ZG is local,\nthat is, the semidirect product ZG * D of ZG by definite semigroups is equal to\nLZG, the variety of semigroups where all local monoids are in ZG. Our main\nresult is thus: ZG * D = LZG. We prove this result using Straubing's delay\ntheorem, by considering paths in the category of idempotents. In the process,\nwe obtain the characterization ZG = MNil \\vee Com, and also characterize the ZG\nlanguages, i.e., the languages whose syntactic monoid is in ZG: they are\nprecisely the languages that are finite unions of disjoint shuffles of\nsingleton languages and regular commutative languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.07724v5"
    },
    {
        "title": "New Techniques for Universality in Unambiguous Register Automata",
        "authors": [
            "Wojciech Czerwiński",
            "Antoine Mottet",
            "Karin Quaas"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Register automata are finite automata equipped with a finite set of registers\nranging over the domain of some relational structure like $(\\mathbb N;=)$ or\n$(\\mathbb Q;<)$. Register automata process words over the domain, and along a\nrun of the automaton, the registers can store data from the input word for\nlater comparisons. It is long known that the universality problem, i.e., the\nproblem to decide whether a given register automaton accepts all words over the\ndomain, is undecidable. Recently, we proved the problem to be decidable in\n2-ExpSpace if the register automaton under study is over $(\\mathbb N;=)$ and\nunambiguous, i.e., every input word has at most one accepting run; this result\nwas shortly after improved to 2-ExpTime by Barloy and Clemente. In this paper,\nwe go one step further and prove that the problem is in ExpSpace, and in PSpace\nif the number of registers is fixed. Our proof is based on new techniques that\nadditionally allow us to show that the problem is in PSpace for single-register\nautomata over $(\\mathbb Q;<)$. As a third technical contribution we prove that\nthe problem is decidable (in ExpSpace) for a more expressive model of\nunambiguous register automata, where the registers can take values\nnondeterministically, if defined over $(\\mathbb N;=)$ and only one register is\nused.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.08331v1"
    },
    {
        "title": "On polynomial grammars extended with substitution",
        "authors": [
            "Janusz Schmude"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate decidability of equivalence of register transducers, also\ncalled copyful Streaming String Transducers in case of string input, extended\nwith an operation of substituting a register for all occurrences of a given\nletter in another register. We reduce to zeroness of polynomial grammars (over\nring of polynomials) extended with analogous substitution operation by encoding\nstrings into polynomials; a similar method was used successfully by Seidl et\nal. in 2018. We give two restrictions under which register transducers with\nsubstitution have decidable equivalence. They seem to be very restrictive but\non the other hand, they seem to be on the edge of the scope of this\n\"polynomial\" method, as in the third result we give a rather restricted model\nof polynomial grammars with substitution that has undecidable equivalence.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.08705v1"
    },
    {
        "title": "Synthesis and Implementation of Distributed Supervisory Controllers with\n  Communication Delays",
        "authors": [
            "R. H. J. Schouten",
            "L. Moormann",
            "J. M. van de Mortel-Fronczak",
            "J. E. Rooda"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In literature, extensive research has been done with respect to synthesis of\nsupervisory controllers. Such synthesized supervisors can be distributed for\nimplementation on multiple physical controllers. This paper discusses a method\nfor distributing a synthesized supervisory controller. In this method,\ndependency structure matrices are used to distribute a system, the supervisor\nis then distributed accordingly, using existing localization theory. The\nexistence of communication delays between supervisory controllers is\nunavoidable in a distributed application. The influence of these delays on the\nbehavior of a supervisor is therefore studied using delay robustness theory.\nThis paper introduces the use of mutex algorithms to make the distributed\nsupervisor delay-robust. A case study is used to demonstrate the method and\nhardware in the loop testing is used to validate the resulting distributed\nsupervisor.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.09821v1"
    },
    {
        "title": "Simplest Non-Regular Deterministic Context-Free Language",
        "authors": [
            "Petr Jancar",
            "Jiri Sima"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a new notion of C-simple problems for a class C of decision\nproblems (i.e. languages), w.r.t. a particular reduction. A problem is C-simple\nif it can be reduced to each problem in C. This can be viewed as a conceptual\ncounterpart to C-hard problems to which all problems in C reduce. Our concrete\nexample is the class of non-regular deterministic context-free languages\n(DCFL'), with a truth-table reduction by Mealy machines (which proves to be a\npreorder). The main technical result is a proof that the DCFL' language\n$L=\\{0^n1^n; n\\geq 1\\}$ is DCFL'-simple, which can thus be viewed as the\nsimplest problem in the class DCFL'. This result has already provided an\napplication, to the computational model of neural networks 1ANN at the first\nlevel of analog neuron hierarchy. This model was proven not to recognize $L$,\nby using a specialized technical argument that can hardly be generalized to\nother languages in DCFL'. By the result that $L$ is DCFL'-simple, w.r.t. the\nreduction that can be implemented by 1ANN, we immediately obtain that 1ANN\ncannot accept any language in DCFL'. It thus seems worthwhile to explore if\nlooking for C-simple problems in other classes C under suitable reductions\ncould provide effective tools for expanding the lower-bound results known for\nsingle problems to the whole classes of problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.10416v1"
    },
    {
        "title": "Decision Power of Weak Asynchronous Models of Distributed Computing",
        "authors": [
            "Philipp Czerner",
            "Roland Guttenberg",
            "Martin Helfrich",
            "Javier Esparza"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Esparza and Reiter have recently conducted a systematic comparative study of\nmodels of distributed computing consisting of a network of identical\nfinite-state automata that cooperate to decide if the underlying graph of the\nnetwork satisfies a given property. The study classifies models according to\nfour criteria, and shows that twenty initially possible combinations collapse\ninto seven equivalence classes with respect to their decision power, i.e. the\nproperties that the automata of each class can decide. However, Esparza and\nReiter only show (proper) inclusions between the classes, and so do not\ncharacterise their decision power. In this paper we do so for labelling\nproperties, i.e. properties that depend only on the labels of the nodes, but\nnot on the structure of the graph. In particular, majority (whether more nodes\ncarry label $a$ than $b$) is a labelling property. Our results show that only\none of the seven equivalence classes identified by Esparza and Reiter can\ndecide majority for arbitrary networks. We then study the expressive power of\nthe classes on bounded-degree networks, and show that three classes can. In\nparticular, we present an algorithm for majority that works for all\nbounded-degree networks under adversarial schedulers, i.e. even if the\nscheduler must only satisfy that every node makes a move infinitely often, and\nprove that no such algorithm can work for arbitrary networks.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.11630v2"
    },
    {
        "title": "Directing Words of Fuzzy Finite Automata",
        "authors": [
            "Magnus Steinby"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A deterministic finite automaton is directable if it has a directing word\nwhich takes the automaton from every state to the same state. These notions\nhave been extended also to other kinds of automata. Thus, B.~Imreh and\nM.~Steinby (1999) identified three natural types of directing words, called\nD1-, D2- and D3-directing words, for nondeterministic finite automata (NFAs).\nHere we adapt these notions for fuzzy finite automata (FFAs). The D3-directing\nwords obtained this way are precisely the directing words introduced by\nV.~Karthikeyan and M. Rajasekar (2015). With any FFA F we associate an NFA Fnd\nwhich has the same Di-directing words as F. Thus, if these definitions are\nused, the theory of directable FFAs reduces to that of NFAs.\n  We also introduce three new kinds of directing words of fuzzy automata that\nwe call DD1-, DD2- and DD3-directing words, respectively which depend more on\nthe fuzzy transition degrees between states. We establish some basic properties\nof the sets $DDi(F)$ of DDi-directing words of any given FFA F. In particular,\nit is shown that these languages are regular, and that DDi-directability is\ndecidable. For so-called normal FFAs the languages DDi(F) are shown to have\nsome special properties. Several relationships between the families of the\ncorresponding sets DDi(F) of DDi-directing words are presented. We also\ndetermine the complete meet-semilattice of the various classes of\nDDi-directable FFAs and normal FFAs and their intersections.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.00942v1"
    },
    {
        "title": "On the determinization of event-clock input-driven pushdown automata",
        "authors": [
            "Mizuhito Ogawa",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Input-driven pushdown automata (also known as visibly pushdown automata and\nas nested word automata) are a subclass of deterministic pushdown automata and\na superclass of the parenthesis languages. Nguyen and Ogawa (\"Event-clock\nvisibly pushdown automata\", SOFSEM 2009) defined a timed extension of these\nautomata under the event-clock model, and showed that this model can be\ndeterminized using the method of region construction. This paper defines a\nfurther extension of this model with the event clock on the call-return\noperations, and proposes a new, direct determinization procedure for these\nautomata: an $n$-state nondeterministic automaton with $k$ different clock\nconstraints is transformed to a deterministic automaton with $2^{n^2}$ states,\n$2^{n^2+k}$ stack symbols and the same clock constraints as in the original\nautomaton. The construction is shown to be asymptotically optimal with respect\nto both the number of states and the number of stack symbols.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.04079v1"
    },
    {
        "title": "Equivalence Checking and Intersection of Deterministic Timed Finite\n  State Machines",
        "authors": [
            "Davide Bresolin",
            "Khaled El-Fakih",
            "Tiziano Villa",
            "Nina Yevtushenko"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  There has been a growing interest in defining models of automata enriched\nwith time, such as finite automata extended with clocks (timed automata). In\nthis paper, we study deterministic timed finite state machines (TFSMs), i.e.,\nfinite state machines with a single clock, timed guards and timeouts which\ntransduce timed input words into timed output words. We solve the problem of\nequivalence checking by defining a bisimulation from timed FSMs to untimed ones\nand viceversa. Moreover, we apply these bisimulation relations to build the\nintersection of two timed finite state machines by untiming them, intersecting\nthem and transforming back to the timed intersection.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.04868v1"
    },
    {
        "title": "Converting Nondeterministic Two-Way Automata into Small Deterministic\n  Linear-Time Machines",
        "authors": [
            "Bruno Guillon",
            "Giovanni Pighizzini",
            "Luca Prigioniero",
            "Daniel Průša"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In 1978 Sakoda and Sipser raised the question of the cost, in terms of size\nof representations, of the transformation of two-way and one-way\nnondeterministic automata into equivalent two-way deterministic automata.\nDespite all the attempts, the question has been answered only for particular\ncases (e.g., restrictions of the class of simulated automata or of the class of\nsimulating automata). However the problem remains open in the general case, the\nbest-known upper bound being exponential. We present a new approach in which\nunrestricted nondeterministic finite automata are simulated by deterministic\nmodels extending two-way deterministic finite automata, paying a polynomial\nincrease of size only. Indeed, we study the costs of the conversions of\nnondeterministic finite automata into some variants of one-tape deterministic\nTuring machines working in linear time, namely Hennie machines, weight-reducing\nTuring machines, and weight-reducing Hennie machines. All these variants are\nknown to share the same computational power: they characterize the class of\nregular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.05485v2"
    },
    {
        "title": "Weight-Reducing Turing Machines",
        "authors": [
            "Bruno Guillon",
            "Giovanni Pighizzini",
            "Luca Prigioniero",
            "Daniel Průša"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  It is well-known that one-tape Turing machines working in linear time are no\nmore powerful than finite automata, namely they recognize exactly the class of\nregular languages. We prove that it is not decidable if a one-tape machine\nworks in linear time, even if it is deterministic and restricted to use only\nthe portion of the tape which initially contains the input. This motivates the\nintroduction of a constructive variant of one-tape machines, called\nweight-reducing machine, and the investigation of its properties. We focus on\nthe deterministic case. In particular, we show that, paying a polynomial size\nincrease only, each weight-reducing machine can be turned into a halting one\nthat works in linear time. Furthermore each weight-reducing machine can be\nconverted into equivalent nondeterministic and deterministic finite automata by\npaying exponential and doubly-exponential increase in size, respectively. These\ncosts cannot be reduced in general.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.05486v2"
    },
    {
        "title": "Languages of Higher-Dimensional Automata",
        "authors": [
            "Uli Fahrenberg",
            "Christian Johansen",
            "Georg Struth",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce languages of higher-dimensional automata (HDAs) and develop some\nof their properties. To this end, we define a new category of precubical sets,\nuniquely naturally isomorphic to the standard one, and introduce a notion of\nevent consistency. HDAs are then finite, labeled, event-consistent precubical\nsets with distinguished subsets of initial and accepting cells. Their languages\nare sets of interval orders closed under subsumption; as a major technical step\nwe expose a bijection between interval orders and a subclass of HDAs. We show\nthat any finite subsumption-closed set of interval orders is the language of an\nHDA, that languages of HDAs are closed under binary unions and parallel\ncomposition, and that bisimilarity implies language equivalence.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.07557v2"
    },
    {
        "title": "Regularity Conditions for Iterated Shuffle on Commutative Regular\n  Languages",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We identify a subclass of the regular commutative languages that is closed\nunder the iterated shuffle, or shuffle closure. In particular, it is\nregularity-preserving on this subclass. This subclass contains the commutative\ngroup languages and, for every alphabet $\\Sigma$, the class\n$\\textbf{Com}^+(\\Sigma^*)$ given by the ordered variety $\\textbf{Com}^+$. Then,\nwe state a simple characterization when the iterated shuffle on finite\ncommutative languages gives a regular language again and state partial results\nfor aperiodic commutative languages. We also show that the aperiodic, or\nstar-free, commutative languages and the commutative group languages are closed\nunder projection.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.09587v2"
    },
    {
        "title": "A General Language-Based Framework for Specifying and Verifying Notions\n  of Opacity",
        "authors": [
            "Andrew Wintenberg",
            "Matthew Blischke",
            "Stéphane Lafortune",
            "Necmiye Ozay"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Opacity is an information flow property that captures the notion of plausible\ndeniability in dynamic systems, that is whether an intruder can deduce that\n\"secret\" behavior has occurred. In this paper we provide a general framework of\nopacity to unify the many existing notions of opacity that exist for discrete\nevent systems. We use this framework to discuss language-based and state-based\nnotions of opacity over automata. We present several methods for language-based\nopacity verification, and a general approach to transform state-based notions\ninto language-based ones. We demonstrate this approach for current-state and\ninitial-state opacity, unifying existing results. We then investigate the\nnotions of K-step opacity. We provide a language-based view of K-step opacity\nencompassing two existing notions and two new ones. We then analyze the\ncorresponding language-based verification methods both formally and with\nnumerical examples. In each case, the proposed methods offer significant\nreductions in runtime and space complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.10501v1"
    },
    {
        "title": "Discovering an Algorithm Actually Learning Restricted Single Occurrence\n  Regular Expression with Interleaving",
        "authors": [
            "Xiaofan Wang",
            "Xiaolan Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A recent paper proposed an algorithm iSOIRE, which combines single-occurrence\nautomaton (SOA) and maximum independent set (MIS) to learn a subclass\nsingle-occurrence regular expressions with interleaving (SOIREs) and claims the\nlearnt expression is SOIRE, which has unrestricted usage for interleaving.\nHowever, in reality, the learnt expression still has many restrictions for\nusing interleaving, even does for Kleene-star or interation, i.e, the learnt\nexpression is not an SOIRE, we prove that by examples. In this paper, for the\nalgorithm iSOIRE, we first give the basic notions, then provide analyses about\nincorrectness, finally present the correct result learnt by iSOIRE. Our\ntheoretical analyses demonstrate that the result derived by iSOIRE belongs to a\nsubclass of SOIREs.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.10546v1"
    },
    {
        "title": "Nonterminal complexity of some families of infinite regular languages",
        "authors": [
            "Dmitry Golubenko"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Nonterminal complexity of a context-free language is the smallest possible\nnumber of nonterminals in its generating grammar. While in general case\nnonterminal complexity computation problem is unsolvable, it can be computed\nfor different families of regular languages. In this paper we study nonterminal\ncomplexity of some families of infinite regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.11174v1"
    },
    {
        "title": "On the Uniform Distribution of Regular Expressions",
        "authors": [
            "Sabine Broda",
            "António Machiavelo",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Although regular expressions do not correspond univocally to regular\nlanguages, it is still worthwhile to study their properties and algorithms. For\nthe average case analysis one often relies on the uniform random generation\nusing a specific grammar for regular expressions, that can represent regular\nlanguages with more or less redundancy. Generators that are uniform on the set\nof expressions are not necessarily uniform on the set of regular languages.\nNevertheless, it is not straightforward that asymptotic estimates obtained by\nconsidering the whole set of regular expressions are different from those\nobtained using a more refined set that avoids some large class of equivalent\nexpressions. In this paper we study a set of expressions that avoid a given\nabsorbing pattern. It is shown that, although this set is significantly smaller\nthan the standard one, the asymptotic average estimates for the size of the\nGlushkov automaton for these expressions does not differ from the standard\ncase.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.13175v1"
    },
    {
        "title": "Aperiodic two-way transducers and FO-transductions",
        "authors": [
            "Olivier Carton",
            "Luc Dartois"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Deterministic two-way transducers on finite words have been shown by\nEngelfriet and Hoogeboom to have the same expressive power as\nMSO-transductions. We introduce a notion of aperiodicity for these transducers\nand we show that aperiodic transducers correspond exactly to FO-transductions.\nThis lifts to transducers the classical equivalence for languages between\nFO-definability, recognition by aperiodic monoids and acceptance by\ncounter-free automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.15651v1"
    },
    {
        "title": "A Note on the Join of Varieties of Monoids with LI",
        "authors": [
            "Nathan Grosshans"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this note, we give a characterisation in terms of identities of the join\nof $\\mathbf{V}$ with the variety of finite locally trivial semigroups\n$\\mathbf{LI}$ for several well-known varieties of finite monoids $\\mathbf{V}$\nby using classical algebraic-automata-theoretic techniques. To achieve this, we\nuse the new notion of essentially-$\\mathbf{V}$ stamps defined by Grosshans,\nMcKenzie and Segoufin and show that it actually coincides with the join of\n$\\mathbf{V}$ and $\\mathbf{LI}$ precisely when some natural condition on the\nvariety of languages corresponding to $\\mathbf{V}$ is verified.This work is a\nkind of rediscovery of the work of J. C. Costa around 20 years ago from a\nrather different angle, since Costa's work relies on the use of advanced\ndevelopments in profinite topology, whereas what is presented here essentially\nuses an algebraic, language-based approach.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.15659v3"
    },
    {
        "title": "The Simplest Proof of Parikh's Theorem via Derivation Trees",
        "authors": [
            "Alexander Rubtsov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parikh's theorem is a fundamental result of the formal language's theory.\nThere had been published many proofs and many papers claimed to provide a\nsimplified proof, but most of them are long and still complicated. We provide\nthe proof that is really short, simple and discloses the nature of this\nfundamental result. We follow the technique closed to the original Parikh's\npaper and our proof is similar to the proof by Ryoma Sin'ya 2019, but we\nprovide more detailed exposition and pretend to more simplicity as well. We\nachieve the simplicity via nonconstructivenes that allows us avoiding many\ndifficulties met by other proofs.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.00047v1"
    },
    {
        "title": "Descriptional Complexity of Finite Automata -- Selected Highlights",
        "authors": [
            "Arto Salomaa",
            "Kai Salomaa",
            "Taylor J. Smith"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The state complexity, respectively, nondeterministic state complexity of a\nregular language $L$ is the number of states of the minimal deterministic,\nrespectively, of a minimal nondeterministic finite automaton for $L$. Some of\nthe most studied state complexity questions deal with size comparisons of\nnondeterministic finite automata of differing degree of ambiguity. More\ngenerally, if for a regular language we compare the size of description by a\nfinite automaton and by a more powerful language definition mechanism, such as\na context-free grammar, we encounter non-recursive trade-offs. Operational\nstate complexity studies the state complexity of the language resulting from a\nregularity preserving operation as a function of the complexity of the argument\nlanguages. Determining the state complexity of combined operations is generally\nchallenging and for general combinations of operations that include\nintersection and marked concatenation it is uncomputable.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.03708v4"
    },
    {
        "title": "ALMA: Automata Learner using Modulo 2 Multiplicity Automata",
        "authors": [
            "Nevin George"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present ALMA (Automata Learner using modulo 2 Multiplicity Automata), a\nJava-based tool that can learn any automaton accepting regular languages of\nfinite or infinite words with an implementable membership query function. Users\ncan either pass as input their own membership query function, or use the\npredefined membership query functions for modulo 2 multiplicity automata and\nnon-deterministic B\\\"uchi automata. While learning, ALMA can output the state\nof the observation table after every equivalence query, and upon termination,\nit can output the dimension, transition matrices, and final vector of the\nlearned modulo 2 multiplicity automaton. Users can test whether a word is\naccepted by performing a membership query on the learned automaton.\n  ALMA follows the polynomial-time learning algorithm of Beimel et. al.\n(Learning functions represented as multiplicity automata. J. ACM 47(3), 2000),\nwhich uses membership and equivalence queries and represents hypotheses using\nmodulo 2 multiplicity automata. ALMA also implements a polynomial-time learning\nalgorithm for strongly unambiguous B\\\"uchi automata by Angluin et. al.\n(Strongly unambiguous B\\\"uchi automata are polynomially predictable with\nmembership queries. CSL 2020), and a minimization algorithm for modulo 2\nmultiplicity automata by Sakarovitch (Elements of Automata Theory. 2009).\n",
        "pdf_link": "http://arxiv.org/pdf/2301.04077v2"
    },
    {
        "title": "On the Comparison of Discounted-Sum Automata with Multiple Discount\n  Factors",
        "authors": [
            "Udi Boker",
            "Guy Hefetz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We look into the problems of comparing nondeterministic discounted-sum\nautomata on finite and infinite words. That is, the problems of checking for\nautomata $A$ and $B$ whether or not it holds that for all words $w$,\n$A(w)=B(w), A(w) \\leq B(w)$, or $A(w)<B(w)$.\n  These problems are known to be decidable when both automata have the same\nsingle integral discount factor, while decidability is open in all other\nsettings: when the single discount factor is a non-integral rational; when each\nautomaton can have multiple discount factors; and even when each has a single\nintegral discount factor, but the two are different.\n  We show that it is undecidable to compare discounted-sum automata with\nmultiple discount factors, even if all are integrals, while it is decidable to\ncompare them if each has a single, possibly different, integral discount\nfactor. To this end, we also provide algorithms to check for given\nnondeterministic automaton $N$ and deterministic automaton $D$, each with a\nsingle, possibly different, rational discount factor, whether or not $N(w) =\nD(w)$, $N(w) \\geq D(w)$, or $N(w) > D(w)$ for all words $w$.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.04086v2"
    },
    {
        "title": "Certificates for Probabilistic Pushdown Automata via Optimistic Value\n  Iteration",
        "authors": [
            "Tobias Winkler",
            "Joost-Pieter Katoen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Probabilistic pushdown automata (pPDA) are a standard model for discrete\nprobabilistic programs with procedures and recursion. In pPDA, many\nquantitative properties are characterized as least fixpoints of polynomial\nequation systems. In this paper, we study the problem of certifying that these\nquantities lie within certain bounds. To this end, we first characterize the\npolynomial systems that admit easy-to-check certificates for validating bounds\non their least fixpoint. Second, we present a sound and complete Optimistic\nValue Iteration algorithm for computing such certificates. Third, we show how\ncertificates for polynomial systems can be transferred to certificates for\nvarious quantitative pPDA properties. Experiments demonstrate that our\nalgorithm computes succinct certificates for several intricate example programs\nas well as stochastic context-free grammars with $> 10^4$ production rules.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.08657v2"
    },
    {
        "title": "Parikh Automata on Infinite Words",
        "authors": [
            "Mario Grobler",
            "Leif Sabellek",
            "Sebastian Siebertz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Parikh automata on finite words were first introduced by Klaedtke and\nRue{\\ss} [Automata, Languages and Programming, 2003]. In this paper, we\nintroduce several variants of Parikh automata on infinite words and study their\nexpressiveness. We show that one of our new models is equivalent to synchronous\nblind counter machines introduced by Fernau and Stiebe [Fundamenta\nInformaticae, 2008]. All our models admit {\\epsilon}-elimination, which to the\nbest of our knowledge is an open question for blind counter automata. We then\nstudy the classical decision problems of the new automata models.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.08969v1"
    },
    {
        "title": "Unboundedness problems for machines with reversal-bounded counters",
        "authors": [
            "Pascal Baumann",
            "Flavio D'Alessandro",
            "Moses Ganardi",
            "Oscar Ibarra",
            "Ian McQuillan",
            "Lia Schütze",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider a general class of decision problems concerning formal languages,\ncalled ``(one-dimensional) unboundedness predicates'', for automata that\nfeature reversal-bounded counters (RBCA). We show that each problem in this\nclass reduces -- non-deterministically in polynomial time -- to the same\nproblem for just finite automata. We also show an analogous reduction for\nautomata that have access to both a pushdown stack and reversal-bounded\ncounters (PRBCA).\n  This allows us to answer several open questions: For example, we show that it\nis coNP-complete to decide whether a given (P)RBCA language $L$ is bounded,\nmeaning whether there exist words $w_1,\\ldots,w_n$ with $L\\subseteq w_1^*\\cdots\nw_n^*$. For PRBCA, even decidability was open. Our methods also show that there\nis no language of a (P)RBCA of intermediate growth. This means, the number of\nwords of each length grows either polynomially or exponentially. Part of our\nproof is likely of independent interest: We show that one can translate an RBCA\ninto a machine with $\\mathbb{Z}$-counters in logarithmic space, while\npreserving the accepted language.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.10198v1"
    },
    {
        "title": "A weakly universal weighted cellular automaton in the heptagrid with 6\n  states",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we prove that there is a weakly universal weighted cellular\nautomaton in the heptagrid, the tessellation {7,3} of the hyperbolic plane,\nwith 6 states. The present paper improves the same result deposited on\narXiv:2301.10691v1 and also arXiv:2301.10691v2. In the deposited papers, the\nresult is proved with 7 states. In the present replacement the number of states\nis reduced to 6. Such a reducing is not trivial and requires substantial\nchanges in the implementation. The maximal weight is now 34, a very strong\nreduction with the best result with 7 states. Also, the table has 137 entries,\nsignifcantly less than the 160 entries of the paper with 7 states. The\nreduction is obtained by a new implementation of the tracks which play a key\nrole as far as without tracks there is no computational universality result.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.10691v4"
    },
    {
        "title": "Regular Separability in Büchi VASS",
        "authors": [
            "Pascal Baumann",
            "Roland Meyer",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the ($\\omega$-)regular separability problem for B\\\"uchi VASS\nlanguages: Given two B\\\"uchi VASS with languages $L_1$ and $L_2$, check whether\nthere is a regular language that fully contains $L_1$ while remaining disjoint\nfrom $L_2$. We show that the problem is decidable in general and\nPSPACE-complete in the 1-dimensional case, assuming succinct counter updates.\nThe results rely on several arguments. We characterize the set of all regular\nlanguages disjoint from $L_2$. Based on this, we derive a (sound and complete)\nnotion of inseparability witnesses, non-regular subsets of $L_1$. Finally, we\nshow how to symbolically represent inseparability witnesses and how to check\ntheir existence.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.11242v1"
    },
    {
        "title": "Fast Matching of Regular Patterns with Synchronizing Counting (Technical\n  Report)",
        "authors": [
            "Lukáš Holík",
            "Juraj Síč",
            "Lenka Turoňová",
            "Tomáš Vojnar"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Fast matching of regular expressions with bounded repetition, aka counting,\nsuch as (ab){50,100}, i.e., matching linear in the length of the text and\nindependent of the repetition bounds, has been an open problem for at least two\ndecades. We show that, for a wide class of regular expressions with counting,\nwhich we call synchronizing, fast matching is possible. We empirically show\nthat the class covers nearly all counting used in usual applications of regex\nmatching. This complexity result is based on an improvement and analysis of a\nrecent matching algorithm that compiles regexes to deterministic counting-set\nautomata (automata with registers that hold sets of numbers).\n",
        "pdf_link": "http://arxiv.org/pdf/2301.12851v1"
    },
    {
        "title": "Monadic Expressions and their Derivatives [extended version]",
        "authors": [
            "Samira Attou",
            "Ludovic Mignot",
            "Clément Miklarz",
            "Florent Nicart"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We propose another interpretation of well-known derivatives computations from\nregular expressions, due to Brzozowski, Antimirov or Lombardy and Sakarovitch,\n  in order to abstract the underlying data structures (e.g. sets or linear\ncombinations) using the notion of monad.\n  As an example of this generalization advantage, we first introduce a new\nderivation technique based on the graded module monad\n  and then show an application of this technique to generalize the parsing of\nexpression with capture groups and back references.\n  We also extend operators defining expressions to any n-ary functions over\nvalue sets, such as\n  classical operations (like negation or intersection for Boolean weights) or\nmore exotic ones (like algebraic mean for rational weights).\n  Moreover, we present how to compute a (non-necessarily finite) automaton from\nsuch an extended expression, using the Colcombet and Petrisan categorical\ndefinition of automata.\n  These category theory concepts allow us to perform this construction in a\nunified way, whatever the underlying monad.\n  Finally, to illustrate our work, we present a Haskell implementation of these\nnotions using advanced techniques of functional programming,\n  and we provide a web interface to manipulate concrete examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.13054v1"
    },
    {
        "title": "Weighted One-Deterministic-Counter Automata",
        "authors": [
            "Prince Mathew",
            "Vincent Penelle",
            "Prakash Saivasan",
            "A. V. Sreejith"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce weighted one-deterministic-counter automata (ODCA). These are\nweighted one-counter automata (OCA) with the property of counter-determinacy,\nmeaning that all paths labelled by a given word starting from the initial\nconfiguration have the same counter-effect. Weighted ODCAs are a strict\nextension of weighted visibly OCAs, which are weighted OCAs where the input\nalphabet determines the actions on the counter.\n  We present a novel problem called the co-VS (complement to a vector space)\nreachability problem for weighted ODCAs over fields, which seeks to determine\nif there exists a run from a given configuration of a weighted ODCA to another\nconfiguration whose weight vector lies outside a given vector space. We\nestablish two significant properties of witnesses for co-VS reachability: they\nsatisfy a pseudo-pumping lemma, and the lexicographically minimal witness has a\nspecial form. It follows that the co-VS reachability problem is in P.\n  These reachability problems help us to show that the equivalence problem of\nweighted ODCAs over fields is in P by adapting the equivalence proof of\ndeterministic real-time OCAs by B\\\"ohm et al. This is a step towards resolving\nthe open question of the equivalence problem of weighted OCAs. Furthermore, we\ndemonstrate that the regularity problem, the problem of checking whether an\ninput weighted ODCA over a field is equivalent to some weighted automaton, is\nin P. Finally, we show that the covering and coverable equivalence problems for\nuninitialised weighted ODCAs are decidable in polynomial time. We also consider\nboolean ODCAs and show that the equivalence problem for (non-deterministic)\nboolean ODCAs is in PSPACE, whereas it is undecidable for (non-deterministic)\nboolean OCAs.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.13456v2"
    },
    {
        "title": "Coverability in 2-VASS with One Unary Counter is in NP",
        "authors": [
            "Filip Mazowiecki",
            "Henry Sinclair-Banks",
            "Karol Węgrzycki"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Coverability in Petri nets finds applications in verification of safety\nproperties of reactive systems. We study coverability in the equivalent model:\nVector Addition Systems with States (VASS).\n  A k-VASS can be seen as k counters and a finite automaton whose transitions\nare labelled with k integers. Counter values are updated by adding the\nrespective transition labels. A configuration in this system consists of a\nstate and k counter values. Importantly, the counters are never allowed to take\nnegative values. The coverability problem asks whether one can traverse the\nk-VASS from the initial configuration to a configuration with at least the\ncounter values of the target.\n  In a well-established line of work on k-VASS, coverability in 2-VASS is\nalready PSPACE-hard when the integer updates are encoded in binary. This lower\nbound limits the practicality of applications, so it is natural to focus on\nrestrictions. In this paper we initiate the study of 2-VASS with one unary\ncounter. Here, one counter receives binary encoded updates and the other\nreceives unary encoded updates. Our main result is that coverability in 2-VASS\nwith one unary counter is in NP. This improves upon the inherited\nstate-of-the-art PSPACE upper bound. Our main technical contribution is that\none only needs to consider runs in a certain compressed linear form.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.13543v1"
    },
    {
        "title": "Quotient Complexities of Atoms of Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Hellis Tamm"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  An atom of a regular language L with n (left) quotients is a non-empty\nintersection of uncomplemented or complemented quotients of L, where each of\nthe n quotients appears in a term of the intersection. The quotient complexity\nof L, which is the same as the state complexity of L, is the number of\nquotients of L. We prove that, for any language L with quotient complexity n,\nthe quotient complexity of any atom of L with r complemented quotients has an\nupper bound of 2^n-1 if r=0 or r=n, and 1+\\sum_{k=1}^{r} \\sum_{h=k+1}^{k+n-r}\nC_{h}^{n} \\cdot C_{k}^{h} otherwise, where C_j^i is the binomial coefficient.\nFor each n\\ge 1, we exhibit a language whose atoms meet these bounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.0295v2"
    },
    {
        "title": "An Entertaining Example of Using the Concepts of Context-Free Grammar\n  and Pushdown Automation",
        "authors": [
            "Krasimir Yordzhev"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  A formal-linguistic approach for solving an entertaining task is made in this\npaper. The well-known task of the Hanoi towers is discussed in relation to some\nconcepts of discrete mathematics. A context-free grammar which generate an\nalgorithm for solving this task is described. A deterministic pushdown\nautomation which in its work imitates the work of monks in solving the task of\nthe Hanoi towers is built.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.1095v1"
    },
    {
        "title": "On the Properties of Language Classes Defined by Bounded Reaction\n  Automata",
        "authors": [
            "Fumiya Okubo",
            "Satoshi Kobayashi",
            "Takashi Yokomori"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Reaction automata are a formal model that has been introduced to investigate\nthe computing powers of interactive behaviors of biochemical reactions([14]).\nReaction automata are language acceptors with multiset rewriting mechanism\nwhose basic frameworks are based on reaction systems introduced in [4]. In this\npaper we continue the investigation of reaction automata with a focus on the\nformal language theoretic properties of subclasses of reaction automata, called\nlinearbounded reaction automata (LRAs) and exponentially-bounded reaction\nautomata (ERAs). Besides LRAs, we newly introduce an extended model (denoted by\nlambda-LRAs) by allowing lambda-moves in the accepting process of reaction, and\ninvestigate the closure properties of language classes accepted by both LRAs\nand lambda-LRAs. Further, we establish new relationships of language classes\naccepted by LRAs and by ERAs with the Chomsky hierarchy. The main results\ninclude the following : (i) the class of languages accepted by lambda-LRAs\nforms an AFL with additional closure properties, (ii) any recursively\nenumerable language can be expressed as a homomorphic image of a language\naccepted by an LRA, (iii) the class of languages accepted by ERAs coincides\nwith the class of context-sensitive languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.3082v1"
    },
    {
        "title": "A Perfect Model for Bounded Verification",
        "authors": [
            "Javier Esparza",
            "Pierre Ganty",
            "Rupak Majumdar"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  A class of languages C is perfect if it is closed under Boolean operations\nand the emptiness problem is decidable. Perfect language classes are the basis\nfor the automata-theoretic approach to model checking: a system is correct if\nthe language generated by the system is disjoint from the language of bad\ntraces. Regular languages are perfect, but because the disjointness problem for\nCFLs is undecidable, no class containing the CFLs can be perfect.\n  In practice, verification problems for language classes that are not perfect\nare often under-approximated by checking if the property holds for all\nbehaviors of the system belonging to a fixed subset. A general way to specify a\nsubset of behaviors is by using bounded languages (languages of the form w1*\n... wk* for fixed words w1,...,wk). A class of languages C is perfect modulo\nbounded languages if it is closed under Boolean operations relative to every\nbounded language, and if the emptiness problem is decidable relative to every\nbounded language.\n  We consider finding perfect classes of languages modulo bounded languages. We\nshow that the class of languages accepted by multi-head pushdown automata are\nperfect modulo bounded languages, and characterize the complexities of decision\nproblems. We also show that bounded languages form a maximal class for which\nperfection is obtained. We show that computations of several known models of\nsystems, such as recursive multi-threaded programs, recursive counter machines,\nand communicating finite-state machines can be encoded as multi-head pushdown\nautomata, giving uniform and optimal underapproximation algorithms modulo\nbounded languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.3194v1"
    },
    {
        "title": "Strictness of the Collapsible Pushdown Hierarchy",
        "authors": [
            "Alexander Kartzow",
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We present a pumping lemma for each level of the collapsible pushdown graph\nhierarchy in analogy to the second author's pumping lemma for higher-order\npushdown graphs (without collapse). Using this lemma, we give the first known\nexamples that separate the levels of the collapsible pushdown graph hierarchy\nand of the collapsible pushdown tree hierarchy, i.e., the hierarchy of trees\ngenerated by higher-order recursion schemes. This confirms the open conjecture\nthat higher orders allow one to generate more graphs and more trees.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.3250v2"
    },
    {
        "title": "Large Aperiodic Semigroups",
        "authors": [
            "Janusz Brzozowski",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The syntactic complexity of a regular language is the size of its syntactic\nsemigroup. This semigroup is isomorphic to the transition semigroup of the\nminimal deterministic finite automaton accepting the language, that is, to the\nsemigroup generated by transformations induced by non-empty words on the set of\nstates of the automaton. In this paper we search for the largest syntactic\nsemigroup of a star-free language having $n$ left quotients; equivalently, we\nlook for the largest transition semigroup of an aperiodic finite automaton with\n$n$ states.\n  We introduce two new aperiodic transition semigroups. The first is generated\nby transformations that change only one state; we call such transformations and\nresulting semigroups unitary. In particular, we study complete unitary\nsemigroups which have a special structure, and we show that each maximal\nunitary semigroup is complete. For $n \\ge 4$ there exists a complete unitary\nsemigroup that is larger than any aperiodic semigroup known to date.\n  We then present even larger aperiodic semigroups, generated by\ntransformations that map a non-empty subset of states to a single state; we\ncall such transformations and semigroups semiconstant. In particular, we\nexamine semiconstant tree semigroups which have a structure based on full\nbinary trees. The semiconstant tree semigroups are at present the best\ncandidates for largest aperiodic semigroups.\n  We also prove that $2^n-1$ is an upper bound on the state complexity of\nreversal of star-free languages, and resolve an open problem about a special\ncase of state complexity of concatenation of star-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.0157v2"
    },
    {
        "title": "Tight Bounds for Active Self-Assembly Using an Insertion Primitive",
        "authors": [
            "Benjamin Hescott",
            "Caleb Malchik",
            "Andrew Winslow"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We prove two tight bounds on the behavior of a model of self-assembling\nparticles introduced by Dabby and Chen (SODA 2013), called insertion systems,\nwhere monomers insert themselves into the middle of a growing linear polymer.\nFirst, we prove that the expressive power of these systems is equal to\ncontext-free grammars, answering a question posed by Dabby and Chen. Second, we\nprove that systems of $k$ monomer types can deterministically construct\npolymers of length $n = 2^{\\Theta(k^{3/2})}$ in $O(\\log^{5/3}(n))$ expected\ntime, and that this is optimal in both the number of monomer types and expected\ntime.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.0359v5"
    },
    {
        "title": "Testing for Synchronization",
        "authors": [
            "Mikhail V. Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the first problem that appears in any application of\nsynchronizing automata, namely, the problem of deciding whether or not a given\n$n$-state $k$-letter automaton is synchronizing. First we generalize results\nfrom \\cite{RandSynch},\\cite{On2Problems} for the case of strongly connected\npartial automata. Specifically, for $k>1$ we show that an automaton is\nsynchronizing with probability $1-O(\\frac{1}{n^{0.5k}})$ and present an\nalgorithm with linear in $n$ expected time, while the best known algorithm is\nquadratic on each instance. This results are interesting due to their\napplications in synchronization of finite state information sources. After that\nwe consider the synchronization of reachable partial automata that has\napplication for splicing systems in computational biology. For this case we\nprove that the problem of testing a given automaton for synchronization is\nNP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.2553v4"
    },
    {
        "title": "Separation Property for wB- and wS-regular Languages",
        "authors": [
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we show that {\\omega}B- and {\\omega}S-regular languages satisfy\nthe following separation-type theorem If L1,L2 are disjoint languages of\n{\\omega}-words both recognised by {\\omega}B- (resp. {\\omega}S)-automata then\nthere exists an {\\omega}-regular language Lsep that contains L1, and whose\ncomplement contains L2. In particular, if a language and its complement are\nrecognised by {\\omega}B- (resp. {\\omega}S)-automata then the language is\n{\\omega}-regular. The result is especially interesting because, as shown by\nBoja\\'nczyk and Colcombet, {\\omega}B-regular languages are complements of\n{\\omega}S-regular languages. Therefore, the above theorem shows that these are\ntwo mutually dual classes that both have the separation property. Usually (e.g.\nin descriptive set theory or recursion theory) exactly one class from a pair C,\nCc has the separation property. The proof technique reduces the separation\nproperty for {\\omega}-word languages to profinite languages using Ramsey's\ntheorem and topological methods. After that reduction, the analysis of the\nseparation property in the profinite monoid is relatively simple. The whole\nconstruction is technically not complicated, moreover it seems to be quite\nextensible. The paper uses a framework for the analysis of B- and S-regular\nlanguages in the context of the profinite monoid that was proposed by\nToru\\'nczyk.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.3214v2"
    },
    {
        "title": "Unambiguous Buchi is weak",
        "authors": [
            "Henryk Michalewski",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A non-deterministic automaton running on infinite trees is unambiguous if it\nhas at most one accepting run on every tree. The class of languages\nrecognisable by unambiguous tree automata is still not well-understood. In\nparticular, decidability of the problem whether a given language is\nrecognisable by some unambiguous automaton is open. Moreover, there are no\nknown upper bounds on the descriptive complexity of unambiguous languages among\nall regular tree languages.\n  In this paper we show the following complexity collapse: if a\nnon-deterministic parity tree automaton $A$ is unambiguous and its priorities\nare between $i$ and $2n$ then the language recognised by $A$ is in the class\n$Comp(i+1,2n)$. A particular case of this theorem is for $i=n=1$: if $A$ is an\nunambiguous Buchi tree automaton then $L(A)$ is recognisable by a weak\nalternating automaton (or equivalently definable in weak MSO). The main\nmotivation for this result is a theorem by Finkel and Simonnet stating that\nevery unambiguous Buchi automaton recognises a Borel language.\n  The assumptions of the presented theorem are syntactic (we require one\nautomaton to be both unambiguous and of particular parity index). However, to\nthe authors' best knowledge this is the first theorem showing a collapse of the\nparity index that exploits the fact that a given automaton is unambiguous.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.4025v3"
    },
    {
        "title": "Continuous Speech Recognition Based on Deterministic Finite Automata\n  Machine using Utterance and Pitch Verification",
        "authors": [
            "M. Tharun Prasath"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper introduces a set of acoustic modeling techniques for utterance\nverification (UV) based continuous speech recognition (CSR). Utterance\nverification in this work implies the ability to determine when portions of a\nhypothesized word string correspond to incorrectly decoded vocabulary words or\nout-of-vocabulary words that may appear in an utterance. This capability is\nimplemented here as a likelihood ratio (LR). There are two UV techniques that\nare presented here. The first is voice verification along with the vocabulary\ntesting, at the same time the parameters for UV models are generated based on\nthe optimization criterion which is directly related to the LR measure. The\nsecond technique is a pitch recognition based on weighted finite-state\ntransducers. These transducers provide a common and natural representation for\nmajor components of speech recognition systems, including hidden Markov models\n(HMMs), context-dependency models, pronunciation dictionaries, statistical\ngrammars, and word or phone lattices. The finite state machine processes the\nacoustic parameters of UV models. The results of an experimental study\npresented in the paper shows that LR based parameter estimation results in a\nsignificant improvement in UV performance for this task. The study also found\nthat the use of the LR based weighted finite-state transducers along with the\nUV, can provide as much as an 11% improvement in UV performance when compared\nto existing UV procedures. Finally, it was also found that the performance of\nthe finite state machine was highly dependent on the use of the LR criterion in\ntraining acoustic models. Several observations are made in the paper concerning\nthe formation of confidence measures for UV and the interaction of these\ntechniques with statistical language models.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.5382v1"
    },
    {
        "title": "An Efficient Algorithm for the Equation Tree Automaton via the\n  $k$-C-Continuations",
        "authors": [
            "Ludovic Mignot",
            "Nadia Ouali Sebti",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Champarnaud and Ziadi, and Khorsi et al. show how to compute the equation\nautomaton of word regular expression $E$ via the $k$-C-Continuations.\n  Kuske and Meinecke extend the computation of the equation automaton to a\nregular tree expression $E$ over a ranked alphabet $\\Sigma$ and produce a\n$O(R\\cdot|E|^2)$ time and space complexity algorithm, where $R$ is the maximal\nrank of a symbol occurring in $\\Sigma$ and $|E|$ is the size of $E$. In this\npaper, we give a full description of the algorithm based on the acyclic\nminimization of Revuz. Our algorithm, which is performed in an $O(|Q|\\cdot|E|)$\ntime and space complexity, where $|Q|$ is the number of states of the produced\nautomaton, is more efficient than the one obtained by Kuske and Meinecke.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.5951v1"
    },
    {
        "title": "Zero-Reachability in Probabilistic Multi-Counter Automata",
        "authors": [
            "Tomáš Brázdil",
            "Stefan Kiefer",
            "Antonín Kučera",
            "Petr Novotný",
            "Joost-Pieter Katoen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the qualitative and quantitative zero-reachability problem in\nprobabilistic multi-counter systems. We identify the undecidable variants of\nthe problems, and then we concentrate on the remaining two cases. In the first\ncase, when we are interested in the probability of all runs that visit zero in\nsome counter, we show that the qualitative zero-reachability is decidable in\ntime which is polynomial in the size of a given pMC and doubly exponential in\nthe number of counters. Further, we show that the probability of all\nzero-reaching runs can be effectively approximated up to an arbitrarily small\ngiven error epsilon > 0 in time which is polynomial in log(epsilon),\nexponential in the size of a given pMC, and doubly exponential in the number of\ncounters. In the second case, we are interested in the probability of all runs\nthat visit zero in some counter different from the last counter. Here we show\nthat the qualitative zero-reachability is decidable and SquareRootSum-hard, and\nthe probability of all zero-reaching runs can be effectively approximated up to\nan arbitrarily small given error epsilon > 0 (these result applies to pMC\nsatisfying a suitable technical condition that can be verified in polynomial\ntime). The proof techniques invented in the second case allow to construct\ncounterexamples for some classical results about ergodicity in stochastic Petri\nnets.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.6840v1"
    },
    {
        "title": "On the Disambiguation of Weighted Automata",
        "authors": [
            "Mehryar Mohri",
            "Michael D. Riley"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present a disambiguation algorithm for weighted automata. The algorithm\nadmits two main stages: a pre-disambiguation stage followed by a transition\nremoval stage. We give a detailed description of the algorithm and the proof of\nits correctness. The algorithm is not applicable to all weighted automata but\nwe prove sufficient conditions for its applicability in the case of the\ntropical semiring by introducing the *weak twins property*. In particular, the\nalgorithm can be used with all acyclic weighted automata, relevant to\napplications. While disambiguation can sometimes be achieved using\ndeterminization, our disambiguation algorithm in some cases can return a result\nthat is exponentially smaller than any equivalent deterministic automaton. We\nalso present some empirical evidence of the space benefits of disambiguation\nover determinization in speech recognition and machine translation\napplications.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.0500v1"
    },
    {
        "title": "Simultaneous Finite Automata: An Efficient Data-Parallel Model for\n  Regular Expression Matching",
        "authors": [
            "Ryoma Sin'ya",
            "Kiminori Matsuzaki",
            "Masataka Sassa"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Automata play important roles in wide area of computing and the growth of\nmulticores calls for their efficient parallel implementation. Though it is\nknown in theory that we can perform the computation of a finite automaton in\nparallel by simulating transitions, its implementation has a large overhead due\nto the simulation. In this paper we propose a new automaton called simultaneous\nfinite automaton (SFA) for efficient parallel computation of an automaton. The\nkey idea is to extend an automaton so that it involves the simulation of\ntransitions. Since an SFA itself has a good property of parallelism, we can\ndevelop easily a parallel implementation without overheads. We have implemented\na regular expression matcher based on SFA, and it has achieved over 10-times\nspeedups on an environment with dual hexa-core CPUs in a typical case.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.0562v1"
    },
    {
        "title": "On state complexity of unions of binary factor-free languages",
        "authors": [
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  It has been conjectured in 2011 by Brzozowski et al. that if $K$ and $L$ are\nfactor-free regular languages over a binary alphabet having state complexity\n$m$ and $n$, resp, then the state complexity of $K\\cup L$ is at most\n$mn-(m+n)+3-\\min\\{m,n\\}$.\n  We disprove this conjecture by giving a lower bound of\n$mn-(m+n)-2-\\lfloor\\frac{\\min\\{m,n\\}-2}{2}\\rfloor$, which exceeds the\nconjectured bound whenever $\\min\\{m,n\\}\\geq 10$.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.1107v1"
    },
    {
        "title": "Graph Spectral Properties of Deterministic Finite Automata",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We prove that a minimal automaton has a minimal adjacency matrix rank and a\nminimal adjacency matrix nullity using equitable partition (from graph spectra\ntheory) and Nerode partition (from automata theory). This result naturally\nintroduces the notion of matrix rank into a regular language L, the minimal\nadjacency matrix rank of a deterministic automaton that recognises L. We then\ndefine and focus on rank-one languages: the class of languages for which the\nrank of minimal automaton is one. We also define the expanded canonical\nautomaton of a rank-one language.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.2553v1"
    },
    {
        "title": "Interprocedural Reachability for Flat Integer Programs",
        "authors": [
            "Pierre Ganty",
            "Radu Iosif"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study programs with integer data, procedure calls and arbitrary call\ngraphs. We show that, whenever the guards and updates are given by octagonal\nrelations, the reachability problem along control flow paths within some\nlanguage w1* ... wd* over program statements is decidable in Nexptime. To\nachieve this upper bound, we combine a program transformation into the same\nclass of programs but without procedures, with an Np-completeness result for\nthe reachability problem of procedure-less programs. Besides the program, the\nexpression w1* ... wd* is also mapped onto an expression of a similar form but\nthis time over the transformed program statements. Several arguments involving\ncontext-free grammars and their generative process enable us to give tight\nbounds on the size of the resulting expression. The currently existing gap\nbetween Np-hard and Nexptime can be closed to Np-complete when a certain\nparameter of the analysis is assumed to be constant.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.3069v3"
    },
    {
        "title": "Complexity of checking whether two automata are synchronized by the same\n  language",
        "authors": [
            "Marina Maslennikova"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A deterministic finite automaton is said to be synchronizing if it has a\nreset word, i.e. a word that brings all states of the automaton to a particular\none. We prove that it is a PSPACE-complete problem to check whether the\nlanguage of reset words for a given automaton coincides with the language of\nreset words for some particular automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.3576v1"
    },
    {
        "title": "Derivatives of Parsing Expression Grammars",
        "authors": [
            "Aaron Moss"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper introduces a new derivative parsing algorithm for recognition of\nparsing expression grammars. Derivative parsing is shown to have a polynomial\nworst-case time bound, an improvement on the exponential bound of the recursive\ndescent algorithm. This work also introduces asymptotic analysis based on\ninputs with a constant bound on both grammar nesting depth and number of\nbacktracking choices; derivative and recursive descent parsing are shown to run\nin linear time and constant space on this useful class of inputs, with both the\ntheoretical bounds and the reasonability of the input class validated\nempirically. This common-case constant memory usage of derivative parsing is an\nimprovement on the linear space required by the packrat algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.4841v2"
    },
    {
        "title": "Proceedings 14th International Conference on Automata and Formal\n  Languages",
        "authors": [
            "Zoltán Ésik",
            "Zoltán Fülöp"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The 14th International Conference Automata and Formal Languages (AFL 2014)\nwas held in Szeged, Hungary, from the 27th to the 29th of May, 2014. The\nconference was organized by the Department of Foundations of Computer Science\nof the University of Szeged. Topics of interest covered the theory and\napplications of automata and formal languages and related areas.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5272v1"
    },
    {
        "title": "On Varieties of Automata Enriched with an Algebraic Structure (Extended\n  Abstract)",
        "authors": [
            "Ondřej Klíma"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Eilenberg correspondence, based on the concept of syntactic monoids, relates\nvarieties of regular languages with pseudovarieties of finite monoids. Various\nmodifications of this correspondence related more general classes of regular\nlanguages with classes of more complex algebraic objects. Such generalized\nvarieties also have natural counterparts formed by classes of finite automata\nequipped with a certain additional algebraic structure. In this survey, we\noverview several variants of such varieties of enriched automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5595v1"
    },
    {
        "title": "Decision Problems for Deterministic Pushdown Automata on Infinite Words",
        "authors": [
            "Christof Löding"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The article surveys some decidability results for DPDAs on infinite words\n(omega-DPDA). We summarize some recent results on the decidability of the\nregularity and the equivalence problem for the class of weak omega-DPDAs.\nFurthermore, we present some new results on the parity index problem for\nomega-DPDAs. For the specification of a parity condition, the states of the\nomega-DPDA are assigned priorities (natural numbers), and a run is accepting if\nthe highest priority that appears infinitely often during a run is even. The\nbasic simplification question asks whether one can determine the minimal number\nof priorities that are needed to accept the language of a given omega-DPDA. We\nprovide some decidability results on variations of this question for some\nclasses of omega-DPDAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5596v1"
    },
    {
        "title": "Equivalence Problems for Tree Transducers: A Brief Survey",
        "authors": [
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The decidability of equivalence for three important classes of tree\ntransducers is discussed. Each class can be obtained as a natural restriction\nof deterministic macro tree transducers (MTTs): (1) no context parameters,\ni.e., top-down tree transducers, (2) linear size increase, i.e., MSO definable\ntree transducers, and (3) monadic input and output ranked alphabets. For the\nfull class of MTTs, decidability of equivalence remains a long-standing open\nproblem.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5597v1"
    },
    {
        "title": "Grammars with two-sided contexts",
        "authors": [
            "Mikhail Barash",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In a recent paper (M. Barash, A. Okhotin, \"Defining contexts in context-free\ngrammars\", LATA 2012), the authors introduced an extension of the context-free\ngrammars equipped with an operator for referring to the left context of the\nsubstring being defined. This paper proposes a more general model, in which\ncontext specifications may be two-sided, that is, both the left and the right\ncontexts can be specified by the corresponding operators. The paper gives the\ndefinitions and establishes the basic theory of such grammars, leading to a\nnormal form and a parsing algorithm working in time O(n^4), where n is the\nlength of the input string.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5598v1"
    },
    {
        "title": "Analyzing Catastrophic Backtracking Behavior in Practical Regular\n  Expression Matching",
        "authors": [
            "Martin Berglund",
            "Frank Drewes",
            "Brink van der Merwe"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We develop a formal perspective on how regular expression matching works in\nJava, a popular representative of the category of regex-directed matching\nengines. In particular, we define an automata model which captures all the\naspects needed to study such matching engines in a formal way. Based on this,\nwe propose two types of static analysis, which take a regular expression and\ntell whether there exists a family of strings which makes Java-style matching\nrun in exponential time.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5599v1"
    },
    {
        "title": "Measuring Communication in Parallel Communicating Finite Automata",
        "authors": [
            "Henning Bordihn",
            "Martin Kutrib",
            "Andreas Malcher"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Systems of deterministic finite automata communicating by sending their\nstates upon request are investigated, when the amount of communication is\nrestricted. The computational power and decidability properties are studied for\nthe case of returning centralized systems, when the number of necessary\ncommunications during the computations of the system is bounded by a function\ndepending on the length of the input. It is proved that an infinite hierarchy\nof language families exists, depending on the number of messages sent during\ntheir most economical recognitions. Moreover, several properties are shown to\nbe not semi-decidable for the systems under consideration.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5600v1"
    },
    {
        "title": "Simplifying Nondeterministic Finite Cover Automata",
        "authors": [
            "Cezar Câmpeanu"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The concept of Deterministic Finite Cover Automata (DFCA) was introduced at\nWIA '98, as a more compact representation than Deterministic Finite Automata\n(DFA) for finite languages. In some cases representing a finite language,\nNondeterministic Finite Automata (NFA) may significantly reduce the number of\nstates used. The combined power of the succinctness of the representation of\nfinite languages using both cover languages and non-determinism has been\nsuggested, but never systematically studied. In the present paper, for\nnondeterministic finite cover automata (NFCA) and l-nondeterministic finite\ncover automaton (l-NFCA), we show that minimization can be as hard as\nminimizing NFAs for regular languages, even in the case of NFCAs using unary\nalphabets. Moreover, we show how we can adapt the methods used to reduce, or\nminimize the size of NFAs/DFCAs/l-DFCAs, for simplifying NFCAs/l-NFCAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5601v1"
    },
    {
        "title": "On Determinism and Unambiguity of Weighted Two-way Automata",
        "authors": [
            "Vincent Carnino",
            "Sylvain Lombardy"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper, we first study the conversion of weighted two-way automata to\none-way automata. We show that this conversion preserves the unambiguity but\ndoes not preserve the determinism. Yet, we prove that the conversion of an\nunambiguous weighted one-way automaton into a two-way automaton leads to a\ndeterministic two-way automaton. As a consequence, we prove that unambiguous\nweighted two-way automata are equivalent to deterministic weighted two-way\nautomata in commutative semirings.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5602v1"
    },
    {
        "title": "Operations on Automata with All States Final",
        "authors": [
            "Kristína Čevorová",
            "Galina Jirásková",
            "Peter Mlynárčik",
            "Matúš Palmovský",
            "Juraj Šebej"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the complexity of basic regular operations on languages represented\nby incomplete deterministic or nondeterministic automata, in which all states\nare final. Such languages are known to be prefix-closed. We get tight bounds on\nboth incomplete and nondeterministic state complexity of complement,\nintersection, union, concatenation, star, and reversal on prefix-closed\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5603v1"
    },
    {
        "title": "Commutative Languages and their Composition by Consensual Methods",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Pierluigi San Pietro"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Commutative languages with the semilinear property (SLIP) can be naturally\nrecognized by real-time NLOG-SPACE multi-counter machines. We show that unions\nand concatenations of such languages can be similarly recognized, relying on --\nand further developing, our recent results on the family of consensually\nregular (CREG) languages. A CREG language is defined by a regular language on\nthe alphabet that includes the terminal alphabet and its marked copy. New\nconditions, for ensuring that the union or concatenation of CREG languages is\nclosed, are presented and applied to the commutative SLIP languages. The paper\ncontributes to the knowledge of the CREG family, and introduces novel\ntechniques for language composition, based on arithmetic congruences that act\nas language signatures. Open problems are listed.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5604v1"
    },
    {
        "title": "Representations of Circular Words",
        "authors": [
            "László Hegedüs",
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this article we give two different ways of representations of circular\nwords. Representations with tuples are intended as a compact notation, while\nrepresentations with trees give a way to easily process all conjugates of a\nword. The latter form can also be used as a graphical representation of\nperiodic properties of finite (in some cases, infinite) words. We also define\niterative representations which can be seen as an encoding utilizing the\nflexible properties of circular words. Every word over the two letter alphabet\ncan be constructed starting from ab by applying the fractional power and the\ncyclic shift operators one after the other, iteratively.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5607v1"
    },
    {
        "title": "More Structural Characterizations of Some Subregular Language Families\n  by Biautomata",
        "authors": [
            "Markus Holzer",
            "Sebastian Jakobi"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study structural restrictions on biautomata such as, e.g., acyclicity,\npermutation-freeness, strongly permutation-freeness, and orderability, to\nmention a few. We compare the obtained language families with those induced by\ndeterministic finite automata with the same property. In some cases, it is\nshown that there is no difference in characterization between deterministic\nfinite automata and biautomata as for the permutation-freeness, but there are\nalso other cases, where it makes a big difference whether one considers\ndeterministic finite automata or biautomata. This is, for instance, the case\nwhen comparing strongly permutation-freeness, which results in the family of\ndefinite language for deterministic finite automata, while biautomata induce\nthe family of finite and co-finite languages. The obtained results nicely fall\ninto the known landscape on classical language families.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5608v1"
    },
    {
        "title": "Boolean Circuit Complexity of Regular Languages",
        "authors": [
            "Maris Valdats"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we define a new descriptional complexity measure for\nDeterministic Finite Automata, BC-complexity, as an alternative to the state\ncomplexity. We prove that for two DFAs with the same number of states\nBC-complexity can differ exponentially. In some cases minimization of DFA can\nlead to an exponential increase in BC-complexity, on the other hand\nBC-complexity of DFAs with a large state space which are obtained by some\nstandard constructions (determinization of NFA, language operations), is\nreasonably small. But our main result is the analogue of the \"Shannon effect\"\nfor finite automata: almost all DFAs with a fixed number of states have\nBC-complexity that is close to the maximum.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5611v1"
    },
    {
        "title": "Distinguishability Operations and Closures on Regular Languages",
        "authors": [
            "Cezar Câmpeanu",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Given a regular language $L$, we study the language of words $\\mathsf{D}(L)$,\nthat distinguish between pairs of different left-quotients of $L$. We\ncharacterize this distinguishability operation, show that its iteration has\nalways a fixed point, and we generalize this result to operations derived from\nclosure operators and Boolean operators. We give an upper bound for the state\ncomplexity of the distinguishability operation, and prove its tightness. We\nshow that the set of minimal words that can be used to distinguish between\ndifferent left-quotients of a language $L$ has at most $n-1$ elements, where\n$n$ is the state complexity of $L$, and we also study the properties of its\niteration. We generalize the results for the languages of words that\ndistinguish between pairs of different right-quotients and two-sided quotients\nof a language $L$.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.0160v3"
    },
    {
        "title": "Statistical Study On The Number Of Injective Linear Finite Transducers",
        "authors": [
            "Ivone Amorim",
            "António Machiavelo",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The notion of linear finite transducer (LFT) plays a crucial role in some\ncryptographic systems. In this paper we present a way to get an approximate\nvalue, by random sampling, for the number of non-equivalent injective LFTs. By\nintroducing a recurrence relation to count canonical LFTs, we show how to\nestimate the percentage of $\\tau$-injective LFTs. Several experimental results\nare presented, which by themselves constitute an important step towards the\nevaluation of the key space of those systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.0169v1"
    },
    {
        "title": "On the Computation of Distances for Probabilistic Context-Free Grammars",
        "authors": [
            "Colin de la Higuera",
            "James Scicluna",
            "Mark-Jan Nederhof"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Probabilistic context-free grammars (PCFGs) are used to define distributions\nover strings, and are powerful modelling tools in a number of areas, including\nnatural language processing, software engineering, model checking,\nbio-informatics, and pattern recognition. A common important question is that\nof comparing the distributions generated or modelled by these grammars: this is\ndone through checking language equivalence and computing distances. Two PCFGs\nare language equivalent if every string has identical probability with both\ngrammars. This also means that the distance (whichever norm is used) is null.\nIt is known that the language equivalence problem is interreducible with that\nof multiple ambiguity for context-free grammars, a long-standing open question.\nIn this work, we prove that computing distances corresponds to solving\nundecidable questions: this is the case for the L1, L2 norm, the variation\ndistance and the Kullback-Leibler divergence. Two more results are less\nnegative: 1. The most probable string can be computed, and, 2. The Chebyshev\ndistance (where the distance between two distributions is the maximum\ndifference of probabilities over all strings) is interreducible with the\nlanguage equivalence problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.1513v1"
    },
    {
        "title": "Checking Whether an Automaton Is Monotonic Is NP-complete",
        "authors": [
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  An automaton is monotonic if its states can be arranged in a linear order\nthat is preserved by the action of every letter. We prove that the problem of\ndeciding whether a given automaton is monotonic is NP-complete. The same result\nis obtained for oriented automata, whose states can be arranged in a cyclic\norder. Moreover, both problems remain hard under the restriction to binary\ninput alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.5068v3"
    },
    {
        "title": "Some Properties of Brzozowski Derivatives of Regular Expressions",
        "authors": [
            "N. Murugesan",
            "O. V. Shanmuga Sundaram"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Brzozowski derivatives of a regular expression are developed for constructing\ndeterministic automata from the given regular expression in the algebraic way.\nIn this paper,some lemmas of the regular expressions are discussed and the\nregular languages of the derivatives are illustrated. Also the generalizations\nof the Brzozowski derivatives are proved as theorems with help of properties\nand known results.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.5902v1"
    },
    {
        "title": "A Characterization for Decidable Separability by Piecewise Testable\n  Languages",
        "authors": [
            "Wojciech Czerwiński",
            "Wim Martens",
            "Lorijn van Rooijen",
            "Marc Zeitoun",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The separability problem for word languages of a class $\\mathcal{C}$ by\nlanguages of a class $\\mathcal{S}$ asks, for two given languages $I$ and $E$\nfrom $\\mathcal{C}$, whether there exists a language $S$ from $\\mathcal{S}$ that\nincludes $I$ and excludes $E$, that is, $I \\subseteq S$ and $S\\cap E =\n\\emptyset$. In this work, we assume some mild closure properties for\n$\\mathcal{C}$ and study for which such classes separability by a piecewise\ntestable language (PTL) is decidable. We characterize these classes in terms of\ndecidability of (two variants of) an unboundedness problem. From this, we\ndeduce that separability by PTL is decidable for a number of language classes,\nsuch as the context-free languages and languages of labeled vector addition\nsystems. Furthermore, it follows that separability by PTL is decidable if and\nonly if one can compute for any language of the class its downward closure wrt.\nthe scattered substring ordering (i.e., if the set of scattered substrings of\nany language of the class is effectively regular).\n  The obtained decidability results contrast some undecidability results. In\nfact, for all (non-regular) language classes that we present as examples with\ndecidable separability, it is undecidable whether a given language is a PTL\nitself.\n  Our characterization involves a result of independent interest, which states\nthat for any kind of languages $I$ and $E$, non-separability by PTL is\nequivalent to the existence of common patterns in $I$ and $E$.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.1042v4"
    },
    {
        "title": "Weighted finite automata with output",
        "authors": [
            "Jelena Ignjatović",
            "Miroslav Ćirić",
            "Zorana Jančić"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In this paper we prove the equivalence of sequential, Mealy-type and\nMoore-type weighted finite automata with output, with respect to various\nsemantics which are defined here.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.2415v1"
    },
    {
        "title": "Finite Automata for the Sub- and Superword Closure of CFLs:\n  Descriptional and Computational Complexity",
        "authors": [
            "Georg Bachmeier",
            "Michael Luttenberger",
            "Maximilian Schlund"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We answer two open questions by (Gruber, Holzer, Kutrib, 2009) on the\nstate-complexity of representing sub- or superword closures of context-free\ngrammars (CFGs): (1) We prove a (tight) upper bound of $2^{\\mathcal{O}(n)}$ on\nthe size of nondeterministic finite automata (NFAs) representing the subword\nclosure of a CFG of size $n$. (2) We present a family of CFGs for which the\nminimal deterministic finite automata representing their subword closure\nmatches the upper-bound of $2^{2^{\\mathcal{O}(n)}}$ following from (1).\nFurthermore, we prove that the inequivalence problem for NFAs representing sub-\nor superword-closed languages is only NP-complete as opposed to PSPACE-complete\nfor general NFAs. Finally, we extend our results into an approximation method\nto attack inequivalence problems for CFGs.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.2737v2"
    },
    {
        "title": "Symbolic Solving of Extended Regular Expression Inequalities",
        "authors": [
            "Matthias Keil",
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper presents a new solution to the containment problem for extended\nregular expressions that extends basic regular expressions with intersection\nand complement operators and consider regular expressions on infinite alphabets\nbased on potentially infinite character sets. Standard approaches deciding the\ncontainment do not take extended operators or character sets into account. The\nalgorithm avoids the translation to an expression-equivalent automaton and\nprovides a purely symbolic term rewriting systems for solving regular\nexpressions inequalities.\n  We give a new symbolic decision procedure for the containment problem based\non Brzozowski's regular expression derivatives and Antimirov's rewriting\napproach to check containment. We generalize Brzozowski's syntactic derivative\noperator to two derivative operators that work with respect to (potentially\ninfinite) representable character sets.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.3227v1"
    },
    {
        "title": "What is known about the Value 1 Problem for Probabilistic Automata?",
        "authors": [
            "Nathanaël Fijalkow"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The value 1 problem is a decision problem for probabilistic automata over\nfinite words: are there words accepted by the automaton with arbitrarily high\nprobability? Although undecidable, this problem attracted a lot of attention\nover the last few years. The aim of this paper is to review and relate the\nresults pertaining to the value 1 problem. In particular, several algorithms\nhave been proposed to partially solve this problem. We show the relations\nbetween them, leading to the following conclusion: the Markov Monoid Algorithm\nis the most correct algorithm known to (partially) solve the value 1 problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.3770v1"
    },
    {
        "title": "On the Synchronizing Probability Function and the Triple Rendezvous Time\n  for Synchronizing Automata",
        "authors": [
            "François Gonze",
            "Raphaël M. Jungers"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Cerny's conjecture is a longstanding open problem in automata theory. We\nstudy two different concepts, which allow to approach it from a new angle. The\nfirst one is the triple rendezvous time, i.e., the length of the shortest word\nmapping three states onto a single one. The second one is the synchronizing\nprobability function of an automaton, a recently introduced tool which\nreinterprets the synchronizing phenomenon as a two-player game, and allows to\nobtain optimal strategies through a Linear Program.\n  Our contribution is twofold. First, by coupling two different novel\napproaches based on the synchronizing probability function and properties of\nlinear programming, we obtain a new upper bound on the triple rendezvous time.\nSecond, by exhibiting a family of counterexamples, we disprove a conjecture on\nthe growth of the synchronizing probability function. We then suggest natural\nfollow-ups towards Cernys conjecture.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.4034v5"
    },
    {
        "title": "Unified Analysis of Collapsible and Ordered Pushdown Automata via Term\n  Rewriting",
        "authors": [
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We model collapsible and ordered pushdown systems with term rewriting, by\nencoding higher-order stacks and multiple stacks into trees. We show a uniform\ninverse preservation of recognizability result for the resulting class of term\nrewriting systems, which is obtained by extending the classic saturation-based\napproach. This result subsumes and unifies similar analyses on collapsible and\nordered pushdown systems. Despite the rich literature on inverse preservation\nof recognizability for term rewrite systems, our result does not seem to follow\nfrom any previous study.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.4065v1"
    },
    {
        "title": "The field of the Reals and the Random Graph are not Finite-Word\n  Ordinal-Automatic",
        "authors": [
            "Alexander Kartzow"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Recently, Schlicht and Stephan lifted the notion of automatic-structures to\nthe notion of (finite-word) ordinal-automatic structures. These are structures\nwhose domain and relations can be represented by automata reading finite words\nwhose shape is some fixed ordinal $\\alpha$. We lift Delhomm\\'e's\nrelative-growth-technique from the automatic and tree-automatic setting to the\nordinal-automatic setting. This result implies that the random graph is not\nordinal-automatic and infinite integral domains are not ordinal-automatic with\nrespect to ordinals below $\\omega_1+\\omega^\\omega$ where $\\omega_1$ is the\nfirst uncountable ordinal.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.5197v1"
    },
    {
        "title": "Minimisation of Multiplicity Tree Automata",
        "authors": [
            "Stefan Kiefer",
            "Ines Marusic",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider the problem of minimising the number of states in a multiplicity\ntree automaton over the field of rational numbers. We give a minimisation\nalgorithm that runs in polynomial time assuming unit-cost arithmetic. We also\nshow that a polynomial bound in the standard Turing model would require a\nbreakthrough in the complexity of polynomial identity testing by proving that\nthe latter problem is logspace equivalent to the decision version of\nminimisation. The developed techniques also improve the state of the art in\nmultiplicity word automata: we give an NC algorithm for minimising multiplicity\nword automata. Finally, we consider the minimal consistency problem: does there\nexist an automaton with $n$ states that is consistent with a given finite\nsample of weight-labelled words or trees? We show that this decision problem is\ncomplete for the existential theory of the rationals, both for words and for\ntrees of a fixed alphabet rank.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.5352v4"
    },
    {
        "title": "Determinization of fuzzy automata by means of the degrees of language\n  inclusion",
        "authors": [
            "Ivana Micić",
            "Zorana Jančić",
            "Jelena Ignjatović",
            "Miroslav Ćirić"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Determinization of fuzzy finite automata is understood here as a procedure of\ntheir conversion into equivalent crisp-deterministic fuzzy automata, which can\nbe viewed as being deterministic with possibly infinitely many states, but with\nfuzzy sets of terminal states. Particularly significant determinization methods\nare those that provide a minimal crisp-deterministic fuzzy automaton equivalent\nto the original fuzzy finite automaton, called canonization methods. One\ncanonization method for fuzzy finite automata, the Brzozowski type\ndeterminization, has been developed recently by Jan\\v{c}i\\'{c} and\n\\'{C}iri\\'{c} in [10]. Here we provide another canonization method for a fuzzy\nfinite automaton $\\cal A=(A,\\sigma, \\delta,\\tau)$ over a complete residuated\nlattice $\\cal L$, based on the degrees of inclusion of the right fuzzy\nlanguages associated with states of $\\cal A$ into the left derivatives of the\nfuzzy language recognized by $\\cal A$. The proposed procedure terminates in a\nfinite number of steps whenever the membership values taken by $\\delta $,\n$\\sigma $ and $\\tau $ generate a finite subsemiring of the semiring reduct of\n$\\cal L$. This procedure is generally faster than the Brzozowski type\ndeterminization, and if the basic operations in the residuated lattice $\\cal L$\ncan be performed in constant time, it has the same computational time as all\nother determinization procedures provided in [8], [11], [12].\n",
        "pdf_link": "http://arxiv.org/pdf/1410.6063v2"
    },
    {
        "title": "Defining and composing big state machines",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A sequence function alternative representation of state machines.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.00507v1"
    },
    {
        "title": "A Transfer Theorem for the Separation Problem",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate two problems for a class C of regular word languages. The\nC-membership problem asks for an algorithm to decide whether an input language\nbelongs to C. The C-separation problem asks for an algorithm that, given as\ninput two regular languages, decides whether there exists a third language in C\ncontaining the first language, while being disjoint from the second. These\nproblems are considered as means to obtain a deep understanding of the class C.\n  It is usual for such classes to be defined by logical formalisms. Logics are\noften built on top of each other, by adding new predicates. A natural\nconstruction is to enrich a logic with the successor relation. In this paper,\nwe obtain simple self-contained proofs of two transfer results: we show that\nfor suitable logically defined classes, the membership, resp. the separation\nproblem for a class enriched with the successor relation reduces to the same\nproblem for the original class.\n  Our reductions work both for languages of finite words and infinite words.\nThe proofs are mostly self-contained, and only require a basic background on\nregular languages. This paper therefore gives new, simple proofs of results\nthat were considered as difficult, such as the decid- ability of the membership\nproblem for the levels 1, 3/2, 2 and 5/2 of the dot-depth hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.00569v1"
    },
    {
        "title": "*-Continuous Kleene $ω$-Algebras",
        "authors": [
            "Zoltán Ésik",
            "Uli Fahrenberg",
            "Axel Legay"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We define and study basic properties of *-continuous Kleene $\\omega$-algebras\nthat involve a *-continuous Kleene algebra with a *-continuous action on a\nsemimodule and an infinite product operation that is also *-continuous. We show\nthat *-continuous Kleene $\\omega$-algebras give rise to iteration\nsemiring-semimodule pairs. We show how our work can be applied to solve certain\nenergy problems for hybrid systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.01118v1"
    },
    {
        "title": "Scanning and Parsing Languages with Ambiguities and Constraints: The\n  Lamb and Fence Algorithms",
        "authors": [
            "Luis Quesada",
            "Fernando Berzal",
            "Francisco J. Cortijo"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Traditional language processing tools constrain language designers to\nspecific kinds of grammars. In contrast, model-based language processing tools\ndecouple language design from language processing. These tools allow the\noccurrence of lexical and syntactic ambiguities in language specifications and\nthe declarative specification of constraints for resolving them. As a result,\nthese techniques require scanners and parsers able to parse context-free\ngrammars, handle ambiguities, and enforce constraints for disambiguation. In\nthis paper, we present Lamb and Fence. Lamb is a scanning algorithm that\nsupports ambiguous token definitions and the specification of custom pattern\nmatchers and constraints. Fence is a chart parsing algorithm that supports\nambiguous context-free grammars and the definition of constraints on\nassociativity, composition, and precedence, as well as custom constraints. Lamb\nand Fence, in conjunction, enable the implementation of the ModelCC model-based\nlanguage processing tool.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.02795v1"
    },
    {
        "title": "Equation $x^iy^jx^k=u^iv^ju^k$ in words",
        "authors": [
            "Jana Hadravová",
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We will prove that the word $a^ib^ja^k$ is periodicity forcing if $j \\geq 3$\nand $i+k \\geq 3$, where $i$ and $k$ are positive integers. Also we will give\nexamples showing that both bounds are optimal.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.03602v1"
    },
    {
        "title": "Root-Weighted Tree Automata and their Applications to Tree Kernels",
        "authors": [
            "Ludovic Mignot",
            "Nadia Ouali-Sebti",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper, we define a new kind of weighted tree automata where the\nweights are only supported by final states. We show that these automata are\nsequentializable and we study their closures under classical regular and\nalgebraic operations. We then use these automata to compute the subtree kernel\nof two finite tree languages in an efficient way. Finally, we present some\nperspectives involving the root-weighted tree automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.03895v1"
    },
    {
        "title": "Complexity of Problems of Commutative Grammars",
        "authors": [
            "Eryk Kopczynski"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider commutative regular and context-free grammars, or, in other\nwords, Parikh images of regular and context-free languages. By using linear\nalgebra and a branching analog of the classic Euler theorem, we show that,\nunder an assumption that the terminal alphabet is fixed, the membership problem\nfor regular grammars (given v in binary and a regular commutative grammar G,\ndoes G generate v?) is P, and that the equivalence problem for context free\ngrammars (do G_1 and G_2 generate the same language?) is in $\\mathrm{\\Pi_2^P}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.04245v3"
    },
    {
        "title": "Transformation From Legal-marking Set to Admissible-marking Set of Petri\n  Nets With Uncontrollable Transitions",
        "authors": [
            "ShouGuang Wang",
            "Dan You",
            "MengChu Zhou",
            "Carla Seatsu"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Linear constraint transformation is an essential step to solve the forbidden\nstate problem in Petri nets that contain uncontrollable transitions. This work\nstudies the equivalent transformation from a legal-marking set to its\nadmissible-marking set given such a net. First, the concepts of an\nescaping-marking set and a transforming marking set are defined. Based on them,\ntwo algorithms are given to compute the admissible-marking set and the\ntransforming marking set, which establish the theoretical foundation for the\nequivalent transformation of linear constraints. Second, the theory about the\nequivalent transformation of a disjunction of linear constraints imposed to\nPetri nets with uncontrollable transitions is established. Third, two rules are\ngiven to decide the priority of transitions for transformation. Finally, the\ntransformation procedure from a given linear constraint to a logic expression\nof linear constraints that can describe its entire admissible-marking set is\nillustrated via two examples.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.04777v1"
    },
    {
        "title": "Regularity Preserving but not Reflecting Encodings",
        "authors": [
            "Jörg Endrullis",
            "Clemens Grabmayer",
            "Dimitri Hendriks"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Encodings, that is, injective functions from words to words, have been\nstudied extensively in several settings. In computability theory the notion of\nencoding is crucial for defining computability on arbitrary domains, as well as\nfor comparing the power of models of computation. In language theory much\nattention has been devoted to regularity preserving functions.\n  A natural question arising in these contexts is: Is there a bijective\nencoding such that its image function preserves regularity of languages, but\nits pre-image function does not? Our main result answers this question in the\naffirmative: For every countable class C of languages there exists a bijective\nencoding f such that for every language L in C its image f[L] is regular.\n  Our construction of such encodings has several noteworthy consequences.\nFirstly, anomalies arise when models of computation are compared with respect\nto a known concept of implementation that is based on encodings which are not\nrequired to be computable: Every countable decision model can be implemented,\nin this sense, by finite-state automata, even via bijective encodings. Hence\ndeterministic finite-state automata would be equally powerful as Turing machine\ndeciders.\n  A second consequence concerns the recognizability of sets of natural numbers\nvia number representations and finite automata. A set of numbers is said to be\nrecognizable with respect to a representation if an automaton accepts the\nlanguage of representations. Our result entails that there is one number\nrepresentation with respect to which every recursive set is recognizable.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.04835v1"
    },
    {
        "title": "$\\mathbb{N}$-algebraicity of zeta functions of sofic-Dyck shifts",
        "authors": [
            "Marie-Pierre Béal",
            "Cǎtǎlin Dima"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We prove that the multivariate zeta function of a sofic-Dyck shift is the\ncommutative series of some visibly pushdown language. As a consequence the zeta\nfunction of a sofic-Dyck shift is the generating function of a visibly pushdown\nlanguage and is thus an $\\mathbb{N}$-algebraic series.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.05843v2"
    },
    {
        "title": "A Canonical Form for Weighted Automata and Applications to Approximate\n  Minimization",
        "authors": [
            "Borja Balle",
            "Prakash Panangaden",
            "Doina Precup"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study the problem of constructing approximations to a weighted automaton.\nWeighted finite automata (WFA) are closely related to the theory of rational\nseries. A rational series is a function from strings to real numbers that can\nbe computed by a finite WFA. Among others, this includes probability\ndistributions generated by hidden Markov models and probabilistic automata. The\nrelationship between rational series and WFA is analogous to the relationship\nbetween regular languages and ordinary automata. Associated with such rational\nseries are infinite matrices called Hankel matrices which play a fundamental\nrole in the theory of minimal WFA. Our contributions are: (1) an effective\nprocedure for computing the singular value decomposition (SVD) of such infinite\nHankel matrices based on their representation in terms of finite WFA; (2) a new\ncanonical form for finite WFA based on this SVD decomposition; and, (3) an\nalgorithm to construct approximate minimizations of a given WFA. The goal of\nour approximate minimization algorithm is to start from a minimal WFA and\nproduce a smaller WFA that is close to the given one in a certain sense. The\ndesired size of the approximating automaton is given as input. We give bounds\ndescribing how well the approximation emulates the behavior of the original\nWFA.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.06841v3"
    },
    {
        "title": "Construction of rational expression from tree automata using a\n  generalization of Arden's Lemma",
        "authors": [
            "Younes Guellouma",
            "Ludovic Mignot",
            "Hadda Cherroun",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Arden's Lemma is a classical result in language theory allowing the\ncomputation of a rational expression denoting the language recognized by a\nfinite string automaton. In this paper we generalize this important lemma to\nthe rational tree languages. Moreover, we propose also a construction of a\nrational tree expression which denotes the accepted tree language of a finite\ntree automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.07686v1"
    },
    {
        "title": "FO2(<,+1,~) on data trees, data tree automata and branching vector\n  addition systems",
        "authors": [
            "Florent Jacquemard",
            "Luc Segoufin",
            "Jerémie Dimino"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A data tree is an unranked ordered tree where each node carries a label from\na finite alphabet and a datum from some infinite domain. We consider the two\nvariable first order logic FO2(<,+1,~) over data trees. Here +1 refers to the\nchild and the next sibling relations while < refers to the descendant and\nfollowing sibling relations. Moreover, ~ is a binary predicate testing data\nequality. We exhibit an automata model, denoted DAD# that is more expressive\nthan FO2(<,+1,~) but such that emptiness of DAD# and satisfiability of\nFO2(<,+1,~) are inter-reducible. This is proved via a model of counter tree\nautomata, denoted EBVASS, that extends Branching Vector Addition Systems with\nStates (BVASS) with extra features for merging counters. We show that, as\ndecision problems, reachability for EBVASS, satisfiability of FO2(<,+1,~) and\nemptiness of DAD# are equivalent.\n",
        "pdf_link": "http://arxiv.org/pdf/1601.01579v2"
    },
    {
        "title": "Piecewise Testable Languages and Nondeterministic Automata",
        "authors": [
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A regular language is $k$-piecewise testable if it is a finite boolean\ncombination of languages of the form $\\Sigma^* a_1 \\Sigma^* \\cdots \\Sigma^* a_n\n\\Sigma^*$, where $a_i\\in\\Sigma$ and $0\\le n \\le k$. Given a DFA $A$ and $k\\ge\n0$, it is an NL-complete problem to decide whether the language $L(A)$ is\npiecewise testable and, for $k\\ge 4$, it is coNP-complete to decide whether the\nlanguage $L(A)$ is $k$-piecewise testable. It is known that the depth of the\nminimal DFA serves as an upper bound on $k$. Namely, if $L(A)$ is piecewise\ntestable, then it is $k$-piecewise testable for $k$ equal to the depth of $A$.\nIn this paper, we show that some form of nondeterminism does not violate this\nupper bound result. Specifically, we define a class of NFAs, called ptNFAs,\nthat recognize piecewise testable languages and show that the depth of a ptNFA\nprovides an (up to exponentially better) upper bound on $k$ than the minimal\nDFA. We provide an application of our result, discuss the relationship between\n$k$-piecewise testability and the depth of NFAs, and study the complexity of\n$k$-piecewise testability for ptNFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.00361v2"
    },
    {
        "title": "Weight Computation of Regular Tree Languages",
        "authors": [
            "Jochen Burghardt"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present a general framework to define an application-dependent weight\nmeasure on terms that subsumes e.g. total simplification orderings, and an O(n\nlog n) algorithm for the simultaneous computation of the minimal weight of a\nterm in the language of each nonterminal of a regular tree grammar, based on\nBarzdins' liquid-flow technique.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.02928v1"
    },
    {
        "title": "A ternary square-free sequence avoiding factors equivalent to $abcacba$",
        "authors": [
            "James D. Currie"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We solve a problem of Petrova, finalizing the classification of letter\npatterns avoidable by ternary square-free words; we show that there is a\nternary square-free word avoiding letter pattern $xyzxzyx$. In fact, we: (1)\ncharacterize all the (two-way) infinite ternary square-free words avoiding\nletter pattern $xyzxzyx$ (2) characterize the lexicographically least (one-way)\ninfinite ternary square-free word avoiding letter pattern $xyzxzyx$ (3) show\nthat the number of ternary square-free words of length $n$ avoiding letter\npattern $xyzxzyx$ grows exponentially with $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.03059v1"
    },
    {
        "title": "Fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata over distributive\n  lattices",
        "authors": [
            "Xiujuan Wei",
            "Yongming Li"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We give a new version of fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata\nover distributive lattices: weights are putting in every leaf node of run trees\nrather than along with edges from every node to its children. Such settings are\ngreat benefit to obtain complement just by taking dual operation and replacing\neach final weight with its complement. We prove that $L$-fuzzy nondeterministic\n$\\mathrm{B\\ddot{u}chi}$ automata have the same expressive power as $L$-fuzzy\nalternating $\\mathrm{B\\ddot{u}chi}$ ones. A direct construction (without\nrelated knowledge about $L$-fuzzy nondeterministic $\\mathrm{B\\ddot{u}chi}$ ones\nsuch as: above equivalence relation and their closure properties) is given to\nshow that the languages recognized by $L$-fuzzy alternating\nco-$\\mathrm{B\\ddot{u}chi}$ automata are also $L$-fuzzy $\\omega$-regular.\nFurthermore, the closure properties and the discussion about decision problems\nfor fuzzy alternating $\\mathrm{B\\ddot{u}chi}$ automata are illustrated in our\npaper.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.04541v1"
    },
    {
        "title": "Operations on Weakly Recognizing Morphisms",
        "authors": [
            "Lukas Fleischer",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Weakly recognizing morphisms from free semigroups onto finite semigroups are\na classical way for defining the class of omega-regular languages, i.e., a set\nof infinite words is weakly recognizable by such a morphism if and only if it\nis accepted by some B\\\"uchi automaton. We consider the descriptional complexity\nof various constructions for weakly recognizing morphisms. This includes the\nconversion from and to B\\\"uchi automata, the conversion into strongly\nrecognizing morphisms, and complementation. For some problems, we are able to\ngive more precise bounds in the case of binary alphabets or simple semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.05376v2"
    },
    {
        "title": "The trace monoids in the queue monoid and in the direct product of two\n  free monoids",
        "authors": [
            "Dietrich Kuske",
            "Olena Prianychnykova"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We prove that a trace monoid embeds into the queue monoid if and only if it\nembeds into the direct product of two free monoids. We also give a decidable\ncharacterization of these trace monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.07217v1"
    },
    {
        "title": "Homing Vector Automata",
        "authors": [
            "Özlem Salehi",
            "A. C. Cem Say",
            "Flavio D'Alessandro"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce homing vector automata, which are finite automata augmented by a\nvector that is multiplied at each step by a matrix determined by the current\ntransition, and have to return the vector to its original setting in order to\naccept the input. The computational power and properties of deterministic,\nnondeterministic, blind, non-blind, real-time and one-way versions of these\nmachines are examined and compared to various related types of automata. A\ngeneralized version of the Stern-Brocot encoding method, suitable for\nrepresenting strings on arbitrary alphabets, is also developed.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.09185v2"
    },
    {
        "title": "Linear Distances between Markov Chains",
        "authors": [
            "Przemysław Daca",
            "Thomas A. Henzinger",
            "Jan Křetínský",
            "Tatjana Petrov"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce a general class of distances (metrics) between Markov chains,\nwhich are based on linear behaviour. This class encompasses distances given\ntopologically (such as the total variation distance or trace distance) as well\nas by temporal logics or automata. We investigate which of the distances can be\napproximated by observing the systems, i.e. by black-box testing or simulation,\nand we provide both negative and positive results.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.00186v2"
    },
    {
        "title": "Derivatives for Enhanced Regular Expressions",
        "authors": [
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Regular languages are closed under a wealth of formal language operators.\nIncorporating such operators in regular expressions leads to concise language\nspecifications, but the transformation of such enhanced regular expressions to\nfinite automata becomes more involved.\n  We present an approach that enables the direct construction of finite\nautomata from regular expressions enhanced with further operators that preserve\nregularity. Our construction is based on an extension of the theory of\nderivatives for regular expressions. To retain the standard results about\nderivatives, we develop a derivability criterion for the compatibility of the\nextra operators with derivatives.\n  Some derivable operators do not preserve regularity. Derivatives provide a\ndecision procedure for the word problem of regular expressions enhanced with\nsuch operators.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.00817v1"
    },
    {
        "title": "The Commutativity Problem of the MapReduce Framework: A Transducer-based\n  Approach",
        "authors": [
            "Yu-Fang Chen",
            "Lei Song",
            "Zhilin Wu"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  MapReduce is a popular programming model for data parallel computation. In\nMapReduce, the reducer produces an output from a list of inputs. Due to the\nscheduling policy of the platform, the inputs may arrive at the reducers in\ndifferent order. The commutativity problem of reducers asks if the output of a\nreducer is independent of the order of its inputs. Although the problem is\nundecidable in general, the MapReduce programs in practice are usually used for\ndata analytics and thus require very simple control flow. By exploiting the\nsimplicity, we propose a programming language for reducers where the\ncommutativity problem is decidable. The main idea of the reducer language is to\nseparate the control and data flow of programs and disallow arithmetic\noperations in the control flow. The decision procedure for the commutativity\nproblem is obtained through a reduction to the equivalence problem of streaming\nnumerical transducers (SNTs), a novel automata model over infinite alphabets\nintroduced in this paper. The design of SNTs is inspired by streaming\ntransducers (Alur and Cerny, POPL 2011). Nevertheless, the two models are\nintrinsically different since the outputs of SNTs are integers while those of\nstreaming transducers are data words. The decidability of the equivalence of\nSNTs is achieved with an involved combinatorial analysis of the evolvement of\nthe values of the integer variables during the runs of SNTs.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.01497v3"
    },
    {
        "title": "Derived-term Automata for Extended Weighted Rational Expressions",
        "authors": [
            "Akim Demaille"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present an algorithm to build an automaton from a rational expression.\nThis approach introduces support for extended weighted expressions. Inspired by\nderived-term based algorithms, its core relies on a different construct,\nrational expansions. We introduce an inductive algorithm to compute the\nexpansion of an expression from which the automaton follows. This algorithm is\nindependent of the size of the alphabet, and actually even supports infinite\nalphabets. It can easily be accommodated to generate deterministic (weighted)\nautomata. These constructs are implemented in Vcsn, a free-software platform\ndedicated to weighted automata and rational expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.01530v1"
    },
    {
        "title": "Schützenberger Products in a Category",
        "authors": [
            "Liang-Ting Chen",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The Sch\\\"utzenberger product of monoids is a key tool for the algebraic\ntreatment of language concatenation. In this paper we generalize the\nSch\\\"utzenberger product to the level of monoids in an algebraic category\n$\\mathscr{D}$, leading to a uniform view of the corresponding constructions for\nmonoids (Sch\\\"utzenberger), ordered monoids (Pin), idempotent semirings\n(Kl\\'ima and Pol\\'ak) and algebras over a field (Reutenauer). In addition,\nassuming that $\\mathscr{D}$ is part of a Stone-type duality, we derive a\ncharacterization of the languages recognized by Sch\\\"utzenberger products.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.01810v1"
    },
    {
        "title": "The complexity of downward closure comparisons",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The downward closure of a language is the set of all (not necessarily\ncontiguous) subwords of its members. It is well-known that the downward closure\nof every language is regular. Moreover, recent results show that downward\nclosures are computable for quite powerful system models.\n  One advantage of abstracting a language by its downward closure is that then\nequivalence and inclusion become decidable. In this work, we study the\ncomplexity of these two problems. More precisely, we consider the following\ndecision problems: Given languages $K$ and $L$ from classes $\\mathcal{C}$ and\n$\\mathcal{D}$, respectively, does the downward closure of $K$ include (equal)\nthat of $L$?\n  These problems are investigated for finite automata, one-counter automata,\ncontext-free grammars, and reversal-bounded counter automata. For each\ncombination, we prove a completeness result either for fixed or for arbitrary\nalphabets. Moreover, for Petri net languages, we show that both problems are\nAckermann-hard and for higher-order pushdown automata of order~$k$, we prove\nhardness for complements of nondeterministic $k$-fold exponential time.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.03149v1"
    },
    {
        "title": "On the Gap Between Separating Words and Separating Their Reversals",
        "authors": [
            "Farzam Ebrahimnejad"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A deterministic finite automaton (DFA) separates two strings $w$ and $x$ if\nit accepts $w$ and rejects $x$. The minimum number of states required for a DFA\nto separate $w$ and $x$ is denoted by $sep(w,x)$. The present paper shows that\nthe difference $|sep(w,x)-sep(w^R,x^R)|$ is unbounded for a binary alphabet;\nhere $w^R$ stands for the mirror image of $w$. This solves an open problem\nstated in [Demaine, Eisenstat, Shallit, Wilson: Remarks on separating words.\nDCFS 2011. LNCS vol. 6808, pp. 147-157.]\n",
        "pdf_link": "http://arxiv.org/pdf/1605.04835v3"
    },
    {
        "title": "Complexity of Prefix-Convex Regular Languages",
        "authors": [
            "Janusz Brzozowski",
            "Corwin Sinnamon"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A language $L$ over an alphabet $\\Sigma$ is prefix-convex if, for any words\n$x,y,z\\in\\Sigma^*$, whenever $x$ and $xyz$ are in $L$, then so is $xy$.\nPrefix-convex languages include right-ideal, prefix-closed, and prefix-free\nlanguages. We study complexity properties of prefix-convex regular languages.\nIn particular, we find the quotient/state complexity of boolean operations,\nproduct (concatenation), star, and reversal, the size of the syntactic\nsemigroup, and the quotient complexity of atoms. For binary operations we use\narguments with different alphabets when appropriate; this leads to higher tight\nupper bounds than those obtained with equal alphabets. We exhibit most complex\nprefix-convex languages that meet the complexity bounds for all the measures\nlisted above.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.06697v3"
    },
    {
        "title": "A Free Energy Foundation of Semantic Similarity in Automata and\n  Languages",
        "authors": [
            "Cewei Cui",
            "Zhe Dang"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper develops a free energy theory from physics including the\nvariational principles for automata and languages and also provides algorithms\nto compute the energy as well as efficient algorithms for estimating the\nnondeterminism in a nondeterministic finite automaton. This theory is then used\nas a foundation to define a semantic similarity metric for automata and\nlanguages. Since automata are a fundamental model for all modern programs while\nlanguages are a fundamental model for the programs' behaviors, we believe that\nthe theory and the metric developed in this paper can be further used for\nreal-word programs as well.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.07224v2"
    },
    {
        "title": "Construction of Non-expandable Non-overlapping Sets of Pictures",
        "authors": [
            "Marcella Anselmo",
            "Dora Giammarresi",
            "Maria Madonia"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The non-overlapping sets of pictures are sets such that no two pictures in\nthe set (properly) overlap. They are the generalization to two dimensions of\nthe cross-bifix-free sets of strings. Non-overlapping sets of pictures are\nnon-expandable when no other picture can be added without violating the\nproperty. We present a construction of non-expandable non-overlapping (NENO)\nsets of pictures and show some examples of application.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.09061v1"
    },
    {
        "title": "Myhill-Nerode Relation for Sequentiable Structures",
        "authors": [
            "Stefan Gerdjikov",
            "Stoyan Mihov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Sequentiable structures are a subclass of monoids that generalise the free\nmonoids and the monoid of non-negative real numbers with addition. In this\npaper we consider functions $f:\\Sigma^*\\rightarrow {\\cal M}$ and define the\nMyhill-Nerode relation for these functions. We prove that a function of finite\nindex, $n$, can be represented with a subsequential transducer with $n$ states.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.02910v1"
    },
    {
        "title": "Simulations and Antichains for Efficient Handling of Finite Automata",
        "authors": [
            "Lukáš Holík"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This thesis is focused on techniques for finite automata and their use in\npractice, with the main emphasis on nondeterministic tree automata. This\nconcerns namely techniques for size reduction and language inclusion testing,\nwhich are two problems that are crucial for many applications of tree automata.\nFor size reduction of tree automata, we adapt the simulation quotient technique\nthat is well established for finite word automata. We give efficient algorithms\nfor computing tree automata simulations and we also introduce a new type of\nrelation that arises from a combination of tree automata downward and upward\nsimulation and that is very well suited for quotienting. The combination\nprinciple is relevant also for word automata. We then generalise the so called\nantichain universality and language inclusion checking technique developed\noriginally for finite word automata for tree automata. Subsequently, we improve\nthe antichain technique for both word and tree automata by combining it with\nthe simulation-based inclusion checking techniques, significantly improving\nefficiency of the antichain method. We then show how the developed reduction\nand inclusion checking methods improve the method of abstract regular tree\nmodel checking, the method that was the original motivation for starting the\nwork on tree automata. Both the reduction and the language inclusion methods\nare based on relatively simple and general principles that can be further\nextended for other types of automata and related formalisms. An example is our\nadaptation of the reduction methods for alternating B\\\"uchi automata, which\nresults in an efficient alternating automata size reduction technique.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.03208v1"
    },
    {
        "title": "Parikh Image of Pushdown Automata",
        "authors": [
            "Pierre Ganty",
            "Elena Gutiérrez"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We compare pushdown automata (PDAs for short) against other representations.\nFirst, we show that there is a family of PDAs over a unary alphabet with $n$\nstates and $p \\geq 2n + 4$ stack symbols that accepts one single long word for\nwhich every equivalent context-free grammar needs $\\Omega(n^2(p-2n-4))$\nvariables. This family shows that the classical algorithm for converting a PDA\nto an equivalent context-free grammar is optimal even when the alphabet is\nunary. Moreover, we observe that language equivalence and Parikh equivalence,\nwhich ignores the ordering between symbols, coincide for this family. We\nconclude that, when assuming this weaker equivalence, the conversion algorithm\nis also optimal. Second, Parikh's theorem motivates the comparison of PDAs\nagainst finite state automata. In particular, the same family of unary PDAs\ngives a lower bound on the number of states of every Parikh-equivalent finite\nstate automaton. Finally, we look into the case of unary deterministic PDAs. We\nshow a new construction converting a unary deterministic PDA into an equivalent\ncontext-free grammar that achieves best known bounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.08315v1"
    },
    {
        "title": "Bidirectional Nested Weighted Automata",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Nested weighted automata (NWA) present a robust and convenient\nautomata-theoretic formalism for quantitative specifications. Previous works\nhave considered NWA that processed input words only in the forward direction.\nIt is natural to allow the automata to process input words backwards as well,\nfor example, to measure the maximal or average time between a response and the\npreceding request. We therefore introduce and study bidirectional NWA that can\nprocess input words in both directions. First, we show that bidirectional NWA\ncan express interesting quantitative properties that are not expressible by\nforward-only NWA. Second, for the fundamental decision problems of emptiness\nand universality, we establish decidability and complexity results for the new\nframework which match the best-known results for the special case of\nforward-only NWA. Thus, for NWA, the increased expressiveness of\nbidirectionality is achieved at no additional computational complexity. This is\nin stark contrast to the unweighted case, where bidirectional finite automata\nare no more expressive but exponentially more succinct than their forward-only\ncounterparts.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.08316v1"
    },
    {
        "title": "Decidable Weighted Expressions with Presburger Combinators",
        "authors": [
            "Emmanuel Filiot",
            "Nicolas Mazzocchi",
            "Jean-François Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper, we investigate the expressive power and the algorithmic\nproperties of weighted expressions, which define functions from finite words to\nintegers. First, we consider a slight extension of an expression formalism,\nintroduced by Chatterjee. et. al. in the context of infinite words, by which to\ncombine values given by unambiguous (max,+)-automata, using Presburger\narithmetic. We show that important decision problems such as emptiness,\nuniversality and comparison are PSpace-c for these expressions. We then\ninvestigate the extension of these expressions with Kleene star. This allows to\niterate an expression over smaller fragments of the input word, and to combine\nthe results by taking their iterated sum. The decision problems turn out to be\nundecidable, but we introduce the decidable and still expressive class of\nsynchronised expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.08855v1"
    },
    {
        "title": "Efficient Online Timed Pattern Matching by Automata-Based Skipping",
        "authors": [
            "Masaki Waga",
            "Ichiro Hasuo",
            "Kohei Suenaga"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The timed pattern matching problem is an actively studied topic because of\nits relevance in monitoring of real-time systems. There one is given a log $w$\nand a specification $\\mathcal{A}$ (given by a timed word and a timed automaton\nin this paper), and one wishes to return the set of intervals for which the log\n$w$, when restricted to the interval, satisfies the specification\n$\\mathcal{A}$. In our previous work we presented an efficient timed pattern\nmatching algorithm: it adopts a skipping mechanism inspired by the classic\nBoyer--Moore (BM) string matching algorithm. In this work we tackle the problem\nof online timed pattern matching, towards embedded applications where it is\nvital to process a vast amount of incoming data in a timely manner.\nSpecifically, we start with the Franek-Jennings-Smyth (FJS) string matching\nalgorithm---a recent variant of the BM algorithm---and extend it to timed\npattern matching. Our experiments indicate the efficiency of our FJS-type\nalgorithm in online and offline timed pattern matching.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.09174v1"
    },
    {
        "title": "On the Synchronization of Circular Semi-Flower Automata",
        "authors": [
            "Shubh N. Singh",
            "Ankit Raj"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Pin proved that every circular automaton with a prime number of states\ncontaining a non-permutation is synchronizing. In this paper, we investigate\nthe synchronization of circular semi-flower automata. We first prove that every\nsemi-flower automaton is a one-cluster automaton. Subsequently, we prove that\nevery semi-flower automaton containing a 1-cycle is synchronizing. Further, we\nprove that every circular semi-flower automaton with an odd number of states\ncontaining a 2-cycle is synchronizing.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.01711v1"
    },
    {
        "title": "Regular Tree Algebras",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a class of algebras that can be used as recognisers for regular\ntree languages. We show that it is the only such class that forms a\npseudo-variety and we prove the existence of syntactic algebras. Finally, we\ngive a more algebraic characterisation of the algebras in our class.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.03559v4"
    },
    {
        "title": "Congruence based proofs of the recognizability theorems for free\n  many-sorted algebras",
        "authors": [
            "Juan Climent Vidal",
            "Enric Cosme Llópez"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We generalize several recognizability theorems for free single-sorted\nalgebras to the field of many-sorted algebras and provide, in a uniform way and\nwithout using neither regular tree grammars nor tree automata, purely algebraic\nproofs of them based on the concept of congruence.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.08217v1"
    },
    {
        "title": "A Parametric Framework for Reversible Pi-Calculi",
        "authors": [
            "Doriana Medic",
            "Claudio Antares Mezzina",
            "Iain Phillips",
            "Nobuko Yoshida"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper presents a study of causality in a reversible, concurrent setting.\nThere exist various notions of causality in pi-calculus, which differ in the\ntreatment of parallel extrusions of the same name. In this paper we present a\nuniform framework for reversible pi-calculi that is parametric with respect to\na data structure that stores information about an extrusion of a name.\nDifferent data structures yield different approaches to the parallel extrusion\nproblem. We map three well-known causal semantics into our framework. We show\nthat the (parametric) reversibility induced by our framework is\ncausally-consistent and prove a causal correspondence between an appropriate\ninstance of the framework and Boreale and Sangiorgi's causal semantics.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.08655v1"
    },
    {
        "title": "Simplified Parsing Expression Derivatives",
        "authors": [
            "Aaron Moss"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper presents a new derivative parsing algorithm for parsing expression\ngrammars; this new algorithm is both simpler and faster than the existing\nparsing expression derivative algorithm presented by Moss. This new algorithm\nimproves on the worst-case space and runtime bounds of the previous algorithm\nby a linear factor, as well as decreasing runtime by about half in practice. A\nproof of correctness for the new algorithm is included in this paper, a result\nnot present in earlier work.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.08893v1"
    },
    {
        "title": "A Framework for Rewriting Families of String Diagrams",
        "authors": [
            "Vladimir Zamdzhiev"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We describe a mathematical framework for equational reasoning about infinite\nfamilies of string diagrams which is amenable to computer automation. The\nframework is based on context-free families of string diagrams which we\nrepresent using context-free graph grammars. We model equations between\ninfinite families of diagrams using rewrite rules between context-free\ngrammars. Our framework represents equational reasoning about concrete string\ndiagrams and context-free families of string diagrams using double-pushout\nrewriting on graphs and context-free graph grammars respectively. We prove that\nour representation is sound by showing that it respects the concrete semantics\nof string diagrammatic reasoning and we show that our framework is appropriate\nfor software implementation by proving the membership problem is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.03814v2"
    },
    {
        "title": "XML Navigation and Transformation by Tree-Walking Automata and\n  Transducers with Visible and Invisible Pebbles",
        "authors": [
            "Joost Engelfriet",
            "Hendrik Jan Hoogeboom",
            "Bart Samwel"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The pebble tree automaton and the pebble tree transducer are enhanced by\nadditionally allowing an unbounded number of \"invisible\" pebbles (as opposed to\nthe usual \"visible\" ones). The resulting pebble tree automata recognize the\nregular tree languages (i.e., can validate all generalized DTD's) and hence can\nfind all matches of MSO definable patterns. Moreover, when viewed as a\nnavigational device, they lead to an XPath-like formalism that has a path\nexpression for every MSO definable binary pattern. The resulting pebble tree\ntransducers can apply arbitrary MSO definable tests to (the observable part of)\ntheir configurations, they (still) have a decidable typechecking problem, and\nthey can model the recursion mechanism of XSLT. The time complexity of the\ntypechecking problem for conjunctive queries that use MSO definable patterns\ncan often be reduced through the use of invisible pebbles.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.05730v1"
    },
    {
        "title": "Computing with P Systems",
        "authors": [
            "Apostolos Syropoulos",
            "Stratos Doumanis",
            "Konstantinos T. Sotiriades"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  P systems are computing conceptual computing devices that are at least as\npowerful as Turing machines. However, until recently it was not known how one\ncan encode any recursive function as a P~system. Here we propose a new encoding\nof recursive as P~systems with graph-like structure, which is the main\ndifference with previous documented attempts. The consequence of this and other\nsuch efforts is that they provide a solid ground for the implementation of real\nprogramming languages in existing hardware.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.08664v1"
    },
    {
        "title": "The Containment Problem for Unambiguous Register Automata",
        "authors": [
            "Antoine Mottet",
            "Karin Quaas"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We investigate the complexity of the containment problem \"Does $L(A)\\subseteq\nL(B)$ hold?\", where $B$ is an unambiguous register automaton and $A$ is an\narbitrary register automaton. We prove that the problem is decidable and give\nupper bounds on the computational complexity in the general case, and when $B$\nis restricted to have a fixed number of registers.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.08985v2"
    },
    {
        "title": "Transfinite Lyndon words",
        "authors": [
            "Olivier Carton",
            "Luc Boasson"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we extend the notion of Lyndon word to transfinite words. We\nprove two main results. We first show that, given a transfinite word, there\nexists a unique factorization in Lyndon words that are densely non-increasing,\na relaxation of the condition used in the case of finite words.\n  In the annex, we prove that the factorization of a rational word has a\nspecial form and that it can be computed from a rational expression describing\nthe word.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.09033v6"
    },
    {
        "title": "On finitely ambiguous Büchi automata",
        "authors": [
            "Christof Löding",
            "Anton Pirogov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Unambiguous B\\\"uchi automata, i.e. B\\\"uchi automata allowing only one\naccepting run per word, are a useful restriction of B\\\"uchi automata that is\nwell-suited for probabilistic model-checking. In this paper we propose a more\npermissive variant, namely finitely ambiguous B\\\"uchi automata, a\ngeneralisation where each word has at most $k$ accepting runs, for some fixed\n$k$. We adapt existing notions and results concerning finite and bounded\nambiguity of finite automata to the setting of $\\omega$-languages and present a\ntranslation from arbitrary nondeterministic B\\\"uchi automata with $n$ states to\nfinitely ambiguous automata with at most $3^n$ states and at most $n$ accepting\nruns per word.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.09415v1"
    },
    {
        "title": "Computing the Width of Non-deterministic Automata",
        "authors": [
            "Denis Kuperberg",
            "Anirban Majumdar"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a measure called width, quantifying the amount of nondeterminism\nin automata. Width generalises the notion of good-for-games (GFG) automata,\nthat correspond to NFAs of width 1, and where an accepting run can be built\non-the-fly on any accepted input. We describe an incremental determinisation\nconstruction on NFAs, which can be more efficient than the full powerset\ndeterminisation, depending on the width of the input NFA. This construction can\nbe generalised to infinite words, and is particularly well-suited to coB\\\"uchi\nautomata. For coB\\\"uchi automata, this procedure can be used to compute either\na deterministic automaton or a GFG one, and it is algorithmically more\nefficient in the last case. We show this fact by proving that checking whether\na coB\\\"uchi automaton is determinisable by pruning is NP-complete. On finite or\ninfinite words, we show that computing the width of an automaton is\nEXPTIME-complete. This implies EXPTIME-completeness for multipebble simulation\ngames on NFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.00483v4"
    },
    {
        "title": "First Order Alternation",
        "authors": [
            "Radu Iosif",
            "Xiao Xu"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce first order alternating automata, a generalization of boolean\nalternating automata, in which transition rules are described by multisorted\nfirst order formulae, with states and internal variables given by uninterpreted\npredicate terms. The model is closed under union, intersection and complement,\nand its emptiness problem is undecidable, even for the simplest data theory of\nequality. To cope with this limitation, we develop an abstraction refinement\nsemi-algorithm based on lazy annotation of the symbolic execution paths with\ninterpolants, obtained by applying (i) quantifier elimination with witness term\ngeneration and (ii) Lyndon interpolation in the quantifier-free data theory\nwith uninterpreted predicate symbols. This provides a method for checking\ninclusion of timed and finite-memory register automata, and emptiness of\nquantified predicate automata, previously used in the verification of\nparameterized concurrent programs, composed of replicated threads, with a\nshared-memory communication model.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.02398v2"
    },
    {
        "title": "Reachability Analysis of Pushdown Systems with an Upper Stack",
        "authors": [
            "Adrien Pommellet",
            "Marcio Diaz",
            "Tayssir Touili"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Pushdown systems (PDSs) are a natural model for sequential programs, but they\ncan fail to accurately represent the way an assembly stack actually operates.\nIndeed, one may want to access the part of the memory that is below the current\nstack or base pointer, hence the need for a model that keeps track of this part\nof the memory.\n  To this end, we introduce pushdown systems with an upper stack (UPDSs), an\nextension of PDSs where symbols popped from the stack are not destroyed but\ninstead remain just above its top, and may be overwritten by later push rules.\nWe prove that the sets of successors post* and predecessors pre* of a regular\nset of configurations of such a system are not always regular, but that post*\nis context-sensitive, so that we can decide whether a single configuration is\nforward reachable or not.\n  In order to under-approximate pre* in a regular fashion, we consider a\nbounded-phase analysis of UPDSs, where a phase is a part of a run during which\neither push or pop rules are forbidden. We then present a method to\nover-approximate post* that relies on regular abstractions of runs of UPDSs.\nFinally, we show how these approximations can be used to detect stack overflows\nand stack pointer manipulations with malicious intent.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.02982v1"
    },
    {
        "title": "The ordinal generated by an ordinal grammar is computable",
        "authors": [
            "Kitti Gelle",
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A prefix grammar is a context-free grammar whose nonterminals generate\nprefix-free languages. A prefix grammar $G$ is an ordinal grammar if the\nlanguage $L(G)$ is well-ordered with respect to the lexicographic ordering. It\nis known that from a finite system of parametric fixed point equations one can\nconstruct an ordinal grammar $G$ such that the lexicographic order of $G$ is\nisomorphic with the least solution of the system, if this solution is\nwell-ordered. In this paper we show that given an ordinal grammar, one can\ncompute (the Cantor normal form of) the order type of the lexicographic order\nof its language, yielding that least solutions of fixed point equation systems\ndefining algebraic ordinals are effectively computable (and thus, their\nisomorphism problem is also decidable).\n",
        "pdf_link": "http://arxiv.org/pdf/1811.03595v2"
    },
    {
        "title": "Symbolic Register Automata",
        "authors": [
            "Loris D'Antoni",
            "Tiago Ferreira",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Symbolic Finite Automata and Register Automata are two orthogonal extensions\nof finite automata motivated by real-world problems where data may have\nunbounded domains. These automata address a demand for a model over large or\ninfinite alphabets, respectively. Both automata models have interesting\napplications and have been successful in their own right. In this paper, we\nintroduce Symbolic Register Automata, a new model that combines features from\nboth symbolic and register automata, with a view on applications that were\npreviously out of reach. We study their properties and provide algorithms for\nemptiness, inclusion and equivalence checking, together with experimental\nresults.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.06968v2"
    },
    {
        "title": "Real-Time Systems Modeling and Analysis",
        "authors": [
            "Lakhan Shiva Kamireddy"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper is a survey of extensions to finite automata theory to model\nreal-time systems as well as systems exhibiting mixed discrete-continuous\nbehavior. Real-time systems maintain a continuous and timely interaction with\nthe environment, often adhering to some timing constraints. Therefore, the\nfinite automata theory is extended to measure real-time values and accept or\nreject runs on a class of automata known as timed-automata, upon satisfying\nsome timed properties. The automata modeling the mixed discrete-continuous\nbehavior of hybrid systems has its continuous-time dynamics described using\nordinary differential equations for the state space and discrete-time dynamics\ndescribing the control decisions. Based on these dynamical system models, we\nlikewise extend the finite automata theory to describe the behavior of hybrid\nsystems using Hybrid Automata. We further study some applications of this class\nof systems, sometimes referred to as Cyber-physical systems and perform a\ncase-study on Peterson's Mutual Exclusion protocol using Uppaal.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.10083v1"
    },
    {
        "title": "A short and elegant proof of a theorem of J.-E. Pin",
        "authors": [
            "Michiel de Bondt"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We give a short proof of a theorem of J.-E. Pin (theorem 1.1 below), which\ncan be found in his thesis. The part of the proof which is my own (not Pin's)\nis a complete replacement of the same part in an earlier version of this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.11660v3"
    },
    {
        "title": "Path category for free - Open morphisms from coalgebras with\n  non-deterministic branching",
        "authors": [
            "Thorsten Wißmann",
            "Jérémy Dubut",
            "Shin-ya Katsumata",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  There are different categorical approaches to variations of transition\nsystems and their bisimulations. One is coalgebra for a functor G, where a\nbisimulation is defined as a span of G-coalgebra homomorphism. Another one is\nin terms of path categories and open morphisms, where a bisimulation is defined\nas a span of open morphisms. This similarity is no coincidence: given a functor\nG, fulfilling certain conditions, we derive a path-category for pointed\nG-coalgebras and lax homomorphisms, such that the open morphisms turn out to be\nprecisely the G-coalgebra homomorphisms. The above construction provides\npath-categories and trace semantics for free for different flavours of\ntransition systems: (1) non-deterministic tree automata (2) regular\nnondeterministic nominal automata (RNNA), an expressive automata notion living\nin nominal sets (3) multisorted transition systems. This last instance relates\nto Lasota's construction, which is in the converse direction.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.12294v2"
    },
    {
        "title": "Causality for General LTL-definable Properties",
        "authors": [
            "Georgiana Caltais",
            "Sophie Linnea Guetlein",
            "Stefan Leue"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we provide a notion of causality for the violation of general\nLinear Temporal Logic (LTL) properties. The current work is a natural extension\nof the previously proposed approach handling causality in the context of\nLTL-definable safety properties. The major difference is that now,\ncounterexamples of general LTL properties are not merely finite traces, but\ninfinite lasso-shaped traces. We analyze such infinite counterexamples and\nidentify the relevant ordered occurrences of causal events, obtained by\nunfolding the looping part of the lasso shaped counterexample sufficiently many\ntimes. The focus is on LTL properties from practical considerations: the\ncurrent results are to be implemented in QuantUM, a tool for causality\nchecking, that exploits explicit state LTL model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.00588v1"
    },
    {
        "title": "Model Learning: A Survey on Foundation, Tools and Applications",
        "authors": [
            "Shahbaz Ali",
            "Hailong Sun",
            "Yongwang Zhao"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The quality and correct functioning of software components embedded in\nelectronic systems are of utmost concern especially for safety and\nmission-critical systems. Model-based testing and formal verification\ntechniques can be employed to enhance the reliability of software systems.\nFormal models form the basis and are prerequisite for the application of these\ntechniques. An emerging and promising model learning technique can complement\ntesting and verification techniques by providing learned models of black box\nsystems fully automatically. This paper surveys one such state of the art\ntechnique called model learning which recently has attracted much attention of\nresearchers especially from the domains of testing and verification. This\nsurvey paper reviews and provides comparison summaries highlighting the merits\nand shortcomings of learning techniques, algorithms, and tools which form the\nbasis of model learning. This paper also surveys the successful applications of\nmodel learning technique in multidisciplinary fields making it promising for\ntesting and verification of realistic systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.01910v1"
    },
    {
        "title": "Separation for dot-depth two",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The dot-depth hierarchy of Brzozowski and Cohen classifies the star-free\nlanguages of finite words. By a theorem of McNaughton and Papert, these are\nalso the first-order definable languages. The dot-depth rose to prominence\nfollowing the work of Thomas, who proved an exact correspondence with the\nquantifier alternation hierarchy of first-order logic: each level in the\ndot-depth hierarchy consists of all languages that can be defined with a\nprescribed number of quantifier blocks. One of the most famous open problems in\nautomata theory is to settle whether the membership problem is decidable for\neach level: is it possible to decide whether an input regular language belongs\nto this level?\n  Despite a significant research effort, membership by itself has only been\nsolved for low levels. A recent breakthrough was achieved by replacing\nmembership with a more general problem: separation. Given two input languages,\none has to decide whether there exists a third language in the investigated\nlevel containing the first language and disjoint from the second. The\nmotivation is that: (1) while more difficult, separation is more rewarding (2)\nit provides a more convenient framework (3) all recent membership algorithms\nare reductions to separation for lower levels.\n  We present a separation algorithm for dot-depth two. While this is our most\nprominent application, our result is more general. We consider a family of\nhierarchies that includes the dot-depth: concatenation hierarchies. They are\nbuilt via a generic construction process. One first chooses an initial class,\nthe basis, which is the lowest level in the hierarchy. Further levels are built\nby applying generic operations. Our main theorem states that for any\nconcatenation hierarchy whose basis is finite, separation is decidable for\nlevel one. In the special case of the dot-depth, this can be lifted to level\ntwo using previously known results.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.03361v5"
    },
    {
        "title": "Regular Expression Search on Compressed Text",
        "authors": [
            "Pierre Ganty",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present an algorithm for searching regular expression matches in\ncompressed text. The algorithm reports the number of matching lines in the\nuncompressed text in time linear in the size of its compressed version. We\ndefine efficient data structures that yield nearly optimal complexity bounds\nand provide a sequential implementation --zearch-- that requires up to 25% less\ntime than the state of the art.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.05252v1"
    },
    {
        "title": "The Power of One-State Turing Machines",
        "authors": [
            "Marzio De Biasi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  At first glance, one-state Turing machines are very weak: the halting problem\nfor them is decidable, and, without memory, they cannot even accept a simple\none element language such as $L = \\{ 1 \\}$ . Nevertheless it has been showed\nthat a one-state Turing machine can accept non regular languages. We extend\nsuch result and prove that they can also recognize non context-free languages,\nso for some tasks they are more powerful than pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.07125v1"
    },
    {
        "title": "Quantum finite automata: survey, status and research directions",
        "authors": [
            "Amandeep Singh Bhatia",
            "Ajay Kumar"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Quantum computing is concerned with computer technology based on the\nprinciples of quantum mechanics, with operations performed at the quantum\nlevel. Quantum computational models make it possible to analyze the resources\nrequired for computations. Quantum automata can be classified thusly: quantum\nfinite automata, quantum sequential machine, quantum pushdown automata, quantum\nTuring machine and orthomodular lattice-valued automata. These models are\nuseful for determining the expressive power and boundaries of various\ncomputational features. In light of the current state of quantum computation\ntheory research, a systematic review of the literature seems timely. This\narticle seeks to provide a comprehensive and systematic analysis of quantum\nfinite automata models, quantum finite automata models with density operators\nand quantum finite automata models with classical states, interactive proof\nsystems, quantum communication complexity and query complexity as described in\nthe literature. The statistics of quantum finite automata related papers are\nshown and open problems are identified for more advanced research. The current\nstatus of quantum automata theory is distributed into various categories. This\nresearch work also highlights the previous research, current status and future\ndirections of quantum automata models.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.07992v1"
    },
    {
        "title": "On the effects of firing memory in the dynamics of conjunctive networks",
        "authors": [
            "Eric Goles",
            "Pedro Montealegre",
            "Martín Ríos Wilson"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Boolean networks are one of the most studied discrete models in the context\nof the study of gene expression. In order to define the dynamics associated to\na Boolean network, there are several \\emph{update schemes} that range from\nparallel or \\emph{synchronous} to \\emph{asynchronous.} However, studying each\npossible dynamics defined by different update schemes might not be efficient.\nIn this context, considering some type of temporal delay in the dynamics of\nBoolean networks emerges as an alternative approach. In this paper, we focus in\nstudying the effect of a particular type of delay called \\emph{firing memory}\nin the dynamics of Boolean networks. Particularly, we focus in symmetric\n(non-directed) conjunctive networks and we show that there exist examples that\nexhibit attractors of non-polynomial period. In addition, we study the\nprediction problem consisting in determinate if some vertex will eventually\nchange its state, given an initial condition. We prove that this problem is\n{\\bf PSPACE}-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.09789v1"
    },
    {
        "title": "Kleene Theorems for Free Choice Nets Labelled with Distributed Alphabets",
        "authors": [
            "Ramchandra Phawade"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We provided (PNSE'2014) expressions for free choice nets having \"distributed\nchoice property\" which makes the nets \"direct product\" representable.\n  In a recent work (PNSE'2016), we gave equivalent syntax for a larger class of\nfree choice nets obtained by dropping distributed choice property.\n  In both these works, the classes of free choice nets were restricted by a\n\"product condition\" on the set of final markings. In this paper we do away with\nthis restriction and give expressions for the resultant classes of nets which\ncorrespond to \"free choice synchronous products and Zielonka automata\". For\nfree choice nets with distributed choice property, we give an alternative\ncharacterization using properties checkable in polynomial time.\n  Free choice nets we consider are 1-bounded, S-coverable, and are labelled\nwith distributed alphabets, where S-components of the associated S-cover\nrespect the given alphabet distribution.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01168v1"
    },
    {
        "title": "On Injectivity of Quantum Finite Automata",
        "authors": [
            "Paul C. Bell",
            "Mika Hirvensalo"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider notions of freeness and ambiguity for the acceptance probability\nof Moore-Crutchfield Measure Once Quantum Finite Automata (MO-QFA). We study\nthe injectivity problem of determining if the acceptance probability function\nof a MO-QFA is injective over all input words, i.e., giving a distinct\nprobability for each input word. We show that the injectivity problem is\nundecidable for 8 state MO-QFA, even when all unitary matrices and the\nprojection matrix are rational and the initial state vector is real algebraic.\nWe also show undecidability of this problem when the initial vector is\nrational, although with a huge increase in the number of states. We utilize\nproperties of quaternions, free rotation groups, representations of tuples of\nrationals as linear sums of radicals and a reduction of the mixed modification\nof Post's correspondence problem, as well as a new result on rational\npolynomial packing functions which may be of independent interest.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01471v2"
    },
    {
        "title": "Static Analysis of Multithreaded Recursive Programs Communicating via\n  Rendez-vous",
        "authors": [
            "Adrien Pommellet",
            "Tayssir Touili"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present in this paper a generic framework for the analysis of\nmulti-threaded programs with recursive procedure calls, synchronisation by\nrendez-vous between parallel threads, and dynamic creation of new threads. To\nthis end, we consider a model called Synchronized Dynamic Pushdown Networks\n(SDPNs) that can be seen as a network of pushdown processes executing\nsynchronized transitions, spawning new pushdown processes, and performing\ninternal pushdown actions. The reachability problem for this model is\nunfortunately undecidable. Therefore, we tackle this problem by introducing an\nabstraction framework based on Kleene algebras in order to compute an\nabstraction of the execution paths between two regular sets of configurations.\nWe combine an automata theoretic saturation procedure with constraint solving\nin a finite domain. We then apply this framework to an iterative abstraction\nrefinement scheme, using multiple abstractions of increasing complexity and\nprecision.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.02834v1"
    },
    {
        "title": "From LTL to Unambiguous Büchi Automata via Disambiguation of\n  Alternating Automata",
        "authors": [
            "Simon Jantsch",
            "David Müller",
            "Christel Baier",
            "Joachim Klein"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper proposes a new algorithm for the generation of unambiguous B\\\"uchi\nautomata (UBA) from LTL formulas. Unlike existing tableau-based LTL-to-UBA\ntranslations, our algorithm deals with very weak alternating automata (VWAA) as\nan intermediate representation. It relies on a new notion of unambiguity for\nVWAA and a disambiguation procedure for VWAA. We introduce optimizations on the\nVWAA level and new LTL simplifications targeted at generating small UBA.\n  We report on an implementation of the construction in our tool duggi and\ndiscuss experimental results that compare the automata sizes and computation\ntimes of duggi with the tableau-based LTL-to-UBA translation of the SPOT tool\nset. Our experiments also cover the analysis of Markov chains under LTL\nspecifications, which is an important application of UBA.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.02887v1"
    },
    {
        "title": "fbSAT: Automatic Inference of Minimal Finite-State Models of Function\n  Blocks Using SAT Solver",
        "authors": [
            "Konstantin Chukharev",
            "Daniil Chivilikhin"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Finite-state models are widely used in software engineering, especially in\ncontrol systems development. Commonly, in control applications such models are\ndeveloped manually, hence, keeping them up-to-date requires extra effort. To\nsimplify the maintenance process, an automatic approach may be used, allowing\nto infer models from behavior examples and temporal properties. As an example\nof a specific control systems development application we focus on inferring\nfinite-state models of function blocks (FBs) defined by the IEC 61499\ninternational standard for distributed automation systems. In this paper we\npropose a method for FB model inference from behavior examples based on\nreduction to Boolean satisfiability problem (SAT). Additionally, we take into\naccount linear temporal properties using counterexample-guided synthesis. We\nalso present the developed tool fbSAT which implements the proposed method, and\nevaluate it in two case studies: inference of a finite-state model of a\nPick-and-Place manipulator, and reconstruction of randomly generated automata.\nIn contrast to existing approaches, the suggested method is more efficient and\nproduces finite-state models minimal both in terms of number of states and\nguard conditions complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.03285v3"
    },
    {
        "title": "On The Structure of Dyck Languages",
        "authors": [
            "Rita Gitik",
            "Eliyahy Rips"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We prove that the closure of the one-sided Dyck language in a free monoid is\na two-sided Dyck language.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.05368v1"
    },
    {
        "title": "Abelian-square factors and binary words",
        "authors": [
            "Salah Triki"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this work, we affirm the conjecture proposed by Gabriele Fici and Filippo\nMignosi at the 10th Conference on Combinatorics on Words.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.05369v1"
    },
    {
        "title": "Visualização e animação de autómatos em Ocsigen Framework",
        "authors": [
            "Rita Macedo",
            "Artur Miguel Dias",
            "António Ravara"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Formal Languages and Automata Theory are important foundational topics in\nComputer Science. Their rigorous and formal characteristics make their learning\nthem demanding. An important support for the assimilation of concepts is the\npossibility of interactively visualizing concrete examples of these\ncomputational models, facilitating understanding them. The tools available are\nneither complete nor fully support the interactive aspect. This project aims at\nthe development of an interactive web tool in Portuguese to help in an assisted\nand intuitive way to understand the concepts and algorithms in question, seeing\nthem work step-by-step, through typical examples preloaded or built by the user\n(an original aspect of our platform). The tool should therefore enable the\ncreation and edition of an automata, as well as execute the relevant classical\nalgorithms such as word acceptance, model conversions, etc. It is also intended\nto visualize not only the process of construction of the automaton, but also\nall the steps of applying the given algorithm. This tool uses the Ocsigen\nFramework because it provides the development of complete and interactive web\ntools written in OCaml, a functional language with a strong type checking\nsystem and therefore perfect for a web page without errors. Ocsigen was also\nchosen because it allows the creation of dynamic pages with a singular\nclient-server system. This article presents the first phase of the development\nof the project. It is already possible to create automata, check the nature of\nits states and verify step-by-step (with undo) the acceptance of a word.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.05384v1"
    },
    {
        "title": "Tagged Deterministic Finite Automata with Lookahead",
        "authors": [
            "Ulya Trofimovich"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper extends the work of Laurikari and Kuklewicz on tagged\ndeterministic finite automata (TDFA) in the context of submatch extraction in\nregular expressions. The main goal of this work is application of TDFA to lexer\ngenerators that optimize for speed of the generated code. I suggest a number of\npractical improvements to Laurikari algorithm; notably, the use of one-symbol\nlookahead, which results in significant reduction of tag variables and\noperations on them. Experimental results confirm that lookahead-aware TDFA are\nconsiderably faster and usually smaller than baseline TDFA; and they are\nreasonably close in speed and size to ordinary DFA used for recognition of\nregular languages. The proposed algorithm can handle repeated submatch and\ntherefore is applicable to full parsing. Furthermore, I examine the problem of\ndisambiguation in the case of leftmost greedy and POSIX policies. I formalize\nPOSIX disambiguation algorithm suggested by Kuklewicz and show that the\nresulting TDFA are as efficient as Laurikari TDFA or TDFA that use leftmost\ngreedy disambiguation. All discussed algorithms are implemented in the open\nsource lexer generator RE2C.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.08837v1"
    },
    {
        "title": "Two-way Parikh Automata",
        "authors": [
            "Emmanuel Filiot",
            "Shibashis Guha",
            "Nicolas Mazzocchi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Parikh automata extend automata with counters whose values can only be tested\nat the end of the computation, with respect to membership into a semi-linear\nset. Parikh automata have found several applications, for instance in\ntransducer theory, as they enjoy decidable emptiness problem. In this paper, we\nstudy two-way Parikh automata. We show that emptiness becomes undecidable in\nthe non-deterministic case. However, it is PSpace-C when the number of visits\nto any input position is bounded and the semi-linear set is given as an\nexistential Presburger formula. We also give tight complexity bounds for the\ninclusion, equivalence and universality problems. Finally, we characterise\nprecisely the complexity of those problems when the semi-linear constraint is\ngiven by an arbitrary Presburger formula.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.09362v1"
    },
    {
        "title": "Minimization of visibly pushdown automata is NP-complete",
        "authors": [
            "Olivier Gauwin",
            "Anca Muscholl",
            "Michael Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that the minimization of visibly pushdown automata is NP-complete.\nThis result is obtained by introducing immersions, that recognize multiple\nlanguages (over a usual, non-visible alphabet) using a common deterministic\ntransition graph, such that each language is associated with an initial state\nand a set of final states. We show that minimizing immersions is NP-complete,\nand reduce this problem to the minimization of visibly pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.09563v3"
    },
    {
        "title": "Single use register automata for data words",
        "authors": [
            "Mikołaj Bojańczyk",
            "Rafał Stefański"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Our starting point are register automata for data words, in the style of\nKaminski and Francez. We study the effects of the single-use restriction, which\nsays that a register is emptied immediately after being used. We show that\nunder the single-use restriction, the theory of automata for data words becomes\nmuch more robust. The main results are: (a) five different machine models are\nequivalent as language acceptors, including one-way and two-way single-use\nregister automata; (b) one can recover some of the algebraic theory of\nlanguages over finite alphabets, including a version of the Krohn-Rhodes\nTheorem; (c) there is also a robust theory of transducers, with four equivalent\nmodels, including two-way single use transducers and a variant of streaming\nstring transducers for data words. These results are in contrast with automata\nfor data words without the single-use restriction, where essentially all models\nare pairwise non-equivalent.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.10504v2"
    },
    {
        "title": "State Identification for Labeled Transition Systems with Inputs and\n  Outputs",
        "authors": [
            "Petra van den Bos",
            "Frits Vaandrager"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  For Finite State Machines (FSMs) a rich testing theory has been developed to\ndiscover aspects of their behavior and ensure their correct functioning.\nAlthough this theory is widely used, e.g., to check conformance of protocol\nimplementations, its applicability is limited by restrictions of the FSM\nframework: the fact that inputs and outputs alternate in an FSM, and outputs\nare fully determined by the previous input and state. Labeled Transition\nSystems with inputs and outputs (LTSs), as studied in ioco testing theory,\nprovide a richer framework for testing component oriented systems, but lack the\nalgorithms for test generation from FSM theory.\n  In this article, we propose an algorithm for the fundamental problem of state\nidentification during testing of LTSs. Our algorithm is a direct generalization\nof the well-known algorithm for computing adaptive distinguishing sequences for\nFSMs proposed by Lee & Yannakakis. Our algorithm has to deal with so-called\ncompatible states, states that cannot be distinguished in case of an\nadversarial system-under-test. Analogous to the result of Lee & Yannakakis, we\nprove that if an (adaptive) test exists that distinguishes all pairs of\nincompatible states of an LTS, our algorithm will find one. In practice, such\nadaptive tests typically do not exist. However, in experiments with an\nimplementation of our algorithm on an industrial benchmark, we find that tests\nproduced by our algorithm still distinguish more than 99% of the incompatible\nstate pairs.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.11034v2"
    },
    {
        "title": "The order type of scattered context-free orderings of rank one is\n  computable",
        "authors": [
            "Kitti Gelle",
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A linear ordering is called context-free if it is the lexicographic ordering\nof some context-free language and is called scattered if it has no dense\nsubordering. Each scattered ordering has an associated ordinal, called its\nrank. It is known that the isomorphism problem of scattered context-free\norderings is undecidable, if one of them has a rank at least two. In this paper\nwe show that it is decidable whether a context-free ordering has rank at most\none, and if so, its order type is effectively computable.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.11573v1"
    },
    {
        "title": "Regular languages, derivatives and finite automata",
        "authors": [
            "Ola Wingbrant"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This report is mostly written for educational purposes. It is meant as a self\ncontained introduction to regular languages, regular expressions, and regular\nexpression matching by using Brzozowski derivatives. As such it is mostly based\non the work by Brzozowski[4] and Owens et al.[12] The language basics material\nhave been inspired by books[2] and web material[16].\n  Chapter 1 introduces the fundamental concepts of formal languages, as well as\nthe idea of string derivatives. In chapter 2 we define the class of regular\nlanguages, and further develops the theory of derivatives for that class. We\nuse derivatives to prove the Myhill-Nerod theorem, the Pumping lemma, and the\nclosure of regular languages under all Boolean connectives. In chapter 3 we\nintroduce regular expressions and regular expression matching. Chapter 4\nconnects the theory of regular languages and derivatives with that of finite\nautomata. Chapter 5 looks at the concept of anchors, and how this can be\nincorporated into a matcher based on derivatives. Chapter 6 discusses\nsubmatching using derivatives with an approach inspired by Laurikari and his\nwork on tagged transitions[11]. This is the part we consider as our main\ncontribution to the field. In the last chapter, chapter 7, we summarize by\ngiving a regular expression matching algorithm using the previously discussed\ntechniques. We also discuss related work by others.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.13577v1"
    },
    {
        "title": "Unambiguous separators for tropical tree automata",
        "authors": [
            "Thomas Colcombet",
            "Sylvain Lombardy"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we show that given a max-plus automaton (over trees, and with\nreal weights) computing a function $f$ and a min-plus automaton (similar)\ncomputing a function $g$ such that $f\\leqslant g$, there exists effectively an\nunambiguous tropical automaton computing $h$ such that $f\\leqslant h\\leqslant\ng$. This generalizes a result of Lombardy and Mairesse of 2006 stating that\nseries which are both max-plus and min-plus rational are unambiguous. This\ngeneralization goes in two directions: trees are considered instead of words,\nand separation is established instead of characterization (separation implies\ncharacterization). The techniques in the two proofs are very different.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.02164v1"
    },
    {
        "title": "Decidability of membership problems for flat rational subsets of\n  $\\mathrm{GL}(2,\\mathbb{Q})$ and singular matrices",
        "authors": [
            "Volker Diekert",
            "Igor Potapov",
            "Pavel Semukhin"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider membership problems for rational subsets of the semigroup of\n$2\\times 2$ matrices over $\\mathbb{Q}$. For a semigroup $M$, the rational\nsubsets $\\mathrm{Rat}(M)$ are defined as the sets accepted by NFAs whose\ntransitions are labeled by elements of $M$. In general, it is undecidable on\ninputs $m\\in M$ and $R\\in \\mathrm{Rat}(M)$ whether $m$ belongs to $R$.\nTherefore, we restrict our attention to the family $\\mathrm{FRat}(M,S)$ of flat\nrational subsets of $M$ over $S$, where $S$ is a subsemigroup of $M$. It\nconsists of finite unions of the form $g_0L_1g_1 \\cdots L_tg_t$, where $L_i\\in\n\\mathrm{Rat}(S)$ and $g_i\\in M$. Assuming that the membership for\n$\\mathrm{Rat}(S)$ is decidable, we prove various results when the membership\nfor $\\mathrm{FRat}(M,S)$ is decidable.\n  If $H$ is a subgroup of a group $G$, then we provide a rather general\ncondition when $\\mathrm{FRat}(G,H)$ is an (effective) relative Boolean algebra.\nThis leads to one of our main results that the emptiness problem for Boolean\ncombinations of sets in\n$\\mathrm{FRat}(\\mathrm{GL}(2,\\mathbb{Q}),\\mathrm{GL}(2,\\mathbb{Z}))$ is\ndecidable. It is possible that this result cannot be pushed any further as\nindicated by the following dichotomy: if $G$ is a finitely generated group such\nthat $\\mathrm{GL}(2,\\mathbb{Z}) < G < \\mathrm{GL}(2,\\mathbb{Q})$, then either\n$G\\cong \\mathrm{GL}(2,\\mathbb{Z})\\times \\mathbb{Z}^k$ or $G$ contains an\nextension of the Baumslag-Solitar group $\\mathrm{BS}(1,q)$ of infinite index.\nIt is open whether the membership for rational subsets is decidable in the\nlatter case. For singular matrices, we will show that the membership problem\nfor $\\mathrm{FRat}(\\mathbb{Q}^{2\\times 2},S)$ is decidable in doubly\nexponential time, where $S$ is the monoid generated by\n$\\mathrm{GL}(2,\\mathbb{Z})\\cup \\{r\\in \\mathbb{Q}\\,\\mid\\,r>1\\} \\cup\n\\{0,\\left(\\begin{smallmatrix}1 & 0\\\\ 0 & 0\\end{smallmatrix}\\right)\\}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.02302v6"
    },
    {
        "title": "Reactive Synthesis with Maximum Realizability of Linear Temporal Logic\n  Specifications",
        "authors": [
            "Rayna Dimitrova",
            "Mahsa Ghasemi",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A challenging problem for autonomous systems is to synthesize a reactive\ncontroller that conforms to a set of given correctness properties. Linear\ntemporal logic (LTL) provides a formal language to specify the desired\nbehavioral properties of systems. In applications in which the specifications\noriginate from various aspects of the system design, or consist of a large set\nof formulas, the overall system specification may be unrealizable. Driven by\nthis fact, we develop an optimization variant of synthesis from LTL formulas,\nwhere the goal is to design a controller that satisfies a set of hard\nspecifications and minimally violates a set of soft specifications. To that\nend, we introduce a value function that, by exploiting the LTL semantics,\nquantifies the level of violation of properties. Inspired by the idea of\nbounded synthesis, we fix a bound on the implementation size and search for an\nimplementation that is optimal with respect to the said value function. We\npropose a novel maximum satisfiability encoding of the search for an optimal\nimplementation (within the given bound on the implementation size). We\niteratively increase the bound on the implementation size until a termination\ncriterion, such as a threshold over the value function, is met.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.02561v1"
    },
    {
        "title": "Parity Games: Another View on Lehtinen's Algorithm",
        "authors": [
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Recently, five quasi-polynomial-time algorithms solving parity games were\nproposed. We elaborate on one of the algorithms, by Lehtinen (2018).\n  Czerwi\\'nski et al. (2019) observe that four of the algorithms can be\nexpressed as constructions of separating automata (of quasi-polynomial size),\nthat is, automata that accept all plays decisively won by one of the players,\nand rejecting all plays decisively won by the other player. The separating\nautomata corresponding to three of the algorithms are deterministic, and it is\nclear that deterministic separating automata can be used to solve parity games.\nThe separating automaton corresponding to the algorithm of Lehtinen is\nnondeterministic, though. While this particular automaton can be used to solve\nparity games, this is not true for every nondeterministic separating automaton.\nAs a first (more conceptual) contribution, we specify when a nondeterministic\nseparating automaton can be used to solve parity games.\n  We also repeat the correctness proof of the Lehtinen's algorithm, using\nseparating automata. In this part, we prove that her construction actually\nleads to a faster algorithm than originally claimed in her paper: its\ncomplexity is $n^{O(\\log n)}$ rather than $n^{O(\\log d \\cdot \\log n)}$ (where\n$n$ is the number of nodes, and $d$ the number of priorities of a considered\nparity game), which is similar to complexities of the other\nquasi-polynomial-time algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.03919v1"
    },
    {
        "title": "Equivalence kernels of sequential functions and sequential observation\n  synthesis",
        "authors": [
            "Paulin Fournier",
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that one can decide if a rational equivalence relation can be given\nas the equivalence kernel of a sequential letter-to-letter transduction. This\nproblem comes from the setting of games with imperfect information. In [1, p.\n6] the authors propose to model imperfect information by a rational equivalence\nrelation and leave open the problem of deciding if one can synthesize a\nsequential letter-to-letter transducer (Mealy machine) which maps equivalent\nhistories to the same sequence of observations. We also show that knowing if an\nequivalence relation can be given as the equivalence kernel of a sequential\ntransducer is undecidable, even if the relation is given as a letter-to-letter\ntransducer.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.06019v1"
    },
    {
        "title": "Pumping lemmas for classes of languages generated by folding systems",
        "authors": [
            "Jorge C. Lucero"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Geometric folding processes are ubiquitous in natural systems ranging from\nprotein biochemistry to patterns of insect wings and leaves. In a previous\nstudy, a folding operation between strings of formal languages was introduced\nas a model of such processes. The operation was then used to define a folding\nsystem (F-system) as a construct consisting of a core language, containing the\nstrings to be folded, and a folding procedure language, which defines how the\nfolding is done. This paper reviews main definitions associated with F-systems\nand next it determines necessary conditions for a language to belong to classes\ngenerated by such systems. The conditions are stated in the form of pumping\nlemmas and four classes are considered, in which the core and folding procedure\nlanguages are both regular, one of them is regular and the other context-free,\nor both are context-free. Full demonstrations of the lemmas are provided, and\nthe analysis is illustrated with examples.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.08518v1"
    },
    {
        "title": "Learning One-Clock Timed Automata",
        "authors": [
            "Jie An",
            "Mingshuai Chen",
            "Bohua Zhan",
            "Naijun Zhan",
            "Miaomiao Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present an algorithm for active learning of deterministic timed automata\nwith a single clock. The algorithm is within the framework of Angluin's $L^*$\nalgorithm and inspired by existing work on the active learning of symbolic\nautomata. Due to the need of guessing for each transition whether it resets the\nclock, the algorithm is of exponential complexity in the size of the learned\nautomata. Before presenting this algorithm, we propose a simpler version where\nthe teacher is assumed to be smart in the sense of being able to provide the\nreset information. We show that this simpler setting yields a polynomial\ncomplexity of the learning process. Both of the algorithms are implemented and\nevaluated on a collection of randomly generated examples. We furthermore\ndemonstrate the simpler algorithm on the functional specification of the TCP\nprotocol.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.10680v3"
    },
    {
        "title": "Residuality and Learning for Nondeterministic Nominal Automata",
        "authors": [
            "Joshua Moerman",
            "Matteo Sammartino"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We are motivated by the following question: which data languages admit an\nactive learning algorithm? This question was left open in previous work by the\nauthors, and is particularly challenging for languages recognised by\nnondeterministic automata. To answer it, we develop the theory of residual\nnominal automata, a subclass of nondeterministic nominal automata. We prove\nthat this class has canonical representatives, which can always be constructed\nvia a finite number of observations. This property enables active learning\nalgorithms, and makes up for the fact that residuality -- a semantic property\n-- is undecidable for nominal automata. Our construction for canonical residual\nautomata is based on a machine-independent characterisation of residual\nlanguages, for which we develop new results in nominal lattice theory. Studying\nresiduality in the context of nominal languages is a step towards a better\nunderstanding of learnability of automata with some sort of nondeterminism.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.11666v7"
    },
    {
        "title": "Cerny-Starke conjecture from the sixties of XX century",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A word $s$ of letters on edges of underlying graph $\\Gamma$ of deterministic\nfinite automaton (DFA) is called synchronizing if $s$ sends all states of the\nautomaton to a unique state. J. \\v{C}erny discovered in 1964 a sequence of\n$n$-state complete DFA possessing a minimal synchronizing word of length\n$(n-1)^2$. The hypothesis, mostly known today as \\v{C}erny conjecture, claims\nthat $(n-1)^2$ is a precise upper bound on the length of such a word over\nalphabet $\\Sigma$ of letters on edges of $\\Gamma$ for every complete $n$-state\nDFA. The hypothesis was formulated in 1966 by Starke. Algebra with nonstandard\noperation over special class of matrices induced by words in the alphabet of\nlabels on edges is used to prove the conjecture. The proof is based on the\nconnection between length of words $u$ and dimension of the space generated by\nsolution $L_x$ of matrix equation $M_uL_x=M_s$ for synchronizing word $s$, as\nwell as on relation between ranks of $M_u$ and $L_x$. Important role below\nplaced the notion of pseudo inverseL matrix, sometimes reversible.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.06177v4"
    },
    {
        "title": "The State Complexity of Lexicographically Smallest Words and Computing\n  Successors",
        "authors": [
            "Lukas Fleischer",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Given a regular language L over an ordered alphabet $\\Sigma$, the set of\nlexicographically smallest (resp., largest) words of each length is itself\nregular. Moreover, there exists an unambiguous finite-state transducer that, on\na given word w, outputs the length-lexicographically smallest word larger than\nw (henceforth called the L-successor of w). In both cases, naive constructions\nresult in an exponential blowup in the number of states. We prove that if L is\nrecognized by a DFA with n states, then $2^{\\Theta(\\sqrt{n \\log n})}$ states\nare sufficient for a DFA to recognize the subset S(L) of L composed of its\nlexicographically smallest words. We give a matching lower bound that holds\neven if S(L) is represented as an NFA. We then show that the same upper and\nlower bounds hold for an unambiguous finite-state transducer that computes\nL-successors.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.08249v1"
    },
    {
        "title": "Composition and Weight Pushing of Monotonic Subsequential Failure\n  Transducers Representing Probabilistic Models",
        "authors": [
            "Diana Geneva",
            "Georgi Shopov",
            "Stoyan Mihov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We present a construction for the composition of subsequential transducers\n(representing conditional probabilistic models) with subsequential failure\ntransducers (representing probabilistic models). Under certain conditions,\nsatisfied by the corresponding transduction devices, a more efficient\nconstruction is applicable that avoids the creation of unnecessary states.\nFurthermore, the weights of the resulting failure transducers can be\nefficiently redistributed via weight pushing in the $\\langle \\mathbb{R}_+, +,\n\\times, 0, 1 \\rangle$ and $\\langle \\mathbb{R}_+, \\max, \\times, 0, 1 \\rangle$\nsemirings.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.09364v2"
    },
    {
        "title": "Minimising Good-for-Games automata is NP complete",
        "authors": [
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This paper discusses the hardness of finding minimal good-for-games (GFG)\nBuchi, Co-Buchi, and parity automata with state based acceptance. The problem\nappears to sit between finding small deterministic and finding small\nnondeterministic automata, where minimality is NP-complete and PSPACE-complete,\nrespectively. However, recent work of Radi and Kupferman has shown that\nminimising Co-Buchi automata with transition based acceptance is tractable,\nwhich suggests that the complexity of minimising GFG automata might be cheaper\nthan minimising deterministic automata.\n  We show for the standard state based acceptance that the minimality of a GFG\nautomaton is NP-complete for Buchi, Co-Buchi, and parity GFG automata. The\nproofs are a surprisingly straight forward generalisation of the proofs from\ndeterministic Buchi automata: they use a similar reductions, and the same hard\nclass of languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.11979v1"
    },
    {
        "title": "Event structures for the reversible early internal Pi-calculus",
        "authors": [
            "Eva Graversen",
            "Iain Phillips",
            "Nobuko Yoshida"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The pi-calculus is a widely used process calculus, which models\ncommunications between processes and allows the passing of communication links.\nVarious operational semantics of the pi-calculus have been proposed, which can\nbe classified according to whether transitions are unlabelled (so-called\nreductions) or labelled. With labelled transitions, we can distinguish early\nand late semantics. The early version allows a process to receive names it\nalready knows from the environment, while the late semantics and reduction\nsemantics do not. All existing reversible versions of the pi-calculus use\nreduction or late semantics, despite the early semantics of the (forward-only)\npi-calculus being more widely used than the late. We define piIH, the first\nreversible early pi-calculus, and give it a denotational semantics in terms of\nreversible bundle event structures. The new calculus is a reversible form of\nthe internal pi-calculus, which is a subset of the pi-calculus where every link\nsent by an output is private, yielding greater symmetry between inputs and\noutputs.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.01211v2"
    },
    {
        "title": "Non-maximal sensitivity to synchronism in periodic elementary cellular\n  automata: exact asymptotic measures",
        "authors": [
            "Pedro P. B. de Oliveira",
            "Enrico Formenti",
            "Kévin Perrot",
            "Sara Riva",
            "Eurico L. P. Ruivo"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In [11] and [13] the authors showed that elementary cellular automata rules\n0, 3, 8, 12, 15, 28, 32, 34, 44, 51, 60, 128, 136, 140, 160, 162, 170, 200 and\n204 (and their conjugation, reflection, reflected-conjugation) are not maximum\nsensitive to synchronism, i.e. they do not have a different dynamics for each\n(non-equivalent) block-sequential update schedule (defined as ordered\npartitions of cell positions). In this work we present exact measurements of\nthe sensitivity to synchronism for these rules, as functions of the size. These\nexhibit a surprising variety of values and associated proof methods, such as\nthe special pairs of rule 128, and the connection to the bissection of Lucas\nnumbers of rule 8.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.07128v3"
    },
    {
        "title": "Regular matching problems for infinite trees",
        "authors": [
            "Carlos Camino",
            "Volker Diekert",
            "Besik Dundua",
            "Mircea Marin",
            "Géraud Sénizergues"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the matching problem of regular tree languages, that is, \"$\\exists\n\\sigma:\\sigma(L)\\subseteq R$?\" where $L,R$ are regular tree languages over the\nunion of finite ranked alphabets $\\Sigma$ and $\\mathcal{X}$ where $\\mathcal{X}$\nis an alphabet of variables and $\\sigma$ is a substitution such that\n$\\sigma(x)$ is a set of trees in $T(\\Sigma\\cup H)\\setminus H$ for all $x\\in\n\\mathcal{X}$. Here, $H$ denotes a set of \"holes\" which are used to define a\n\"sorted\" concatenation of trees. Conway studied this problem in the special\ncase for languages of finite words in his classical textbook \"Regular algebra\nand finite machines\" published in 1971. He showed that if $L$ and $R$ are\nregular, then the problem \"$\\exists \\sigma \\forall x\\in \\mathcal{X}:\n\\sigma(x)\\neq \\emptyset\\wedge \\sigma(L)\\subseteq R$?\" is decidable. Moreover,\nthere are only finitely many maximal solutions, the maximal solutions are\nregular substitutions, and they are effectively computable. We extend Conway's\nresults when $L,R$ are regular languages of finite and infinite trees, and\nlanguage substitution is applied inside-out, in the sense of Engelfriet and\nSchmidt (1977/78). More precisely, we show that if $L\\subseteq\nT(\\Sigma\\cup\\mathcal{X})$ and $R\\subseteq T(\\Sigma)$ are regular tree languages\nover finite or infinite trees, then the problem \"$\\exists \\sigma \\forall x\\in\n\\mathcal{X}: \\sigma(x)\\neq \\emptyset\\wedge \\sigma_{\\mathrm{io}}(L)\\subseteq\nR$?\" is decidable. Here, the subscript \"$\\mathrm{io}$\" in\n$\\sigma_{\\mathrm{io}}(L)$ refers to \"inside-out\". Moreover, there are only\nfinitely many maximal solutions $\\sigma$, the maximal solutions are regular\nsubstitutions and effectively computable. The corresponding question for the\noutside-in extension $\\sigma_{\\mathrm{oi}}$ remains open, even in the\nrestricted setting of finite trees.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.09926v8"
    },
    {
        "title": "State Complexity Bounds for the Commutative Closure of Group Languages",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work we construct an automaton for the commutative closure of a given\nregular group language. The number of states of the resulting automaton is\nbounded by the number of states of the original automaton, raised to the power\nof the alphabet size, times the product of the order of the letters, viewed as\npermutations of the state set. This gives the asymptotic state bound\n$O((n\\exp(\\sqrt{n\\ln n}))^{|\\Sigma|})$, if the original regular language is\naccepted by an automaton with $n$ states. Depending on the automaton in\nquestion, we label points of $\\mathbb N_0^{|\\Sigma|}$ by subsets of states and\nintroduce unary automata which decompose the thus labelled grid. Based on these\nconstructions, we give a general regularity condition, which is fulfilled for\ngroup languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.11772v4"
    },
    {
        "title": "Church Synthesis on Register Automata over Linearly Ordered Data Domains",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In a Church synthesis game, two players, Adam and Eve, alternately pick some\nelement in a finite alphabet, for an infinite number of rounds. The game is won\nby Eve if the omega-word formed by this infinite interaction belongs to a given\nlanguage S, called the specification. It is well-known that for omega-regular\nspecifications, it is decidable whether Eve has a strategy to enforce the\nspecification no matter what Adam does. We study the extension of Church\nsynthesis games to the linearly ordered data domains (Q, <) and (N, <). In this\nsetting, the infinite interaction between Adam and Eve results in an omega-data\nword, i.e., an infinite sequence of elements in the domain.\n  We study this problem when specifications are given as register automata.\nThose automata consist in finite automata equipped with a finite set of\nregisters in which they can store data values, that they can then compare with\nincoming data values with respect to the linear order. Church games over (N, <)\nare however undecidable, even for deterministic register automata. Thus, we\nintroduce one-sided Church games, where Eve instead operates over a finite\nalphabet, while Adam still manipulates data. We show that they are determined,\nand that deciding the existence of a winning strategy is in ExpTime, both for Q\nand N. This follows from a study of constraint sequences, which abstract the\nbehaviour of register automata, and allow us to reduce Church games to\nomega-regular games. We present an application of one-sided Church games to a\ntransducer synthesis problem. In this application, a transducer models a\nreactive system (Eve) which outputs data stored in its registers, depending on\nits interaction with an environment (Adam) which inputs data to the system.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.12141v7"
    },
    {
        "title": "Cost Automata, Safe Schemes, and Downward Closures",
        "authors": [
            "David Barozzini",
            "Lorenzo Clemente",
            "Thomas Colcombet",
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work we prove decidability of the model-checking problem for safe\nrecursion schemes against properties defined by alternating B-automata. We then\nexploit this result to show how to compute downward closures of languages of\nfinite trees recognized by safe recursion schemes.\n  Higher-order recursion schemes are an expressive formalism used to define\nlanguages of finite and infinite ranked trees by means of fixed points of\nlambda terms. They extend regular and context-free grammars, and are equivalent\nin expressive power to the simply typed $\\lambda Y$-calculus and collapsible\npushdown automata. Safety in a syntactic restriction which limits their\nexpressive power.\n  The class of alternating B-automata is an extension of alternating parity\nautomata over infinite trees; it enhances them with counting features that can\nbe used to describe boundedness properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.12187v6"
    },
    {
        "title": "Timed games and deterministic separability",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota",
            "Radosław Piórkowski"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study a generalisation of B\\\"uchi-Landweber games to the timed setting.\nThe winning condition is specified by a non-deterministic timed automaton with\nepsilon transitions and only Player I can elapse time. We show that for fixed\nnumber of clocks and maximal numerical constant available to Player II, it is\ndecidable whether she has a winning timed controller using these resources.\nMore interestingly, we also show that the problem remains decidable even when\nthe maximal numerical constant is not specified in advance, which is an\nimportant technical novelty not present in previous literature on timed games.\nWe complement these two decidability result by showing undecidability when the\nnumber of clocks available to Player II is not fixed. As an application of\ntimed games, and our main motivation to study them, we show that they can be\nused to solve the deterministic separability problem for nondeterministic timed\nautomata with epsilon transitions. This is a novel decision problem about timed\nautomata which has not been studied before. We show that separability is\ndecidable when the number of clocks of the separating automaton is fixed and\nthe maximal constant is not. The problem whether separability is decidable\nwithout bounding the number of clocks of the separator remains an interesting\nopen problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.12868v1"
    },
    {
        "title": "The state complexity of a class of operations involving roots and\n  boolean operations",
        "authors": [
            "Pascal Caron",
            "Edwin Hamel-de-le-court",
            "Jean-Gabriel Luque"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Modifiers are a sets of functions acting on tuple of automata and allowing\none to construct regular operations. We define and study the class of friendly\nmodifiers that describes a class of regular operations involving compositions\nof boolean operations and roots. We also give an explicit tight bound for the\nstate complexity of these operations.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.12958v1"
    },
    {
        "title": "Descriptional Complexity of Winning Sets of Regular Languages",
        "authors": [
            "Pierre Marcus",
            "Ilkka Törmä"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We investigate certain word-construction games with variable turn orders. In\nthese games, Alice and Bob take turns on choosing consecutive letters of a word\nof fixed length, with Alice winning if the result lies in a predetermined\ntarget language. The turn orders that result in a win for Alice form a binary\nlanguage that is regular whenever the target language is, and we prove some\nupper and lower bounds for its state complexity based on that of the target\nlanguage.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.13668v1"
    },
    {
        "title": "Ambiguity, Weakness, and Regularity in Probabilistic Büchi Automata",
        "authors": [
            "Christof Löding",
            "Anton Pirogov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Probabilistic B\\\"uchi automata are a natural generalization of PFA to\ninfinite words, but have been studied in-depth only rather recently and many\ninteresting questions are still open. PBA are known to accept, in general, a\nclass of languages that goes beyond the regular languages. In this work we\nextend the known classes of restricted PBA which are still regular, strongly\nrelying on notions concerning ambiguity in classical omega-automata.\nFurthermore, we investigate the expressivity of the not yet considered but\nnatural class of weak PBA, and we also show that the regularity problem for\nweak PBA is undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.13692v1"
    },
    {
        "title": "Standard words and solutions of the word equation $X_1^2 \\dotsm X_n^2 =\n  (X_1 \\dotsm X_n)^2$",
        "authors": [
            "Jarkko Peltomäki",
            "Aleksi Saarela"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider solutions of the word equation $X_1^2 \\dotsm X_n^2 = (X_1 \\dotsm\nX_n)^2$ such that the squares $X_i^2$ are minimal squares found in optimal\nsquareful infinite words. We apply a method developed by the second author for\nstudying word equations and prove that there are exactly two families of\nsolutions: reversed standard words and words obtained from reversed standard\nwords by a simple substitution scheme. A particular and remarkable consequence\nis that a word $w$ is a standard word if and only if its reversal is a solution\nto the word equation and $\\gcd(|w|, |w|_1) = 1$. This result can be interpreted\nas a yet another characterization for standard Sturmian words.\n  We apply our results to the symbolic square root map $\\sqrt{\\cdot}$ studied\nby the first author and M. A. Whiteland. We prove that if the language of a\nminimal subshift $\\Omega$ contains infinitely many solutions to the word\nequation, then either $\\Omega$ is Sturmian and $\\sqrt{\\cdot}$-invariant or\n$\\Omega$ is a so-called SL-subshift and not $\\sqrt{\\cdot}$-invariant. This\nresult is progress towards proving the conjecture that a minimal and\n$\\sqrt{\\cdot}$-invariant subshift is necessarily Sturmian.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.14657v2"
    },
    {
        "title": "Scattered one-counter languges have rank less than $ω^2$",
        "authors": [
            "Szabolcs Ivan"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A linear ordering is called context-free if it is the lexicographic ordering\nof some context-free language and is called scattered if it has no dense\nsubordering. Each scattered ordering has an associated ordinal, called its\nrank. It is known that scattered context-free (regular, resp.) orderings have\nrank less than $\\omega^\\omega$ ($\\omega$, resp).\n  In this paper we confirm the conjecture that one-counter languages have rank\nless than $\\omega^2$.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.00090v2"
    },
    {
        "title": "A Quasiorder-based Perspective on Residual Automata",
        "authors": [
            "Pierre Ganty",
            "Elena Gutiérrez",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work, we define a framework of automata constructions based on\nquasiorders over words to provide new insights on the class of residual\nautomata. We present a new residualization operation and a generalized\ndouble-reversal method for building the canonical residual automaton for a\ngiven language. Finally, we use our framework to offer a quasiorder-based\nperspective on NL*, an online learning algorithm for residual automata. We\nconclude that quasiorders are fundamental to residual automata as congruences\nare to deterministic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.00359v3"
    },
    {
        "title": "Computing maximally-permissive strategies in acyclic timed automata",
        "authors": [
            "Emily Clement",
            "Thierry Jéron",
            "Nicolas Markey",
            "David Mentré"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Timed automata are a convenient mathematical model for modelling and\nreasoning about real-time systems. While they provide a powerful way of\nrepresenting timing aspects of such systems, timed automata assume arbitrary\nprecision and zero-delay actions; in particular, a state might be declared\nreachable in a timed automaton, but impossible to reach in the physical system\nit models. In this paper, we consider permissive strategies as a way to\novercome this problem: such strategies propose intervals of delays instead of\nsingle delays, and aim at reaching a target state whichever delay actually\ntakes place. We develop an algorithm for computing the optimal permissiveness\n(and an associated maximally-permissive strategy) in acyclic timed automata and\ngames.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.01815v2"
    },
    {
        "title": "Wreath/cascade products and related decomposition results for the\n  concurrent setting of Mazurkiewicz traces (extended version)",
        "authors": [
            "Bharat Adsul",
            "Paul Gastin",
            "Saptarshi Sarkar",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We develop a new algebraic framework to reason about languages of\nMazurkiewicz traces. This framework supports true concurrency and provides a\nnon-trivial generalization of the wreath product operation to the trace\nsetting. A novel local wreath product principle has been established. The new\nframework is crucially used to propose a decomposition result for recognizable\ntrace languages, which is an analogue of the Krohn-Rhodes theorem. We prove\nthis decomposition result in the special case of acyclic architectures and\napply it to extend Kamp's theorem to this setting. We also introduce and\nanalyze distributed automata-theoretic operations called local and global\ncascade products. Finally, we show that aperiodic trace languages can be\ncharacterized using global cascade products of localized and distributed\ntwo-state reset automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.07940v2"
    },
    {
        "title": "Greibach Normal Form for $ω$-Algebraic Systems and Weighted Simple\n  $ω$-Pushdown Automata",
        "authors": [
            "Manfred Droste",
            "Sven Dziadek",
            "Werner Kuich"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In weighted automata theory, many classical results on formal languages have\nbeen extended into a quantitative setting. Here, we investigate weighted\ncontext-free languages of infinite words, a generalization of\n$\\omega$-context-free languages (Cohen, Gold 1977) and an extension of weighted\ncontext-free languages of finite words (Chomsky, Sch\\\"utzenberger 1963). As in\nthe theory of formal grammars, these weighted context-free languages, or\n$\\omega$-algebraic series, can be represented as solutions of mixed\n$\\omega$-algebraic systems of equations and by weighted $\\omega$-pushdown\nautomata.\n  In our first main result, we show that (mixed) $\\omega$-algebraic systems can\nbe transformed into Greibach normal form. We use the Greibach normal form in\nour second main result to prove that simple $\\omega$-reset pushdown automata\nrecognize all $\\omega$-algebraic series. Simple $\\omega$-reset automata do not\nuse $\\epsilon$-transitions and can change the stack only by at most one symbol.\nThese results generalize fundamental properties of context-free languages to\nweighted context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.08866v2"
    },
    {
        "title": "Multi-dimensional Long-Run Average Problems for Vector Addition Systems\n  with States",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A vector addition system with states (VASS) consists of a finite set of\nstates and counters. A transition changes the current state to the next state,\nand every counter is either incremented, or decremented, or left unchanged. A\nstate and value for each counter is a configuration; and a computation is an\ninfinite sequence of configurations with transitions between successive\nconfigurations. A probabilistic VASS consists of a VASS along with a\nprobability distribution over the transitions for each state. Qualitative\nproperties such as state and configuration reachability have been widely\nstudied for VASS. In this work we consider multi-dimensional long-run average\nobjectives for VASS and probabilistic VASS. For a counter, the cost of a\nconfiguration is the value of the counter; and the long-run average value of a\ncomputation for the counter is the long-run average of the costs of the\nconfigurations in the computation. The multi-dimensional long-run average\nproblem given a VASS and a threshold value for each counter, asks whether there\nis a computation such that for each counter the long-run average value for the\ncounter does not exceed the respective threshold. For probabilistic VASS,\ninstead of the existence of a computation, we consider whether the expected\nlong-run average value for each counter does not exceed the respective\nthreshold. Our main results are as follows: we show that the multi-dimensional\nlong-run average problem (a) is NP-complete for integer-valued VASS; (b) is\nundecidable for natural-valued VASS (i.e., nonnegative counters); and (c) can\nbe solved in polynomial time for probabilistic integer-valued VASS, and\nprobabilistic natural-valued VASS when all computations are non-terminating.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.08917v1"
    },
    {
        "title": "Determinisability of one-clock timed automata",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota",
            "Radosław Piórkowski"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The deterministic membership problem for timed automata asks whether the\ntimed language recognised by a nondeterministic timed automaton can be\nrecognised by a deterministic timed automaton. We show that the problem is\ndecidable when the input automaton is a one-clock nondeterministic timed\nautomaton without epsilon transitions and the number of clocks of the\ndeterministic timed automaton is fixed. We show that the problem in all the\nother cases is undecidable, i.e., when either 1) the input nondeterministic\ntimed automaton has two clocks or more, or 2) it uses epsilon transitions, or\n3) the number of clocks of the output deterministic automaton is not fixed.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.09340v1"
    },
    {
        "title": "A note on the class of languages generated by F-systems over regular\n  languages",
        "authors": [
            "Jorge C. Lucero",
            "Sławek Staworko"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  An F-system is a computational model that performs a folding operation on\nwords of a given language, following directions coded on words of another given\nlanguage. This paper considers the case in which both given languages are\nregular, and it shows that the class of languages generated by such F-systems\nis a proper subset of the class of linear context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.15705v2"
    },
    {
        "title": "On Store Languages and Applications",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The store language of a machine of some arbitrary type is the set of all\nstore configurations (state plus store contents but not the input) that can\nappear in an accepting computation. New algorithms and characterizations of\nstore languages are obtained, such as the result that any nondeterministic\npushdown automaton augmented with reversal-bounded counters, where the pushdown\ncan \"flip\" its contents up to a bounded number of times, can be accepted by a\nmachine with only reversal-bounded counters. Then, connections are made between\nstore languages and several model checking and reachability problems, such as\naccepting the set of all predecessor and successor configurations from a given\nset of configurations, and determining whether there are at least one, or\ninfinitely many, common configurations between accepting computations of two\nmachines. These are explored for a variety of different machine models often\ncontaining multiple parallel data stores. Many of the machine models studied\ncan accept the set of predecessor configurations (of a regular set of\nconfigurations), the set of successor configurations, and the set of common\nconfigurations between two machines, with a machine model that is simpler than\nitself, with a decidable emptiness, infiniteness, and disjointness property.\nStore languages are key to showing these properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.00523v1"
    },
    {
        "title": "Automata-based Quantitative Verification",
        "authors": [
            "Suguman Bansal"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Quantitative analysis of computing systems is an emerging area in automated\nformal analysis. Such properties address aspects such as costs and rewards,\nquality measures, resource consumption, distance metrics, etc.\n  Existing solutions for problems in quantitative analysis face two challenges,\nnamely lack of generalizability and separation-of-techniques. Lack of\ngeneralizability refers to the issue that solution approaches are specialized\nto cost model. Different cost models deploy such disparate algorithms that\nthere is no transfer of knowledge from one cost model to another.\nSeparation-of-techniques refers to the inherent dichotomy in solving problems\nin quantitative analysis. Most algorithms comprise of a structural phase which\nreasons about the structure of the quantitative system(s) using techniques from\nautomata or graphs, and a numerical phase, which reasons about the quantitative\ndimension/cost model using numerical methods. The techniques used in both\nphases are so unlike each other that they are difficult to combine, thereby\nimpacting scalability.\n  This thesis contributes to a novel framework that addresses these challenges.\nThe introduced framework, called comparator automata or comparators in short,\nbuilds on automata-theoretic foundations to generalize across a variety of cost\nmodels. Comparators enable automata-based methods in the numerical phase, hence\neradicating the dependence on numerical methods. In doing so, comparators are\nable to integrate the structural and numerical phases. On the theoretical\nfront, we demonstrate that these have the advantage of generalizable results,\nand yield complexity-theoretic improvements over a range of problems in\nquantitative analysis. On the empirical front, we demonstrate that\ncomparator-based solutions render more efficient, scalable, and robust\nperformance, and are able to integrate quantitative with qualitative\nobjectives.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.02055v1"
    },
    {
        "title": "On some representations of context-free languages",
        "authors": [
            "Krasimir Yordzhev"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Context-free languages are widely used to describe the syntax of programming\nlanguages and natural languages. Usually, we describe a context-free language\nmathematically with the help of context-free grammar (for generation) or\npushdown automata (for recognition). The purpose of this study is to describe\nsome unconventional methods of description of context-free languages, namely a\nrepresentation with the help of finite digraphs and with automata - generators\nof context-free languages. We will mainly focus on the mathematical models of\nthese representations.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.04823v1"
    },
    {
        "title": "Online Monitoring $ω$-Regular Properties in Unknown Markov Chains",
        "authors": [
            "Javier Esparza",
            "Stefan Kiefer",
            "Jan Kretinsky",
            "Maximilian Weininger"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study runtime monitoring of $\\omega$-regular properties. We consider a\nsimple setting in which a run of an unknown finite-state Markov chain $\\mathcal\nM$ is monitored against a fixed but arbitrary $\\omega$-regular specification\n$\\varphi$. The purpose of monitoring is to keep aborting runs that are\n\"unlikely\" to satisfy the specification until $\\mathcal M$ executes a correct\nrun. We design controllers for the reset action that (assuming that $\\varphi$\nhas positive probability) satisfy the following property w.p.1: the number of\nresets is finite, and the run executed by $\\mathcal M$ after the last reset\nsatisfies $\\varphi$.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.08347v1"
    },
    {
        "title": "Generators and Bases for Monadic Closures",
        "authors": [
            "Stefan Zetzsche",
            "Alexandra Silva",
            "Matteo Sammartino"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  It is well-known that every regular language admits a unique minimal\ndeterministic acceptor. Establishing an analogous result for non-deterministic\nacceptors is significantly more difficult, but nonetheless of great practical\nimportance. To tackle this issue, a number of sub-classes of non-deterministic\nautomata have been identified, all admitting canonical minimal representatives.\nIn previous work, we have shown that such representatives can be recovered\ncategorically in two steps. First, one constructs the minimal bialgebra\naccepting a given regular language, by closing the minimal coalgebra with\nadditional algebraic structure over a monad. Second, one identifies canonical\ngenerators for the algebraic part of the bialgebra, to derive an equivalent\ncoalgebra with side effects in a monad. In this paper, we further develop the\ngeneral theory underlying these two steps. On the one hand, we show that\nderiving a minimal bialgebra from a minimal coalgebra can be realized by\napplying a monad on an appropriate category of subobjects. On the other hand,\nwe explore the abstract theory of generators and bases for algebras over a\nmonad.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.10223v6"
    },
    {
        "title": "State-space construction of Hybrid Petri nets with multiple stochastic\n  firings",
        "authors": [
            "Jannik Hüls",
            "Carina Pilch",
            "Patricia Schinke",
            "Henner Niehaus",
            "Joanna Delicaris",
            "Anne Remke"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Hybrid Petri nets have been extended to include general transitions that fire\nafter a randomly distributed amount of time. With a single general one-shot\ntransition the state space and evolution over time can be represented either as\na Parametric Location Tree or as a Stochastic Time Diagram. Recent work has\nshown that both representations can be combined and then allow multiple\nstochastic firings. This work presents an algorithm for building the Parametric\nLocation Tree with multiple general transition firings and shows how its\ntransient probability distribution can be computed using multi-dimensional\nintegration. We discuss the (dis-)advantages of an interval arithmetic and a\ngeometric approach to compute the areas of integration. Furthermore, we provide\ndetails on how to perform a Monte Carlo integration either directly on these\nintervals or convex polytopes, or after transformation to standard simplices. A\ncase study on a battery-backup system shows the feasibility of the approach and\ndiscusses the performance of the different integration approaches.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.11056v1"
    },
    {
        "title": "Learning automata and transducers: a categorical approach",
        "authors": [
            "Thomas Colcombet",
            "Daniela Petrişan",
            "Riccardo Stabile"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we present a categorical approach to learning automata over\nwords, in the sense of the $L^*$-algorithm of Angluin. This yields a new\ngeneric $L^*$-like algorithm which can be instantiated for learning\ndeterministic automata, automata weighted over fields, as well as subsequential\ntransducers. The generic nature of our algorithm is obtained by adopting an\napproach in which automata are simply functors from a particular category\nrepresenting words to a \"computation category\". We establish that the\nsufficient properties for yielding the existence of minimal automata (that were\ndisclosed in a previous paper), in combination with some additional hypotheses\nrelative to termination, ensure the correctness of our generic algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.13675v1"
    },
    {
        "title": "On Krohn-Rhodes theory for semiautomata",
        "authors": [
            "Karl-Heinz Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Krohn-Rhodes theory encompasses the techniques for the study of finite\nautomata and their decomposition into elementary automata. The famous result of\nKrohn and Rhodes roughly states that each finite automaton can be decomposed\ninto elementary components which correspond to permutation and reset automata\nconnected by a cascade product. However, this outcome is not easy to access for\nthe working computer scientist. This paper provides a short introduction into\nKrohn-Rhodes theory based on the valuable work of Ginzburg.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.16235v1"
    },
    {
        "title": "Conversion of LSAT behavioral specifications to automata",
        "authors": [
            "Sander Thuijsman",
            "Michel Reniers"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The Logistics Specification and Analysis Tool (LSAT) is a model-based\nengineering tool used for manufacturing system design and analysis. Using a\ndomain specific language, a system can be specified in LSAT. In this paper, a\nconversion method is presented to obtain the system behavior of an LSAT\nspecification in automata structure.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.03249v1"
    },
    {
        "title": "The algebra of binary trees is affine complete",
        "authors": [
            "Andre Arnold",
            "Patrick Cegielski",
            "Serge Grigorieff",
            "Irene Guessarian"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A function on an algebra is congruence preserving if, for any congruence, it\nmaps pairs of congruent elements onto pairs of congruent elements. We show that\non the algebra of binary trees whose leaves are labeled by letters of an\nalphabet containing at least three letters, a function is congruence preserving\nif and only if it is polynomial.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.03925v3"
    },
    {
        "title": "Polynomial time algorithm for left [right] local testability",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A right [left] locally testable language S is a language with the property\nthat for some non negative integer k two words u and v in alphabet S are equal\nin the semi group if (1) the prefix and suffix of the words of length k\ncoincide, (2) the set of segments of length k of the words as well as 3) the\norder of the first appearance of these segments in prefixes [suffixes]\ncoincide. We present necessary and sufficient condition for graph [semi group]\nto be transition graph [semi group] of the deterministic finite automaton that\naccepts right [left] locally testable language and necessary and sufficient\ncondition for transition graph of the deterministic finite automaton with\nlocally idempotent semi group. We introduced polynomial time algorithms for the\nright [left] local testable problem for transition semi group and transition\ngraph of the deterministic finite automaton based on these conditions.\nPolynomial time algorithm verifies transition graph of automaton with locally\nidempotent transition semi group.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.04236v1"
    },
    {
        "title": "Some new Features and Algorithms for the Study of DFA",
        "authors": [
            "Avraham N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The work presents some new algorithms realized recently in the package\nTESTAS. They decide whether or not deterministic finite automaton (DFA) is\nsynchronizing, several procedures find relatively short synchronizing words and\na synchronizing word of the minimal length. We check the existence of a\ncoloring of directed graph that turns the graph into a synchronizing DFA. The\nalgorithm finds the coloring (better known as the road coloring) if it exists.\nOtherwise, the k-synchronizing road coloring can be found. We use a linear\nvisualization of the graph of an automaton based on its structural properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.05575v1"
    },
    {
        "title": "Nondeterministic functional transducer inference algorithm",
        "authors": [
            "Aleksander Mendoza-Drosik"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The purpose of this paper is to present an algorithm for inferring\nnondeterministic functional transducers. It has a lot in common with other well\nknown algorithms such has RPNI and OSTIA. Indeed we will argue that this\nalgorithm is a generalisation of both of them. Functional transducers are all\nthose nondeterministic transducers whose regular relation is a function.\nEpsilon transitions as well as subsequential output can be erased for such\nmachines, with the exception of output for empty string being lost. Learning\npartial functional transducers from negative examples is equivalent to learning\ntotal from positive-only data.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.05710v2"
    },
    {
        "title": "Precise estimation on the order of local testability of deterministic\n  finite automaton",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A locally testable language L is a language with the property that for some\nnon negative integer k, called the order or the level of local testable,\nwhether or not a word u in the language L depends on (1) the prefix and the\nsuffix of the word u of length k-1 and (2) the set of intermediate partial\nstrings of length k of the word u. For given k the language is called\nk-testable. We give necessary and sufficient conditions for the language of an\nautomaton to be k-testable in the terms of the length of paths of a related\ngraph. Some estimations of the upper and of the lower bound of testable order\nfollow from these results. We improve the upper bound on the testable order of\nlocally testable deterministic finite automaton with n states to n(n-2)+1 This\nbound is the best possible. We give an answer on the following conjecture of\nKim, McNaughton and Mac-CLoskey for deterministic finite locally testable\nautomaton with n states: \\Is the local testable order of no greater than n in\npower 1.5 when the alphabet size is two?\" Our answer is negative. In the case\nof size two the situation is the same as in general case.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.06253v1"
    },
    {
        "title": "Reducing the time complexity of testing for local threshold testability",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A locally threshold testable language L is a language with the property that\nfor some non negative integers k and l and for some word u from L, a word v\nbelongs to L if and only if\n  (1) the prefixes [suffixes] of length k-1 of words u and v coincide,\n  (2) the numbers of occurrences of every factor of length k in both words u\nand v are either the same or greater than l-1.\n  A deterministic finite automaton is called locally threshold testable if the\nautomaton accepts a locally threshold testable language for some l and k.\n  New necessary and sufficient conditions for a deterministic finite automaton\nto be locally threshold testable are found. On the basis of these conditions,\nwe modify the algorithm to verify local threshold testability of the automaton\nand to reduce the time complexity of the algorithm. The algorithm is\nimplemented as a part of the $C/C ^{++}$ package TESTAS.\n\\texttt{http://www.cs.biu.ac.il/$\\sim$trakht/Testas.html}.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.06262v1"
    },
    {
        "title": "On Language Varieties Without Boolean Operations",
        "authors": [
            "Fabian Birkmann",
            "Stefan Milius",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Eilenberg's variety theorem marked a milestone in the algebraic theory of\nregular languages by establishing a formal correspondence between properties of\nregular languages and properties of finite monoids recognizing them. Motivated\nby classes of languages accepted by quantum finite automata, we introduce basic\nvarieties of regular languages, a weakening of Eilenberg's original concept\nthat does not require closure under any boolean operations, and prove a variety\ntheorem for them. To do so, we investigate the algebraic recognition of\nlanguages by lattice bimodules, generalizing Klima and Polak's lattice\nalgebras, and we utilize the duality between algebraic completely distributive\nlattices and posets.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.06951v1"
    },
    {
        "title": "Congruences for Stochastic Automata",
        "authors": [
            "Ernst-Erich Doberkat"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Congruences for stochastic automata are defined, the correspondin factor\nautomata are constructed and investigated for automata ove analytic spaces. We\nstudy the behavior under finite and infinite streams. Congruences consist of\nmultiple parts, it is shown that factoring can be done in multiple steps,\nguided by these parts.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.06954v1"
    },
    {
        "title": "Mathematical Approach in Automata and Automata Association",
        "authors": [
            "Sergio Henrique Maciel"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The transition structure of an automaton can be used to create a natural\ntopology to the set of states of an automaton, generating, this way, a\ntopological space. Probabilistic automata can also be modeled in terms of\nmeasure theory. A system of many automata would be reduced to simple\nmathematical structures and analyzed by a topological point of view.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.08108v2"
    },
    {
        "title": "Recurrence in Dense-time AMS Assertions",
        "authors": [
            "Sayandeep Sanyal",
            "Antonio Anastasio Bruto da Costa",
            "Pallab Dasgupta"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The notion of recurrence over continuous or dense time, as required for\nexpressing Analog and Mixed-Signal (AMS) behaviours, is fundamentally different\nfrom what is offered by the recurrence operators of SystemVerilog Assertions\n(SVA). This article introduces the formal semantics of recurrence over dense\ntime and provides a methodology for the runtime verification of such properties\nusing interval arithmetic. Our property language extends SVA with dense\nreal-time intervals and predicates containing real-valued signals. We provide a\ntool kit which interfaces with off-the-shelf EDA tools through standard VPI.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.08805v1"
    },
    {
        "title": "Weighted automata are compact and actively learnable",
        "authors": [
            "Artem Kaznatcheev",
            "Prakash Panangaden"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that weighted automata over the field of two elements can be\nexponentially more compact than non-deterministic finite state automata. To\nshow this, we combine ideas from automata theory and communication complexity.\nHowever, weighted automata are also efficiently learnable in Angluin's minimal\nadequate teacher model in a number of queries that is polynomial in the size of\nthe minimal weighted automaton.. We include an algorithm for learning WAs over\nany field based on a linear algebraic generalization of the Angluin-Schapire\nalgorithm. Together, this produces a surprising result: weighted automata over\nfields are structured enough that even though they can be very compact, they\nare still efficiently learnable.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.10498v3"
    },
    {
        "title": "Ambiguity through the lens of measure theory",
        "authors": [
            "Olivier Carton"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we establish a strong link between the ambiguity for finite\nwords of a B\\\"uchi automaton and the ambiguity for infinite words of the same\nautomaton. This link is based on measure theory. More precisely, we show that\nsuch an automaton is unambiguous, in the sense that no finite word labels two\nruns with the same starting state and the same ending state if and only if for\neach state, the set of infinite sequences labelling two runs starting from that\nstate has measure zero. The measure used to define these negligible sets, that\nis sets of measure zero, can be any measure computed by a weighted automaton\nwhich is compatible with the B\\\"uchi automaton. This latter condition is very\nnatural: the measure must put weight on cylinders [w] where w is the label of\nsome run in the B\\\"uchi automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.10534v4"
    },
    {
        "title": "Optimal Transformations of Muller Conditions",
        "authors": [
            "Antonio Casares",
            "Thomas Colcombet",
            "Nathanaël Fijalkow"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we are interested in automata over infinite words and infinite\nduration games, that we view as general transition systems. We study\ntransformations of systems using a Muller condition into ones using a parity\ncondition, extending Zielonka's construction. We introduce the alternating\ncycle decomposition transformation, and we prove a strong optimality result:\nfor any given deterministic Muller automaton, the obtained parity automaton is\nminimal both in size and number of priorities among those automata admitting a\nmorphism into the original Muller automaton.\n  We give two applications. The first is an improvement in the process of\ndeterminisation of B\\\"uchi automata into parity automata by Piterman and\nSchewe. The second is to present characterisations on the possibility of\nrelabelling automata with different acceptance conditions.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.13041v4"
    },
    {
        "title": "Automatic Optimizations for Stream-based Monitoring Languages",
        "authors": [
            "Jan Baumeister",
            "Bernd Finkbeiner",
            "Matthis Kruse",
            "Maximilian Schwenger"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Runtime monitors that are specified in a stream-based monitoring language\ntend to be easier to understand, maintain, and reuse than those written in a\nstandard programming language. Because of their formal semantics, such\nspecification languages are also a natural choice for safety-critical\napplications. Unlike for standard programming languages, there is, however, so\nfar very little support for automatic code optimization. In this paper, we\npresent the first collection of code transformations for the stream-based\nmonitoring language RTLola. We show that classic compiler optimizations, such\nas Sparse Conditional Constant Propagation and Common Subexpression\nElimination, can be adapted to monitoring specifications. We also develop new\ntransformations -- Pacing Type Refinement and Filter Refinement -- which\nexploit the specific modular structure of RTLola as well as the implementation\nfreedom afforded by a declarative specification language. We demonstrate the\nsignificant impact of the code transformations on benchmarks from the\nmonitoring of unmanned aircraft systems (UAS).\n",
        "pdf_link": "http://arxiv.org/pdf/2011.13344v1"
    },
    {
        "title": "State Complexity of the Set of Synchronizing Words for Circular Automata\n  and Automata over Binary Alphabets",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Most slowly synchronizing automata over binary alphabets are circular, i.e.,\ncontaining a letter permuting the states in a single cycle, and their set of\nsynchronizing words has maximal state complexity, which also implies complete\nreachability.Here, we take a closer look at generalized circular and completely\nreachable automata. We derive that over a binary alphabet every completely\nreachable automaton must be circular, a consequence of a structural result\nstating that completely reachable automata over strictly less letters than\nstates always contain permutational letters. We state sufficient conditions for\nthe state complexity of the set of synchronizing words of a generalized\ncircular automaton to be maximal. We apply our main criteria to the family\n$\\mathscr K_n$ of automata that was previously only conjectured to have this\nproperty.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.14404v1"
    },
    {
        "title": "State complexity of halting, returning and reversible graph-walking\n  automata",
        "authors": [
            "Olga Martynova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Graph-walking automata (GWA) traverse graphs by moving between the nodes\nfollowing the edges, using a finite-state control to decide where to go next.\nIt is known that every GWA can be transformed to a GWA that halts on every\ninput, to a GWA returning to the initial node in order to accept, and to a\nreversible GWA. This paper establishes lower bounds on the state blow-up of\nthese transformations, as well as closely matching upper bounds. It is shown\nthat making an $n$-state GWA traversing $k$-ary graphs halt on every input\nrequires at most $2nk+1$ states and at least $2(n-1)(k-3)$ states in the worst\ncase; making a GWA return to the initial node before acceptance takes at most\n$2nk+n$ and at least $2(n-1)(k-3)$ states in the worst case; Automata\nsatisfying both properties at once have at most $4nk+1$ and at least\n$4(n-1)(k-3)$ states in the worst case. Reversible automata have at most\n$4nk+1$ and at least $4(n-1)(k-3)-1$ states in the worst case.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.14856v1"
    },
    {
        "title": "Encoding sinusoidal functions in hybrid automata formalism",
        "authors": [
            "Nikolaos Kekatos"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Hybrid systems can express a plethora of physical phenomena and systems as\nthey can combine continuous and discrete dynamics. There exist several tools\nthat enable the reachability analysis of hybrid systems modeled as hybrid\nautomata. However, these tools exhibit certain limitations in the type of\nmathematical operations that they natively support. For example, SpaceEx, a\nwell-established tool in the hybrid verification community, supports the use of\nlinear ODEs in the flow of each discrete location. Mathematical functions like\nalgebraic equations or trigonometric functions have to be encoded as the\nsolutions of a set of ODEs. In this article, we provide a mechanism to define\nsinusoidal functions that are supported by SpaceEx. We also show how certain\nSimulink blocks can be translated into hybrid automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.00012v1"
    },
    {
        "title": "Bidimensional linear recursive sequences and universality of unambiguous\n  register automata",
        "authors": [
            "Corentin Barloy",
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the universality and inclusion problems for register automata over\nequality data. We show that the universality and the inclusion problems can be\nsolved with 2-EXPTIME complexity when the input automata are without guessing\nand unambiguous, improving on the currently best-known 2-EXPSPACE upper bound\nby Mottet and Quaas. When the number of registers of both automata is fixed, we\nobtain a lower EXPTIME complexity, also improving the EXPSPACE upper bound from\nMottet and Quaas for fixed number of registers. We reduce inclusion to\nuniversality, and then we reduce universality to the problem of counting the\nnumber of orbits of runs of the automaton. We show that the orbit-counting\nfunction satisfies a system of bidimensional linear recursive equations with\npolynomial coefficients (linrec), which generalises analogous recurrences for\nthe Stirling numbers of the second kind, and then we show that universality\nreduces to the zeroness problem for linrec sequences. While such a counting\napproach is classical and has successfully been applied to unambiguous finite\nautomata and grammars over finite alphabets, its application to register\nautomata over infinite alphabets is novel. We provide two algorithms to decide\nthe zeroness problem for bidimensional linear recursive sequences arising from\norbit-counting functions. Both algorithms rely on techniques from linear\nnon-commutative algebra. The first algorithm performs variable elimination and\nhas elementary complexity. The second algorithm is a refined version of the\nfirst one and it relies on the computation of the Hermite normal form of\nmatrices over a skew polynomial field. The second algorithm yields an EXPTIME\ndecision procedure for the zeroness problem of linrec sequences, which in turn\nyields the claimed bounds for the universality and inclusion problems of\nregister automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.01033v1"
    },
    {
        "title": "Nondeterministic Syntactic Complexity",
        "authors": [
            "Robert Myers",
            "Stefan Milius",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a new measure on regular languages: their nondeterministic\nsyntactic complexity. It is the least degree of any extension of the `canonical\nboolean representation' of the syntactic monoid. Equivalently, it is the least\nnumber of states of any subatomic nondeterministic acceptor. It turns out that\nessentially all previous structural work on nondeterministic state-minimality\ncomputes this measure. Our approach rests on an algebraic interpretation of\nnondeterministic finite automata as deterministic finite automata endowed with\nsemilattice structure. Crucially, the latter form a self-dual category.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.03039v2"
    },
    {
        "title": "A Ramsey Theorem for Finite Monoids",
        "authors": [
            "Ismaël Jecker"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Repeated idempotent elements are commonly used to characterise iterable\nbehaviours in abstract models of computation. Therefore, given a monoid $M$, it\nis natural to ask how long a sequence of elements of $M$ needs to be to ensure\nthe presence of consecutive idempotent factors. This question is formalised\nthrough the notion of the Ramsey function $R_M$ associated to M, obtained by\nmapping every positive integer $k$ to the minimal integer $R_M(k)$ such that\nevery word $u$ in $M^*$ of length $R_M(k)$ contains $k$ consecutive non-empty\nfactors that correspond to the same idempotent element of $M$.\n  In this work, we study the behaviour of the Ramsey function $R_M$ by\ninvestigating the regular $D$-length of $M$, defined as the largest size $L(M)$\nof a submonoid of $M$ isomorphic to the set of natural numbers $\\{1,2, ...,\nL(M)\\}$ equipped with the Max operation. We show that the regular $D$-length of\n$M$ determines the degree of $R_M$, by proving that $k^{L(M)} \\leq R_M(k) \\leq\n(k|M|^4)^{L(M)}$.\n  To allow applications of this result, we provide the value of the regular\n$D$-length of diverse monoids. In particular, we prove that the full monoid of\n$n \\times n$ Boolean matrices, which is used to express transition monoids of\nnon-deterministic automata, has a regular $D$-length of $\\frac{n^2+n+2}{2}$.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.05895v1"
    },
    {
        "title": "SD-Regular Transducer Expressions for Aperiodic Transformations",
        "authors": [
            "Luc Dartois",
            "Paul Gastin",
            "Shankara Narayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  FO transductions, aperiodic deterministic two-way transducers, as well as\naperiodic streaming string transducers are all equivalent models for first\norder definable functions. In this paper, we solve the long standing open\nproblem of expressions capturing first order definable functions, thereby\ngeneralizing the seminal SF=AP (star free expressions = aperiodic languages)\nresult of Sch\\\"utzenberger. Our result also generalizes a lesser known\ncharacterization by Sch\\\"utzenberger of aperiodic languages by SD-regular\nexpressions (SD=AP). We show that every first order definable function over\nfinite words captured by an aperiodic deterministic two-way transducer can be\ndescribed with an SD-regular transducer expression (SDRTE). An SDRTE is a\nregular expression where Kleene stars are used in a restricted way: they can\nappear only on aperiodic languages which are prefix codes of bounded\nsynchronization delay. SDRTEs are constructed from simple functions using the\ncombinators unambiguous sum (deterministic choice), Hadamard product, and\nunambiguous versions of the Cauchy product and the k-chained Kleene-star, where\nthe star is restricted as mentioned. In order to construct an SDRTE associated\nwith an aperiodic deterministic two-way transducer, (i) we concretize\nSch\\\"utzenberger's SD=AP result, by proving that aperiodic languages are\ncaptured by SD-regular expressions which are unambiguous and stabilising; (ii)\nby structural induction on the unambiguous, stabilising SD-regular expressions\ndescribing the domain of the transducer, we construct SDRTEs. Finally, we also\nlook at various formalisms equivalent to SDRTEs which use the function\ncomposition, allowing to trade the k-chained star for a 1-star.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.07130v1"
    },
    {
        "title": "Formal FT-based Cause-Consequence Reliability Analysis using Theorem\n  Proving",
        "authors": [
            "Mohamed Abdelghany",
            "Sofiene Tahar"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Cause-consequence Diagram (CCD) is widely used as a deductive safety analysis\ntechnique for decision-making at the critical-system design stage. This\napproach models the causes of subsystem failures in a highly-critical system\nand their potential consequences using Fault Tree (FT) and Event Tree (ET)\nmethods, which are well-known dependability modeling techniques.\nPaper-and-pencil-based approaches and simulation tools, such as the Monte-Carlo\napproach, are commonly used to carry out CCD analysis, but lack the ability to\nrigorously verify essential system reliability properties. In this work, we\npropose to use formal techniques based on theorem proving for the formal\nmodeling and step-analysis of CCDs to overcome the inaccuracies of the\nsimulation-based analysis and the error-proneness of informal reasoning by\nmathematical proofs. In particular, we use the HOL4 theorem prover, which is a\ncomputer-based mathematical reasoning tool. To this end, we developed a\nformalization of CCDs in Higher-Order Logic (HOL), based on the algebraic\napproach, using HOL4. We demonstrate the practical effectiveness of the\nproposed CCD formalization by performing the formal reliability analysis of the\nIEEE 39-bus electrical power network. Also, we formally determine the Forced\nOutage Rate (FOR) of the power generation units and the network reliability\nindex, i.e., System Average Interruption Duration Index (SAIDI). To assess the\naccuracy of our proposed approach, we compare our results with those obtained\nwith MATLAB Monte-Carlo Simulation (MCS) as well as other state-of-the-art\napproaches for subsystem-level reliability analysis.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.07174v1"
    },
    {
        "title": "Certifying Inexpressibility",
        "authors": [
            "Orna Kupferman",
            "Salomon Sickert"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Different classes of automata on infinite words have different expressive\npower. Deciding whether a given language $L \\subseteq \\Sigma^\\omega$ can be\nexpressed by an automaton of a desired class can be reduced to deciding a game\nbetween Prover and Refuter: in each turn of the game, Refuter provides a letter\nin $\\Sigma$, and Prover responds with an annotation of the current state of the\nrun (for example, in the case of B\\\"uchi automata, whether the state is\naccepting or rejecting, and in the case of parity automata, what the color of\nthe state is). Prover wins if the sequence of annotations she generates is\ncorrect: it is an accepting run iff the word generated by Refuter is in $L$. We\nshow how a winning strategy for Refuter can serve as a simple and\neasy-to-understand certificate to inexpressibility, and how it induces\nadditional forms of certificates. Our framework handles all classes of\ndeterministic automata, including ones with structural restrictions like weak\nautomata. In addition, it can be used for refuting separation of two languages\nby an automaton of the desired class, and for finding automata that approximate\n$L$ and belong to the desired class.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.08756v2"
    },
    {
        "title": "Orbit-Finite-Dimensional Vector Spaces and Weighted Register Automata",
        "authors": [
            "Mikołaj Bojańczyk",
            "Joanna Fijalkow",
            "Bartek Klin",
            "Joshua Moerman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We develop a theory of vector spaces spanned by orbit-finite sets. Using this\ntheory, we give a decision procedure for equivalence of weighted register\nautomata, which are the common generalization of weighted automata and register\nautomata for infinite alphabets. The algorithm runs in exponential time, and in\npolynomial time for a fixed number of registers. As a special case, we can\ndecide, with the same complexity, language equivalence for unambiguous register\nautomata, which improves previous results in three ways: (a) we allow for order\ncomparisons on atoms, and not just equality; (b) the complexity is\nexponentially better; and (c) we allow automata with guessing.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.02438v4"
    },
    {
        "title": "Visualization of the Computation Process of a Universal Register Machine",
        "authors": [
            "Shigeru Ninagawa",
            "Genaro J. Martinez"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Universal register machine, a formal model of computation, can be emulated on\nthe array of the Game of Life, a two-dimensional cellular automaton. We perform\nspectral analysis on the computation dynamical process of the universal\nregister machine on the Game of Life. The array is divided into small sectors\nand the power spectrum is calculated from the evolution in each sector. The\npower spectrum can be classified into four categories by its shape; null, white\nnoise, sharp peaks, and power law. By representing the shape of power spectrum\nby a mark, we can visualize the activity of the sector during the computation\nprocess. For example, the track of pulse moving between components of the\nuniversal register machine and the position of frequently modified registers\ncan be identified. This method can expose the functional difference in each\nregion of computing machine.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.02920v3"
    },
    {
        "title": "Congruence Relations for Büchi Automata",
        "authors": [
            "Yong Li",
            "Yih-Kuen Tsay",
            "Andrea Turrini",
            "Moshe Y. Vardi",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We revisit here congruence relations for B\\\"uchi automata, which play a\ncentral role in the automata-based verification. The size of the classical\ncongruence relation is in $3^{\\mathcal{O}(n^2)}$, where $n$ is the number of\nstates of a given B\\\"uchi automaton $\\mathcal{A}$. Here we present improved\ncongruence relations that can be exponentially coarser than the classical one.\nWe further give asymptotically optimal congruence relations of size\n$2^{\\mathcal{O}(n \\log n)}$. Based on these optimal congruence relations, we\nobtain an optimal translation from B\\\"uchi automata to a family of\ndeterministic finite automata (FDFW) that accepts the complementary language.\nTo the best of our knowledge, our construction is the first direct and optimal\ntranslation from B\\\"uchi automata to FDFWs.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.03555v3"
    },
    {
        "title": "Determinisability of register and timed automata",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota",
            "Radosław Piórkowski"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The deterministic membership problem for timed automata asks whether the\ntimed language given by a nondeterministic timed automaton can be recognised by\na deterministic timed automaton. An analogous problem can be stated in the\nsetting of register automata. We draw the complete decidability/complexity\nlandscape of the deterministic membership problem, in the setting of both\nregister and timed automata. For register automata, we prove that the\ndeterministic membership problem is decidable when the input automaton is a\nnondeterministic one-register automaton (possibly with epsilon transitions) and\nthe number of registers of the output deterministic register automaton is\nfixed. This is optimal: We show that in all the other cases the problem is\nundecidable, i.e., when either (1) the input nondeterministic automaton has two\nregisters or more (even without epsilon transitions), or (2) it uses guessing,\nor (3) the number of registers of the output deterministic automaton is not\nfixed. The landscape for timed automata follows a similar pattern. We show that\nthe problem is decidable when the input automaton is a one-clock\nnondeterministic timed automaton without epsilon transitions and the number of\nclocks of the output deterministic timed automaton is fixed. Again, this is\noptimal: We show that the problem in all the other cases is undecidable, i.e.,\nwhen either (1) the input nondeterministic timed automaton has two clocks or\nmore, or (2) it uses epsilon transitions, or (3) the number of clocks of the\noutput deterministic automaton is not fixed.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.03690v4"
    },
    {
        "title": "Control Synthesis for Parametric Timed Automata under Unavoidability\n  Specifications",
        "authors": [
            "Ebru Aydin Gol"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Timed automata (TA) is used for modeling systems with timing aspects. A TA\nextends a finite automaton with a set of real valued variables called clocks,\nthat measure the time and constraints over the clocks guard the transitions. A\nparametric TA (PTA) is a TA extension that allows parameters in clock\nconstraints. In this paper, we focus on synthesis of a control strategy and\nparameter valuation for a PTA such that each run of the resulting TA reaches a\ntarget location within the given amount of time while avoiding unsafe\nlocations. We propose an algorithm based on depth first analysis combined with\nan iterative feasibility check. The algorithm iteratively constructs a symbolic\nrepresentation of the possible solutions, and employs a feasibility check to\nterminate the exploration along infeasible directions. Once the construction is\ncompleted, a mixed integer linear program is solved for each candidate strategy\nto generate a parameter valuation and a control strategy pair. We present a\nrobotic planning example to motivate the problem and to illustrate the results.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.09154v1"
    },
    {
        "title": "A Congruence-Based Perspective on Finite Tree Automata",
        "authors": [
            "Pierre Ganty",
            "Elena Gutiérrez",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We provide new insights on the determinization and minimization of tree\nautomata using congruences on trees. From this perspective, we study a\nBrzozowski's style minimization algorithm for tree automata. First, we prove\ncorrect this method relying on the following fact: when the automata-based and\nthe language-based congruences coincide, determinizing the automaton yields the\nminimal one. Such automata-based congruences, in the case of word automata, are\ndefined using pre and post operators. Now we extend these operators to tree\nautomata, a task that is particularly challenging due to the reduced expressive\npower of deterministic top-down (or equivalently co-deterministic bottom-up)\nautomata. We leverage further our framework to offer an extension of the\noriginal result by Brzozowski for word automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.11453v3"
    },
    {
        "title": "Resynchronized Uniformization and Definability Problems for Rational\n  Relations",
        "authors": [
            "Christof Löding",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Regular synchronization languages can be used to define rational relations of\nfinite words, and to characterize subclasses of rational relations, like\nautomatic or recognizable relations. We provide a systematic study of the\ndecidability of uniformization and definability problems for subclasses of\nrational relations defined in terms of such synchronization languages. We\nrephrase known results in this setting and complete the picture by adding\nseveral new decidability and undecidability results.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.12508v4"
    },
    {
        "title": "Canonical Automata via Distributive Law Homomorphisms",
        "authors": [
            "Stefan Zetzsche",
            "Gerco van Heerdt",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The classical powerset construction is a standard method converting a\nnon-deterministic automaton into a deterministic one recognising the same\nlanguage. Recently, the powerset construction has been lifted to a more general\nframework that converts an automaton with side-effects, given by a monad, into\na deterministic automaton accepting the same language. The resulting automaton\nhas additional algebraic properties, both in the state space and transition\nstructure, inherited from the monad. In this paper, we study the reverse\nconstruction and present a framework in which a deterministic automaton with\nadditional algebraic structure over a given monad can be converted into an\nequivalent succinct automaton with side-effects. Apart from recovering examples\nfrom the literature, such as the canonical residual finite-state automaton and\nthe \\'atomaton, we discover a new canonical automaton for a regular language by\nrelating the free vector space monad over the two element field to the\nneighbourhood monad. Finally, we show that every regular language satisfying a\nsuitable property parametric in two monads admits a size-minimal succinct\nacceptor.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.13421v6"
    },
    {
        "title": "Formal characterization and efficient verification of a biological\n  robustness property",
        "authors": [
            "Lucia Nasti",
            "Roberta Gori",
            "Paolo Milazzo"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Robustness is an observable property for which a chemical reaction network\n(CRN) can maintain its functionalities despite the influence of different\nperturbations. In general, to verify whether a network is robust, it is\nnecessary to consider all the possible parameter configurations. This is a\nprocess that can entail a massive computational effort. In the work of Rizk et\nal., the authors propose a definition of robustness in linear temporal logic\n(LTL) through which, on the basis of multiple numerical timed traces obtained\nby considering different parameter configurations, they verify the robustness\nof a reaction network. In this paper, we focus on a notion of initial\nconcentration robustness ($\\alpha$-robustness), which is related to the\ninfluence of the perturbation of the initial concentration of one species\n(i.e., the input) on the concentration of another species (i.e., the output) at\nthe steady state. We characterize this notion of robustness in the framework\nproposed by Rizk et al., and we show that, for monotonic reaction networks,\nthis allows us to drastically reduce the number of traces necessary to verify\nrobustness of the CRN.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.13831v1"
    },
    {
        "title": "Pebble transducers with unary output",
        "authors": [
            "Gaëtan Douéneau-Tabot"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Boja\\'nczyk recently initiated an intensive study of deterministic pebble\ntransducers, which are two-way automata that can drop marks (named \"pebbles\")\non their input word, and produce an output word. They describe functions from\nwords to words. Two natural restrictions of this definition have been\ninvestigated: marble transducers by Dou\\'eneau-Tabot et al., and\ncomparison-free pebble transducers (that we rename here \"blind transducers\") by\nNguy\\^en et al.\n  Here, we study the decidability of membership problems between the classes of\nfunctions computed by pebble, marble and blind transducers that produce a unary\noutput. First, we show that pebble and marble transducers have the same\nexpressive power when the outputs are unary (which is false over non-unary\noutputs). Then, we characterize 1-pebble transducers with unary output that\ndescribe a function computable by a blind transducer, and show that the\nmembership problem is decidable. These results can be interpreted in terms of\nautomated simplification of programs.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.14019v6"
    },
    {
        "title": "Guessing the buffer bound for k-synchronizability",
        "authors": [
            "Cinzia Di Giusto",
            "Laetitia Laversa",
            "Etienne Lozes"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A communicating system is $k$-synchronizable if all of the message sequence\ncharts representing the executions can be divided into slices of $k$ sends\nfollowed by $k$ receptions. It was previously shown that, for a fixed given\n$k$, one could decide whether a communicating system is $k$-synchronizable.\nThis result is interesting because the reachability problem can be solved for\n$k$-synchronizable systems. However, the decision procedure assumes that the\nbound $k$ is fixed. In this paper we improve this result and show that it is\npossible to decide if such a bound $k$ exists.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.14408v1"
    },
    {
        "title": "Methodology for Biasing Random Simulation for Rapid Coverage of Corner\n  Cases in AMS Designs",
        "authors": [
            "Sayandeep Sanyal",
            "Ayan Chakraborty",
            "Pallab Dasgupta",
            "Aritra Hazra"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Exploring the limits of an Analog and Mixed Signal (AMS) circuit by driving\nappropriate inputs has been a serious challenge to the industry. Doing an\nexhaustive search of the entire input state space is a time-consuming exercise\nand the returns to efforts ratio is quite low. In order to meet time-to-market\nrequirements, often suboptimal coverage results of an integrated circuit (IC)\nare leveraged. Additionally, no standards have been defined which can be used\nto identify a target in the continuous state space of analog domain such that\nthe searching algorithm can be guided with some heuristics. In this report, we\nelaborate on two approaches for tackling this challenge - one is based on\nfrequency domain analysis of the circuit, while the other applies the concept\nof Bayesian optimization. We have also presented our results by applying the\ntwo approaches on an industrial LDO and a few AMS benchmark circuits.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.14785v1"
    },
    {
        "title": "Long Runs Imply Big Separators in Vector Addition Systems",
        "authors": [
            "Wojciech Czerwiński",
            "Adam Jędrych"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Despite recent progress which settled the complexity of the reachability\nproblem for Vector Addition Systems with States (VASSes) as being\nAckermann-complete we still lack much understanding for that problem. A\nstriking example is the reachability problem for three-dimensional VASSes\n(3-VASSes): it is only known to be PSpace-hard and not known to be elementary.\nOne possible approach which turned out to be successful for many VASS\nsubclasses is to prove that to check reachability it suffices to inspect only\nruns of some bounded length. This approach however has its limitations, it is\nusually hard to design an algorithm substantially faster than the possible size\nof finite reachability sets in that VASS subclass. It motivates a search for\nother techniques, which may be suitable for designing fast algorithms. In 2010\nLeroux has proven that non-reachability between two configurations implies\nseparability of the source from the target by some semilinear set, which is an\ninductive invariant. There can be a reasonable hope that it suffices to look\nfor separators of bounded size, which would deliver an efficient algorithm for\nVASS reachability. In the paper we show that also this approach meets an\nobstacle: in VASSes fulfilling some rather natural conditions existence of only\nlong runs between some configurations implies existence of only big separators\nbetween some other configurations (and in a slightly modified VASS).\nAdditionally we prove that a few known examples of involved VASSes fulfil the\nmentioned conditions. Therefore improving the complexity of the reachability\nproblem (for any subclass) using the separators approach may not be simpler\nthan using the short run approach.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.00052v2"
    },
    {
        "title": "Properties of Graphs Specified by a Regular Language",
        "authors": [
            "Volker Diekert",
            "Henning Fernau",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Traditionally, graph algorithms get a single graph as input, and then they\nshould decide if this graph satisfies a certain property $\\Phi$. What happens\nif this question is modified in a way that we get a possibly infinite family of\ngraphs as an input, and the question is if there is a graph satisfying $\\Phi$\nin the family? We approach this question by using formal languages for\nspecifying families of graphs, in particular by regular sets of words. We show\nthat certain graph properties can be decided by studying the syntactic monoid\nof the specification language $L$ if a certain torsion condition is satisfied.\nThis condition holds trivially if $L$ is regular. More specifically, we use a\nnatural binary encoding of finite graphs over a binary alphabet $\\Sigma$, and\nwe define a regular set $\\mathbb{G}\\subseteq \\Sigma^*$ such that every nonempty\nword $w\\in \\mathbb{G}$ defines a finite and nonempty graph. Also, graph\nproperties can then be syntactically defined as languages over $\\Sigma$. Then,\nwe ask whether the automaton $\\mathcal{A}$ specifies some graph satisfying a\ncertain property~$\\Phi$. Our structural results show that we can answer this\nquestion for all \"typical\" graph properties.\n  In order to show our results, we split $L$ into a finite union of subsets and\nevery subset of this union defines in a natural way a single finite graph $F$\nwhere some edges and vertices are marked. The marked graph in turn defines an\ninfinite graph $F^\\infty$ and therefore the family of finite subgraphs of\n$F^\\infty$ where $F$ appears as an induced subgraph. This yields a geometric\ndescription of all graphs specified by $L$ based on splitting $L$ into finitely\nmany pieces; then using the notion of graph retraction, we obtain an easily\nunderstandable description of the graphs in each piece.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.00436v2"
    },
    {
        "title": "Winning Sets of Regular Languages: Descriptional and Computational\n  Complexity",
        "authors": [
            "Pierre Marcus",
            "Ilkka Törmä"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate certain word-construction games with variable turn orders. In\nthese games, Alice and Bob take turns on choosing consecutive letters of a word\nof fixed length, with Alice winning if the result lies in a predetermined\ntarget language. The turn orders that result in a win for Alice form a binary\nlanguage that is regular whenever the target language is, and we prove some\nupper and lower bounds for its state complexity based on that of the target\nlanguage. We also consider the computational complexity of membership and\nintersection problems of winning sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.00452v1"
    },
    {
        "title": "Deterministic and game separability for regular languages of infinite\n  trees",
        "authors": [
            "Lorenzo Clemente",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We show that it is decidable whether two regular languages of infinite trees\nare separable by a deterministic language, resp., a game language. We consider\ntwo variants of separability, depending on whether the set of priorities of the\nseparator is fixed, or not. In each case, we show that separability can be\ndecided in EXPTIME, and that separating automata of exponential size suffice.\nWe obtain our results by reducing to infinite duration games with\n{\\omega}-regular winning conditions and applying the finite-memory determinacy\ntheorem of B\\\"uchi and Landweber.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.01137v1"
    },
    {
        "title": "Degrees of Restriction for Two-Dimensional Automata",
        "authors": [
            "Taylor J. Smith",
            "Kai Salomaa"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A three-way (resp., two-way) two-dimensional automaton has a read-only input\nhead that moves in three (resp., two) directions on a finite array of cells\nlabelled by symbols of the input alphabet. Restricting the input head movement\nof a two-dimensional automaton results in a model that is weaker in terms of\nrecognition power.\n  In this paper, we introduce the notion of \"degrees of restriction\" for\ntwo-dimensional automata, and we develop sets of extended two-dimensional\nautomaton models that allow for some bounded number of restricted moves. We\nestablish recognition hierarchies for both deterministic and nondeterministic\nextended three-way two-dimensional automata, and we find similar hierarchies\nfor both deterministic and nondeterministic extended two-way two-dimensional\nautomata. We also prove incomparability results between nondeterministic and\ndeterministic extended three-way two-dimensional automata. Lastly, we consider\nclosure properties for some operations on languages recognized by extended\nthree-way two-dimensional automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.01179v1"
    },
    {
        "title": "Environment Modeling During Model Checking of Cyber-Physical Systems",
        "authors": [
            "Guangyao Chen",
            "Zhihao Jiang"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Ensuring the safety and efficacy of Cyber-Physical Systems (CPSs) is\nchallenging due to the large variability of their operating environment. Model\nchecking has been proposed for validation of CPSs, but the models of the\nenvironment are either too specific to capture the variability of the\nenvironment, or too abstract to provide counter-examples interpretable by\nexperts in the application domain. Domain-specific solutions to this problem\nrequire expertise in both formal methods and the application domain, which\nprevents effective application of model checking in CPSs validation. A\ndomain-independent framework based on timed-automata is proposed for\nabstraction and refinement of environment models during model checking. The\nframework maintains an abstraction tree of environment models, which provides\ninterpretable counter-examples while ensuring coverage of environment\nbehaviors. With the framework, experts in the application domain can\neffectively use model checking without expertise in formal methods.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.01236v1"
    },
    {
        "title": "Petri Net Invariant Synthesis",
        "authors": [
            "Peter Chini",
            "Florian Furbach"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the synthesis of inductive half spaces (IHS). These are linear\ninequalities that form inductive invariants for Petri nets, capable of\ndisproving reachability or coverability. IHS generalize classic notions of\ninvariants like traps or siphons. Their synthesis is desirable for disproving\nreachability or coverability where traditional invariants may fail.\n  We formulate a CEGAR-loop for the synthesis of IHS. The first step is to\nestablish a structure theory of IHS. We analyze the space of IHS with methods\nfrom discrete mathematics and derive a linear constraint system closely\nover-approximating the space. To discard false positives, we provide an\nalgorithm that decides whether a given half space is indeed inductive, a\nproblem that we prove to be coNP-complete. We implemented the CEGAR-loop in the\ntool INEQUALIZER and our experiments show that it is competitive against\nstate-of-the-art techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.03096v1"
    },
    {
        "title": "Parallel Sandpiles or Spurious Bidirectional Icepiles?",
        "authors": [
            "Gianpiero Cattaneo",
            "Luca Manzoni"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In a recent paper E. Formenti and K. Perrot (FP) introduce a global rule\nassumed to describe the discrete time dynamics associated with a sandpile model\nunder the parallel application of a suitable local rule acting on d dimensional\nlattices of cells equipped with uniform neighborhood. In this paper we submit\nthis approach to a critical analysis, in the simplest elementary particular\ncase of a one-dimensional lattice, which can be divided in two parts. In the\nfirst part we prove that the FP global rule does not describe the dynamics of\nstandard sandpiles, but rather furnishes a description of the quite different\nsituation of height difference between consecutive piles. This is a semantic\nuncorrect difference of interpretation. In the second part we investigate the\nconsequences of the uncorrect FP assumption proving that their global rule\ndescribes a bidirectional spurious dynamics of icepiles (rather than\nsandpiles), in the sense that this latter is the consequence of application of\nthree local rules: bidirectional vertical rule, bidirectional horizontal rule\n(typical of icepiles), and a granule jump from the bottom to the top (spurious\nrule of the dynamics).\n",
        "pdf_link": "http://arxiv.org/pdf/2105.04308v3"
    },
    {
        "title": "Policy Synthesis for Metric Interval Temporal Logic with Probabilistic\n  Distributions",
        "authors": [
            "Lening Li",
            "Jie Fu"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Metric Temporal Logic can express temporally evolving properties with\ntime-critical constraints or time-triggered constraints for real-time systems.\nThis paper extends the Metric Interval Temporal Logic with a distribution\neventuality operator to express time-sensitive missions for a system\ninteracting with a dynamic, probabilistic environment. This formalism enables\nus to describe the probabilistic occurrences of random external events as part\nof the task specification and event-triggered temporal constraints for the\nintended system's behavior. The main contributions of this paper are two folds:\nFirst, we propose a procedure to translate a specification into a stochastic\ntimed automaton. Second, we develop an approximate-optimal probabilistic\nplanning problem for synthesizing the control policy that maximizes the\nprobability for the planning agent to achieve the task, provided that the\nexternal events satisfy the specification. The planning algorithm employs a\ntruncation in the clocks for the timed automaton to reduce the planning in a\ncountably infinite state space to a finite state space with a bounded error\nguarantee. We illustrate the method with a robot motion planning example.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.04593v1"
    },
    {
        "title": "On Complementing Unambiguous Automata and Graphs With Many Cliques and\n  Cocliques",
        "authors": [
            "Emil Indzhev",
            "Stefan Kiefer"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We show that for any unambiguous finite automaton with $n$ states there\nexists an unambiguous finite automaton with $\\sqrt{n+1} \\cdot 2^{n/2}$ states\nthat recognizes the complement language. This builds and improves upon a\nsimilar result by Jir\\'asek et al. [Int. J. Found. Comput. Sci. 29 (5) (2018)].\nOur improvement is based on a reduction to and an analysis of a problem from\nextremal graph theory: we show that for any graph with $n$ vertices, the\nproduct of the number of its cliques with the number of its cocliques\n(independent sets) is bounded by $(n+1) 2^n$.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.07470v2"
    },
    {
        "title": "Comparison-free polyregular functions",
        "authors": [
            "Lê Thành Dũng Tito Nguyên",
            "Camille Noûs",
            "Cécilia Pradic"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This paper introduces a new automata-theoretic class of string-to-string\nfunctions with polynomial growth. Several equivalent definitions are provided:\na machine model which is a restricted variant of pebble transducers, and a few\ninductive definitions that close the class of regular functions under certain\noperations. Our motivation for studying this class comes from another\ncharacterization, which we merely mention here but prove elsewhere, based on a\n$\\lambda$-calculus with a linear type system.As their name suggests, these\ncomparison-free polyregular functions form a subclass of polyregular functions;\nwe prove that the inclusion is strict. We also show that they are incomparable\nwith HDT0L transductions, closed under usual function composition -- but not\nunder a certain ``map'' combinator -- and satisfy a comparison-free version of\nthe pebble minimization theorem.On the broader topic of polynomial growth\ntransductions, we also consider the recently introduced layered streaming\nstring transducers (SSTs), or equivalently k-marble transducers. We prove that\na function can be obtained by composing such transducers together if and only\nif it is polyregular, and that k-layered SSTs (or k-marble transducers) are\nclosed under ``map'' and equivalent to a corresponding notion of (k+1)-layered\nHDT0L systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.08358v2"
    },
    {
        "title": "The Černy Conjecture for aperiodic automata",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A word w is called a synchronizing (recurrent, reset) word of a deterministic\nfinite automaton (DFA) if w brings all states of the automaton to some state; a\nDFA that has a synchronizing word is said to be synchronizing. Cerny\nconjectured in 1964 that every n-state synchronizing DFA possesses a\nsynchronizing word of length at most (n -1)2. We consider automaton with\naperiodic transition monoid (such automaton is called aperiodic). We show that\nevery synchronizing n-state aperiodic automaton has a synchronizing word of\nlength at most n(n-2)+1. Thus, for aperiodic automaton as well as for\nautomatons accepting only star-free languages, the Cerny conjecture holds true.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.09105v1"
    },
    {
        "title": "Conelikes and Ranker Comparisons",
        "authors": [
            "Viktor Henriksson",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  For every fixed class of regular languages, there is a natural hierarchy of\nincreasingly more general problems: Firstly, the membership problem asks\nwhether a given language belongs to the fixed class of languages. Secondly, the\nseparation problem asks for two given languages whether they can be separated\nby a language from the fixed class. And thirdly, the covering problem is a\ngeneralization of separation problem to more than two given languages. Most\ninstances of such problems were solved by the connection of regular languages\nand finite monoids. Both the membership problem and the separation problem were\nalso extended to ordered monoids. The computation of pointlikes can be\ninterpreted as the algebraic counterpart of the covering problem. In this\npaper, we consider the extension the computation of pointlikes to ordered\nmonoids. This leads to the notion of conelikes for the corresponding algebraic\nframework.\n  We apply this framework to the Trotter-Weil hierarchy and both the full and\nthe half levels of the $\\text{FO}^2$ quantifier alternation hierarchy. As a\nconsequence, we solve the covering problem for the resulting subvarieties of\n$\\mathbf{DA}$. An important combinatorial tool are uniform ranker\ncharacterizations for all subvarieties under consideration; these\ncharacterizations stem from order comparisons of ranker positions.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.09346v2"
    },
    {
        "title": "Forest languages defined by counting maximal paths",
        "authors": [
            "Martin Beaudry"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A leaf path language is a Boolean combination of sets of the form\n$\\mathsf{{}^mE}^k L$, with $k \\ge 1$ and $L$ a regular word language, which\nconsist of those forests where the node labels in at least $k$ leaf-to-root\npaths make up a word that belongs to $L$. We look at the class $\\mathsf{*D}$ of\nthe languages recognized by iterated wreath products of syntactic algebras of\nleaf path languages. We prove the existence of an algorithm that, given a\nregular forest language, returns in finite time a sequence of such algebras;\ntheir wreath product is divided by the language's syntactic algebra if, and\nonly if this language belongs to $\\mathsf{*D}$, which makes membership in this\nclass a decidable question. The result also applies to the subclasses\n$\\mathsf{PDL}$ and $\\mathsf{CTL^*}$.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.09970v2"
    },
    {
        "title": "A Generic Solution to Register-bounded Synthesis with an Application to\n  Discrete Orders",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study synthesis of reactive systems interacting with environments using an\ninfinite data domain. A popular formalism for specifying and modelling such\nsystems is register automata and transducers. They extend finite-state automata\nby adding registers to store data values and to compare the incoming data\nvalues against stored ones. Synthesis from nondeterministic or universal\nregister automata is undecidable in general. However, its register-bounded\nvariant, where additionally a bound on the number of registers in a sought\ntransducer is given, is known to be decidable for universal register automata\nwhich can compare data for equality, i.e., for data domain (N,=). This paper\nextends the decidability border to the domain (N,<) of natural numbers with\nlinear order. Our solution is generic: we define a sufficient condition on data\ndomains (regular approximability) for decidability of register-bounded\nsynthesis. The condition is satisfied by natural data domains like (N,<). It\nallows one to use simple language-theoretic arguments and avoid technical\ngame-theoretic reasoning. Further, by defining a generic notion of reducibility\nbetween data domains, we show the decidability of synthesis in the domain\n(N^d,<^d) of tuples of numbers equipped with the component-wise partial order\nand in the domain (\\Sigma^*,\\prec) of finite strings with the prefix relation.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.09978v4"
    },
    {
        "title": "Minimization and Synthesis of the Tail in Sequential Compositions of\n  Mealy Machines",
        "authors": [
            "Alberto Larrauri",
            "Roderick Bloem"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We consider a system consisting of a sequential composition of Mealy\nmachines, called head and tail. We study two problems related to these systems.\nIn the first problem, models of both head and tail components are available,\nand the aim is to obtain a replacement for the tail with the minimum number of\nstates. We introduce a minimization method for this context which yields an\nexponential improvement over the state of the art. In the second problem, only\nthe head is known, and a desired model for the whole system is given. The\nobjective is to construct a tail that causes the system to behave according to\nthe given model. We show that, while it is possible to decide in polynomial\ntime whether such a tail exists, there are instances where its size is\nexponential in the sizes of the head and the desired system. This shows that\nthe complexity of the synthesis procedure is at least exponential, matching the\nupper bound in complexity provided by the existing methods for solving unknown\ncomponent equations.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.10292v2"
    },
    {
        "title": "An algorithm to verify local threshold testability of deterministic\n  finite automata",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A locally threshold testable language L is a language with the property that\nfor some non negative integers k and l, whether or not a word u is in the\nlanguage L depends on (1) the prefix and suffix of the word u of length k > 1\nand (2) the set of intermediate substrings of length k of the word u where the\nsets of substrings occurring at least j times are the same, for j <= L. For\ngiven k and L the language is called l-threshold k-testable. A finite\ndeterministic automaton is called l-threshold k-testable if the automaton\naccepts a l-threshold k-testable language. In this paper, the necessary and\nsufficient conditions for an automaton to be locally threshold testable are\nfound. We introduce the first polynomial time algorithm to verify local\nthreshold testability of the automaton based on this characterization. New\nversion of polynomial time algorithm to verify the local testability will be\npresented too.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.10654v1"
    },
    {
        "title": "Asynchronous wreath product and cascade decompositions for concurrent\n  behaviours",
        "authors": [
            "Bharat Adsul",
            "Paul Gastin",
            "Saptarshi Sarkar",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We develop new algebraic tools to reason about concurrent behaviours modelled\nas languages of Mazurkiewicz traces and asynchronous automata. These tools\nreflect the distributed nature of traces and the underlying causality and\nconcurrency between events, and can be said to support true concurrency. They\ngeneralize the tools that have been so efficient in understanding, classifying\nand reasoning about word languages. In particular, we introduce an asynchronous\nversion of the wreath product operation and we describe the trace languages\nrecognized by such products (the so-called asynchronous wreath product\nprinciple). We then propose a decomposition result for recognizable trace\nlanguages, analogous to the Krohn-Rhodes theorem, and we prove this\ndecomposition result in the special case of acyclic architectures. Finally, we\nintroduce and analyze two distributed automata-theoretic operations. One, the\nlocal cascade product, is a direct implementation of the asynchronous wreath\nproduct operation. The other, global cascade sequences, although conceptually\nand operationally similar to the local cascade product, translates to a more\ncomplex asynchronous implementation which uses the gossip automaton of Mukund\nand Sohoni. This leads to interesting applications to the characterization of\ntrace languages definable in first-order logic: they are accepted by a\nrestricted local cascade product of the gossip automaton and 2-state\nasynchronous reset automata, and also by a global cascade sequence of 2-state\nasynchronous reset automata. Over distributed alphabets for which the\nasynchronous Krohn-Rhodes theorem holds, a local cascade product of such\nautomata is sufficient and this, in turn, leads to the identification of a\nsimple temporal logic which is expressively complete for such alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.10897v5"
    },
    {
        "title": "Automata Learning for Automated Test Generation of Real Time\n  Localization Systems",
        "authors": [
            "Swantje Plambeck",
            "Jakob Schyga",
            "Johannes Hinckeldeyn",
            "Jochen Kreutzfeldt",
            "Görschwin Fey"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Cyber Physical Systems (CPSs) are often black box systems for which no exact\nmodel exists. Automata learning allows to build abstract models of CPSs and is\nused in several scenarios, i.e. simulation, monitoring, and test case\ngeneration. Real time localization systems (RTLSs) are an example of\nparticularly complex and often safety critical CPSs. We present a procedure for\nautomatic test case generation with automata learning and apply this approach\nin a case study to a localization system.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.11911v1"
    },
    {
        "title": "On the Minimisation of Transition-Based Rabin Automata and the Chromatic\n  Memory Requirements of Muller Conditions",
        "authors": [
            "Antonio Casares"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we relate the problem of determining the chromatic memory\nrequirements of Muller conditions with the minimisation of transition-based\nRabin automata. Our first contribution is a proof of the NP-completeness of the\nminimisation of transition-based Rabin automata. Our second contribution\nconcerns the memory requirements of games over graphs using Muller conditions.\nA memory structure is a finite state machine that implements a strategy and is\nupdated after reading the edges of the game; the special case of chromatic\nmemories being those structures whose update function only consider the colours\nof the edges. We prove that the minimal amount of chromatic memory required in\ngames using a given Muller condition is exactly the size of a minimal Rabin\nautomaton recognising this condition. Combining these two results, we deduce\nthat finding the chromatic memory requirements of a Muller condition is\nNP-complete. This characterisation also allows us to prove that chromatic\nmemories cannot be optimal in general, disproving a conjecture by Kopczy\\'nski.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.12009v3"
    },
    {
        "title": "A package TESTAS for checking some kinds of testability",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We implement a set of procedures for deciding whether or not a language given\nby its minimal automaton or by its syntactic semigroup is locally testable,\nright or left locally testable, threshold locally testable, strictly locally\ntestable, or piecewise testable. The bounds on order of local testability of\ntransition graph and order of local testability of transition semigroup are\nalso found. For given k, the k-testability of transition graph is verified.\nSome new effective polynomial time algorithms are used. These algorithms have\nbeen implemented as a C/C++ package.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.12583v1"
    },
    {
        "title": "Adapting Behaviors via Reactive Synthesis",
        "authors": [
            "Gal Amram",
            "Suguman Bansal",
            "Dror Fried",
            "Lucas M. Tabajara",
            "Moshe Y. Vardi",
            "Gera Weiss"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In the \\emph{Adapter Design Pattern}, a programmer implements a \\emph{Target}\ninterface by constructing an \\emph{Adapter} that accesses an existing\n\\emph{Adaptee} code. In this work, we present a reactive synthesis\ninterpretation to the adapter design pattern, wherein an algorithm takes an\n\\emph{Adaptee} and a \\emph{Target} transducers, and the aim is to synthesize an\n\\emph{Adapter} transducer that, when composed with the {\\em Adaptee}, generates\na behavior that is equivalent to the behavior of the {\\em Target}. One use of\nsuch an algorithm is to synthesize controllers that achieve similar goals on\ndifferent hardware platforms. While this problem can be solved with existing\nsynthesis algorithms, current state-of-the-art tools fail to scale. To cope\nwith the computational complexity of the problem, we introduce a special form\nof specification format, called {\\em Separated GR($k$)}, which can be solved\nwith a scalable synthesis algorithm but still allows for a large set of\nrealistic specifications. We solve the realizability and the synthesis problems\nfor Separated GR($k$), and show how to exploit the separated nature of our\nspecification to construct better algorithms, in terms of time complexity, than\nknown algorithms for GR($k$) synthesis. We then describe a tool, called\nSGR($k$), that we have implemented based on the above approach and show, by\nexperimental evaluation, how our tool outperforms current state-of-the-art\ntools on various benchmarks and test-cases.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.13837v1"
    },
    {
        "title": "Definability Results for Top-Down Tree Transducers",
        "authors": [
            "Sebastian Maneth",
            "Helmut Seidl",
            "Martin Vu"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We prove that for a given deterministic top-down transducer with look-ahead\nit is decidable whether or not its translation is definable (1)~by a linear\ntop-down tree transducer or (2)~by a tree homomorphism. We present algorithms\nthat construct equivalent such transducers if they exist.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.14860v1"
    },
    {
        "title": "A new distance based on minimal absent words and applications to\n  biological sequences",
        "authors": [
            "Giuseppa Castiglione",
            "Jia Gao",
            "Sabrina Mantaci",
            "Antonio Restivo"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A minimal absent word of a sequence x, is a sequence yt hat is not a factorof\nx, but all of its proper factors are factors of x as well. The set of minimal\nabsent words uniquely defines the sequence itself. In recent times minimal\nabsent words have been used in order to compare sequences. In fact, to do this,\none can compare the sets of their minimal absent words. Chairungasee and\nCrochemorein [2] define a distance between pairs of sequences x and y, where\nthe symmetric difference of the sets of minimal absent words of x and y is\ninvolved. Here, weconsider a different distance, introduced in [1], based on a\nspecific subset of such symmetric difference that, in our opinion, better\ncapture the different features ofthe considered sequences. We show the result\nof some experiments where the distance is tested on a dataset of genetic\nsequences by 11 living species, in order to compare the new distance with the\nones existing in literature.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.14990v1"
    },
    {
        "title": "Ordering regular languages: a danger zone",
        "authors": [
            "Giovanna D'Agostino",
            "Davide Martincigh",
            "Alberto Policriti"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Ordering the collection of states of a given automaton starting from an order\nof the underlying alphabet is a natural move towards a computational treatment\nof the language accepted by the automaton. Along this path, Wheeler\n\\emph{graphs} have been recently introduced as an extension/adaptation of the\nBurrows-Wheeler Transform (the now famous BWT, originally defined on strings)\nto graphs. These graphs constitute an important data-structure for languages,\nsince they allow a very efficient storage mechanism for the transition function\nof an automaton, while providing a fast support to all sorts of substring\nqueries. This is possible as a consequence of a property -- the so-called\n\\emph{path coherence} -- valid on Wheeler graphs and consisting in an ordering\non nodes that \"propagates\" to (collections of) strings. By looking at a Wheeler\ngraph as an automaton, the ordering on strings corresponds to the\nco-lexicographic order of the words entering each state. This leads naturally\nto consider the class of regular languages accepted by Wheeler automata, i.e.\nthe Wheeler languages.\n  It has been shown that, as opposed to the general case, the classic\ndeterminization by powerset construction is polynomial on Wheeler languages. As\na consequence, most of the classical problems turn out to be \"easy\" -- that is,\nsolvable in polynomial time -- on Wheeler languages. Moreover, deciding whether\na DFA is Wheeler and deciding whether a DFA accepts a Wheeler language is\npolynomial.\n  Our contribution here is to put an upper bound to easy problems. For\ninstance, whenever we generalize by switching to general NFAs or by not fixing\nan order of the underlying alphabet, the above mentioned problems become \"hard\"\n-- that is NP-complete or even PSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.00315v3"
    },
    {
        "title": "The Inclusion Problem for Forest Languages under Substitutions",
        "authors": [
            "Marcial Gaißert",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We consider algorithms and lower bounds for various problems over forest\nlanguages; as input models we allow forest algebras, deterministic forest\nautomata and nondeterministic forest automata. For the equivalence problem, we\ngive an almost-linear-time algorithm for both forest algebras and deterministic\nforest automata; this is complemented by a polynomial time hardness result. The\nemptiness problem is complete for polynomial time over each of the three\nmodels. Additionally, we consider the emptiness of intersection problem for\nforest algebras and deterministic forest automata; this problem turns out to be\ncomplete for exponential time. It is well-known that the corresponding problems\nfor word languages are complete for nondeterministic logarithmic space and for\npolynomial space, respectively.\n  Equipped with this toolbox of algorithms and lower bounds, we consider\nvarious inclusion problems for regular forest languages under substitutions.\nThe substitutions in this paper replace leaf variables by forest languages.\nDepending on the direction of the inclusion, the problem for a given\nsubstitution is either complete for polynomial time or for exponential time; in\nparticular, the equivalence problem under substitutions is complete for\nexponential time and, hence, more difficult than the equivalence problem for\nforest languages without substitutions. If we ask whether there exists a\nsubstitution such that a given inclusion holds, then this problem is either\ncomplete for NP or exponential time, depending on whether we consider inclusion\nor equivalence; moreover, the problem is undecidable if the substitution is\napplied on both sides.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.02571v1"
    },
    {
        "title": "Generalized Linear One-Way Jumping Finite Automata",
        "authors": [
            "Ujjwal Kumar Mishra",
            "Kalpana Mahalingam",
            "Rama Raghavan"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A new discontinuous model of computation called one-way jumping finite\nautomata was defined by H. Chigahara et. al. This model was a restricted\nversion of the model jumping finite automata. These automata read an input\nsymbol-by-symbol and jump only in one direction. A generalized linear one-way\njumping finite automaton makes jumps after deleting a substring of an input\nstring and then changes its state. These automata can make sequence of jumps in\nonly one direction on an input string either from left to right or from right\nto left. We show that newly defined model is powerful than its original\ncounterpart. We define and compare the variants, generalized right linear\none-way jumping finite automata and generalized left linear one-way jumping\nfinite automata. We also compare the newly defined models with Chomsky\nhierarchy. Finally, we explore closure properties of the model.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.02937v1"
    },
    {
        "title": "Reduction Using Induced Subnets To Systematically Prove Properties For\n  Free-Choice Nets",
        "authors": [
            "Wil M. P. van der Aalst"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We use sequences of t-induced T-nets and p-induced P-nets to convert\nfree-choice nets into T-nets and P-nets while preserving properties such as\nwell-formedness, liveness, lucency, pc-safety, and perpetuality. The approach\nis general and can be applied to different properties. This allows for more\nsystematic proofs that \"peel off\" non-trivial parts while retaining the essence\nof the problem (e.g., lifting properties from T-net and P-net to free-choice\nnets).\n",
        "pdf_link": "http://arxiv.org/pdf/2106.03658v2"
    },
    {
        "title": "Generalized Circular One-Way Jumping Finite Automata",
        "authors": [
            "Ujjwal Kumar Mishra",
            "Kalpana Mahalingam",
            "Rama Raghavan"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A discontinuous model of computation called one-way jumping finite automata\nwas defined by H. Chigahara et. al. This model was a restricted version of the\nmodel jumping finite automata. One-way jumping finite automata change their\nstates after deleting a letter of an input and jump only in one direction.\nAllowing a state to delete a subword instead of a letter, we define a new model\ngeneralized circular one-way jumping finite automata. These automata work on an\ninput in a circular manner. Similar to one-way jumping finite automata,\ngeneralized circular one-way jumping finite automata also jump only in one\ndirection. We show that this newly defined model is powerful than one-way\njumping finite automata. We define new variants(right and left) of the model\ngeneralized circular one-way jumping finite automata and compare them. We also\ncompare the newly defined model with Chomsky hierarchy. Finally, we explore\nclosure properties of the model.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.03852v1"
    },
    {
        "title": "Automatic winning shifts",
        "authors": [
            "Jarkko Peltomäki",
            "Ville Salo"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  To each one-dimensional subshift $X$, we may associate a winning shift $W(X)$\nwhich arises from a combinatorial game played on the language of $X$.\nPreviously it has been studied what properties of $X$ does $W(X)$ inherit. For\nexample, $X$ and $W(X)$ have the same factor complexity and if $X$ is a sofic\nsubshift, then $W(X)$ is also sofic. In this paper, we develop a notion of\nautomaticity for $W(X)$, that is, we propose what it means that a vector\nrepresentation of $W(X)$ is accepted by a finite automaton.\n  Let $S$ be an abstract numeration system such that addition with respect to\n$S$ is a rational relation. Let $X$ be a subshift generated by an $S$-automatic\nword. We prove that as long as there is a bound on the number of nonzero\nsymbols in configurations of $W(X)$ (which follows from $X$ having sublinear\nfactor complexity), then $W(X)$ is accepted by a finite automaton, which can be\neffectively constructed from the description of $X$. We provide an explicit\nautomaton when $X$ is generated by certain automatic words such as the\nThue-Morse word.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.07249v2"
    },
    {
        "title": "The Connection between Process Complexity of Event Sequences and Models\n  discovered by Process Mining",
        "authors": [
            "Adriano Augusto",
            "Jan Mendling",
            "Maxim Vidgof",
            "Bastian Wurm"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Process mining is a research area focusing on the design of algorithms that\ncan automatically provide insights into business processes. Among the most\npopular algorithms are those for automated process discovery, which have the\nultimate goal to generate a process model that summarizes the behavior recorded\nin an event log. Past research had the aim to improve process discovery\nalgorithms irrespective of the characteristics of the input log. In this paper,\nwe take a step back and investigate the connection between measures capturing\ncharacteristics of the input event log and the quality of the discovered\nprocess models. To this end, we review the state-of-the-art process complexity\nmeasures, propose a new process complexity measure based on graph entropy, and\nanalyze this set of complexity measures on an extensive collection of event\nlogs and corresponding automatically discovered process models. Our analysis\nshows that many process complexity measures correlate with the quality of the\ndiscovered process models, demonstrating the potential of using complexity\nmeasures as predictors of process model quality. This finding is important for\nprocess mining research, as it highlights that not only algorithms, but also\nconnections between input data and output quality should be studied.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.07990v2"
    },
    {
        "title": "Posets with Interfaces as a Model for Concurrency",
        "authors": [
            "Uli Fahrenberg",
            "Christian Johansen",
            "Georg Struth",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce posets with interfaces (iposets) and generalise their standard\nserial composition to a new gluing composition. In the partial order semantics\nof concurrency, interfaces and gluing allow modelling events that extend in\ntime and across components. Alternatively, taking a decompositional view,\ninterfaces allow cutting through events, while serial composition may only cut\nthrough edges of a poset. We show that iposets under gluing composition form a\ncategory, which generalises the monoid of posets under serial composition up to\nisomorphism. They form a 2-category when a subsumption order and a lax tensor\nin the form of a non-commutative parallel composition are added, which\ngeneralises the interchange monoids used for modelling series-parallel posets.\nWe also study the gluing-parallel hierarchy of iposets, which generalises the\nstandard series-parallel one. The class of gluing-parallel iposets contains\nthat of series-parallel posets and the class of interval orders, which are well\nstudied in concurrency theory, too. We also show that it is strictly contained\nin the class of all iposets by identifying several forbidden substructures.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.10895v2"
    },
    {
        "title": "The degree of a finite set of words",
        "authors": [
            "Dominique Perrin",
            "Andrew Ryzhikov"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We prove several results concerning finitely generated submonoids of the free\nmonoid. These results generalize those known for free submonoids. We prove in\nparticular that if $X=Y\\circ Z$ is a composition of finite sets of words with\n$Y$ complete, then $d(X)\\le d(Y)d(Z)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.14471v2"
    },
    {
        "title": "A Set Automaton to Locate All Pattern Matches in a Term",
        "authors": [
            "Rick Erkens",
            "Jan Friso Groote"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Term pattern matching is the problem of finding all pattern matches in a\nsubject term, given a set of patterns. Finding efficient algorithms for this\nproblem is an important direction for research [19]. We present a new set\nautomaton solution for the term pattern matching problem that is based on match\nset derivatives where each function symbol in the subject pattern is visited\nexactly once. The algorithm allows for various traversal patterns over the\nsubject term and is particularly suited to search the subject term in parallel.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.15311v1"
    },
    {
        "title": "Finite-image property of weighted tree automata over past-finite\n  monotonic strong bimonoids",
        "authors": [
            "Manfred Droste",
            "Zoltán Fülöp",
            "Dávid Kószó",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We consider weighted tree automata over strong bimonoids (for short: wta). A\nwta $\\mathcal{A}$ has the finite-image property if its recognized weighted tree\nlanguage $[\\![\\mathcal{A}]\\!]$ has finite image; moreover, $\\mathcal{A}$ has\nthe preimage property if the preimage under $[\\![\\mathcal{A}]\\!]$ of each\nelement of the underlying strong bimonoid is a recognizable tree language. For\neach wta $\\mathcal{A}$ over a past-finite monotonic strong bimonoid we prove\nthe following results. In terms of $\\mathcal{A}$'s structural properties, we\ncharacterize whether it has the finite-image property. We characterize those\npast-finite monotonic strong bimonoids such that for each wta $\\mathcal{A}$ it\nis decidable whether $\\mathcal{A}$ has the finite-image property. In\nparticular, the finite-image property is decidable for wta over past-finite\nmonotonic semirings. Moreover, we prove that $\\mathcal{A}$ has the preimage\nproperty. All our results also hold for weighted string automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.15867v1"
    },
    {
        "title": "Determinization and Limit-determinization of Emerson-Lei automata",
        "authors": [
            "Tobias John",
            "Simon Jantsch",
            "Christel Baier",
            "Sascha Klüppelholz"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the problem of determinizing $\\omega$-automata whose acceptance\ncondition is defined on the transitions using Boolean formulas, also known as\ntransition-based Emerson-Lei automata (TELA). The standard approach to\ndeterminize TELA first constructs an equivalent generalized B\\\"uchi automaton\n(GBA), which is later determinized. We introduce three new ways of translating\nTELA to GBA. Furthermore, we give a new determinization construction which\ndeterminizes several GBA separately and combines them using a product\nconstruction. An experimental evaluation shows that the product approach is\ncompetitive when compared with state-of-the-art determinization procedures. We\nalso study limit-determinization of TELA and show that this can be done with a\nsingle-exponential blow-up, in contrast to the known double-exponential\nlower-bound for determinization. Finally, one version of the\nlimit-determinization procedure yields good-for-MDP automata which can be used\nfor quantitative probabilistic model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.15892v1"
    },
    {
        "title": "Improved constructions for succinct affine automata",
        "authors": [
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Affine finite automata (AfA) can be more succinct than probabilistic and\nquantum finite automata when recognizing some regular languages with\nbounded-error. In this paper, we improve previously known constructions given\nfor the succinctness of AfAs in three ways. First, we replace some of fixed\nerror bounds with arbitrarily small error bounds. Second, we present new\nconstructions by using less states than the previous constructions. Third, we\nshow that any language recognized by a nondeterministic finite automaton (NFA)\nis also recognized by bounded-error AfAs having one more state, and so, AfAs\ninherit all succinct results by NFAs. As a special case, we also show that any\nlanguage recognized by a NFA is recognized by AfAs with zero error if the\nnumber of accepting path(s) for each member is exactly the same number.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.16197v1"
    },
    {
        "title": "Certifying DFA Bounds for Recognition and Separation",
        "authors": [
            "Orna Kupferman",
            "Nir Lavee",
            "Salomon Sickert"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The automation of decision procedures makes certification essential. We\nsuggest to use determinacy of turn-based two-player games with regular winning\nconditions in order to generate certificates for the number of states that a\ndeterministic finite automaton (DFA) needs in order to recognize a given\nlanguage. Given a language $L$ and a bound $k$, recognizability of $L$ by a DFA\nwith $k$ states is reduced to a game between Prover and Refuter. The\ninteraction along the game then serves as a certificate. Certificates generated\nby Prover are minimal DFAs. Certificates generated by Refuter are faulty\nattempts to define the required DFA. We compare the length of offline\ncertificates, which are generated with no interaction between Prover and\nRefuter, and online certificates, which are based on such an interaction, and\nare thus shorter. We show that our approach is useful also for certification of\nseparability of regular languages by a DFA of a given size. Unlike DFA\nminimization, which can be solved in polynomial time, separation is\nNP-complete, and thus the certification approach is essential. In addition, we\nprove NP-completeness of a strict version of separation.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.01566v1"
    },
    {
        "title": "Decision problems for origin-close top-down tree transducers (full\n  version)",
        "authors": [
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Tree transductions are binary relations of finite trees. For tree\ntransductions defined by non-deterministic top-down tree transducers,\ninclusion, equivalence and synthesis problems are known to be undecidable.\nAdding origin semantics to tree transductions, i.e., tagging each output node\nwith the input node it originates from, is a known way to recover decidability\nfor inclusion and equivalence. The origin semantics is rather rigid, in this\nwork, we introduce a similarity measure for transducers with origin semantics\nand show that we can decide inclusion, equivalence and synthesis problems for\norigin-close non-deterministic top-down tree transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.02591v1"
    },
    {
        "title": "Deciding Top-Down Determinism of Regular Tree Languages",
        "authors": [
            "Peter Leupold",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  It is well known that for a regular tree language it is decidable whether or\nnot it can be recognized by a deterministic top-down tree automaton (DTA).\nHowever, the computational complexity of this problem has not been studied. We\nshow that for a given deterministic bottom-up tree automaton it can be decided\nin quadratic time whether or not its language can be recognized by a DTA. Since\nthere are finite tree languages that cannot be recognized by DTAs, we also\nconsider finite unions of \\DTAs and show that also here, definability within\ndeterministic bottom-up tree automata is decidable in quadratic time.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.03174v1"
    },
    {
        "title": "Nominal Büchi Automata with Name Allocation",
        "authors": [
            "Henning Urbat",
            "Daniel Hausmann",
            "Stefan Milius",
            "Lutz Schröder"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Infinite words over infinite alphabets serve as models of the temporal\ndevelopment of the allocation and (re-)use of resources over linear time. We\napproach omega-languages over infinite alphabets in the setting of nominal\nsets, and study languages of infinite bar strings, i.e. infinite sequences of\nnames that feature binding of fresh names; binding corresponds roughly to\nreading letters from input words in automata models with registers. We\nintroduce regular nominal nondeterministic B\\\"uchi automata (B\\\"uchi RNNAs), an\nautomata model for languages of infinite bar strings, repurposing the\npreviously introduced RNNAs over finite bar strings. Our machines feature\nexplicit binding (i.e. resource-allocating) transitions and process their input\nvia a B\\\"uchi-type acceptance condition. They emerge from the abstract\nperspective on name binding given by the theory of nominal sets. As our main\nresult we prove that, in contrast to most other nondeterministic automata\nmodels over infinite alphabets, language inclusion of B\\\"uchi RNNAs is\ndecidable and in fact elementary. This makes B\\\"uchi RNNAs a suitable tool for\napplications in model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.03213v2"
    },
    {
        "title": "Syntactic Minimization of Nondeterministic Finite Automata",
        "authors": [
            "Robert Samuel Ralph Myers",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Nondeterministic automata may be viewed as succinct programs implementing\ndeterministic automata, i.e. complete specifications. Converting a given\ndeterministic automaton into a small nondeterministic one is known to be\ncomputationally very hard; in fact, the ensuing decision problem is\nPSPACE-complete. This paper stands in stark contrast to the status quo. We\nrestrict attention to subatomic nondeterministic automata, whose individual\nstates accept unions of syntactic congruence classes. They are general enough\nto cover almost all structural results concerning nondeterministic\nstate-minimality. We prove that converting a monoid recognizing a regular\nlanguage into a small subatomic acceptor corresponds to an NP-complete problem.\nThe NP certificates are solutions of simple equations involving relations over\nthe syntactic monoid. We also consider the subclass of atomic nondeterministic\nautomata introduced by Brzozowski and Tamm. Given a deterministic automaton and\nanother one for the reversed language, computing small atomic acceptors is\nshown to be NP-complete with analogous certificates. Our complexity results\nemerge from an algebraic characterization of (sub)atomic acceptors in terms of\ndeterministic automata with semilattice structure, combined with an equivalence\nof categories leading to succinct representations.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.03229v2"
    },
    {
        "title": "On the expressive power of non-deterministic and unambiguous Petri nets\n  over infinite words",
        "authors": [
            "Olivier Finkel",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We prove that $\\omega$-languages of (non-deterministic) Petri nets and\n$\\omega$-languages of (non-deterministic) Turing machines have the same\ntopological complexity: the Borel and Wadge hierarchies of the class of\n$\\omega$-languages of (non-deterministic) Petri nets are equal to the Borel and\nWadge hierarchies of the class of $\\omega$-languages of (non-deterministic)\nTuring machines. We also show that it is highly undecidable to determine the\ntopological complexity of a Petri net $\\omega$-language. Moreover, we infer\nfrom the proofs of the above results that the equivalence and the inclusion\nproblems for $\\omega$-languages of Petri nets are $\\Pi_2^1$-complete, hence\nalso highly undecidable.\n  Additionally, we show that the situation is quite the opposite when\nconsidering unambiguous Petri nets, which have the semantic property that at\nmost one accepting run exists on every input. We provide a procedure of\ndeterminising them into deterministic Muller counter machines with counter\ncopying. As a consequence, we entail that the $\\omega$-languages recognisable\nby unambiguous Petri nets are $\\Delta^0_3$ sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.04025v2"
    },
    {
        "title": "Algebra and coalgebra of stream products",
        "authors": [
            "Michele Boreale",
            "Daniele Gorla"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study connections among polynomials, differential equations and streams\nover a field K, in terms of algebra and coalgebra. We first introduce the class\nof (F,G)-products on streams, those where the stream derivative of a product\ncan be expressed as a polynomial of the streams themselves and their\nderivatives. Our first result is that, for every (F,G)-product, there is a\ncanonical way to construct a transition function on polynomials such that the\ninduced unique final coalgebra morphism from polynomials into streams is the\n(unique) K-algebra homomorphism -- and vice versa. This implies one can reason\nalgebraically on streams, via their polynomial representation. We apply this\nresult to obtain an algebraic-geometric decision algorithm for polynomial\nstream equivalence, for an underlying generic (F,G)-product. As an example of\nreasoning on streams, we focus on specific products (convolution, shuffle,\nHadamard) and show how to obtain closed forms of algebraic generating functions\nof combinatorial sequences, as well as solutions of nonlinear ordinary\ndifferential equations.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.04455v1"
    },
    {
        "title": "Decomposing Permutation Automata",
        "authors": [
            "Ismaël Jecker",
            "Nicolas Mazzocchi",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A deterministic finite automaton (DFA) is composite if its language can be\ndecomposed into an intersection of languages of smaller DFAs. Otherwise, A is\nprime. This notion of primality was introduced by Kupferman and Mosheiff in\n2013, and while they proved that we can decide whether a DFA is composite, the\nprecise complexity of this problem is still open, with a doubly-exponential gap\nbetween the upper and lower bounds. In this work, we focus on permutation DFAs,\ni.e., those for which the transition monoid is a group. We provide an NP\nalgorithm to decide whether a permutation DFA is composite, and show that the\ndifficulty of this problem comes from the number of non-accepting states of the\ninstance: we give a fixed-parameter tractable algorithm with the number of\nrejecting states as the parameter. Moreover, we investigate the class of\ncommutative permutation DFAs. Their structural properties allow us to decide\ncompositionality in NLOGSPACE, and even in LOGSPACE if the alphabet size is\nfixed. Despite this low complexity, we show that complex behaviors still arise\nin this class: we provide a family of composite DFAs each requiring\npolynomially many factors with respect to its size. We also consider the\nvariant of the problem that asks whether a DFA is k-factor composite, that is,\ndecomposable into k smaller DFAs, for some given integer k. We show that, for\ncommutative permutation DFAs, restricting the number of factors makes the\ndecision computationally harder, and yields a problem with tight bounds: it is\nNP-complete. Finally, we show that in general, this problem is in PSPACE, and\nit is in LOGSPACE for DFAs with a singleton alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.04683v1"
    },
    {
        "title": "A New Approach for Active Automata Learning Based on Apartness",
        "authors": [
            "Frits Vaandrager",
            "Bharat Garhewal",
            "Jurriaan Rot",
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present $L^{\\#}$, a new and simple approach to active automata learning.\nInstead of focusing on equivalence of observations, like the $L^{\\ast}$\nalgorithm and its descendants, $L^{\\#}$ takes a different perspective: it tries\nto establish apartness, a constructive form of inequality. $L^{\\#}$ does not\nrequire auxiliary notions such as observation tables or discrimination trees,\nbut operates directly on tree-shaped automata. $L^{\\#}$ has the same asymptotic\nquery and symbol complexities as the best existing learning algorithms, but we\nshow that adaptive distinguishing sequences can be naturally integrated to\nboost the performance of $L^{\\#}$ in practice. Experiments with a prototype\nimplementation, written in Rust, suggest that $L^{\\#}$ is competitive with\nexisting algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.05419v4"
    },
    {
        "title": "Normal Sequences with Non-Maximal Automatic Complexity",
        "authors": [
            "Liam Jordon",
            "Philippe Moser"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This paper examines Automatic Complexity, a complexity notion introduced by\nShallit and Wang in 2001. We demonstrate that there exists a normal sequence\n$T$ such that $I(T) = 0$ and $S(T) \\leq 1/2$, where $I(T)$ and $S(T)$ are the\nlower and upper automatic complexity rates of $T$ respectively. We furthermore\nshow that there exists a Champernowne sequence $C$, i.e. a sequence formed by\nconcatenating all strings of length $1$ followed by concatenating all strings\nof length $2$ and so on, such that $S(C) \\leq 2/3$.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.05979v3"
    },
    {
        "title": "Bottom-Up Derivatives of Tree Expressions",
        "authors": [
            "Samira Attou",
            "Ludovic Mignot",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we extend the notion of (word) derivatives and partial\nderivatives due to (respectively) Brzozowski and Antimirov to tree derivatives\nusing already known inductive formulae of quotients.\n  We define a new family of extended regular tree expressions (using negation\nor intersection operators), and we show how to compute a Brzozowski-like\ninductive tree automaton; the fixed point of this construction, when it exists,\nis the derivative tree automaton.\n  Such a deterministic tree automaton can be used to solve the membership test\nefficiently: the whole structure is not necessarily computed, and the\nderivative computations can be performed in parallel.\n  We also show how to solve the membership test using our (Bottom-Up) partial\nderivatives, without computing an automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.13373v1"
    },
    {
        "title": "Scope-Bounded Reachability in Valence Systems",
        "authors": [
            "Aneesh K. Shetty",
            "S. Krishna",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Multi-pushdown systems are a standard model for concurrent recursive\nprograms, but they have an undecidable reachability problem. Therefore, there\nhave been several proposals to underapproximate their sets of runs so that\nreachability in this underapproximation becomes decidable. One such\nunderapproximation that covers a relatively high portion of runs is scope\nboundedness. In such a run, after each push to stack $i$, the corresponding pop\noperation must come within a bounded number of visits to stack $i$. In this\nwork, we generalize this approach to a large class of infinite-state systems.\n  For this, we consider the model of valence systems, which consist of a\nfinite-state control and an infinite-state storage mechanism that is specified\nby a finite undirected graph. This framework captures pushdowns, vector\naddition systems, integer vector addition systems, and combinations thereof.\nFor this framework, we propose a notion of scope boundedness that coincides\nwith the classical notion when the storage mechanism happens to be a\nmulti-pushdown. We show that with this notion, reachability can be decided in\nPSPACE for every storage mechanism in the framework. Moreover, we describe the\nfull complexity landscape of this problem across all storage mechanisms, both\nin the case of (i) the scope bound being given as input and (ii) for fixed\nscope bounds.\n  Finally, we provide an almost complete description of the complexity\nlandscape if even a description of the storage mechanism is part of the input.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.00963v1"
    },
    {
        "title": "Constructing deterministic $ω$-automata from examples by an\n  extension of the RPNI algorithm",
        "authors": [
            "León Bohn",
            "Christof Löding"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The RPNI algorithm (Oncina, Garcia 1992) constructs deterministic finite\nautomata from finite sets of negative and positive example words. We propose\nand analyze an extension of this algorithm to deterministic $\\omega$-automata\nwith different types of acceptance conditions. In order to obtain this\ngeneralization of RPNI, we develop algorithms for the standard acceptance\nconditions of $\\omega$-automata that check for a given set of example words and\na deterministic transition system, whether these example words can be accepted\nin the transition system with a corresponding acceptance condition. Based on\nthese algorithms, we can define the extension of RPNI to infinite words. We\nprove that it can learn all deterministic $\\omega$-automata with an informative\nright congruence in the limit with polynomial time and data. We also show that\nthe algorithm, while it can learn some automata that do not have an informative\nright congruence, cannot learn deterministic $\\omega$-automata for all regular\n$\\omega$-languages in the limit. Finally, we also prove that active learning\nwith membership and equivalence queries is not easier for automata with an\ninformative right congruence than for general deterministic $\\omega$-automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.03735v1"
    },
    {
        "title": "State Complexity of Projection on Languages Recognized by Permutation\n  Automata and Commuting Letters",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The projected language of a general deterministic automaton with $n$ states\nis recognizable by a deterministic automaton with $2^{n-1} + 2^{n-m} - 1$\nstates, where $m$ denotes the number of states incident to unobservable\nnon-loop transitions, and this bound is best possible. Here, we derive the\ntight bound $2^{n - \\lceil \\frac{m}{2} \\rceil} - 1$ for permutation automata.\nFor a state-partition automaton with $n$ states (also called automata with the\nobserver property) the projected language is recognizable with $n$ states. Up\nto now, these, and finite languages projected onto unary languages, were the\nonly classes of automata known to possess this property. We show that this is\nalso true for commutative automata and we find commutative automata that are\nnot state-partition automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.06976v1"
    },
    {
        "title": "A Mechanically Verified Theory of Contracts",
        "authors": [
            "Stéphane Kastenbaum",
            "Benoît Boyer",
            "Jean-Pierre Talpin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Cyber-physical systems (CPS) are assemblies of networked, heterogeneous,\nhardware, and software components sensing, evaluating, and actuating a physical\nenvironment. This heterogeneity induces complexity that makes CPSs challenging\nto model correctly. Since CPSs often have critical functions, it is however of\nutmost importance to formally verify them in order to provide the highest\nguarantees of safety. Faced with CPS complexity, model abstraction becomes\nparamount to make verification attainable. To this end, assume/guarantee\ncontracts enable component model abstraction to support a sound, structured,\nand modular verification process. While abstractions of models by contracts are\nusually proved sound, none of the related contract frameworks themselves have,\nto the best of our knowledge, been formally proved correct so far. In this aim,\nwe present the formalization of a generic assume/guarantee contract theory in\nthe proof assistant Coq. We identify and prove theorems that ensure its\ncorrectness. Our theory is generic, or parametric, in that it can be\ninstantiated and used with any given logic, in particular hybrid logics, in\nwhich highly complex cyber-physical systems can uniformly be described.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.13647v1"
    },
    {
        "title": "Extremal Binary PFAs with Small Number of States",
        "authors": [
            "Stijn Cambie",
            "Michiel de Bondt",
            "Henk Don"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The largest known reset thresholds for DFAs are equal to $(n-1)^2$, where $n$\nis the number of states. This is conjectured to be the maximum possible. PFAs\n(with partial transition function) can have exponentially large reset\nthresholds. This is still true if we restrict to binary PFAs. However,\nasymptotics do not give conclusions for fixed $n$. We prove that the maximal\nreset threshold for binary PFAs is strictly greater than $(n-1)^2$ if and only\nif $n\\geq 6$.\n  These results are mostly based on the analysis of synchronizing word lengths\nfor a certain family of binary PFAs. This family has the following properties:\nit contains the well-known \\v{C}ern\\'y automata; for $n\\leq 10$ it contains a\nbinary PFA with maximal possible reset threshold; for all $n\\geq 6$ it contains\na PFA with reset threshold larger than the maximum known for DFAs.\n  Analysis of this family reveals remarkable patterns involving the Fibonacci\nnumbers and related sequences such as the Padovan sequence. We derive explicit\nformulas for the reset thresholds in terms of these recurrent sequences.\n  Asymptotically the \\v{C}ern\\'y family gives reset thresholds of polynomial\norder. We prove that PFAs in the family are not extremal for $n\\geq 41$. For\nthat purpose, we present an improvement of Martyugin's prime number\nconstruction of binary PFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.13927v3"
    },
    {
        "title": "Image-Binary Automata",
        "authors": [
            "Stefan Kiefer",
            "Cas Widdershoven"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a certain restriction of weighted automata over the rationals,\ncalled image-binary automata. We show that such automata accept the regular\nlanguages, can be exponentially more succinct than corresponding NFAs, and\nallow for polynomial complementation, union, and intersection. This compares\nfavourably with unambiguous automata whose complementation requires a\nsuperpolynomial state blowup. We also study an infinite-word version,\nimage-binary B\\\"uchi automata. We show that such automata are amenable to\nprobabilistic model checking, similarly to unambiguous B\\\"uchi automata. We\nprovide algorithms to translate $k$-ambiguous B\\\"uchi automata to image-binary\nB\\\"uchi automata, leading to model-checking algorithms with optimal\ncomputational complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.01049v3"
    },
    {
        "title": "Good-Enough Synthesis",
        "authors": [
            "Shaull Almagor",
            "Orna Kupferman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In the classical synthesis problem, we are given an LTL formula \\psi over\nsets of input and output signals, and we synthesize a system T that realizes\n\\psi: with every input sequences x, the system associates an output sequence\nT(x) such that the generated computation x \\otimes T(x) satisfies \\psi. In\npractice, the requirement to satisfy the specification in all environments is\noften too strong, and it is common to add assumptions on the environment. We\nintroduce a new type of relaxation on this requirement. In good-enough\nsynthesis (GE-synthesis), the system is required to generate a satisfying\ncomputation only if one exists. Formally, an input sequence x is hopeful if\nthere exists some output sequence y such that the computation x \\otimes y\nsatisfies \\psi, and a system GE-realizes \\psi if it generates a computation\nthat satisfies \\psi on all hopeful input sequences. GE-synthesis is\nparticularly relevant when the notion of correctness is multi-valued (rather\nthan Boolean), and thus we seek systems of the highest possible quality, and\nwhen synthesizing autonomous systems, which interact with unexpected\nenvironments and are often only expected to do their best. We study\nGE-synthesis in Boolean and multi-valued settings. In both, we suggest and\nsolve various definitions of GE-synthesis, corresponding to different ways a\ndesigner may want to take hopefulness into account. We show that in all\nvariants, GE-synthesis is not computationally harder than traditional\nsynthesis, and can be implemented on top of existing tools. Our algorithms are\nbased on careful combinations of nondeterministic and universal automata. We\naugment systems that GE-realize their specifications by monitors that provide\nsatisfaction information. In the multi-valued setting, we provide both a\nworst-case analysis and an expectation-based one, the latter corresponding to\nan interaction with a stochastic environment.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.03594v1"
    },
    {
        "title": "Cost Problems for Parametric Time Petri Nets",
        "authors": [
            "Didier Lime",
            "Olivier H. Roux",
            "Charlotte Seidner"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate the problem of parameter synthesis for time Petri nets with a\ncost variable that evolves both continuously with time, and discretely when\nfiring transitions. More precisely, parameters are rational symbolic constants\nused for time constraints on the firing of transitions and we want to\nsynthesise all their values such that some marking is reachable, with a cost\nthat is either minimal or simply less than a given bound.\n  We first prove that the mere existence of values for the parameters such that\nthe latter property holds is undecidable. We nonetheless provide symbolic\nsemi-algorithms for the two synthesis problems and we prove them both sound and\ncomplete when they terminate. We also show how to modify them for the case when\nparameter values are integers. Finally, we prove that these modified versions\nterminate if parameters are bounded. While this is to be expected since there\nare now only a finite number of possible parameter values, our algorithms are\nsymbolic and thus avoid an explicit enumeration of all those values.\nFurthermore, the results are symbolic constraints representing finite unions of\nconvex polyhedra that are easily amenable to further analysis through linear\nprogramming.\n  We finally report on the implementation of the approach in Romeo, a software\ntool for the analysis of time Petri nets.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.03658v2"
    },
    {
        "title": "The decidability of the genus of regular languages and directed\n  emulators",
        "authors": [
            "Guillaume Bonfante",
            "Florian Deloup"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The article continues our study of the genus of a regular language $L$,\ndefined as the minimal genus among all genera of all finite deterministic\nautomata recognizing $L$. Here we define and study two closely related tools on\na directed graph: directed emulators and automatic relations. A directed\nemulator morphism essentially encapsulates at the graph-theoretic level an\nepimorphism onto the minimal deterministic automaton. An automatic relation is\nthe graph-theoretic version of the Myhill-Nerode relation. We show that an\nautomatic relation determines a directed emulator morphism and respectively, a\ndirected emulator morphism determines an automatic relation up to isomorphism.\nConsider the set $S$ of all directed emulators of the underlying directed graph\nof the minimal deterministic automaton for $L$. We prove that the genus of $L$\nis $\\underset{G \\in S}{\\min}\\ g(G)$. We also consider the more restrictive\nnotion of directed cover and prove that the genus of $L$ is reached in the\nclass of directed covers of the underlying directed graph of the minimal\ndeterministic automaton for $L$. This stands in sharp contrast to undirected\nemulators and undirected covers which we also consider. Finally we prove that\nif the problem of determining the minimal genus of a directed emulator of a\ndirected graph has a solution then the problem of determining the minimal genus\nof an undirected emulator of an undirected graph has a solution.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.05735v4"
    },
    {
        "title": "Diagnosability of labeled $\\mathfrak{D_p}$ automata",
        "authors": [
            "Kuize Zhang",
            "Joerg Raisch"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we formulate a notion of diagnosability for labeled weighted\nautomata over a class of dioids which admit both positive and negative numbers\nas well as vectors. The weights can represent diverse physical meanings such as\ntime elapsing and position deviations. We also develop an original tool called\nconcurrent composition to verify diagnosability for such automata. These\nresults are fundamentally new compared with the existing ones in the\nliterature.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.07125v2"
    },
    {
        "title": "On the Power of Finite Ambiguity in Büchi Complementation",
        "authors": [
            "Weizhi Feng",
            "Yong Li",
            "Andrea Turrini",
            "Moshe Y. Vardi",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this work, we exploit the power of \\emph{finite ambiguity} for the\ncomplementation problem of B\\\"uchi automata by using reduced run directed\nacyclic graphs (DAGs) over infinite words, in which each vertex has at most one\npredecessor; these reduced run DAGs have only a finite number of infinite runs,\nthus obtaining the finite ambiguity in B\\\"uchi complementation. We show how to\nuse this type of reduced run DAGs as a unified tool to optimize both rank-based\nand slice-based complementation constructions for B\\\"uchi automata with a\nfinite degree of ambiguity. As a result, given a B\\\"uchi automaton with $n$\nstates and a finite degree of ambiguity, the number of states in the\ncomplementary B\\\"uchi automaton constructed by the classical rank-based and\nslice-based complementation constructions can be improved from $2^{\\mathsf{O}(n\n\\log n)}$ and $\\mathsf{O}((3n)^{n})$ to $\\mathsf{O}(6^{n}) \\subseteq\n2^{\\mathsf{O}(n)}$ and $\\mathsf{O}(4^{n})$, respectively. We further show how\nto construct such reduced run DAGs for limit deterministic B\\\"uchi automata and\nobtain a specialized complementation algorithm, thus demonstrating the\ngenerality of the power of finite ambiguity.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.12828v2"
    },
    {
        "title": "On the Complexity of Intersection Non-emptiness for Star-Free Language\n  Classes",
        "authors": [
            "Emmanuel Arrighi",
            "Henning Fernau",
            "Stefan Hoffmann",
            "Markus Holzer",
            "Ismaël Jecker",
            "Mateus de Oliveira Oliveira",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In the Intersection Non-Emptiness problem, we are given a list of finite\nautomata $A_1,A_2,\\dots,A_m$ over a common alphabet $\\Sigma$ as input, and the\ngoal is to determine whether some string $w\\in \\Sigma^*$ lies in the\nintersection of the languages accepted by the automata in the list. We analyze\nthe complexity of the Intersection Non-Emptiness problem under the promise that\nall input automata accept a language in some level of the dot-depth hierarchy,\nor some level of the Straubing-Th\\'{e}rien hierarchy. Automata accepting\nlanguages from the lowest levels of these hierarchies arise naturally in the\ncontext of model checking. We identify a dichotomy in the dot-depth hierarchy\nby showing that the problem is already NP-complete when all input automata\naccept languages of the levels zero or one half and already PSPACE-hard when\nall automata accept a language from the level one. Conversely, we identify a\ntetrachotomy in the Straubing-Th\\'{e}rien hierarchy. More precisely, we show\nthat the problem is in AC$^0$ when restricted to level zero; complete for\nLOGSPACE or NLOGSPACE, depending on the input representation, when restricted\nto languages in the level one half; NP-complete when the input is given as DFAs\naccepting a language in from level one or three half; and finally,\nPSPACE-complete when the input automata accept languages in level two or\nhigher. Moreover, we show that the proof technique used to show containment in\nNP for DFAs accepting languages in the Straubing-Th\\'{e}rien hierarchy levels\none ore three half does not generalize to the context of NFAs. To prove this,\nwe identify a family of languages that provide an exponential separation\nbetween the state complexity of general NFAs and that of partially ordered\nNFAs. To the best of our knowledge, this is the first superpolynomial\nseparation between these two models of computation.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.01279v1"
    },
    {
        "title": "The complexity of bidirected reachability in valence systems",
        "authors": [
            "Moses Ganardi",
            "Rupak Majumdar",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Reachability problems in infinite-state systems are often subject to\nextremely high complexity. This motivates the investigation of efficient\noverapproximations, where we add transitions to obtain a system in which\nreachability can be decided more efficiently. We consider bidirected\ninfinite-state systems, where for every transition there is a transition with\nopposite effect.\n  We study bidirected reachability in the framework of valence systems, an\nabstract model featuring finitely many control states and an infinite-state\nstorage that is specified by a finite graph. By picking suitable graphs,\nvalence systems can uniformly model counters as in vector addition systems,\npushdowns, integer counters, and combinations thereof.\n  We provide a comprehensive complexity landscape for bidirected reachability\nand show that the complexity drops (often to polynomial time) from that of\ngeneral reachability, for almost every storage mechanism where reachability is\nknown to be decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.03654v2"
    },
    {
        "title": "A Characterization of Totally Compatible Automata",
        "authors": [
            "David Fernando Casas Torres"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Every function on a finite set defines an equivalence relation and,\ntherefore, a partition called the kernel of the function. Automata such that\nevery possible partition is the kernel of a word are called totally compatible.\nA characterization of such automata is given together with an algorithm to\nrecognize them in polynomial running time with respect to the number of states.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.05173v1"
    },
    {
        "title": "The algebra of row monomial matrices",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We consider an algebra with non-standard operations on the class of row\nmonomial matrices (having one unit and rest of zeros in every row). The class\nof row monomial matrices is closed under multiplication, but not closed under\nordinary matrix addition. The paper considers a kind of summation operation on\nrow monomial matrices and the necessary conditions to be closed under the\noperation in this class.\n  The most significant difference between the algebra of row monomial matrices\nand linear algebra is the summation operation, with respect to which the class\nof row monomial matrices is closed.\n  The operation of summation in the algebra can be considered also as an\nalgebra of subsets of any set. The class of subsets of given set is closed\nunder considered operation of summation.\n  The deterministic finite automaton (DFA) can be presented by a complete\nunderlying graph of the automaton with edges labelled by letters of an\nalphabet. Row monomial matrices can be induced by words in the alphabet of\nlabels on edges of underlying graph of DFA and present a mapping of the set of\nstates.\n  A word $s$ of letters on edges of underlying graph $\\Gamma$ of deterministic\nfinite automaton (DFA) is called synchronizing if $s$ sends all states of the\nautomaton to a unique state.\n  J. \\v{C}erny discovered in 1964 a sequence of $n$-state complete DFA\npossessing a minimal synchronizing word of length $(n-1)^2$. The hypothesis,\nmostly known today as \\v{C}erny conjecture, claims that $(n-1)^2$ is a precise\nupper bound on the length of such a word over alphabet $\\Sigma$ of letters on\nedges of $\\Gamma$ for every complete $n$-state DFA. The hypothesis was\nformulated in 1966 by Starke.\n  The following proof of the conjecture uses the algebra of row monomial\nmatrices.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.06839v3"
    },
    {
        "title": "Derived terms without derivation a shifted perspective on the\n  derived-term automaton",
        "authors": [
            "Sylvain Lombardy",
            "Jacques Sakarovitch"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present here a construction for the derived term automaton (aka partial\nderivative, or Antimirov, automaton) of a rational (or regular) expression\nbased on a sole induction on the depth of the expression and without making\nreference to an operation of derivation of the expression. It is particularly\nwell-suited to the case of weighted rational expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.09181v1"
    },
    {
        "title": "Learning Realtime One-Counter Automata",
        "authors": [
            "Véronique Bruyère",
            "Guillermo A. Pérez",
            "Gaëtan Staquet"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present a new learning algorithm for realtime one-counter automata. Our\nalgorithm uses membership and equivalence queries as in Angluin's L* algorithm,\nas well as counter value queries and partial equivalence queries. In a partial\nequivalence query, we ask the teacher whether the language of a given\nfinite-state automaton coincides with a counter-bounded subset of the target\nlanguage. We evaluate an implementation of our algorithm on a number of random\nbenchmarks and on a use case regarding efficient JSON-stream validation.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.09434v2"
    },
    {
        "title": "Weighted Automata and Expressions over Pre-Rational Monoids",
        "authors": [
            "Nicolas Baudru",
            "Louis-Marie Dando",
            "Nathan Lhote",
            "Benjamin Monmege",
            "Pierre-Alain Reynier",
            "Jean-Marc Talbot"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The Kleene theorem establishes a fundamental link between automata and\nexpressions over the free monoid. Numerous generalisations of this result exist\nin the literature. Lifting this result to a weighted setting has been widely\nstudied. Moreover, different monoids can be considered: for instance, two-way\nautomata, and even tree-walking automata, can be described by expressions using\nthe free inverse monoid. In the present work, we aim at combining both research\ndirections and consider weighted extensions of automata and expressions over a\nclass of monoids that we call pre-rational, generalising both the free inverse\nmonoid and graded monoids. The presence of idempotent elements in these\npre-rational monoids leads in the weighted setting to consider infinite sums.\nTo handle such sums, we will have to restrict ourselves to rationally additive\nsemirings. Our main result is thus a generalisation of the Kleene theorem for\npre-rational monoids and rationally additive semirings. As a corollary, we\nobtain a class of expressions equivalent to weighted two-way automata, as well\nas one for tree-walking automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.12395v1"
    },
    {
        "title": "LTL-Based Non-Markovian Inverse Reinforcement Learning",
        "authors": [
            "Mohammad Afzal",
            "Sankalp Gambhir",
            "Ashutosh Gupta",
            "Krishna S",
            "Ashutosh Trivedi",
            "Alvaro Velasquez"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The successes of reinforcement learning in recent years are underpinned by\nthe characterization of suitable reward functions. However, in settings where\nsuch rewards are non-intuitive, difficult to define, or otherwise error-prone\nin their definition, it is useful to instead learn the reward signal from\nexpert demonstrations. This is the crux of inverse reinforcement learning\n(IRL). While eliciting learning requirements in the form of scalar reward\nsignals has been shown to effective, such representations lack explainability\nand lead to opaque learning. We aim to mitigate this situation by presenting a\nnovel IRL method for eliciting declarative learning requirements in the form of\na popular formal logic -- Linear Temporal Logic (LTL) -- from a set of traces\ngiven by the expert policy. A key novelty of the proposed approach is\nquantitative semantics of satisfaction of an LTL formula by a word that,\nfollowing Occam's razor principle, incentivizes simpler explanations. Given a\nsample $S=(P,N)$ consisting of positive traces $P$ and negative traces $N$, the\nproposed algorithms automate the search for a formula $\\varphi$ which provides\nthe simplest explanation (in the $GF$ fragment of LTL) of the samples. We have\nimplemented this approach as an open-source tool QuantLearn to perform\nlogic-based non-Markovian IRL. Our results demonstrate the feasibility of the\nproposed approach in eliciting intuitive LTL-based reward signals from noisy\ndata.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.13616v2"
    },
    {
        "title": "History Determinism vs. Good for Gameness in Quantitative Automata",
        "authors": [
            "Udi Boker",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Automata models between determinism and nondeterminism/alternations can\nretain some of the algorithmic properties of deterministic automata while\nenjoying some of the expressiveness and succinctness of nondeterminism. We\nstudy three closely related such models -- history determinism, good for\ngameness and determinisability by pruning -- on quantitative automata. While in\nthe Boolean setting, history determinism and good for gameness coincide, we\nshow that this is no longer the case in the quantitative setting: good for\ngameness is broader than history determinism, and coincides with a relaxed\nversion of it, defined with respect to thresholds. We further identify criteria\nin which history determinism, which is generally broader than determinisability\nby pruning, coincides with it, which we then apply to typical quantitative\nautomata types. As a key application of good for games and history\ndeterministic automata is synthesis, we clarify the relationship between the\ntwo notions and various quantitative synthesis problems. We show that\ngood-for-games automata are central for \"global\" (classical) synthesis, while\n\"local\" (good-enough) synthesis reduces to deciding whether a nondeterministic\nautomaton is history deterministic.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.14238v1"
    },
    {
        "title": "Token Games and History-Deterministic Quantitative-Automata",
        "authors": [
            "Udi Boker",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A nondeterministic automaton is history-deterministic if its nondeterminism\ncan be resolved by only considering the prefix of the word read so far. Due to\ntheir good compositional properties, history-deterministic automata are useful\nin solving games and synthesis problems. Deciding whether a given\nnondeterministic automaton is history-deterministic (the HDness problem) is\ngenerally a difficult task, which can involve an exponential procedure, or even\nbe undecidable, as is the case for example with pushdown automata. Token games\nprovide a PTime solution to the HDness problem of B\\\"uchi and coB\\\"uchi\nautomata, and it is conjectured that 2-token games characterise HDness for all\n$\\omega$-regular automata.\n  We extend token games to the quantitative setting and analyse their potential\nto help deciding HDness of quantitative automata. In particular, we show that\n1-token games characterise HDness for all quantitative (and Boolean) automata\non finite words, as well as discounted-sum (DSum), Inf and Reachability\nautomata on infinite words, and that 2-token games characterise HDness of\nLimInf and LimSup automata, as well as Sup automata on infinite words. Using\nthese characterisations, we provide solutions to the HDness problem of Safety,\nReachability, Inf and Sup automata on finite and infinite words in PTime, of\nDSum automata on finite and infinite words in NP$\\cap$co-NP, of LimSup automata\nin quasipolynomial time, and of LimInf automata in exponential time, where the\nlatter two are only polynomial for automata with a logarithmic number of\nweights.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.14308v6"
    },
    {
        "title": "Articulations and Products of Transition Systems and their Applications\n  to Petri Net Synthesis",
        "authors": [
            "Raymond Devillers"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In order to speed up the synthesis of Petri nets from labelled transition\nsystems, a divide and conquer strategy consists in defining decompositions of\nlabelled transition systems, such that each component is synthesisable iff so\nis the original system. Then corresponding Petri Net composition operators are\nsearched to combine the solutions of the various components\n  into a solution of the original system. The paper presents two such\ntechniques, which may be combined: products and articulations. They may also be\nused to structure transition systems, and to analyse the performance of\nsynthesis techniques when applied to such structures.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.00202v3"
    },
    {
        "title": "A Framework for Transforming Specifications in Reinforcement Learning",
        "authors": [
            "Rajeev Alur",
            "Suguman Bansal",
            "Osbert Bastani",
            "Kishor Jothimurugan"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Reactive synthesis algorithms allow automatic construction of policies to\ncontrol an environment modeled as a Markov Decision Process (MDP) that are\noptimal with respect to high-level temporal logic specifications. However, they\nassume that the MDP model is known a priori. Reinforcement Learning (RL)\nalgorithms, in contrast, are designed to learn an optimal policy when the\ntransition probabilities of the MDP are unknown, but require the user to\nassociate local rewards with transitions. The appeal of high-level temporal\nlogic specifications has motivated research to develop RL algorithms for\nsynthesis of policies from specifications. To understand the techniques, and\nnuanced variations in their theoretical guarantees, in the growing body of\nresulting literature, we develop a formal framework for defining\ntransformations among RL tasks with different forms of objectives. We define\nthe notion of a sampling-based reduction to transform a given MDP into another\none which can be simulated even when the transition probabilities of the\noriginal MDP are unknown. We formalize the notions of preservation of optimal\npolicies, convergence, and robustness of such reductions. We then use our\nframework to restate known results, establish new results to fill in some gaps,\nand identify open problems. In particular, we show that certain kinds of\nreductions from LTL specifications to reward-based ones do not exist, and prove\nthe non-existence of RL algorithms with PAC-MDP guarantees for safety\nspecifications.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.00272v3"
    },
    {
        "title": "Introduction to probabilistic concurrent systems",
        "authors": [
            "Samy Abbes"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The first part of the paper is an introduction to the theory of probabilistic\nconcurrent systems under a partial order semantics. Key definitions and results\nare given and illustrated on examples. The second part includes contributions.\nWe introduce deterministic concurrent systems as a subclass of concurrent\nsystems. Deterministic concurrent system are \"locally commutative'\" concurrent\nsystems. We prove that irreducible and deterministic concurrent systems have a\nunique probabilistic dynamics, and we characterize these systems by means of\ntheir combinatorial properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.00507v6"
    },
    {
        "title": "Conservative Hybrid Automata from Development Artifacts",
        "authors": [
            "Niklas Metzger",
            "Sanny Schmitt",
            "Maximilian Schwenger"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The verification of cyber-physical systems operating in a safety-critical\nenvironment requires formal system models. The validity of the verification\nhinges on the precision of the model: possible behavior not captured in the\nmodel can result in formally verified, but unsafe systems. Yet, manual\nconstruction is delicate and error-prone while automatic construction does not\nscale for large and complex systems. As a remedy, this paper devises an\nautomatic construction algorithm that utilizes information contained in\nartifacts of the development process: a runtime monitoring specification and\nrecorded test traces. These artifacts incur no additional cost and provide\nsufficient information so that the construction process scales well for large\nsystems. The algorithm uses a hybrid approach between a top-down and a\nbottom-up construction which allows for proving the result conservative, while\nlimiting the level of over-approximation.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.05613v2"
    },
    {
        "title": "Homomorphisms on graph-walking automata",
        "authors": [
            "Olga Martynova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Graph-walking automata (GWA) are a model for graph traversal using\nfinite-state control: these automata move between the nodes of an input graph,\nfollowing its edges. This paper investigates the effect of node-replacement\ngraph homomorphisms on recognizability by these automata. It is not difficult\nto see that the family of graph languages recognized by GWA is closed under\ninverse homomorphisms. The main result of this paper is that, for $n$-state\nautomata operating on graphs with $k$ labels of edge end-points, the inverse\nhomomorphic images require GWA with $kn+O(1)$ states in the worst case. The\nsecond result is that already for tree-walking automata, the family they\nrecognize is not closed under injective homomorphisms. Here the proof is based\non an easy homomorphic characterization of regular tree languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.10214v1"
    },
    {
        "title": "Regulated Multiset Rewriting Systems",
        "authors": [
            "Matej Troják",
            "Samuel Pastva",
            "David Šafránek",
            "Luboš Brim"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Multiset rewriting systems provide a formalism particularly suitable for the\ndescription of biological systems. We present an extension of this formalism\nwith additional controls on the derivations as a tool for reducing possible\nnon-deterministic behaviour by providing additional knowledge about the system.\nWe introduce several regulation mechanisms and compare their generative power.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.13036v1"
    },
    {
        "title": "Commutative Regular Languages with Product-Form Minimal Automata",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a subclass of the commutative regular languages that is\ncharacterized by the property that the state set of the minimal deterministic\nautomaton can be written as a certain Cartesian product. This class behaves\nmuch better with respect to the state complexity of the shuffle, for which we\nfind the bound~$2nm$ if the input languages have state complexities $n$ and\n$m$, and the upward and downward closure and interior operations, for which we\nfind the bound~$n$. In general, only the bounds $(2nm)^{|\\Sigma|}$ and\n$n^{|\\Sigma|}$ are known for these operations in the commutative case. We prove\ndifferent characterizations of this class and present results to construct\nlanguages from this class. Lastly, in a slightly more general setting of\npartial commutativity, we introduce other, related, language classes and\ninvestigate the relations between them.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.13523v1"
    },
    {
        "title": "State Complexity Investigations on Commutative Languages -- The Upward\n  and Downward Closure, Commutative Aperiodic and Commutative Group Languages",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate the state complexity of the upward and downward closure and\ninterior operations on commutative regular languages. Then, we systematically\nstudy the state complexity of these operations and of the shuffle operation on\ncommutative group languages and commutative aperiodic (or star-free) languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.13524v1"
    },
    {
        "title": "Sync-Maximal Permutation Groups Equal Primitive Permutation Groups",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The set of synchronizing words of a given $n$-state automaton forms a regular\nlanguage recognizable by an automaton with $2^n - n$ states. The size of a\nrecognizing automaton for the set of synchronizing words is linked to\ncomputational problems related to synchronization and to the length of\nsynchronizing words. Hence, it is natural to investigate synchronizing automata\nextremal with this property, i.e., such that the minimal deterministic\nautomaton for the set of synchronizing words has $2^n - n$ states. The\nsync-maximal permutation groups have been introduced in [{\\sc S. Hoffmann},\nCompletely Reachable Automata, Primitive Groups and the State Complexity of the\nSet of Synchronizing Words, LATA 2021] by stipulating that an associated\nautomaton to the group and a non-permutation has this extremal property. The\ndefinition is in analogy with the synchronizing groups and analog to a\ncharacterization of primitivity obtained in the mentioned work. The precise\nrelation to other classes of groups was mentioned as an open problem. Here, we\nsolve this open problem by showing that the sync-maximal groups are precisely\nthe primitive groups. Our result gives a new characterization of the primitive\ngroups. Lastly, we explore an alternative and stronger definition than\nsync-maximality.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.13527v1"
    },
    {
        "title": "Some Basic Techniques allowing Petri Net Synthesis: Complexity and\n  Algorithmic Issues",
        "authors": [
            "Raymond Devillers",
            "Ronny Tredup"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In Petri net synthesis we ask whether a given transition system $A$ can be\nimplemented by a Petri net $N$. Depending on the level of accuracy, there are\nthree ways how $N$ can implement $A$: an embedding, the least accurate\nimplementation, preserves only the diversity of states of $A$; a language\nsimulation already preserves exactly the language of $A$; a realization, the\nmost accurate implementation, realizes the behavior of $A$ exactly. However,\nwhatever the sought implementation, a corresponding net does not always exist.\nIn this case, it was suggested to modify the input behavior -- of course as\nlittle as possible. Since transition systems consist of states, events and\nedges, these components appear as a natural choice for modifications. In this\npaper we show that the task of converting an unimplementable transition system\ninto an implementable one by removing as few states or events or edges as\npossible is NP-complete -- regardless of what type of implementation we are\naiming for; we also show that the corresponding parameterized problems are\n$W[2]$-hard, where the number of removed components is considered as the\nparameter; finally, we show there is no $c$-approximation algorithm (with a\npolynomial running time) for neither of these problems, for every constant\n$c\\geq 1$.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.03605v4"
    },
    {
        "title": "Synthesis of Pure and Impure Petri nets With Restricted\n  Place-environments: Complexity Issues",
        "authors": [
            "Raymond Devillers",
            "Ronny Tredup"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Petri net synthesis consists in deciding for a given transition system $A$\nwhether there exists a Petri net $N$ whose reachability graph is isomorphic to\n$A$. Several works examined the synthesis of Petri net subclasses that\nrestrict, for every place $p$ of the net, the cardinality of its preset or of\nits postset or both in advance by small natural numbers $\\varrho$ and $\\kappa$,\nrespectively, such as for example (weighted) marked graphs, (weighted)\nT-systems and choice-free nets. In this paper, we study the synthesis aiming at\nPetri nets which have such restricted place environments, from the viewpoint of\nclassical and parameterized complexity: We first show that, for any fixed\nnatural numbers $\\varrho$ and $\\kappa$, deciding whether for a given transition\nsystem $A$ there is a Petri net $N$ such that (1) its reachability graph is\nisomorphic to $A$ and (2) for every place $p$ of $N$ the preset of $p$ has at\nmost $\\varrho$ and the postset of $p$ has at most $\\kappa$ elements is doable\nin polynomial time. Secondly, we introduce a modified version of the problem,\nnamely Environment Restricted Synthesis (ERS, for short), where $\\varrho$ and\n$\\kappa$ are part of the input, and show that ERS is NP-complete, regardless\nwhether the sought net is impure or pure. In case of the impure nets, our\nmethods also imply that ERS parameterized by $\\varrho+\\kappa$ is $W[2]$-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.03608v6"
    },
    {
        "title": "On LL(k) linear conjunctive grammars",
        "authors": [
            "Ilya Olkhovsky",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Linear conjunctive grammars are a family of formal grammars with an explicit\nconjunction operation allowed in the rules, which is notable for its\ncomputational equivalence fo one-way real-time cellular automata, also known as\ntrellis automata. This paper investigates the LL($k$) subclass of linear\nconjunctive grammars, defined by analogy with the classical LL($k$) grammars:\nthese are grammars that admit top-down linear-time parsing with $k$-symbol\nlookahead. Two results are presented. First, every LL($k$) linear conjunctive\ngrammar can be transformed to an LL(1) linear conjunctive grammar, and,\naccordingly, the hierarchy with respect to $k$ collapses. Secondly, a parser\nfor these grammars that works in linear time and uses logarithmic space is\nconstructed, showing that the family of LL($k$) linear conjunctive languages is\ncontained in the complexity class $L$.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.08014v1"
    },
    {
        "title": "Hiding pebbles when the output alphabet is unary",
        "authors": [
            "Gaëtan Douéneau-Tabot"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Pebble transducers are nested two-way transducers which can drop marks (named\n\"pebbles\") on their input word. Blind transducers have been introduced by\nNguy\\^en et al. as a subclass of pebble transducers, which can nest two-way\ntransducers but cannot drop pebbles on their input.\n  In this paper, we study the classes of functions computed by pebble and blind\ntransducers, when the output alphabet is unary. Our main result shows how to\ndecide if a function computed by a pebble transducer can be computed by a blind\ntransducer. We also provide characterizations of these classes in terms of\nCauchy and Hadamard products, in the spirit of rational series. Furthermore,\npumping-like characterizations of the functions computed by blind transducers\nare given.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.10212v4"
    },
    {
        "title": "Determinization of One-Counter Nets",
        "authors": [
            "Shaull Almagor",
            "Asaf Yeshurun"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  One-Counter Nets (OCNs) are finite-state automata equipped with a counter\nthat is not allowed to become negative, but does not have zero tests. Their\nsimplicity and close connection to various other models (e.g., VASS, Counter\nMachines and Pushdown Automata) make them an attractive model for studying the\nborder of decidability for the classical decision problems.\n  The deterministic fragment of OCNs (DOCNs) typically admits more tractable\ndecision problems, and while these problems and the expressive power of DOCNs\nhave been studied, the determinization problem, namely deciding whether an OCN\nadmits an equivalent DOCN, has not received attention.\n  We introduce four notions of OCN determinizability, which arise naturally due\nto intricacies in the model, and specifically, the interpretation of the\ninitial counter value. We show that in general, determinizability is\nundecidable under most notions, but over a singleton alphabet (i.e., 1\ndimensional VASS) one definition becomes decidable, and the rest become\ntrivial, in that there is always an equivalent DOCN.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.13716v1"
    },
    {
        "title": "Finite-Word Hyperlanguages",
        "authors": [
            "Borzoo Bonakdarpour",
            "Sarai Sheinvald"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Formal languages are in the core of models of computation and their behavior.\nA rich family of models for many classes of languages have been widely studied.\nHyperproperties lift conventional trace-based languages from a set of execution\ntraces to a set of sets of executions. Hyperproperties have been shown to be a\npowerful formalism for expressing and reasoning about information-flow security\npolicies and important properties of cyber-physical systems. Although there is\nan extensive body of work on formal-language representation of trace\nproperties, we currently lack such a general characterization for\nhyperproperties. We introduce hyperlanguages over finite words and models for\nexpressing them. Essentially, these models express multiple words by using\nassignments to quantified word variables. Relying on the standard models for\nregular languages, we propose hyperregular expressions and finite-word\nhyperautomata (NFH), for modeling the class of regular hyperlanguages. We\ndemonstrate the ability of regular hyperlanguages to express hyperproperties\nfor finite traces. We explore the closure properties and the complexity of the\nfundamental decision problems such as nonemptiness, universality, membership,\nand containment for various fragments of NFH.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.01670v1"
    },
    {
        "title": "Completely reachable automata: an interplay between automata, graphs,\n  and trees",
        "authors": [
            "Evgeniya A. Bondar",
            "David Casas",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A deterministic finite automaton in which every non-empty set of states\noccurs as the image of the whole state set under the action of a suitable input\nword is called completely reachable. We characterize such automata in terms of\ngraphs and trees.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.05075v1"
    },
    {
        "title": "Improvements to ltlsynt",
        "authors": [
            "Florian Renkin",
            "Philipp Schlehuber",
            "Alexandre Duret-Lutz",
            "Adrien Pommellet"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  ltlsynt is a tool for LTL reactive synthesis. We summarize its evolution\nsince 2018.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.05376v1"
    },
    {
        "title": "Mechanical proving with Walnut for squares and cubes in partial words",
        "authors": [
            "John Machacek"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Walnut is a software that using automata can prove theorems in combinatorics\non words about automatic sequences. We are able to apply this software to both\nprove new results as well as reprove some old results on avoiding squares and\ncubes in partial words. We also define the notion of an antisquare in a partial\nword and begin the study of binary partial words which contain only a fixed\nnumber of distinct squares and antisquares.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.05954v2"
    },
    {
        "title": "The Normalized Edit Distance with Uniform Operation Costs is a Metric",
        "authors": [
            "Dana Fisman",
            "Joshua Grogin",
            "Oded Margalit",
            "Gera Weiss"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We prove that the normalized edit distance proposed in [Marzal and Vidal\n1993] is a metric when the cost of all the edit operations are the same. This\ncloses a long standing gap in the literature where several authors noted that\nthis distance does not satisfy the triangle inequality in the general case, and\nthat it was not known whether it is satisfied in the uniform case where all the\nedit costs are equal. We compare this metric to two normalized metrics proposed\nas alternatives in the literature, when people thought that Marzal's and\nVidal's distance is not a metric, and identify key properties that explain why\nthe original distance, now known to also be a metric, is better for some\napplications. Our examination is from a point of view of formal verification,\nbut the properties and their significance are stated in an application agnostic\nway.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.06115v3"
    },
    {
        "title": "Characterizing level one in group-based concatenation hierarchies",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We investigate two operators on classes of regular languages: polynomial\nclosure (Pol) and Boolean closure (Bool). We apply these operators to classes\nof group languages G and to their well-suited extensions G+, which is the least\nBoolean algebra containing G and the singleton language containing the empty\nword. This yields the classes Bool(Pol(G)) and Bool(Pol(G+)). These classes\nform the first level in important classifications of classes of regular\nlanguages, called concatenation hierarchies, which admit natural logical\ncharacterizations. We present generic algebraic characterizations of these\nclasses. They imply that one may decide whether a regular language belongs to\nsuch a class, provided that a more general problem called separation is\ndecidable for the input class G. The proofs are constructive and rely\nexclusively on notions from language and automata theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.06826v1"
    },
    {
        "title": "Time distance based computation of the state space of preemptive real\n  time systems",
        "authors": [
            "Abdelkrim Abdelli"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We explore in this paper a novel approach that builds an overapproximation of\nthe state space of preemptive real time systems. Our graph construction extends\nthe expression of a class to the time distance system that encodes the\nquantitative properties of past fired subsequences. This makes it possible to\nrestore relevant time information that is used to tighten still more the DBM\noverapproximation of reachable classes. We succeed thereby to build efficiently\ntighter approximated graphs which are more appropriate to restore the\nquantitative properties of the model. The simulation results show that the\ncomputed graphs are of the same size as the exact graphs while improving by far\nthe times needed for their computation.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.09784v1"
    },
    {
        "title": "Supported Sets -- A New Foundation For Nominal Sets And Automata",
        "authors": [
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The present work proposes and discusses the category of supported sets which\nprovides a uniform foundation for nominal sets of various kinds, such as those\nfor equality symmetry, for the order symmetry, and renaming sets. We show that\nall these differently flavoured categories of nominal sets are monadic over\nsupported sets. Thus, supported sets provide a canonical finite way to\nrepresent nominal sets and the automata therein, e.g. register automata. Name\nbinding in supported sets is modelled by a functor following the idea of de\nBruijn indices. This functor lifts to the well-known abstraction functor in\nnominal sets. Together with the monadicity result, this gives rise to a\ntransformation process that takes the finite representation of a register\nautomaton in supported sets and transforms it into its configuration automaton\nin nominal sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.09825v2"
    },
    {
        "title": "Topological invariants for words of linear factor complexity",
        "authors": [
            "Jason Bell"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Given a finite alphabet $\\Sigma$ and a right-infinite word $w$ over the\nalphabet $\\Sigma$, we construct a topological space ${\\rm Rec}(w)$ consisting\nof all right-infinite recurrent words whose factors are all factors of $w$,\nwhere we work up to an equivalence in which two words are equivalent if they\nhave the exact same set of factors (finite contiguous subwords). We show that\n${\\rm Rec}(w)$ can be endowed with a natural topology and we show that if $w$\nis word of linear factor complexity then ${\\rm Rec}(w)$ is a finite topological\nspace. In addition, we note that there are examples which show that if\n$f:\\mathbb{N}\\to \\mathbb{N}$ is a function that tends to infinity as $n\\to\n\\infty$ then there is a word whose factor complexity function is ${\\rm\nO}(nf(n))$ such that ${\\rm Rec}(w)$ is an infinite set. Finally, we pose a\nrealization problem: which finite topological spaces can arise as ${\\rm\nRec}(w)$ for a word of linear factor complexity?\n",
        "pdf_link": "http://arxiv.org/pdf/2202.00643v2"
    },
    {
        "title": "Approximate NFA Universality and Related Problems Motivated by\n  Information Theory",
        "authors": [
            "Stavros Konstantinidis",
            "Mitja Mastnak",
            "Nelma Moreira",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In coding and information theory, it is desirable to construct maximal codes\nthat can be either variable length codes or error control codes of fixed\nlength. However deciding code maximality boils down to deciding whether a given\nNFA is universal, and this is a hard problem (including the case of whether the\nNFA accepts all words of a fixed length). On the other hand, it is acceptable\nto know whether a code is `approximately' maximal, which then boils down to\nwhether a given NFA is `approximately' universal. Here we introduce the notion\nof a $(1-\\epsilon)$-universal automaton and present polynomial randomized\napproximation algorithms to test NFA universality and related hard automata\nproblems, for certain natural probability distributions on the set of words. We\nalso conclude that the randomization aspect is necessary, as approximate\nuniversality remains hard for any fixed polynomially computable $\\epsilon$.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.01594v2"
    },
    {
        "title": "On the Complexity of Coordinated Table Selective Substitution Systems",
        "authors": [
            "Liliana Cojocaru"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We investigate computational resources used by Turing machines (TMs) and\nalternating Turing machines (ATMs) to accept languages generated by coordinated\ntable selective substitution systems with two components. We prove that the\nclass of languages generated by real-time (RL; 0S)-systems, an alternative\ndevice to generate lambda-free labeled marked Petri nets languages, can be\naccepted by nondeterministic TMs in O(log n) space and O(nlog n) time.\nConsequently, this proper sub-class of Petri nets languages (known also as\nL-languages) is included in NSPACE(log n). The class of languages generated by\n(RL; RB)-systems for which the nonterminal alphabet of the RL-grammar is\ncomposed of only one symbol and the nonterminal alphabet of the RB-grammar is\ncomposed of two symbols, can be accepted by ATMs in O(log n) time and space.\nConsequently, this proper subclass of one-counter languages generated by\none-counter machines with only one control state is included in U_E*-uniform\nNC1, hence in SPACE(log n).\n",
        "pdf_link": "http://arxiv.org/pdf/2202.02613v1"
    },
    {
        "title": "Efficient Construction of Reversible Transducers from Regular Transducer\n  Expressions",
        "authors": [
            "Luc Dartois",
            "Paul Gastin",
            "R. Govind",
            "Shankaranarayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The class of regular transformations has several equivalent characterizations\nsuch as functional MSO transductions, deterministic two-way transducers,\nstreaming string transducers, as well as regular transducer expressions (RTE).\n  For algorithmic applications, it is very common and useful to transform a\nspecification, here, an RTE, to a machine, here, a transducer. In this paper,\nwe give an efficient construction of a two-way reversible transducer (2RFT)\nequivalent to a given RTE. 2RFTs are a well behaved class of transducers which\nare deterministic and co-deterministic (hence allows evaluation in linear time\n\\wrt the input word), and where composition has only polynomial complexity.\n  We show that, for full RTE, the constructed 2RFT has size doubly exponential\nin the size of the expression, while, if the RTE does not use Hadamard product\nor chained-star, the constructed\n  2RFT has size exponential in the size of the RTE.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.04340v1"
    },
    {
        "title": "Minimality Notions via Factorization Systems and Examples",
        "authors": [
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  For the minimization of state-based systems (i.e. the reduction of the number\nof states while retaining the system's semantics), there are two obvious\naspects: removing unnecessary states of the system and merging redundant states\nin the system. In the present article, we relate the two minimization aspects\non coalgebras by defining an abstract notion of minimality.\n  The abstract notions minimality and minimization live in a general category\nwith a factorization system. We will find criteria on the category that ensure\nuniqueness, existence, and functoriality of the minimization aspects. The\nproofs of these results instantiate to those for reachability and observability\nminimization in the standard coalgebra literature. Finally, we will see how the\ntwo aspects of minimization interact and under which criteria they can be\nsequenced in any order, like in automata minimization.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.05701v3"
    },
    {
        "title": "Deciding What is Good-for-MDPs",
        "authors": [
            "Sven Schewe",
            "Qiyi Tang",
            "Tansholpan Zhanabekova"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Nondeterministic Good-for-MDP (GFM) automata are for MDP model checking and\nreinforcement learning what good-for-games automata are for reactive synthesis:\na more compact alternative to deterministic automata that displays\nnondeterminism, but only so much that it can be resolved locally, such that a\nsyntactic product can be analysed. GFM has recently been introduced as a\nproperty for reinforcement learning, where the simpler B\\\"uchi acceptance\nconditions it allows to use is key. However, while there are classic and novel\ntechniques to obtain automata that are GFM, there has not been a decision\nprocedure for checking whether or not an automaton is GFM. We show that\nGFM-ness is decidable and provide an EXPTIME decision procedure as well as a\nPSPACE-hardness proof.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.07629v3"
    },
    {
        "title": "Finite maximal codes and factorizations of cyclic groups",
        "authors": [
            "Clelia De Felice"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Variable-length codes are the bases of the free submonoids of a free monoid.\nThere are some important longstanding open questions about the structure of\nfinite maximal codes, namely the factorization conjecture and the triangle\nconjecture, proposed by Perrin and Sch\\\"{u}tzemberger. The latter concerns\nfinite codes $Y$ which are subsets of $a^* B a^*$, where $a$ is a letter and\n$B$ is an alphabet not containing $a$. A structural property of finite maximal\ncodes has recently been shown by Zhang and Shum. It exhibits a relationship\nbetween finite maximal codes and factorizations of cyclic groups. With the aim\nof highlighting the links between this result and other older ones on maximal\nand factorizing codes, we give a simpler and a new proof of this result. As a\nconsequence, we prove that for any finite maximal code $X \\subseteq (B \\cup \\{a\n\\})^*$ containing the word $a^{pq}$, where $p,q$ are prime numbers, $X \\cap a^*\nB a^*$ satisfies the triangle conjecture. Let $n$ be a positive integer that is\na product of at most two prime numbers. We also prove that it is decidable\nwhether a finite code $Y \\cup a^{n} \\subseteq a^* B a^* \\cup a^*$ is included\nin a finite maximal code and that, if this holds, $Y \\cup a^{n}$ is included in\na code that also satisfies the factorization conjecture.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.09675v1"
    },
    {
        "title": "Well quasi-orders arising from finite ordered semigroups",
        "authors": [
            "Ondřej Klíma",
            "Jonatan Kolegar"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In 1985, Bucher, Ehrenfeucht and Haussler studied derivation relations\nassociated with a given set of context-free rules. Their research motivated a\nquestion regarding homomorphisms from the semigroup of all words onto a finite\nordered semigroup. The question is which of these homomorphisms induce a well\nquasi-order on the set of all words. We show that this problem is decidable and\nthe answer does not depend on the homomorphism, but it is a property of the\nordered semigroup.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.06535v1"
    },
    {
        "title": "Binary codes that do not preserve primitivity",
        "authors": [
            "Štěpán Holub",
            "Martin Raška",
            "Štěpán Starosta"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A code $X$ is not primitivity preserving if there is a primitive list\n${\\mathbf w} \\in {\\tt lists} X$ whose concatenation is imprimitive. We\nformalize a full characterization of such codes in the binary case in the proof\nassistant Isabelle/HOL. Part of the formalization, interesting on its own, is a\ndescription of $\\{x,y\\}$-interpretations of the square $xx$ if $|y| \\leq |x|$.\nWe also provide a formalized parametric solution of the related equation\n$x^jy^k = z^\\ell$.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.11341v1"
    },
    {
        "title": "Ordering Regular Languages and Automata: Complexity",
        "authors": [
            "Giovanna D'Agostino",
            "Davide Martincigh",
            "Alberto Policriti"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Given an order of the underlying alphabet we can lift it to the states of a\nfinite deterministic automaton: to compare states we use the order of the\nstrings reaching them. When the order on strings is the co-lexicographic one\n\\emph{and} this order turns out to be total, the DFA is called Wheeler. This\nrecently introduced class of automata -- the \\emph{Wheeler automata} --\nconstitute an important data-structure for languages, since it allows the\ndesign and implementation of a very efficient tool-set of storage mechanisms\nfor the transition function, supporting a large variety of substring queries.\n  In this context it is natural to consider the class of regular languages\naccepted by Wheeler automata, i.e. the Wheeler languages. An inspiring result\nin this area is the following: it has been shown that, as opposed to the\ngeneral case, the classic determinization by powerset construction is\n\\emph{polynomial} on Wheeler automata. As a consequence, most classical\nproblems, when considered on this class of automata, turn out to be \"easy\" --\nthat is, solvable in polynomial time.\n  In this paper we consider computational problems related to Wheelerness, but\nstarting from non-deterministic automata. We also consider the case of\n\\emph{reduced} non-deterministic ones -- a class of NFA where recognizing\nWheelerness is still polynomial, as for DFA's. Our collection of results shows\nthat moving towards non-determinism is, in most cases, a dangerous path leading\nquickly to intractability.\n  Moreover, we start a study of \"state complexity\" related to Wheeler DFA and\nlanguages, proving that the classic construction for the intersection of\nlanguages turns out to be computationally simpler on Wheeler DFA than in the\ngeneral case. We also provide a construction for the minimum Wheeler DFA\nrecognizing a given Wheeler language.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.12534v1"
    },
    {
        "title": "Kleene Star of the Primes is not Regular in Any Base",
        "authors": [
            "Jason Yuen"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Let $P_b$ denote the primes expressed in base-$b$. In this note, we prove\nthat $P_b^*$ is not regular. This strengthens a classical result that $P_b$ is\nnot regular, due to Minsky and Papert in 1966.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.16088v2"
    },
    {
        "title": "Looking for winning strategies in two-player games on Petri nets with\n  partial observability",
        "authors": [
            "Federica Adobbati",
            "Luca Bernardinello",
            "Lucia Pomello"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We define a game on 1-safe Petri nets, where a user plays against an\nenvironment in order to reach a goal on the system. The goal is expressed\nthrough an LTL-X formula, and represents a behaviour of the system that the\nuser needs to guarantee. The user can try to reach his goal by controlling a\nsubset of transitions, and by observing a subset of local states. Although we\ndo not put any requirement on the local states observable by the user, we\nassume that he cannot be sure to observe them in the exact moment in which they\nbecome marked. For this reason, we define a notion of stability of the\nobservation. We propose a method to determine whether the user has a winning\nstrategy, i.e. if he can win every play by taking some decisions based on the\ninformation available for him.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.01603v1"
    },
    {
        "title": "Continuous rational functions are deterministic regular",
        "authors": [
            "Olivier Carton",
            "Gaëtan Douéneau-Tabot"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A word-to-word function is rational if it can be realized by a\nnon-deterministic one-way transducer. Over finite words, it is a classical\nresult that any rational function is regular, i.e. it can be computed by a\ndeterministic two-way transducer, or equivalently, by a deterministic streaming\nstring transducer (a one-way automaton which manipulates string registers).\n  This result no longer holds for infinite words, since a non-deterministic\none-way transducer can guess, and check along its run, properties such as\ninfinitely many occurrences of some pattern, which is impossible for a\ndeterministic machine. In this paper, we identify the class of rational\nfunctions over infinite words which are also computable by a deterministic\ntwo-way transducer. It coincides with the class of rational functions which are\ncontinuous, and this property can thus be decided. This solves an open question\nraised in a previous paper of Dave et al.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.11235v2"
    },
    {
        "title": "On the size of good-for-games Rabin automata and its link with the\n  memory in Muller games",
        "authors": [
            "Antonio Casares",
            "Thomas Colcombet",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper, we look at good-for-games Rabin automata that recognise a\nMuller language (a language that is entirely characterised by the set of\nletters that appear infinitely often in each word). We establish that minimal\nsuch automata are exactly of the same size as the minimal memory required for\nwinning Muller games that have this language as their winning condition. We\nshow how to effectively construct such minimal automata. Finally, we establish\nthat these automata can be exponentially more succinct than equivalent\ndeterministic ones, thus proving as a consequence that chromatic memory for\nwinning a Muller game can be exponentially larger than unconstrained memory.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.11333v2"
    },
    {
        "title": "Reachability in Bidirected Pushdown VASS",
        "authors": [
            "Moses Ganardi",
            "Rupak Majumdar",
            "Andreas Pavlogiannis",
            "Lia Schütze",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A pushdown vector addition system with states (PVASS) extends the model of\nvector addition systems with a pushdown store. A PVASS is said to be\n\\emph{bidirected} if every transition (pushing/popping a symbol or modifying a\ncounter) has an accompanying opposite transition that reverses the effect.\nBidirectedness arises naturally in many models; it can also be seen as a\noverapproximation of reachability. We show that the reachability problem for\n\\emph{bidirected} PVASS is decidable in Ackermann time and primitive recursive\nfor any fixed dimension. For the special case of one-dimensional bidirected\nPVASS, we show reachability is in $\\mathsf{PSPACE}$, and in fact in polynomial\ntime if the stack is polynomially bounded. Our results are in contrast to the\n\\emph{directed} setting, where decidability of reachability is a long-standing\nopen problem already for one dimensional PVASS, and there is a\n$\\mathsf{PSPACE}$-lower bound already for one-dimensional PVASS with bounded\nstack.\n  The reachability relation in the bidirected (stateless) case is a congruence\nover $\\mathbb{N}^d$. Our upper bounds exploit saturation techniques over\ncongruences. In particular, we show novel elementary-time constructions of\nsemilinear representations of congruences generated by finitely many vector\npairs. In the case of one-dimensional PVASS, we employ a saturation procedure\nover bounded-size counters.\n  We complement our upper bound with a $\\mathsf{TOWER}$-hardness result for\narbitrary dimension and $k$-$\\mathsf{EXPSPACE}$ hardness in dimension $2k+6$\nusing a technique by Lazi\\'{c} and Totzke to implement iterative\nexponentiations.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.11799v1"
    },
    {
        "title": "Fast Coalgebraic Bisimilarity Minimization",
        "authors": [
            "Jules Jacobs",
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Coalgebraic bisimilarity minimization generalizes classical automaton\nminimization to a large class of automata whose transition structure is\nspecified by a functor, subsuming strong, weighted, and probabilistic\nbisimilarity. This offers the enticing possibility of turning bisimilarity\nminimization into an off-the-shelf technology, without having to develop a new\nalgorithm for each new type of automaton. Unfortunately, there is no existing\nalgorithm that is fully general, efficient, and able to handle large systems.\n  We present a generic algorithm that minimizes coalgebras over an arbitrary\nfunctor in the category of sets as long as the action on morphisms is\nsufficiently computable. The functor makes at most $\\mathcal{O}(m \\log n)$\ncalls to the functor-specific action, where $n$ is the number of states and $m$\nis the number of transitions in the coalgebra.\n  While more specialized algorithms can be asymptotically faster than our\nalgorithm (usually by a factor of $\\mathcal{O}(\\frac{m}{n})$), our algorithm is\nespecially well suited to efficient implementation, and our tool Boa often uses\nmuch less time and memory on existing benchmarks, and can handle larger\nautomata, despite being more generic.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.12368v3"
    },
    {
        "title": "Guarded Kleene Algebra with Tests: Automata Learning",
        "authors": [
            "Stefan Zetzsche",
            "Alexandra Silva",
            "Matteo Sammartino"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Guarded Kleene Algebra with Tests (GKAT) is the fragment of Kleene Algebra\nwith Tests (KAT) that arises by replacing the union and iteration operations of\nKAT with predicate-guarded variants. GKAT is more efficiently decidable than\nKAT and expressive enough to model simple imperative programs, making it\nattractive for applications to e.g. network verification. In this paper, we\nfurther explore GKAT's automata theory, and present GL*, an algorithm for\nlearning the GKAT automaton representation of a black-box, by observing its\nbehaviour. A complexity analysis shows that it is more efficient to learn a\nrepresentation of a GKAT program with GL* than with Angluin's existing L*\nalgorithm. We implement GL* and L* in OCaml and compare their performances on\nexample programs.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.14153v7"
    },
    {
        "title": "Deterministic pushdown automata can compress some normal sequences",
        "authors": [
            "Olivier Carton",
            "Sylvain Perifel"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper, we give a deterministic pushdown transducer and a normal\nsequence of digits compressed by it. This solves positively a question left\nopen in a previous paper by V. Becher, P. A. Heiber and the first author.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.00734v6"
    },
    {
        "title": "Group separation strikes back",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Group languages are regular languages recognized by finite groups, or\nequivalently by finite automata in which each letter induces a permutation on\nthe set of states. We investigate the separation problem for this class of\nlanguages: given two arbitrary regular languages as input, we show how to\ndecide if there exists a group language containing the first one while being\ndisjoint from the second. We prove that covering, a problem generalizing\nseparation, is decidable. A simple covering algorithm was already known: it can\nbe obtained indirectly as a corollary of an algebraic theorem by Ash.\nUnfortunately, while deducing the algorithm from this algebraic result is\nstraightforward, all proofs of Ash's result itself require a strong background\non algebraic concepts, and a wealth of technical machinery outside of automata\ntheory. Our proof is independent of previous ones. It relies exclusively on\nstandard notions from automata theory: we directly deal with separation and\nwork with input languages represented by nondeterministic finite automata.\n  We also investigate two strict subclasses. First, the alphabet modulo\ntestable languages are those defined by counting the occurrences of each letter\nmodulo some fixed integer (equivalently, they are the languages recognized by a\ncommutative group). Secondly, the modulo languages are those defined by\ncounting the length of words modulo some fixed integer. We prove that covering\nis decidable for both classes, with algorithms that rely on the construction\nmade for group languages.\n  Our proofs lead to tight complexity bounds for separation for all three\nclasses, as well as for covering for both alphabet modulo testable languages\nand for modulo testable languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.01632v2"
    },
    {
        "title": "A Generic Solution to Register-bounded Synthesis with an Application to\n  Discrete Orders",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study synthesis of reactive systems interacting with environments using an\ninfinite data domain. A popular formalism for specifying and modelling such\nsystems is register automata and transducers. They extend finite-state automata\nby adding registers to store data values and to compare the incoming data\nvalues against stored ones. Synthesis from nondeterministic or universal\nregister automata is undecidable in general. However, its register-bounded\nvariant, where additionally a bound on the number of registers in a sought\ntransducer is given, is known to be decidable for universal register automata\nwhich can compare data for equality, i.e., for data domain $(N,=)$. This paper\nextends the decidability border to the domain $(N,<)$ of natural numbers with\nlinear order. Our solution is generic: we define a sufficient condition on data\ndomains (regular approximability) for decidability of register-bounded\nsynthesis. The condition is satisfied by natural data domains like $(N,<)$. It\nallows one to use simple language-theoretic arguments and avoid technical\ngame-theoretic reasoning. Further, by defining a generic notion of reducibility\nbetween data domains, we show the decidability of synthesis in the domain\n$(N^d,<^d)$ of tuples of numbers equipped with the component-wise partial order\nand in the domain $(\\Sigma^*,\\prec)$ of finite strings with the prefix\nrelation.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.01952v3"
    },
    {
        "title": "Fuzzy Simulations and Bisimulations between Fuzzy Automata",
        "authors": [
            "Linh Anh Nguyen"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Simulations and bisimulations between two fuzzy automata over a complete\nresiduated lattice were defined by \\'Ciri\\'c et al. (2012) as fuzzy relations\nbetween the sets of states of the automata. However, they act as a crisp\nrelationship between the automata. In particular, if there exists a (forward)\nbisimulation between two fuzzy automata, then the fuzzy languages recognized by\nthem are crisply equal. Approximate simulations and bisimulations introduced by\nStanimirovi\\'c et al. (2020) aim at fuzzifying this phenomenon. However, they\nare defined only for fuzzy automata over a complete Heyting algebra and do not\ngive the exact relationship between states of the automata. In this article, we\nintroduce and study fuzzy simulations and bisimulations between fuzzy automata\nover a complete residuated lattice. These notions are novel and have good\nproperties. They are defined for fuzzy automata over any complete residuated\nlattice. We prove that the fuzzy language recognized by a fuzzy automaton is\nfuzzily preserved by fuzzy simulations and fuzzily invariant under fuzzy\nbisimulations. We also prove that the notions of fuzzy simulation and\nbisimulation have the Hennessy-Milner properties, which are a logical\ncharacterization of the greatest fuzzy simulation or bisimulation between two\nfuzzy automata. In addition, we provide results showing that our notions of\nfuzzy simulation and bisimulation are more general and refined than the notions\nof simulation and bisimulation introduced by \\'Ciri\\'c et al. and the notions\nof approximate simulation and bisimulation introduced by Stanimirovi\\'c et al.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.01955v1"
    },
    {
        "title": "Standard Automata Theory and Process Algebra",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The concepts of machine homomorphism and machine products developed in the\nautomata theory literature in the 1960s are more relevant to concurrent systems\nthan is acknowledged in the process algebra literature and offer a\nsophisticated mathematical basis for understanding concurrent systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.03515v5"
    },
    {
        "title": "A Regular and Complete Notion of Delay for Streaming String Transducers",
        "authors": [
            "Emmanuel Filiot",
            "Ismaël Jecker",
            "Christof Löding",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The notion of delay between finite transducers is a core element of numerous\nfundamental results of transducer theory. The goal of this work is to provide a\nsimilar notion for more complex abstract machines: we introduce a new notion of\ndelay tailored to measure the similarity between streaming string transducers\n(SST). We show that our notion is regular: we design a finite automaton that\ncan check whether the delay between any two SSTs executions is smaller than\nsome given bound. As a consequence, our notion enjoys good decidability\nproperties: in particular, while equivalence between non-deterministic SSTs is\nundecidable, we show that equivalence up to fixed delay is decidable. Moreover,\nwe show that our notion has good completeness properties: we prove that two\nSSTs are equivalent if and only if they are equivalent up to some (computable)\nbounded delay. Together with the regularity of our delay notion, it provides an\nalternative proof that SSTs equivalence is decidable. Finally, the definition\nof our delay notion is machine-independent, as it only depends on the origin\nsemantics of SSTs. As a corollary, the completeness result also holds for\nequivalent machine models such as deterministic two-way transducers, or MSO\ntransducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.04287v3"
    },
    {
        "title": "Parsing Expression GLL",
        "authors": [
            "Aaron Moss",
            "Brynn Harrington",
            "Emily Hoppe"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper presents an extension of the GLL parsing algorithm for\ncontext-free grammars which also supports parsing expression grammars with\nordered choice and lookahead. The new PEGLL algorithm retains support for\nunordered choice, and thus parses a common superset of context-free grammars\nand parsing expression grammars. As part of this work, the authors have\nmodified an existing GLL parser-generator to support parsing expression\ngrammars, adding operators for common parsing expressions and modifying the\nlexer algorithm to better support ordered choice.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.04600v2"
    },
    {
        "title": "A polynomial time algorithm for local testability and its level",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A locally testable semigroup S is a semigroup with the property that for some\nnonnegative integer k, called the order or level of local testability, two\nwords u and v in some set of generators for semigroup S are equal in the\nsemigroup if (1) the prefix and suffix of the words of length k coincide, and\n(2) the set of intermediate substrings of length k of the words coincide. The\nlocal testability problem for semigroups is, given a finite semigroup, to\ndecide, if the semigroup is locally testable or not. Recently, we introduced a\npolynomial time algorithm for the local testability problem and to find the\nlevel of local testability for semigroups based on our previous description of\nidentities of $k$-testable semigroups and the structure of locally testable\nsemigroups. The first part of the algorithm we introduce solves the local\ntestability problem. The second part of the algorithm finds the order of local\ntestability of a semigroup. The algorithm is of quadratic order where n is the\norder of the semigroup.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.05434v1"
    },
    {
        "title": "Probabilistic Automata of Bounded Ambiguity",
        "authors": [
            "Nathanaël Fijalkow",
            "Cristian Riveros",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Probabilistic automata are an extension of nondeterministic finite automata\nin which transitions are annotated with probabilities. Despite its simplicity,\nthis model is very expressive and many of the associated algorithmic questions\nare undecidable. In this work we focus on the emptiness problem (and its\nvariant the value problem), which asks whether a given probabilistic automaton\naccepts some word with probability greater than a given threshold. We consider\na natural and well-studied structural restriction on automata, namely the\ndegree of ambiguity, which is defined as the maximum number of accepting runs\nover all words. The known undecidability proofs exploits infinite ambiguity and\nso we focus on the case of finitely ambiguous probabilistic automata. Our main\ncontributions are to construct efficient algorithms for analysing finitely\nambiguous probabilistic automata through a reduction to a multi-objective\noptimisation problem called the stochastic path problem. We obtain a polynomial\ntime algorithm for approximating the value of probabilistic automata of fixed\nambiguity and a quasi-polynomial time algorithm for the emptiness problem for\n2-ambiguous probabilistic automata. We complement these positive results by an\ninapproximability result stating that the value of finitely ambiguous\nprobabilistic automata cannot be approximated unless PTIME = NP.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.08175v2"
    },
    {
        "title": "Binary completely reachable automata",
        "authors": [
            "David Casas",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We characterize complete deterministic finite automata with two input letters\nin which every non-empty set of states occurs as the image of the whole state\nset under the action of a suitable input word. The characterization leads to a\npolynomial-time algorithm for recognizing this class of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.09404v2"
    },
    {
        "title": "All about unambiguous polynomial closure",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study a standard operator on classes of languages: unambiguous polynomial\nclosure. We prove that for every class C of regular languages satisfying mild\nproperties, the membership problem for its unambiguous polynomial closure\nUPol(C) reduces to the same problem for C. We also show that unambiguous\npolynomial closure coincides with alternating left and right deterministic\nclosure. Moreover, we prove that if additionally C is finite, the separation\nand covering problems are decidable for UPol(C). Finally, we present an\noverview of the generic logical characterizations of the classes built using\nunambiguous polynomial closure.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.12703v4"
    },
    {
        "title": "Real-time Visualization of Stream-based Monitoring Data",
        "authors": [
            "Jan Baumeister",
            "Bernd Finkbeiner",
            "Stefan Gumhold",
            "Malte Schledjewski"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Stream-based runtime monitors are used in safety-critical applications such\nas Unmanned Aerial Systems (UAS) to compute comprehensive statistics and\nlogical assessments of system health that provide the human operator with\ncritical information in hand-over situations. In such applications, a visual\ndisplay of the monitoring data can be much more helpful than the textual alerts\nprovided by a more traditional user interface. This visualization requires\nextensive real-time data processing, which includes the synchronization of data\nfrom different streams, filtering and aggregation, and priorization and\nmanagement of user attention. We present a visualization approach for the\n\\rtlola monitoring framework. Our approach is based on the principle that the\nnecessary data processing is the responsibility of the monitor itself, rather\nthan the responsibility of some external visualization tool. We show how the\nvarious aspects of the data transformation can be described as RTLola stream\nequations and linked to the visualization component through a bidirectional\nsynchronous interface. In our experience, this approach leads to highly\ninformative visualizations as well as to understandable and easily maintainable\nmonitoring code.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.12823v1"
    },
    {
        "title": "Learning Deterministic Finite Automata Decompositions from Examples and\n  Demonstrations",
        "authors": [
            "Niklas Lauffer",
            "Beyazit Yalcinkaya",
            "Marcell Vazquez-Chanlatte",
            "Ameesh Shah",
            "Sanjit A. Seshia"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The identification of a deterministic finite automaton (DFA) from labeled\nexamples is a well-studied problem in the literature; however, prior work\nfocuses on the identification of monolithic DFAs. Although monolithic DFAs\nprovide accurate descriptions of systems' behavior, they lack simplicity and\ninterpretability; moreover, they fail to capture sub-tasks realized by the\nsystem and introduce inductive biases away from the inherent decomposition of\nthe overall task. In this paper, we present an algorithm for learning\nconjunctions of DFAs from labeled examples. Our approach extends an existing\nSAT-based method to systematically enumerate Pareto-optimal candidate\nsolutions. We highlight the utility of our approach by integrating it with a\nstate-of-the-art algorithm for learning DFAs from demonstrations. Our\nexperiments show that the algorithm learns sub-tasks realized by the labeled\nexamples, and it is scalable in the domains of interest.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.13013v1"
    },
    {
        "title": "Synchronizable functions on integers",
        "authors": [
            "Didier Caucal",
            "Chloé Rispal"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  For all natural numbers a,b and d > 0, we consider the function f_{a,b,d}\nwhich associates n/d to any integer n when it is a multiple of d, and an + b\notherwise; in particular f_{3,1,2} is the Collatz function. Coding in base a >\n1 with b < a, we realize these functions by input-deterministic\nletter-to-letter transducers with additional output final words. This\nparticular form allows to explicit, for any integer n, the composition n times\nof such a transducer to compute f^n_{a,b,d}. We even realize the closure under\ncomposition f^*_{a,b,d by an infinite input-deterministic letter-to-letter\ntransducer with a regular set of initial states and a length recurrent terminal\nfunction.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.14018v1"
    },
    {
        "title": "Computational and Descriptional Power of Nondeterministic Iterated\n  Uniform Finite-State Transducers",
        "authors": [
            "Martin Kutrib",
            "Andreas Malcher",
            "Carlo Mereghetti",
            "Beatrice Palano"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  An iterated uniform finite-state transducer (IUFST) runs the same\nlength-preserving transduction, starting with a sweep on the input string and\nthen iteratively sweeping on the output of the previous sweep. The IUFST\naccepts the input string by halting in an accepting state at the end of a\nsweep. We consider both the deterministic (IUFST) and nondeterministic (NIUFST)\nversion of this device. We show that constant sweep bounded IUFSTs and NIUFSTs\naccept all and only regular languages. We study the state complexity of\nremoving nondeterminism as well as sweeps on constant sweep bounded NIUFSTs,\nthe descriptional power of constant sweep bounded IUFSTs and NIUFSTs with\nrespect to classical models of finite-state automata, and the computational\ncomplexity of several decidability questions. Then, we focus on non-constant\nsweep bounded devices, proving the existence of a proper infinite nonregular\nlanguage hierarchy depending on the sweep complexity both in the deterministic\nand nondeterministic case. Though NIUFSTss are \"one-way\" devices we show that\nthey characterize the class of context-sensitive languages, that is, the\ncomplexity class DSpace(lin). Finally, we show that the nondeterministic\ndevices are more powerful than their deterministic variant for a sublinear\nnumber of sweeps that is at least logarithmic.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.15631v2"
    },
    {
        "title": "Towards an AAK Theory Approach to Approximate Minimization in the\n  Multi-Letter Case",
        "authors": [
            "Clara Lacroce",
            "Prakash Panangaden",
            "Guillaume Rabusseau"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study the approximate minimization problem of weighted finite automata\n(WFAs): given a WFA, we want to compute its optimal approximation when\nrestricted to a given size. We reformulate the problem as a rank-minimization\ntask in the spectral norm, and propose a framework to apply Adamyan-Arov-Krein\n(AAK) theory to the approximation problem. This approach has already been\nsuccessfully applied to the case of WFAs and language modelling black boxes\nover one-letter alphabets \\citep{AAK-WFA,AAK-RNN}. Extending the result to\nmulti-letter alphabets requires solving the following two steps. First, we need\nto reformulate the approximation problem in terms of noncommutative Hankel\noperators and noncommutative functions, in order to apply results from\nmultivariable operator theory. Secondly, to obtain the optimal approximation we\nneed a version of noncommutative AAK theory that is constructive. In this\npaper, we successfully tackle the first step, while the second challenge\nremains open.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.00172v1"
    },
    {
        "title": "Optimal Codeword Construction for DNA-based Finite Automata",
        "authors": [
            "Anupam Chattopadhyay",
            "Arnab Chakrabarti"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Biomolecular computation has emerged as an important area of computer science\nresearch due to its high information density, immense parallelism opportunity\nalong with potential applications in cryptography, genetic engineering and\nbioinformatics. Computational frameworks using DNA molecules have been proposed\nin the literature to accomplish varied tasks such as simulating logical\noperations, performing matrix multiplication, and encoding instances of NP-hard\nproblems. In one of the key applications, several studies have proposed\nconstruction of finite automata using DNA hybridisation and ligation. The state\nand symbol encoding of these finite automata are done manually. In this\nmanuscript, we study the codeword construction problem for this approach. We\nderive exact theoretical bounds on the number of symbols and states in the\nfinite automata and also obtain the complete set of symbols in a specific case.\nFor automatic encoding, two different solutions, based on a heuristic and on\nInteger Linear Programming (ILP), are proposed. Furthermore, we propose an\nearly simulation-based validation of laboratory experiments. Our proposed flow\naccepts a finite automaton, automatically encodes the symbols for the actual\nexperiments and executes the simulation step-by-step.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.01926v1"
    },
    {
        "title": "Universal Shape Replication Via Self-Assembly With Signal-Passing Tiles",
        "authors": [
            "Andrew Alseth",
            "Daniel Hader",
            "Matthew J. Patitz"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper, we investigate shape-assembling power of a tile-based model of\nself-assembly called the Signal-Passing Tile Assembly Model (STAM). In this\nmodel, the glues that bind tiles together can be turned on and off by the\nbinding actions of other glues via \"signals\". Specifically, the problem we\ninvestigate is \"shape replication\" wherein, given a set of input assemblies of\narbitrary shape, a system must construct an arbitrary number of assemblies with\nthe same shapes and, with the exception of size-bounded junk assemblies that\nresult from the process, no others. We provide the first fully universal shape\nreplication result, namely a single tile set capable of performing shape\nreplication on arbitrary sets of any 3-dimensional shapes without requiring any\nscaling or pre-encoded information in the input assemblies. Our result requires\nthe input assemblies to be composed of signal-passing tiles whose glues can be\ndeactivated to allow deconstruction of those assemblies, which we also prove is\nnecessary by showing that there are shapes whose geometry cannot be replicated\nwithout deconstruction. Additionally, we modularize our construction to create\nsystems capable of creating binary encodings of arbitrary shapes, and building\narbitrary shapes from their encodings. Because the STAM is capable of universal\ncomputation, this then allows for arbitrary programs to be run within an STAM\nsystem, using the shape encodings as input, so that any computable\ntransformation can be performed on the shapes.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.03908v1"
    },
    {
        "title": "A Report on Achieving Complete Regular-Expression Matching using Mealy\n  Machines",
        "authors": [
            "Ricardo Almeida"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  While regexp matching is a powerful mechanism for finding patterns in data\nstreams, regexp engines in general only find matches that do not overlap.\nMoreover, different forms of nondeterministic exploration, where symbols read\nare processed more than once, are often used, which can be costly in real-time\nmatching. We present an algorithm that constructs from any regexp a Mealy\nmachine that finds all matches and while reading each input symbol only once.\nThe machine computed can also detect and distinguish different patterns or\nsub-patterns inside patterns. Additionally, we show how to compute a minimal\nMealy machine via a variation of DFA minimization, by formalizing Mealy\nmachines in terms of regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.04944v1"
    },
    {
        "title": "State complexity of the star of a Boolean operation",
        "authors": [
            "Pascal Caron",
            "Edwin Hamel-de-le court",
            "Jean-Gabriel Luque"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Monsters and modifiers are two concepts recently developed in the state\ncomplexity theory.\n  A monster is an automaton in which every function from states to states is\nrepresented by at least one letter. A modifier is a set of functions allowing\none to transform a set of automata into one automaton. The paper describes a\ngeneral strategy that can be used to compute the state complexity of many\noperations. We illustrate it on the problem of the star of a Boolean operation.\nAfter applying modifiers on monsters, the states of the resulting automata are\nassimilated to combinatorial objects: the tableaux. We investigate the\ncombinatorics of these tableaux in order to deduce the state complexity.\nSpecifically, we recover the state complexity of star of intersection and star\nof union, and we also give the exact state complexity of star of symmetrical\ndifference.\n  We thus harmonize the search strategy for the state complexity of star of any\nBoolean operations.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.05100v1"
    },
    {
        "title": "Reducing the local alphabet size in tiling systems by means of 2D\n  comma-free codes",
        "authors": [
            "Stefano {Crespi Reghizzi}",
            "Antonio Restivo",
            "Pierluigi {San Pietro}"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A recognizable picture language is defined as the projection of a local\npicture language defined by a set of two-by-two tiles, i.e. by a\nstrictly-locally-testable (SLT) language of order 2. The family of recognizable\npicture languages is also defined, using larger $k$ by $k$ tiles, $k>2$, by the\nprojection of the corresponding SLT language. A basic measure of the\ndescriptive complexity of a picture language is given by the size of the SLT\nalphabet using two-by-two tiles, more precisely by the so-called alphabetic\nratio of sizes: SLT-alphabet / picture-alphabet. We study how the alphabetic\nratio changes moving from tiles of size two to tiles of larger size, and we\nobtain the following result: any recognizable picture language over an alphabet\nof size $n$ is the projection of an SLT language over an alphabet of size $2n$.\n  Moreover, two is the minimal alphabetic ratio possible in general. The proof\nrelies on a new family of comma-free picture codes, for which a lower bound on\nnumerosity is established; and on the relation of languages of encoded pictures\nwith SLT languages. Our result reproduces in two dimensions a similar property\n(known as Extended Medvedev's theorem) of the regular word languages,\nconcerning the minimal alphabetic ratio needed to define a language by means of\na projection of an SLT word language.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.05208v1"
    },
    {
        "title": "A Partially Synchronizing Coloring",
        "authors": [
            "A. N. Trahtman"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Given a finite directed graph, a coloring of its edges turns the graph into a\nfinite-state automaton. A k-synchronizing word of a deterministic automaton is\na word in the alphabet of colors at its edges that maps the state set of the\nautomaton at least on k-element subset. A coloring of edges of a directed\nstrongly connected finite graph of a uniform outdegree (constant outdegree of\nany vertex) is k-synchronizing if the coloring turns the graph into a\ndeterministic finite automaton possessing a k-synchronizing word.\n  For k=1 one has the well known road coloring problem. The recent positive\nsolution of the road coloring problem implies an elegant generalization\nconsidered first by Beal and Perrin: a directed finite strongly connected graph\nof uniform outdegree is k-synchronizing iff the greatest common divisor of\nlengths of all its cycles is k.\n  Some consequences for coloring of an arbitrary finite digraph are presented.\n  We describe a subquadratic algorithm of the road coloring for the\nk-synchronization implemented in the package TESTAS. A new linear visualization\nprogram demonstrates the obtained coloring. Some consequences for coloring of\nan arbitrary finite digraph and of such a graph of uniform outdegree are\npresented.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.07116v1"
    },
    {
        "title": "Conformance Testing of Mealy Machines Under Input Restrictions",
        "authors": [
            "Alberto Larrauri",
            "Roderick Bloem"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We introduce a grey-box conformance testing method for networks of\ninterconnected Mealy Machines. This approach addresses the scenario where all\ninterfaces of the component under test are observable, but its inputs are under\nthe control of other white-box components. We prove new conditions for full\nfault detection that exploit repetitions across branching executions of the\ncomposite machine in a novel way.Finally, we provide experimental evaluation of\nour approach on cascade compositions of up to a thousand states, and show that\nit notably out-performs existing black-box testing techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.07441v1"
    },
    {
        "title": "Effective Reductions of Mealy Machines",
        "authors": [
            "Florian Renkin",
            "Philipp Schlehuber-Caissier",
            "Alexandre Duret-Lutz",
            "Adrien Pommellet"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We revisit the problem of reducing incompletely specified Mealy machines with\nreactive synthesis in mind. We propose two techniques: the former is inspired\nby the tool MeMin and solves the minimization problem, the latter is a novel\napproach derived from simulationbased reductions but may not guarantee a\nminimized machine. However, we argue that it offers a good enough compromise\nbetween the size of the resulting Mealy machine and performance. The proposed\nmethods are benchmarked against MeMin on a large collection of test cases made\nof well-known instances as well as new ones.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.10228v1"
    },
    {
        "title": "Divide-and-Conquer Determinization of Büchi Automata based on SCC\n  Decomposition",
        "authors": [
            "Yong Li",
            "Andrea Turrini",
            "Weizhi Feng",
            "Moshe Y. Vardi",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The determinization of a nondeterministic B\\\"uchi automaton (NBA) is a\nfundamental construction of automata theory, with applications to probabilistic\nverification and reactive synthesis. The standard determinization\nconstructions, such as the ones based on the Safra-Piterman's approach, work on\nthe whole NBA. In this work we propose a divide-and-conquer determinization\napproach. To this end, we first classify the strongly connected components\n(SCCs) of the given NBA as inherently weak, deterministic accepting, and\nnondeterministic accepting. We then present how to determinize each type of SCC\nindependently from the others; this results in an easier handling of the\ndeterminization algorithm that takes advantage of the structure of that SCC.\nOnce all SCCs have been determinized, we show how to compose them so to obtain\nthe final equivalent deterministic Emerson-Lei automaton, which can be\nconverted into a deterministic Rabin automaton without blow-up of states and\ntransitions. We implement our algorithm in a our tool COLA and empirically\nevaluate COLA with the state-of-the-art tools Spot and OWL on a large set of\nbenchmarks from the literature. The experimental results show that our\nprototype COLA outperforms Spot and OWL regarding the number of states and\ntransitions.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.13739v1"
    },
    {
        "title": "The Power-Set Construction for Tree Algebras",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study power-set operations on classes of trees and tree algebras. Our main\nresult consists of a distributive law between the tree monad and the\nupwards-closed power-set monad, in the case where all trees are assumed to be\nlinear. For non-linear ones, we prove that such a distributive law does not\nexist.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.00563v5"
    },
    {
        "title": "Timed Alignments",
        "authors": [
            "Thomas Chatain",
            "Neha Rino"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The subject of this paper is to study conformance checking for timed models,\nthat is, process models that consider both the sequence of events in a process\nas well as the timestamps at which each event is recorded. Time-aware process\nmining is a growing subfield of research, and as tools that seek to discover\ntiming related properties in processes develop, so does the need for\nconformance checking techniques that can tackle time constraints and provide\ninsightful quality measures for time-aware process models. In particular, one\nof the most useful conformance artefacts is the alignment, that is, finding the\nminimal changes necessary to correct a new observation to conform to a process\nmodel. In this paper, we set our problem of timed alignment and solve two cases\neach corresponding to a different metric over time processes. For the first, we\nhave an algorithm whose time complexity is linear both in the size of the\nobserved trace and the process model, while for the second we have a quadratic\ntime algorithm for linear process models.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.01870v1"
    },
    {
        "title": "Simulations for Event-Clock Automata",
        "authors": [
            "S Akshay",
            "Paul Gastin",
            "R Govind",
            "B Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Event-clock automata (ECA) are a well-known semantic subclass of timed\nautomata (TA) which enjoy admirable theoretical properties, e.g.,\ndeterminizability, and are practically useful to capture timed specifications.\nHowever, unlike for timed automata, there exist no implementations for checking\nnon-emptiness of event-clock automata. As ECAs contain special prophecy clocks\nthat guess and maintain the time to the next occurrence of specific events,\nthey cannot be seen as a syntactic subclass of TA. Therefore, implementations\nfor TA cannot be directly used for ECAs, and moreover the translation of an ECA\nto a semantically equivalent TA is expensive. Another reason for the lack of\nECA implementations is the difficulty in adapting zone-based algorithms,\ncritical in the timed automata setting, to the event-clock automata setting.\nThis difficulty was studied by Geeraerts et al. in 2011, where the authors\nproposed a zone enumeration procedure that uses zone extrapolations for\nfiniteness. In this article, we propose a different zone-based algorithm to\nsolve the reachability problem for event-clock automata, using simulations for\nfiniteness. A surprising consequence of our result is that for event-predicting\nautomata, the subclass of event-clock automata that only use prophecy clocks,\nwe obtain finiteness even without any simulations. For general event-clock\nautomata, our new algorithm exploits the G-simulation framework, which is the\ncoarsest known simulation relation in timed automata literature, and has been\nrecently used for advances in other extensions of timed automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.02633v5"
    },
    {
        "title": "Z-polyregular functions",
        "authors": [
            "Thomas Colcombet",
            "Gaëtan Douéneau-Tabot",
            "Aliaume Lopez"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper introduces a robust class of functions from finite words to\nintegers that we call Z-polyregular functions. We show that it admits natural\ncharacterizations in terms of logics, Z-rational expressions, Z-rational series\nand transducers.\n  We then study two subclass membership problems. First, we show that the\nasymptotic growth rate of a function is computable, and corresponds to the\nminimal number of variables required to represent it using logical formulas.\nSecond, we show that first-order definability of Z-polyregular functions is\ndecidable. To show the latter, we introduce an original notion of residual\ntransducer, and provide a semantic characterization based on aperiodicity.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.07450v4"
    },
    {
        "title": "Two-Dimensional Typewriter Automata",
        "authors": [
            "Taylor J. Smith"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A typewriter automaton is a special variant of a two-dimensional automaton\nthat receives two-dimensional words as input and is only capable of moving its\ninput head through its input word in three directions: downward, leftward, and\nrightward. In addition, downward and leftward moves may only be made via a\nspecial \"reset\" move that simulates the action of a typewriter's carriage\nreturn.\n  In this paper, we initiate the study of the typewriter automaton model and\nrelate it to similar models, including three-way two-dimensional automata,\nboustrophedon automata, and returning automata. We study the recognition powers\nof the typewriter automaton model, establish closure properties of the class of\nlanguages recognized by the model, and consider operational state complexity\nbounds for the specific operation of row concatenation. We also provide a\nvariety of potential future research directions pertaining to the model.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.10016v1"
    },
    {
        "title": "Assume, Guarantee or Repair -- A Regular Framework for Non Regular\n  Properties (full version)",
        "authors": [
            "Hadar Frenkel",
            "Orna Grumberg",
            "Corina S. Pasareanu",
            "Sarai Sheinvald"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We present Assume-Guarantee-Repair (AGR) - a novel framework which verifies\nthat a program satisfies a set of properties and also repairs the program in\ncase the verification fails. We consider communicating programs - these are\nsimple C-like programs, extended with synchronous actions over communication\nchannels. Our method, which consists of a learning-based approach to\nassume-guarantee reasoning, performs verification and repair simultaneously: in\nevery iteration, AGR either makes another step towards proving that the\n(current) system satisfies the required properties, or alters the system in a\nway that brings it closer to satisfying the properties. To handle\ninfinite-state systems we build finite abstractions, for which we check the\nsatisfaction of complex properties that contain first-order constraints, using\nboth syntactic and semantic-aware methods. We implemented AGR and evaluated it\non various communication protocols. Our experiments present compact proofs of\ncorrectness and quick repairs.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.10534v1"
    },
    {
        "title": "Development of monitoring systems for anomaly detection using ASTD\n  specifications",
        "authors": [
            "El Jabri Chaymae",
            "Frappier Marc",
            "Ecarot Thibaud",
            "Tardif Pierre-Martin"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Anomaly-based intrusion detection systems are essential defenses against\ncybersecurity threats because they can identify anomalies in current\nactivities. However, these systems have difficulties providing entity\nprocessing independence through a programming language. In addition, a\ndegradation of the detection process is caused by the complexity of scheduling\nthe training and detection processes, which are required to keep the anomaly\ndetection system continuously updated. This paper shows how to use the\nalgebraic state-transition diagram (ASTD) language to develop flexible anomaly\ndetection systems. This paper provides a model for detecting point anomalies\nusing the unsupervised non-parametric technique Kernel Density Estimation to\nestimate the probability density of event occurrence. The proposed model caters\nfor both the training and the detection phase continuously. The ASTD language\nstreamlines the modeling of detection systems thanks to its process algebraic\noperators that provide a solution to overcome these challenges. By delegating\nthe combination of anomaly-based detection processes to the ASTD language, the\neffort and complexity are reduced during detection models development. Finally,\nusing a qualitative evaluation, this study demonstrates that the algebraic\noperators in the ASTD specification language overcome these challenges.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.11134v1"
    },
    {
        "title": "Machine-checked executable semantics of Stateflow",
        "authors": [
            "Shicheng Yi",
            "Shuling Wang",
            "Bohua Zhan",
            "Naijun Zhan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Simulink is a widely used model-based development environment for embedded\nsystems. Stateflow is a component of Simulink for modeling event-driven control\nvia hierarchical state machines and flow charts. However, Stateflow lacks an\nofficial formal semantics, making it difficult to formally prove properties of\nits models in safety-critical applications. In this paper, we define a formal\nsemantics for a large subset of Stateflow, covering complex features such as\nhierarchical states and transitions, event broadcasts, early return, temporal\noperators, and so on. The semantics is formalized in Isabelle/HOL and proved to\nbe deterministic. We implement a tactic for automatic execution of the\nsemantics in Isabelle, as well as a translator in Python transforming Stateflow\nmodels to the syntax in Isabelle. Using these tools, we validate the semantics\nagainst a collection of examples illustrating the features we cover.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.11965v1"
    },
    {
        "title": "Optimal Repair For Omega-regular Properties",
        "authors": [
            "Vrunda Dave",
            "Shankara Narayanan Krishna",
            "Vishnu Murali",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper presents an optimization based framework to automate system repair\nagainst omega-regular properties. In the proposed formalization of optimal\nrepair, the systems are represented as Kripke structures, the properties as\n$\\omega$-regular languages, and the repair space as repair machines -- weighted\nomega-regular transducers equipped with B\\\"uchi conditions -- that rewrite\nstrings and associate a cost sequence to these rewritings. To translate the\nresulting cost-sequences to easily interpretable payoffs, we consider several\naggregator functions to map cost sequences to numbers -- including limit\nsuperior, supremum, discounted-sum, and average-sum -- to define quantitative\ncost semantics. The problem of optimal repair, then, is to determine whether\ntraces from a given system can be rewritten to satisfy an $\\omega$-regular\nproperty when the allowed cost is bounded by a given threshold. We also\nconsider the dual challenge of impair verification that assumes that the\nrewritings are resolved adversarially under some given cost restriction, and\nasks to decide if all traces of the system satisfy the specification\nirrespective of the rewritings. With a negative result to the impair\nverification problem, we study the problem of designing a minimal mask of the\nKripke structure such that the resulting traces satisfy the specifications\ndespite the threshold-bounded impairment. We dub this problem as the mask\nsynthesis problem. This paper presents automata-theoretic solutions to repair\nsynthesis, impair verification, and mask synthesis problem for limit superior,\nsupremum, discounted-sum, and average-sum cost semantics.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.13416v1"
    },
    {
        "title": "FORQ-based Language Inclusion Formal Testing",
        "authors": [
            "Kyveli Doveri",
            "Pierre Ganty",
            "Nicolas Mazzocchi"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose a novel algorithm to decide the language inclusion between\n(nondeterministic) B\\\"uchi automata, a PSPACE-complete problem. Our approach,\nlike others before, leverage a notion of quasiorder to prune the search for a\ncounterexample by discarding candidates which are subsumed by others for the\nquasiorder. Discarded candidates are guaranteed to not compromise the\ncompleteness of the algorithm. The novelty of our work lies in the quasiorder\nused to discard candidates. We introduce FORQs (family of right quasiorders)\nthat we obtain by adapting the notion of family of right congruences put\nforward by Maler and Staiger in 1993. We define a FORQ-based inclusion\nalgorithm which we prove correct and instantiate it for a specific FORQ, called\nthe structural FORQ, induced by the B\\\"uchi automaton to the right of the\ninclusion sign. The resulting implementation, called FORKLIFT, scales up better\nthan the state-of-the-art on a variety of benchmarks including benchmarks from\nprogram verification and theorem proving for word combinatorics.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.13549v1"
    },
    {
        "title": "A Diamond Structure in the Transducer Hierarchy",
        "authors": [
            "Noah Kaufmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We answer an open question in the theory of transducer degrees initially\nposed in [1] on the existence of a diamond structure in the transducer\nhierarchy. Transducer degrees are the equivalence classes formed by word\ntransformations which can be realized by a finite state transducer, which form\nan order based on which words can be transformed into other words. We provide a\nconstruction which proves the existence of a diamond structure, while also\nintroducing a new function on streams which may be useful for proving more\nresults about the transducer hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.00554v5"
    },
    {
        "title": "Fair Planning for Mobility-on-Demand with Temporal Logic Requests",
        "authors": [
            "Kaier Liang",
            "Cristian-Ioan Vasile"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Mobility-on-demand systems are transforming the way we think about the\ntransportation of people and goods. Most research effort has been placed on\nscalability issues for systems with a large number of agents and simple\npick-up/drop-off demands. In this paper, we consider fair multi-vehicle route\nplanning with streams of complex, temporal logic transportation demands. We\nconsider an approximately envy-free fair allocation of demands to\nlimited-capacity vehicles based on agents' accumulated utility over a finite\ntime horizon, representing for example monetary reward or utilization level. We\npropose a scalable approach based on the construction of assignment graphs that\nrelate agents to routes and demands, and pose the problem as an Integer Linear\nProgram (ILP). Routes for assignments are computed using automata-based methods\nfor each vehicle and demands sets of size at most the capacity of the vehicle\nwhile taking into account their pick-up wait time and delay tolerances. In\naddition, we integrate utility-based weights in the assignment graph and ILP to\nensure approximative fair allocation. We demonstrate the computational and\noperational performance of our methods in ride-sharing case studies over a\nlarge environment in mid-Manhattan and Linear Temporal Logic demands with\nstochastic arrival times. We show that our method significantly decreases the\nutility deviation between agents and the vacancy rate.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.04416v2"
    },
    {
        "title": "Synthesizing Transducers from Complex Specifications",
        "authors": [
            "Anvay Grover",
            "Ruediger Ehlers",
            "Loris D'Antoni"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Automating string transformations has been one of the killer applications of\nprogram synthesis. Existing synthesizers that solve this problem produce\nprograms in domain-specific languages (DSL) that are engineered to help the\nsynthesizer, and therefore lack nice formal properties. This limitation\nprevents the synthesized programs from being used in verification applications\n(e.g., to check complex pre-post conditions) and makes the synthesizers hard to\nmodify due to their reliance on the given DSL. We present a constraint-based\napproach to synthesizing transducers, a well-studied model with strong closure\nand decidability properties. Our approach handles three types of\nspecifications: (i) input-output examples, (ii) input-output types expressed as\nregular languages, and (iii) input/output distances that bound how many\ncharacters the transducer can modify when processing an input string. Our work\nis the first to support such complex specifications and it does so by using the\nalgorithmic properties of transducers to generate constraints that can be\nsolved using off-the-shelf SMT solvers. Our synthesis approach can be extended\nto many transducer models and it can be used, thanks to closure properties of\ntransducers, to compute repairs for partially correct transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.05131v2"
    },
    {
        "title": "Completely reachable automata: a quadratic decision algorithm and a\n  quadratic upper bound on the reaching threshold",
        "authors": [
            "Robert Ferens",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A complete deterministic finite (semi)automaton (DFA) with a set of states\n$Q$ is \\emph{completely reachable} if every nonempty subset of $Q$ is the image\nof the action of some word applied to $Q$. The concept of completely reachable\nautomata appeared, in particular, in connection with synchronizing automata;\nthe class contains the \\v{C}ern{\\'y} automata and covers several independently\ninvestigated subclasses. The notion was introduced by Bondar and Volkov (2016),\nwho also raised the question about the complexity of deciding if an automaton\nis completely reachable. We develop an algorithm solving this problem, which\nworks in ${\\O(|\\Sigma|\\cdot n^2)}$ time and $\\O(|\\Sigma|\\cdot n)$ space, where\n$n=|Q|$ is the number of states and $|\\Sigma|$ is the size of the input\nalphabet. In the second part, we prove a weak Don's conjecture for this class\nof automata: a subset of states $S \\subseteq Q$ is reachable with a word of\nlength at most $2n(n-|S|) - n \\cdot H_{n-|S|}$, where $H_i$ is the $i$-th\nharmonic number. This implies a quadratic upper bound in $n$ on the length of\nthe shortest synchronizing words (reset threshold) for the class of completely\nreachable automata and generalizes earlier upper bounds derived for its\nsubclasses.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.05956v4"
    },
    {
        "title": "Active Learning for Deterministic Bottom-up Nominal Tree Automata",
        "authors": [
            "R. Nakanishi",
            "Y. Takata",
            "H. Seki"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Nominal set plays a central role in a group-theoretic extension of finite\nautomata to those over an infinite set of data values. Moerman et al. proposed\nan active learning algorithm for nominal word automata with the equality\nsymmetry. In this paper, we introduce deterministic bottom-up nominal tree\nautomata (DBNTA), which operate on trees whose nodes are labelled with elements\nof an orbit finite nominal set. We then prove a Myhill-Nerode theorem for the\nclass of languages recognized by DBNTA and propose an active learning algorithm\nfor DBNTA. The algorithm can deal with any data symmetry that admits least\nsupport, not restricted to the equality symmetry and/or the total order\nsymmetry. To prove the termination of the algorithm, we define a partial order\non nominal sets and show that there is no infinite chain of orbit finite\nnominal sets with respect to this partial order between any two orbit finite\nsets.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.08319v1"
    },
    {
        "title": "Proceedings 12th International Workshop on Non-Classical Models of\n  Automata and Applications",
        "authors": [
            "Henning Bordihn",
            "Géza Horváth",
            "György Vaszil"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The Twelfth International Workshop on Non-Classical Models of Automata and\nApplications (NCMA 2022) was held in Debrecen, Hungary, on August 26 and 27,\n2022, organized by the University of Debrecen. The NCMA workshop series was\nestablished in 2009 as an annual event for researchers working on non-classical\nand classical models of automata, grammars or related devices. Such models are\ninvestigated both as theoretical models and as formal models for applications\nfrom different points of view.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.13015v1"
    },
    {
        "title": "Reversible Computations of One-Way Counter Automata",
        "authors": [
            "Martin Kutrib",
            "Andreas Malcher"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Deterministic one-way time-bounded multi-counter automata are studied with\nrespect to their ability to perform reversible computations, which means that\nthe automata are also backward deterministic and, thus, are able to uniquely\nstep the computation back and forth. We study the computational capacity of\nsuch devices and obtain separation results between irreversible and reversible\nk-counter automata for superpolynomial time. For exponential time we obtain\nmoreover an infinite and tight hierarchy with respect to the number of\ncounters. This hierarchy is shown with Kolmogorov complexity and\nincompressibility arguments. In this way, on passing we can prove this\nhierarchy also for ordinary counter automata. This improves the known hierarchy\nfor ordinary counter automata in the sense that here we consider a weaker\nacceptance condition. Then, it turns out that k+1 reversible counters are not\nbetter than k ordinary counters and vice versa. Finally, almost all usually\nstudied decidability questions turn out to be undecidable and not even\nsemidecidable for reversible multi-counter automata, if at least two counters\nare provided.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14720v1"
    },
    {
        "title": "P versus B: P Systems as a Formal Framework for Controllability of\n  Boolean Networks",
        "authors": [
            "Artiom Alhazov",
            "Rudolf Freund",
            "Sergiu Ivanov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Membrane computing and P systems are a paradigm of massively parallel natural\ncomputing introduced by Gheorghe P\\u{a}un in 1999, inspired by the structure of\nthe living cell and by its biochemical reactions. In spite of this explicit\nbiological motivation, P systems have not been extensively used in modelling\nreal-world systems. To confirm this intuition, we establish a state of the art\ninvestigation comparing the use of P systems to that of Boolean networks in\nthis line of research. We then propose to use P systems as a tool for setting\nup formal frameworks to reason about other formalisms, and we introduce Boolean\nP systems, specifically tailored for capturing sequential controllability of\nBoolean networks. We show how to tackle some technical challenges and prove\nthat sequential controllability properly embeds in the framework of Boolean P\nsystems.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14723v1"
    },
    {
        "title": "Monadic Expressions and their Derivatives",
        "authors": [
            "Samira Attou",
            "Ludovic Mignot",
            "Clément Miklarz",
            "Florent Nicart"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose another interpretation of well-known derivatives computations from\nregular expressions, due to Brzozowski, Antimirov or Lombardy and Sakarovitch,\nin order to abstract the underlying data structures (e.g. sets or linear\ncombinations) using the notion of monad. As an example of this generalization\nadvantage, we introduce a new derivation technique based on the graded module\nmonad.\n  We also extend operators defining expressions to any n-ary functions over\nvalue sets, such as classical operations (like negation or intersection for\nBoolean weights) or more exotic ones (like algebraic mean for rational\nweights).\n  Moreover, we present how to compute a (non-necessarily finite) automaton from\nsuch an extended expression, using the Colcombet and Petrisan categorical\ndefinition of automata. These category theory concepts allow us to perform this\nconstruction in a unified way, whatever the underlying monad.\n  Finally, to illustrate our work, we present a Haskell implementation of these\nnotions using advanced techniques of functional programming, and we provide a\nweb interface to manipulate concrete examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14724v1"
    },
    {
        "title": "On the Generative Capacity of Contextual Grammars with Strictly Locally\n  Testable Selection Languages",
        "authors": [
            "Jürgen Dassow",
            "Bianca Truthe"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We continue the research on the generative capacity of contextual grammars\nwhere contexts are adjoined around whole words (externally) or around subwords\n(internally) which belong to special regular selection languages. All languages\ngenerated by contextual grammars where all selection languages are elements of\na certain subregular language family form again a language family. We\ninvestigate contextual grammars with strictly locally testable selection\nlanguages and compare those families to families which are based on finite,\nmonoidal, nilpotent, combinational, definite, suffix-closed, ordered,\ncommutative, circular, non-counting, power-separating, or union-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14725v1"
    },
    {
        "title": "Conclusive Tree-Controlled Grammars",
        "authors": [
            "Dominika Klobučníková",
            "Zbyněk Křivka",
            "Alexander Meduna"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper presents a new approach to regulation of grammars. It divides the\nderivation trees generated by grammars into two sections-generative and\nconclusive (the conclusion). The former encompasses generation of symbols up\ntill the moment when the lowest rightmost terminal of the derivation tree is\ngenerated, whereas the latter represents the final steps needed to successfully\ngenerate a sentence. A control mechanism based on regulating only the\nconclusion is presented and subsequently applied to tree-controlled grammars,\ncreating conclusive tree-controlled grammars. As the main result, it is shown\nthat the ratio between depths of generative and conclusive sections does not\ninfluence the generative power. In addition, it is demonstrated that any\nrecursively enumerable language is generated by these grammars possessing no\nmore than seven nonterminals while the regulating language is union-free.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14728v1"
    },
    {
        "title": "Non-Returning Finite Automata With Translucent Letters",
        "authors": [
            "František Mráz",
            "Friedrich Otto"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Here we propose a variant of the nondeterministic finite automaton with\ntranslucent letters (NFAwtl) which, after reading and deleting a letter, does\nnot return to the left end of its tape, but rather continues from the position\nof the letter just deleted. When the end-of-tape marker is reached, our\nautomaton can decide whether to accept, to reject, or to continue, which means\nthat it again reads the remaining tape contents from the beginning. This type\nof automaton, called a non-returning finite automaton with translucent letters\nor an nrNFAwtl, is strictly more expressive than the NFAwtl. We study the\nexpressive capacity of this type of automaton and that of its deterministic\nvariant. Also we are interested in closure properties of the resulting classes\nof languages and in decision problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14729v1"
    },
    {
        "title": "Quasi-deterministic 5' -> 3' Watson-Crick Automata",
        "authors": [
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Watson-Crick (WK) finite automata are working on a Watson-Crick tape, that\nis, on a DNA molecule. A double stranded DNA molecule contains two strands,\neach having a 5' and a 3' end, and these two strands together form the molecule\nwith the following properties. The strands have the same length, their 5' to 3'\ndirections are opposite, and in each position, the two strands have nucleotides\nthat are complement of each other (by the Watson-Crick complementary relation).\nConsequently, WK automata have two reading heads, one for each strand. In\ntraditional WK automata both heads read the whole input in the same physical\ndirection, but in 5'->3' WK automata the heads start from the two extremes and\nread the input in opposite direction. In sensing 5'->3' WK automata, the\nprocess on the input is finished when the heads meet, and the model is capable\nto accept the class of linear context-free languages. Deterministic variants\nare weaker, the class named 2detLIN, a proper subclass of linear languages is\naccepted by them. Recently, another specific variants, the state-deterministic\nsensing 5'->3' WK automata are investigated in which the graph of the automaton\nhas the special property that for each node of the graph, all out edges (if\nany) go to a sole node, i.e., for each state there is (at most) one state that\ncan be reached by a direct transition. It was shown that this concept is\nsomewhat orthogonal to the usual concept of determinism in case of sensing\n5'->3' WK automata. In this paper a new concept, the quasi-determinism is\ninvestigated, that is in each configuration of a computation (if it is not\nfinished yet), the next state is uniquely determined although the next\nconfiguration may not be, in case various transitions are enabled at the same\ntime. We show that this new concept is a common generalisation of the usual\ndeterminism and the state-determinism, i.e., the class of quasi-deterministic\nsensing 5'->3' WK automata is a superclass of both of the mentioned other\nclasses. There are various usual restrictions on WK automata, e.g., stateless\nor 1-limited variants. We also prove some hierarchy results among language\nclasses accepted by various subclasses of quasi-deterministic sensing 5'->3' WK\nautomata and also some other already known language classes.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14730v1"
    },
    {
        "title": "On the Accepting State Complexity of Operations on Permutation Automata",
        "authors": [
            "Christian Rauch",
            "Markus Holzer"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We investigate the accepting state complexity of deterministic finite\nautomata for regular languages obtained by applying one of the following\noperations to languages accepted by permutation automata: union, quotient,\ncomplement, difference, intersection, Kleene star, Kleene plus, and reversal.\nThe paper thus joins the study of accepting state complexity of regularity\npreserving language operations which was initiated by the work [J. Dassow: On\nthe number of accepting states of finite automata, J. Autom., Lang. Comb., 21,\n2016]. We show that for almost all of the operations, except for reversal and\nquotient, there is no difference in the accepting state complexity for\npermutation automata compared to deterministic finite automata in general. For\nboth reversal and quotient we prove that certain accepting state complexities\ncannot be obtained; these number are called \"magic\" in the literature.\nMoreover, we solve the left open accepting state complexity problem for the\nintersection of unary languages accepted by permutation automata and\ndeterministic finite automata in general.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.14731v1"
    },
    {
        "title": "How to decide Functionality of Compositions of Top-Down Tree Transducers",
        "authors": [
            "Sebastian Maneth",
            "Helmut Seidl",
            "Martin Vu"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We prove that functionality of compositions of top-down tree transducers is\ndecidable by reducing the problem to the functionality of one top-down tree\ntransducer with look-ahead.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.01044v1"
    },
    {
        "title": "Practical Aspects of Membership Problem of Watson-Crick Context-free\n  Grammars",
        "authors": [
            "Jan Hammer",
            "Zbyněk Křivka"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper focuses on Watson-Crick languages inspired by DNA computing, their\nmodels, and algorithms for deciding the language membership. It analyzes a\nrecently introduced algorithm called WK-CYK and introduces a state space search\nalgorithm that is based on regular Breadth-first search but uses a number of\noptimizations and heuristics to be efficient in practical use and able to\nanalyze longer inputs. The key parts are the heuristics for pruning the state\nspace (detecting dead ends) and heuristics for choosing the most promising\nbranches to continue the search.\n  These two algorithms have been tested with 20 different Watson-Crick grammars\n(40 including their Chomsky normal form versions). While WK-CYK is able to\ndecide the language membership in a reasonable time for inputs of the length of\nroughly 30-50 symbols and its performance is very consistent for all kinds of\ngrammars and inputs, the state space search is usually (89-98 % of cases) more\nefficient and able to do the computation for inputs with lengths of hundreds or\neven thousands of symbols. Thus, the state space search has the potential to be\na good tool for practical Watson-Crick membership testing and is a good basis\nfor improvement the efficiency of the algorithm in the future.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.03655v1"
    },
    {
        "title": "Window Expressions for Stream Data Processing",
        "authors": [
            "M. Praveen",
            "S. Hitarth"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Traditional ways of storing and querying data do not work well in scenarios\nwhere data is being generated continuously and quick decisions need to be\ntaken. For example, in hospital intensive care units, signals from multiple\ndevices need to be monitored and the occurrence of any anomaly should raise\nalarms immediately. A typical design would take the average from a window of\nsay 10 seconds (time-based) or 10 successive (count-based) readings and look\nfor sudden deviations. Existing stream processing systems either restrict the\nwindows to time or count-based windows or let users define customized windows\nin imperative programming languages. These are subject to the implementers'\ninterpretation of what is desired and hard to understand for others. We\nintroduce a formalism for specifying windows based on Monadic Second Order\nlogic. It offers several advantages over ad-hoc definitions written in\nimperative languages. We demonstrate four such advantages. First, we illustrate\nhow practical streaming data queries can be easily written with precise\nsemantics. Second, we can get different but expressively equivalent formalisms\nfor defining windows. We use one of them (regular expressions) to design an\nend-user-friendly language for defining windows. Third, we use another\nexpressively equivalent formalism (automata) to design a processor that\nautomatically generates windows according to specifications. The fourth\nadvantage we demonstrate is more sophisticated. Some window definitions have\nthe problem of too many windows overlapping with each other, overwhelming the\nprocessing engine. This is handled in different ways by different engines, but\nall the options are about what to do when this happens at runtime. We study\nthis as a static analysis question and prove that it is undecidable to check\nwhether such a scenario can ever arise for a given window definition. We\nidentify a decidable fragment...\n",
        "pdf_link": "http://arxiv.org/pdf/2209.04244v2"
    },
    {
        "title": "Composing Copyless Streaming String Transducers",
        "authors": [
            "Rajeev Alur",
            "Taylor Dohmen",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Streaming string transducers (SSTs) implement string-to-string\ntransformations by reading each input word in a single left-to-right pass while\nmaintaining fragments of potential outputs in a finite set of string variables.\nThese variables get updated on transitions of the transducer, where they can be\nassigned new values described by concatenations of variables and output\nsymbols. An SST is called copyless if every update is such that no variable\noccurs more than once amongst all of the assigned expressions. The\ntransformations realized by copyless SSTs coincide with Courcelle's monadic\nsecond-order logic graph transducers (MSOTs) when restricted to string graphs.\nCopyless SSTs with nondeterminism are known to be equivalent to\nnondeterministic MSOTs as well.\n  MSOTs, both deterministic and nondeterministic, are closed under composition.\nGiven the equivalence of MSOTs and copyless SSTs, it is easy to see that\ncopyless SSTs are also closed under composition. The original proof of this\nfact, however, was based on a direct construction to produce a composite\ncopyless SST from two given copyless SSTs. A counterexample discovered by Joost\nEnglefriet showed that this construction may produce copyful transducers. We\nrevisit the original composition constructions for both deterministic and\nnondeterministic SSTs and show that, although they can introduce copyful\nupdates, the resulting copyful behavior they exhibit is superficial. To\ncharacterize this mild copyful behavior, we define a subclass of copyful SSTs,\ncalled diamond-free SSTs, in which two copies of a common variable are never\ncombined in any subsequent assignment. In order to recover a modified version\nof the original construction, we provide a method for producing an equivalent\ncopyless SST from any diamond-free copyful SST.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.05448v2"
    },
    {
        "title": "Software-Hardware Codesign for Efficient In-Memory Regular Pattern\n  Matching",
        "authors": [
            "Lingkun Kong",
            "Qixuan Yu",
            "Agnishom Chattopadhyay",
            "Alexis Le Glaunec",
            "Yi Huang",
            "Konstantinos Mamouras",
            "Kaiyuan Yang"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Regular pattern matching is used in numerous application domains, including\ntext processing, bioinformatics, and network security. Patterns are typically\nexpressed with an extended syntax of regular expressions that include the\ncomputationally challenging construct of bounded iteration or counting, which\ndescribes the repetition of a pattern a fixed number of times. We develop a\ndesign for a specialized in-memory hardware architecture for NFA execution that\nintegrates counter and bit vector elements. The design is inspired by the\ntheoretical model of nondeterministic counter automata (NCA). A key feature of\nour approach is that we statically analyze regular expressions to determine\nbounds on the amount of memory needed for the occurrences of counting. The\nresults of this analysis are used by a regex-to-hardware compiler in order to\nmake an appropriate selection of counter or bit vector elements. We evaluate\nthe performance of our hardware implementation on a simulator based on circuit\nparameters collected by SPICE simulation using a TSMC 28nm process. We find the\nusage of counter and bit vector quickly outperforms unfolding solutions by\norders of magnitude with small counting quantifiers. Experiments concerning\nrealistic workloads show up to 76% energy reduction and 58% area reduction in\ncomparison to traditional in-memory NFA processors.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.05686v1"
    },
    {
        "title": "Characterizing Attributed Tree Translations in Terms of Macro Tree\n  Transducers",
        "authors": [
            "Kenji Hashimoto",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  It is well known that attributed tree transducers can be equipped with\n\"regular look-around\" in order to obtain a more robust class of translations.\nWe present two characterizations of this class in terms of macro tree\ntransducers (MTTs): the first one is a static restriction on the rules of the\nMTTs, where the MTTs need to be equipped with regular look-around. The second\ncharacterization is a dynamic one, where the MTTs only need regular look-ahead.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.07090v1"
    },
    {
        "title": "History-deterministic Parikh Automata",
        "authors": [
            "Enzo Erlich",
            "Mario Grobler",
            "Shibashis Guha",
            "Ismaël Jecker",
            "Karoliina Lehtinen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parikh automata extend finite automata by counters that can be tested for\nmembership in a semilinear set, but only at the end of a run. Thereby, they\npreserve many of the desirable properties of finite automata. Deterministic\nParikh automata are strictly weaker than nondeterministic ones, but enjoy\nbetter closure and algorithmic properties. This state of affairs motivates the\nstudy of intermediate forms of nondeterminism. Here, we investigate\nhistory-deterministic Parikh automata, i.e., automata whose nondeterminism can\nbe resolved on the fly. This restricted form of nondeterminism is well-suited\nfor applications which classically call for determinism, e.g., solving games\nand composition. We show that history-deterministic Parikh automata are\nstrictly more expressive than deterministic ones, incomparable to unambiguous\nones, and enjoy almost all of the closure properties of deterministic automata.\nFinally, we investigate the complexity of resolving nondeterminism in\nhistory-deterministic Parikh automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.07745v3"
    },
    {
        "title": "Constructing Concise Characteristic Samples for Acceptors of Omega\n  Regular Languages",
        "authors": [
            "Dana Angluin",
            "Dana Fisman"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A characteristic sample for a language $L$ and a learning algorithm\n$\\textbf{L}$ is a finite sample of words $T_L$ labeled by their membership in\n$L$ such that for any sample $T \\supseteq T_L$ consistent with $L$, on input\n$T$ the learning algorithm $\\textbf{L}$ returns a hypothesis equivalent to $L$.\nWhich omega automata have characteristic sets of polynomial size, and can these\nsets be constructed in polynomial time? We address these questions here. In\nbrief, non-deterministic omega automata of any of the common types, in\nparticular B\\\"uchi, do not have characteristic samples of polynomial size. For\ndeterministic omega automata that are isomorphic to their right congruence\nautomata, the fully informative languages, polynomial time algorithms for\nconstructing characteristic samples and learning from them are given. The\nalgorithms for constructing characteristic sets in polynomial time for the\ndifferent omega automata (of types B\\\"uchi, coB\\\"uchi, parity, Rabin, Street,\nor Muller), require deterministic polynomial time algorithms for (1)\nequivalence of the respective omega automata, and (2) testing membership of the\nlanguage of the automaton in the informative classes, which we provide.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.09336v6"
    },
    {
        "title": "Realizable and Context-Free Hyperlanguages",
        "authors": [
            "Hadar Frenkel",
            "Sarai Sheinvald"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Hyperproperties lift conventional trace-based languages from a set of\nexecution traces to a set of sets of executions. From a formal-language\nperspective, these are sets of sets of words, namely hyperlanguages.\nHyperautomata are based on classical automata models that are lifted to handle\nhyperlanguages. Finite hyperautomata (NFH) have been suggested to express\nregular hyperproperties. We study the realizability problem for regular\nhyperlanguages: given a set of languages, can it be precisely described by an\nNFH? We show that the problem is complex already for singleton hyperlanguages.\nWe then go beyond regular hyperlanguages, and study context-free\nhyperlanguages. We show that the natural extension to context-free\nhypergrammars is highly undecidable. We then suggest a refined model, namely\nsynchronous hypergrammars, which enables describing interesting non-regular\nhyperproperties, while retaining many decidable properties of context-free\ngrammars.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.10306v1"
    },
    {
        "title": "Generating Tokenizers with Flat Automata",
        "authors": [
            "Hans de Nivelle",
            "Dina Muktubayeva"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We introduce flat automata for automatic generation of tokenizers. Flat\nautomata are a simple representation of standard finite automata. Using the\nflat representation, automata can be easily constructed, combined and printed.\n  Due to the use of border functions, flat automata are more compact than\nstandard automata in the case where intervals of characters are attached to\ntransitions, and the standard algorithms on automata are simpler.\n  We give the standard algorithms for tokenizer construction with automata,\nnamely construction using regular operations, determinization, and\nminimization. We prove their correctness. The algorithms work with intervals of\ncharacters, but are not more complicated than their counterparts on single\ncharacters. It is easy to generate C++ code from the final deterministic\nautomaton. All procedures have been implemented in C++ and are publicly\navailable. The implementation has been used in applications and in teaching.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.10313v1"
    },
    {
        "title": "Comparing Channel Restrictions of Communicating State Machines,\n  High-level Message Sequence Charts, and Multiparty Session Types",
        "authors": [
            "Felix Stutz",
            "Damien Zufferey"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Communicating state machines provide a formal foundation for distributed\ncomputation. Unfortunately, they are Turing-complete and, thus, challenging to\nanalyse. In this paper, we classify restrictions on channels which have been\nproposed to work around the undecidability of verification questions. We\ncompare half-duplex communication, existential B-boundedness, and\nk-synchronisability. These restrictions do not prevent the communication\nchannels from growing arbitrarily large but still restrict the power of the\nmodel. Each restriction gives rise to a set of languages so, for every pair of\nrestrictions, we check whether one subsumes the other or if they are\nincomparable. We investigate their relationship in two different contexts:\nfirst, the one of communicating state machines, and, second, the one of\ncommunication protocol specifications using high-level message sequence charts.\nSurprisingly, these two contexts yield different conclusions. In addition, we\nintegrate multiparty session types, another approach to specify communication\nprotocols, into our classification. We show that multiparty session type\nlanguages are half-duplex, existentially 1-bounded, and 1-synchronisable. To\nshow this result, we provide the first formal embedding of multiparty session\ntypes into high-level message sequence charts.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.10328v1"
    },
    {
        "title": "Active vs. Passive: A Comparison of Automata Learning Paradigms for\n  Network Protocols",
        "authors": [
            "Bernhard K. Aichernig",
            "Edi Muškardin",
            "Andrea Pferscher"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Active automata learning became a popular tool for the behavioral analysis of\ncommunication protocols. The main advantage is that no manual modeling effort\nis required since a behavioral model is automatically inferred from a black-box\nsystem. However, several real-world applications of this technique show that\nthe overhead for the establishment of an active interface might hamper the\npractical applicability. Our recent work on the active learning of Bluetooth\nLow Energy (BLE) protocol found that the active interaction creates a\nbottleneck during learning. Considering the automata learning toolset, passive\nlearning techniques appear as a promising solution since they do not require an\nactive interface to the system under learning. Instead, models are learned\nbased on a given data set. In this paper, we evaluate passive learning for two\nnetwork protocols: BLE and Message Queuing Telemetry Transport (MQTT). Our\nresults show that passive techniques can correctly learn with less data than\nrequired by active learning. However, a general random data generation for\npassive learning is more expensive compared to the costs of active learning.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.14031v1"
    },
    {
        "title": "The maximum length of shortest accepted strings for\n  direction-determinate two-way finite automata",
        "authors": [
            "Olga Martynova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  It is shown that, for every $n \\geqslant 2$, the maximum length of the\nshortest string accepted by an $n$-state direction-determinate two-way finite\nautomaton is exactly $\\binom{n}{\\lfloor\\frac{n}{2}\\rfloor}-1$\n(direction-determinate automata are those that always remember in the current\nstate whether the last move was to the left or to the right). For two-way\nfinite automata of the general form, a family of $n$-state automata with\nshortest accepted strings of length $\\frac{3}{4} \\cdot 2^n - 1$ is constructed.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.00235v1"
    },
    {
        "title": "A generic polynomial time approach to separation by first-order logic\n  without quantifier alternation",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We look at classes of languages associated to the fragment of first-order\nlogic B{\\Sigma}1 which disallows quantifier alternations. Each class is defined\nby choosing the set of predicates on positions that may be used. Two key such\nfragments are those equipped with the linear ordering and possibly the\nsuccessor relation. It is known that these two variants have decidable\nmembership: \"does an input regular language belong to the class ?\". We rely on\na characterization of B{\\Sigma}1 by the operator BPol: given an input class C,\nit outputs a class BPol(C) that corresponds to a variant of B{\\Sigma}1 equipped\nwith special predicates associated to C. We extend these results in two\northogonal directions. First, we use two kinds of inputs: classes G of group\nlanguages (i.e., recognized by a DFA in which each letter induces a permutation\nof the states) and extensions thereof, written G+. The classes BPol(G) and\nBPol(G+) capture many variants of B{\\Sigma}1 which use predicates such as the\nlinear ordering, the successor, the modular predicates or the alphabetic\nmodular predicates.\n  Second, instead of membership, we explore the more general separation\nproblem: decide if two regular languages can be separated by a language from\nthe class under study. We show it is decidable for BPol(G) and BPol(G+) when\nthis is the case for G. This was known for BPol(G) and for two particular\nclasses BPol(G+). Yet, the algorithms were indirect and relied on involved\nframeworks, yielding poor upper complexity bounds. Our approach is direct. We\nwork with elementary concepts (mainly, finite automata). Our main contribution\nconsists in polynomial time Turing reductions from both BPol(G)- and\nBPol(G+)-separation to G-separation. This yields polynomial algorithms for key\nvariants of B{\\Sigma}1, including those equipped with the linear ordering and\npossibly the successor and/or the modular predicates.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.00946v1"
    },
    {
        "title": "On Rational Recursive Sequences",
        "authors": [
            "Lorenzo Clemente",
            "Maria Donten-Bury",
            "Filip Mazowiecki",
            "Michał Pilipczuk"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study the class of rational recursive sequences (ratrec) over the rational\nnumbers. A ratrec sequence is defined via a system of sequences using mutually\nrecursive equations of depth 1, where the next values are computed as rational\nfunctions of the previous values. An alternative class is that of simple ratrec\nsequences, where one uses a single recursive equation, however of depth k: the\nnext value is defined as a rational function of k previous values.\n  We conjecture that the classes ratrec and simple ratrec coincide. The main\ncontribution of this paper is a proof of a variant of this conjecture where the\ninitial conditions are treated symbolically, using a formal variable per\nsequence, while the sequences themselves consist of rational functions over\nthose variables. While the initial conjecture does not follow from this\nvariant, we hope that the introduced algebraic techniques may eventually be\nhelpful in resolving the problem.\n  The class ratrec strictly generalises a well-known class of polynomial\nrecursive sequences (polyrec). These are defined like ratrec, but using\npolynomial functions instead of rational ones. One can observe that if our\nconjecture is true and effective, then we can improve the complexities of the\nzeroness and the equivalence problems for polyrec sequences. Currently, the\nonly known upper bound is Ackermanian, which follows from results on polynomial\nautomata. We complement this observation by proving a PSPACE lower bound for\nboth problems for polyrec. Our lower bound construction also implies that the\nSkolem problem is PSPACE-hard for the polyrec class.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.01635v1"
    },
    {
        "title": "Non-closure under complementation for unambiguous linear grammars",
        "authors": [
            "Olga Martynova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The paper demonstrates the non-closure of the family of unambiguous linear\nlanguages (that is, those defined by unambiguous linear context-free grammars)\nunder complementation. To be precise, a particular unambiguous linear grammar\nis presented, and it is proved that the complement of this language is not\ndefined by any context-free grammar. This also constitutes an alternative proof\nfor the result of Hibbard and Ullian (\"The independence of inherent ambiguity\nfrom complementedness among context-free languages\", J.ACM, 1966) on the\nnon-closure of the unambiguous languages under complementation.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.02329v1"
    },
    {
        "title": "Pebble minimization: the last theorems",
        "authors": [
            "Gaëtan Douéneau-Tabot"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Pebble transducers are nested two-way transducers which can drop marks (named\n\"pebbles\") on their input word. Such machines can compute functions whose\noutput size is polynomial in the size of their input. They can be seen as\nsimple recursive programs whose recursion height is bounded. A natural problem\nis, given a pebble transducer, to compute an equivalent pebble transducer with\nminimal recursion height. This problem is open since the introduction of the\nmodel.\n  In this paper, we study two restrictions of pebble transducers, that cannot\nsee the marks (\"blind pebble transducers\" introduced by Nguy\\^en et al.), or\nthat can only see the last mark dropped (\"last pebble transducers\" introduced\nby Engelfriet et al.). For both models, we provide an effective algorithm for\nminimizing the recursion height. The key property used in both cases is that a\nfunction whose output size is linear (resp. quadratic, cubic, etc.) can always\nbe computed by a machine whose recursion height is 1 (resp. 2, 3, etc.). We\nfinally show that this key property fails as soon as we consider machines that\ncan see more than one mark.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.02426v2"
    },
    {
        "title": "Yet another proof of Parikh's Theorem",
        "authors": [
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parikh's Theorem says that the Parikh image of a context-free language is\nsemilinear. We give a short proof of Parikh's Theorem using the formulation of\nVerma, Seidl, and Schwentick in terms of Presburger arithmetic. The proof\nrelies on an Eulerian property of derivation trees of context-free languages\nand was inspired by Hierholzer's algorithm; it does not use the Chomsky normal\nform.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.02925v1"
    },
    {
        "title": "Myhill-Nerode Theorem for Higher-Dimensional Automata",
        "authors": [
            "Uli Fahrenberg",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We establish a Myhill-Nerode type theorem for higher-dimensional automata\n(HDAs), stating that a language is regular if and only if it has finite prefix\nquotient. HDAs extend standard automata with additional structure, making it\npossible to distinguish between interleavings and concurrency. We also\nintroduce deterministic HDAs and show that not all HDAs are determinizable,\nthat is, there exist regular languages that cannot be recognised by a\ndeterministic HDA. Using our theorem, we develop an internal characterisation\nof deterministic languages. Lastly, we develop analogues of the Myhill-Nerode\nconstruction and of determinacy for HDAs with interfaces.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.08298v5"
    },
    {
        "title": "On History-Deterministic One-Counter Nets",
        "authors": [
            "Aditya Prakash",
            "K. S. Thejaswini"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider the model of history-deterministic one-counter nets (OCNs).\nHistory-determinism is a property of transition systems that allows for a\nlimited kind of non-determinism which can be resolved 'on-the-fly'. Token\ngames, which have been used to characterise history-determinism over various\nmodels, also characterise history-determinism over OCNs. By reducing 1-token\ngames to simulation games, we are able to show that checking for\nhistory-determinism of OCNs is decidable. Moreover, we prove that this problem\nis PSPACE-complete for a unary encoding of transitions, and EXPSPACE-complete\nfor a binary encoding.\n  We then study the language properties of history-deterministic OCNs. We show\nthat the resolvers of non-determinism for history-deterministic OCNs are\neventually periodic. As a consequence, for a given history-deterministic OCN,\nwe construct a language equivalent deterministic one-counter automaton. We also\nshow the decidability of comparing languages of history-deterministic OCNs,\nsuch as language inclusion and language universality.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.10084v3"
    },
    {
        "title": "Timed Alignments with Mixed Moves",
        "authors": [
            "Neha Rino",
            "Thomas Chatain"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The subject of this paper is to study conformance checking for timed models,\nthat is, process models that consider both the sequence of events in a process\nas well as the timestamps at which each event is recorded. Time-aware process\nmining is a growing subfield of research, and as tools that seek to discover\ntiming related properties in processes develop, so does the need for\nconformance checking techniques that can tackle time constraints and provide\ninsightful quality measures for time-aware process models. In particular, one\nof the most useful conformance artefacts is the alignment, that is, finding the\nminimal changes necessary to correct a new observation to conform to a process\nmodel. This paper follows a previous one, where we have set our problem of\ntimed alignment. In the present paper, we solve the case where the metrics used\nto compare timed processes allows mixed moves, i.e. an error on the timestamp\nof an event may or may not have propagated to its successors, and provide\nlinear time algorithms for distance computation and alignment on models with\nsequential causal processes.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.15209v1"
    },
    {
        "title": "A model of actors and grey failures",
        "authors": [
            "Laura Bocchi",
            "Julien Lange",
            "Simon Thompson",
            "A. Laura Voinea"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Existing models for the analysis of concurrent processes tend to focus on\nfail-stop failures, where processes are either working or permanently stopped,\nand their state (working/stopped) is known. In fact, systems are often affected\nby grey failures: failures that are latent, possibly transient, and may affect\nthe system in subtle ways that later lead to major issues (such as crashes,\nlimited availability, overload). We introduce a model of actor-based systems\nwith grey failures, based on two interlinked layers: an actor model, given as\nan asynchronous process calculus with discrete time, and a failure model that\nrepresents failure patterns to inject in the system. Our failure model captures\nnot only fail-stop node and link failures, but also grey failures (e.g.,\npartial, transient). We give a behavioural equivalence relation based on weak\nbarbed bisimulation to compare systems on the basis of their ability to recover\nfrom failures, and on this basis we define some desirable properties of\nreliable systems. By doing so, we reduce the problem of checking reliability\nproperties of systems to the problem of checking bisimulation.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.17508v4"
    },
    {
        "title": "Counterfactual Causality in Networks",
        "authors": [
            "Georgiana Caltais",
            "Can Olmezoglu"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this abstract we propose a framework for explaining violations of safety\nproperties in Software Defined Networks, using counterfactual causal reasoning.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.00758v1"
    },
    {
        "title": "On Minimization and Learning of Deterministic $ω$-Automata in the\n  Presence of Don't Care Words",
        "authors": [
            "Christof Löding",
            "Max Philip Stachon"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study minimization problems for deterministic $\\omega$-automata in the\npresence of don't care words. We prove that the number of priorities in\ndeterministic parity automata can be efficiently minimized under an arbitrary\nset of don't care words. We derive that from a more general result from which\none also obtains an efficient minimization algorithm for deterministic parity\nautomata with informative right-congruence (without don't care words).\n  We then analyze languages of don't care words with a trivial\nright-congruence. For such sets of don't care words it is known that weak\ndeterministic B\\\"uchi automata (WDBA) have a unique minimal automaton that can\nbe efficiently computed from a given WDBA (Eisinger, Klaedtke 2006). We give a\ncongruence-based characterization of the corresponding minimal WDBA, and show\nthat the don't care minimization results for WDBA do not extend to\ndeterministic $\\omega$-automata with informative right-congruence: for this\nclass there is no unique minimal automaton for a given don't care set with\ntrivial right congruence, and the minimization problem is NP-hard. Finally, we\nextend an active learning algorithm for WDBA (Maler, Pnueli 1995) to the\nsetting with an additional set of don't care words with trivial\nright-congruence.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.08787v6"
    },
    {
        "title": "Validating Streaming JSON Documents with Learned VPAs",
        "authors": [
            "Véronique Bruyère",
            "Guillermo A. Perez",
            "Gaëtan Staquet"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We present a new streaming algorithm to validate JSON documents against a set\nof constraints given as a JSON schema. Among the possible values a JSON\ndocument can hold, objects are unordered collections of key-value pairs while\narrays are ordered collections of values. We prove that there always exists a\nvisibly pushdown automaton (VPA) that accepts the same set of JSON documents as\na JSON schema. Leveraging this result, our approach relies on learning a VPA\nfor the provided schema. As the learned VPA assumes a fixed order on the\nkey-value pairs of the objects, we abstract its transitions in a special kind\nof graph, and propose an efficient streaming algorithm using the VPA and its\ngraph to decide whether a JSON document is valid for the schema. We evaluate\nthe implementation of our algorithm on a number of random JSON documents, and\ncompare it to the classical validation algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.08891v2"
    },
    {
        "title": "Waiting Nets: State Classes and Taxonomy",
        "authors": [
            "Loïc Hélouët",
            "Pranay Agrawal"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In time Petri nets (TPNs), time and control are tightly connected: time\nmeasurement for a transition starts only when all resources needed to fire it\nare available. Further, upper bounds on duration of enabledness can force\ntransitions to fire (this is called urgency). For many systems, one wants to\ndecouple control and time, i.e. start measuring time as soon as a part of the\npreset of a transition is filled, and fire it after some delay \\underline{and}\nwhen all needed resources are available. This paper considers an extension of\nTPN called waiting nets that dissociates time measurement and control. Their\nsemantics allows time measurement to start with incomplete presets, and can\nignore urgency when upper bounds of intervals are reached but all resources\nneeded to fire are not yet available. Firing of a transition is then allowed as\nsoon as missing resources are available. It is known that extending bounded\nTPNs with stopwatches leads to undecidability. Our extension is weaker, and we\nshow how to compute a finite state class graph for bounded waiting nets,\nyielding decidability of reachability and coverability. We then compare\nexpressiveness of waiting nets with that of other models w.r.t. timed language\nequivalence, and show that they are strictly more expressive than TPNs.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.10540v5"
    },
    {
        "title": "Some Remarks on Almost Periodic Sequences and Languages",
        "authors": [
            "Gabriel Istrate"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Almost periodicity has been considered in Formal Language Theory in\nconnection with some topics in Symbolic Dynamics. In (P\\u{a}un and Marcus,\nBulletin of EATCS 53 (1994)) some problems concerning this property are raised.\nFor instance it is asked whether there exists some almost periodic word\n$\\alpha$ such that $Sub(\\alpha)$, the set of its finite factors, is\ncontext-free non-regular.\n  We answer negatively (even in a stronger form) this question, as well as\ndiscussing other related topics.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.14613v1"
    },
    {
        "title": "Fingerprinting and Analysis of Bluetooth Devices with Automata Learning",
        "authors": [
            "Andrea Pferscher",
            "Bernhard K. Aichernig"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Automata learning is a technique to automatically infer behavioral models of\nblack-box systems. Today's learning algorithms enable the deduction of models\nthat describe complex system properties, e.g., timed or stochastic behavior.\nDespite recent improvements in the scalability of learning algorithms, their\npractical applicability is still an open issue. Little work exists that\nactually learns models of physical black-box systems. To fill this gap in the\nliterature, we present a case study on applying automata learning on the\nBluetooth Low Energy (BLE) protocol. It shows that not only the size of the\nsystem limits the applicability of automata learning.\n  Also, the interaction with the system under learning creates a major\nbottleneck that is rarely discussed. In this article, we propose a general\nautomata learning architecture for learning a behavioral model of the BLE\nprotocol implemented by a physical device. With this framework, we can\nsuccessfully learn the behavior of six investigated BLE devices. Furthermore,\nwe extended the learning technique to learn security critical behavior, e.g.,\nkey-exchange procedures for encrypted communication. The learned models depict\nseveral behavioral differences and inconsistencies to the BLE specification.\nThis shows that automata learning can be used for fingerprinting black-box\ndevices, i.e., characterizing systems via their specific learned models.\nMoreover, learning revealed a crashing scenario for one device.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.16074v2"
    },
    {
        "title": "Space Complexity of Stack Automata Models",
        "authors": [
            "Oscar H. Ibarra",
            "Jozef Jirásek",
            "Ian McQuillan",
            "Luca Prigioniero"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper examines several measures of space complexity of variants of stack\nautomata: non-erasing stack automata and checking stack automata. These\nmeasures capture the minimum stack size required to accept every word in the\nlanguage of the automaton (weak measure), the maximum stack size used in any\naccepting computation on any accepted word (accept measure),and the maximum\nstack size used in any computation (strong measure). We give a detailed\ncharacterization of the accept and strong space complexity measures for\nchecking stack automata. Exactly one of three cases can occur: the complexity\nis either bounded by a constant, behaves like a linear function, or it can not\nbe bounded by any function of the length of the input word (and it is decidable\nwhich case occurs). However, this result does not hold for non-erasing stack\nautomata; we provide an example where the space complexity grows proportionally\nto the square root of the length of the input. Furthermore, we study the\ncomplexity bounds of machines which accept a given language, and decidability\nof space complexity properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.00891v1"
    },
    {
        "title": "Generalizations of Checking Stack Automata: Characterizations and\n  Hierarchies",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We examine different generalizations of checking stack automata by allowing\nmultiple input heads and multiple stacks, and characterize their computing\npower in terms of two-way multi-head finite automata and space-bounded Turing\nmachines. For various models, we obtain hierarchies in terms of their computing\npower. Our characterizations and hierarchies expand or tighten some previously\nknown results. We also discuss some decidability questions and the space/time\ncomplexity of the models.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.00897v1"
    },
    {
        "title": "Semilinearity of Families of Languages",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Techniques are developed for creating new and general language families of\nonly semilinear languages, and for showing families only contain semilinear\nlanguages. It is shown that for language families L that are semilinear full\ntrios, the smallest full AFL containing L that is also closed under\nintersection with languages in NCM (where NCM is the family of languages\naccepted by NFAs augmented with reversal-bounded counters), is also semilinear.\nIf these closure properties are effective, this also immediately implies\ndecidability of membership, emptiness, and infiniteness for these general\nfamilies. From the general techniques, new grammar systems are given that are\nextensions of well-known families of semilinear full trios, whereby it is\nimplied that these extensions must only describe semilinear languages. This\nalso implies positive decidability properties for the new systems. Some\ncharacterizations of the new families are also given.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.01301v1"
    },
    {
        "title": "Complexity of the emptiness problem for graph-walking automata and for\n  tilings with star subgraphs",
        "authors": [
            "Olga Martynova"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper proves the decidability of the emptiness problem for two models\nwhich recognize graphs: graph-walking automata, and tilings of graphs by star\nsubgraphs (star automata). Furthermore, it is proved that the non-emptiness\nproblem for graph-walking automata (that is, whether a given automaton accepts\nat least one graph) is NEXP-complete. For star automata, which generalize\nnondeterministic tree automata to the case of graphs, it is proved that their\nnon-emptiness problem is NP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.02380v1"
    },
    {
        "title": "Relationships Between Bounded Languages, Counter Machines, Finite-Index\n  Grammars, Ambiguity, and Commutative Regularity",
        "authors": [
            "Arturo Carpi",
            "Flavio D'Alessandro",
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  It is shown that for every language family that is a trio containing only\nsemilinear languages, all bounded languages in it can be accepted by one-way\ndeterministic reversal-bounded multicounter machines (DCM). This implies that\nfor every semilinear trio (where these properties are effective), it is\npossible to decide containment, equivalence, and disjointness concerning its\nbounded languages. A condition is also provided for when the bounded languages\nin a semilinear trio coincide exactly with those accepted by DCM machines, and\nit is used to show that many grammar systems of finite index -- such as\nfinite-index matrix grammars and finite-index ETOL -- have identical bounded\nlanguages as DCM.\n  Then connections between ambiguity, counting regularity, and commutative\nregularity are made, as many machines and grammars that are unambiguous can\nonly generate/accept counting regular or commutatively regular languages. Thus,\nsuch a system that can generate/accept a non-counting regular or\nnon-commutatively regular language implies the existence of inherently\nambiguous languages over that system. In addition, it is shown that every\nlanguage generated by an unambiguous finite-index matrix grammar has a rational\ncharacteristic series in commutative variables, and is counting regular. This\nresult plus the connections are used to demonstrate that finite-index matrix\ngrammars and finite-index ETOL can generate inherently ambiguous languages\n(over their grammars), as do several machine models. It is also shown that all\nbounded languages generated by these two grammar systems (those in any\nsemilinear trio) can be generated unambiguously within the systems. Finally,\nconditions on languages generated by finite-index matrix grammars and\nfinite-index ETOL implying commutative regularity are obtained. In particular,\nit is shown that every finite-index EDOL language is commutatively regular.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.03359v1"
    },
    {
        "title": "On Families of Full Trios Containing Counter Machine Languages",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We look at nondeterministic finite automata augmented with multiple\nreversal-bounded counters where, during an accepting computation, the behavior\nof the counters is specified by some fixed pattern. These patterns can serve as\na useful \"bridge\" to other important automata and grammar models in the\ntheoretical computer science literature, thereby helping in their study.\nVarious pattern behaviors are considered, together with characterizations and\ncomparisons. For example, one such pattern defines exactly the smallest full\ntrio containing all the bounded semilinear languages. Another pattern defines\nthe smallest full trio containing all the bounded context-free languages. The\n\"bridging\" to other families is then applied, e.g. to certain Turing machine\nrestrictions, as well as other families. Certain general decidability\nproperties are also studied using this framework.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.03791v1"
    },
    {
        "title": "State Grammars with Stores",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  State grammars are context-free grammars where the productions have states\nassociated with them, and a production can only be applied to a nonterminal if\nthe current state matches the state in the production. Once states are added to\ngrammars, it is natural to add various stores, similar to machine models. With\nsuch extensions, productions can only be applied if both the state and the\nvalue read from each store matches between the current sentential form and the\nproduction. Here, generative capacity results are presented for different\nderivation modes, with and without additional stores. In particular, with the\nstandard derivation relation, it is shown that adding reversal-bounded counters\ndoes not increase the capacity, and states are enough. Also, state grammars\nwith reversal-bounded counters that operate using leftmost derivations are\nshown to coincide with languages accepted by one-way machines with a pushdown\nand reversal-bounded counters, and these are surprisingly shown to be strictly\nweaker than state grammars with the standard derivation relation (and no\ncounters). The complexity of the emptiness problem involving state grammars\nwith reversal-bounded counters is also studied.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.03992v1"
    },
    {
        "title": "Structural Reductions and Stutter Sensitive Properties",
        "authors": [
            "Emmanuel Paviot-Adet",
            "Denis Poitrenaud",
            "Etienne Renault",
            "Yann Thierry-Mieg"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Verification of properties expressed as $\\omega$-regular languages such as\nLTL can benefit hugely from stutter insensitivity, using a diverse set of\nreduction strategies. However properties that are not stutter invariant, for\ninstance due to the use of the neXt operator of LTL or to some form of counting\nin the logic, are not covered by these techniques in general. We propose in\nthis paper to study a weaker property than stutter insensitivity. In a stutter\ninsensitive language both adding and removing stutter to a word does not change\nits acceptance, any stuttering can be abstracted away; by decomposing this\nequivalence relation into two implications we obtain weaker conditions. We\ndefine a shortening insensitive language where any word that stutters less than\na word in the language must also belong to the language. A lengthening\ninsensitive language has the dual property. A semi-decision procedure is then\nintroduced to reliably prove shortening insensitive properties or deny\nlengthening insensitive properties while working with a \\emph{reduction} of a\nsystem. A reduction has the property that it can only shorten runs. Lipton's\ntransaction reductions or Petri net agglomerations are examples of eligible\nstructural reduction strategies. We also present an approach that can reason\nusing a partition of a property language into its stutter insensitive,\nshortening insensitive, lengthening insensitive and length sensitive parts to\nstill use structural reductions even when working with arbitrary properties. An\nimplementation and experimental evidence is provided showing most non-random\nproperties sensitive to stutter are actually shortening or lengthening\ninsensitive.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.04218v2"
    },
    {
        "title": "Weighted Tree Automata -- May it be a little more?",
        "authors": [
            "Zoltán Fülöp",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This is a book on weighted tree automata. We present the basic definitions\nand some of the important results in a coherent form with full proofs. The\nconcept of weighted tree automata is part of Automata Theory and it touches the\narea of Universal Algebra. It originated from two sources: weighted string\nautomata and finite-state tree automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.05529v2"
    },
    {
        "title": "Correctness Notions for Petri Nets with Identifiers",
        "authors": [
            "Jan Martijn E. M. van der Werf",
            "Andrey Rivkin",
            "Marco Montali",
            "Artem Polyvyanyy"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A model of an information system describes its processes and how resources\nare involved in these processes to manipulate data objects. This paper presents\nan extension to the Petri nets formalism suitable for describing information\nsystems in which states refer to object instances of predefined types and\nresources are identified as instances of special object types. Several\ncorrectness criteria for resource- and object-aware information systems models\nare proposed, supplemented with discussions on their decidability for\ninteresting classes of systems. These new correctness criteria can be seen as\ngeneralizations of the classical soundness property of workflow models\nconcerned with process control flow correctness.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.07363v6"
    },
    {
        "title": "String Compression in FA-Presentable Structures",
        "authors": [
            "Dmitry Berdinsky",
            "Sanjay Jain",
            "Bakhadyr Khoussainov",
            "Frank Stephan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We construct a FA-presentation $\\psi: L \\rightarrow \\mathbb{N}$ of the\nstructure $(\\mathbb{N};\\mathrm{S})$ for which a numerical characteristic $r(n)$\ndefined as the maximum number $\\psi(w)$ for all strings $w \\in L$ of length\nless than or equal to $n$ grows faster than any tower of exponents of a fixed\nheight. This result leads us to a more general notion of a compressibility rate\ndefined for FA-presentations of any FA-presentable structure. We show the\nexistence of FA-presentations for the configuration space of a Turing machine\nand Cayley graphs of some groups for which it grows faster than any tower of\nexponents of a fixed height. For FA-presentations of the Presburger arithmetic\n$(\\mathbb{N};+)$ we show that it is bounded from above by a linear function.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.01009v1"
    },
    {
        "title": "Timed Partial Order Inference Algorithm",
        "authors": [
            "Kandai Watanabe",
            "Bardh Hoxha",
            "Danil Prokhorov",
            "Georgios Fainekos",
            "Morteza Lahijanian",
            "Sriram Sankaranarayana",
            "Tomoya Yamaguchi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this work, we propose the model of timed partial orders (TPOs) for\nspecifying workflow schedules, especially for modeling manufacturing processes.\nTPOs integrate partial orders over events in a workflow, specifying\n``happens-before'' relations, with timing constraints specified using guards\nand resets on clocks -- an idea borrowed from timed-automata specifications.\nTPOs naturally allow us to capture event ordering, along with a restricted but\nuseful class of timing relationships. Next, we consider the problem of mining\nTPO schedules from workflow logs, which include events along with their time\nstamps. We demonstrate a relationship between formulating TPOs and the\ngraph-coloring problem, and present an algorithm for learning TPOs with\ncorrectness guarantees. We demonstrate our approach on synthetic datasets,\nincluding two datasets inspired by real-life applications of aircraft\nturnaround and gameplay videos of the Overcooked computer game. Our TPO mining\nalgorithm can infer TPOs involving hundreds of events from thousands of\ndata-points within a few seconds. We show that the resulting TPOs provide\nuseful insights into the dependencies and timing constraints for workflows.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.02501v1"
    },
    {
        "title": "Weighted Tree Automata with Constraints",
        "authors": [
            "Andreas Maletti",
            "Andreea-Teodora Nász"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The HOM problem, which asks whether the image of a regular tree language\nunder a given tree homomorphism is again regular, is known to be decidable\n[Godoy & Gim\\'enez: The HOM problem is decidable. JACM 60(4), 2013]. However,\nthe problem remains open for regular weighted tree languages. It is\ndemonstrated that the main notion used in the unweighted setting, the tree\nautomaton with equality and inequality constraints, can straightforwardly be\ngeneralized to the weighted setting and can represent the image of any regular\nweighted tree language under any nondeleting and nonerasing tree homomorphism.\nSeveral closure properties as well as decision problems are also investigated\nfor the weighted tree languages generated by weighted tree automata with\nconstraints.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.03434v1"
    },
    {
        "title": "Büchi-like characterizations for Parikh-recognizable omega-languages",
        "authors": [
            "Mario Grobler",
            "Sebastian Siebertz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  B\\\"uchi's theorem states that $\\omega$-regular languages are characterized as\nlanguages of the form $\\bigcup_i U_i V_i^\\omega$, where $U_i$ and $V_i$ are\nregular languages. Parikh automata are automata on finite words whose\ntransitions are equipped with vectors of positive integers, whose sum can be\ntested for membership in a given semi-linear set. We give an intuitive automata\ntheoretic characterization of languages of the form $U_i V_i^\\omega$, where\n$U_i$ and $V_i$ are Parikh-recognizable. Furthermore, we show that the class of\nsuch languages, where $U_i$ is Parikh-recognizable and $V_i$ is regular is\nexactly captured by a model proposed by Klaedtke and Ruess [Automata, Languages\nand Programming, 2003], which again is equivalent to (a small modification of)\nreachability Parikh automata introduced by Guha et al. [FSTTCS, 2022]. We\nfinish this study by introducing a model that captures exactly such languages\nfor regular $U_i$ and Parikh-recognizable $V_i$.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.04087v1"
    },
    {
        "title": "Commuting upper triangular binary morphisms",
        "authors": [
            "Juha Honkala"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A morphism $g$ from the free monoid $X^*$ into itself is called upper\ntriangular if the matrix of $g$ is upper triangular. We characterize all upper\ntriangular binary morphisms $g_1$ and $g_2$ such that $g_1g_2=g_2g_1$.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06158v4"
    },
    {
        "title": "Decision Problems on Copying and Shuffling",
        "authors": [
            "Vesa Halava",
            "Tero Harju",
            "Dirk Nowotka",
            "Esa Sahla"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study decision problems of the form: given a regular or linear\ncontext-free language $L$, is there a word of a given fixed form in $L$, where\ngiven fixed forms are based on word operations copy, marked copy, shuffle and\ntheir combinations.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06248v4"
    },
    {
        "title": "Closure Properties of General Grammars -- Formally Verified",
        "authors": [
            "Martin Dvorak",
            "Jasmin Blanchette"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We formalized general (i.e., type-0) grammars using the Lean 3 proof\nassistant. We defined basic notions of rewrite rules and of words derived by a\ngrammar, and used grammars to show closure of the class of type-0 languages\nunder four operations: union, reversal, concatenation, and the Kleene star. The\nliterature mostly focuses on Turing machine arguments, which are possibly more\ndifficult to formalize. For the Kleene star, we could not follow the literature\nand came up with our own grammar-based construction.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06420v3"
    },
    {
        "title": "A Myhill-Nerode Theorem for Generalized Automata, with Applications to\n  Pattern Matching and Compression",
        "authors": [
            "Nicola Cotumaccio"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The model of generalized automata, introduced by Eilenberg in 1974, allows\nrepresenting a regular language more concisely than conventional automata by\nallowing edges to be labeled not only with characters, but also strings.\nGiammaresi and Montalbano introduced a notion of determinism for generalized\nautomata [STACS 1995]. While generalized deterministic automata retain many\nproperties of conventional deterministic automata, the uniqueness of a minimal\ngeneralized deterministic automaton is lost.\n  In the first part of the paper, we show that the lack of uniqueness can be\nexplained by introducing a set $ \\mathcal{W(A)} $ associated with a generalized\nautomaton $ \\mathcal{A} $. By fixing $ \\mathcal{W(A)} $, we are able to derive\nfor the first time a full Myhill-Nerode theorem for generalized automata, which\ncontains the textbook Myhill-Nerode theorem for conventional automata as a\ndegenerate case.\n  In the second part of the paper, we show that the set $ \\mathcal{W(A)} $\nleads to applications for pattern matching and data compression. Wheeler\nautomata [TCS 2017, SODA 2020] are a popular class of automata that can be\ncompactly stored using $ e \\log \\sigma (1 + o(1)) + O(e) $ bits ($ e $ being\nthe number of edges, $ \\sigma $ being the size of the alphabet) in such a way\nthat pattern matching queries can be solved in $ \\tilde{O}(m) $ time ($ m $\nbeing the length of the pattern). In the paper, we show how to extend these\nresults to generalized automata. More precisely, a Wheeler generalized automata\ncan be stored using $ \\mathfrak{e} \\log \\sigma (1 + o(1)) + O(e + rn) $ bits so\nthat pattern matching queries can be solved in $ \\tilde{O}(r m) $ time, where $\n\\mathfrak{e} $ is the total length of all edge labels, $ r $ is the maximum\nlength of an edge label and $ n $ is the number of states.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06506v2"
    },
    {
        "title": "Supervisory Control of Modular Discrete-Event Systems under Partial\n  Observation: Normality",
        "authors": [
            "Jan Komenda",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Complex systems are often composed of many small communicating components\ncalled modules. We investigate the synthesis of supervisory controllers for\nmodular systems under partial observation that, as the closed-loop system,\nrealize the supremal normal sublanguage of the specification. We call such\ncontrollers maximally permissive normal supervisors. The challenge in modular\nsystems is to find conditions under which the global nonblocking and maximally\npermissive normal supervisor can be achieved locally as the parallel\ncomposition of local normal supervisors. We show that a structural concept of\nhierarchical supervisory control called modified observation consistency (MOC)\nis such a condition. However, the algorithmic verification of MOC is an open\nproblem, and therefore it is necessary to find easily-verifiable conditions\nthat ensure MOC. We show that the condition that all shared events are\nobservable is such a condition. Considering specifications, we examine both\nlocal specifications, where each module has its own specification, and global\nspecifications. We combine our results for normality with the existing results\nfor controllability to locally synthesize the nonblocking and maximally\npermissive controllable and normal supervisor. Finally, we illustrate the\nresults on an industrial case study of the patient table of an MRI scanner.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.10666v1"
    },
    {
        "title": "Constructing Deterministic Parity Automata from Positive and Negative\n  Examples",
        "authors": [
            "León Bohn",
            "Christof Löding"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present a polynomial time algorithm that constructs a deterministic parity\nautomaton (DPA) from a given set of positive and negative ultimately periodic\nexample words. We show that this algorithm is complete for the class of\n$\\omega$-regular languages, that is, it can learn a DPA for each regular\n$\\omega$-language. For use in the algorithm, we give a definition of a DPA,\nthat we call the precise DPA of a language, and show that it can be constructed\nfrom the syntactic family of right congruences for that language (introduced by\nMaler and Staiger in 1997). Depending on the structure of the language, the\nprecise DPA can be of exponential size compared to a minimal DPA, but it can\nalso be a minimal DPA. The upper bound that we obtain on the number of examples\nrequired for our algorithm to find a DPA for $L$ is therefore exponential in\nthe size of a minimal DPA, in general. However we identify two parameters of\nregular $\\omega$-languages such that fixing these parameters makes the bound\npolynomial.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.11043v3"
    },
    {
        "title": "A P Systems Variant for Reasoning about Sequential Controllability of\n  Boolean Networks",
        "authors": [
            "Artiom Alhazov",
            "Vincent Ferrari-Dominguez",
            "Rudolf Freund",
            "Nicolas Glade",
            "Sergiu Ivanov"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A Boolean network is a discrete dynamical system operating on vectors of\nBoolean variables. The action of a Boolean network can be conveniently\nexpressed as a system of Boolean update functions, computing the new values for\neach component of the Boolean vector as a function of the other components.\nBoolean networks are widely used in modelling biological systems that can be\nseen as consisting of entities which can be activated or deactivated, expressed\nor inhibited, on or off. P systems on the other hand are classically introduced\nas a model of hierarchical multiset rewriting. However, over the years the\ncommunity has proposed a wide range of P system variants including diverse\ningredients suited for various needs. In this work, we propose a new variant --\nBoolean P systems -- specifically designed for reasoning about sequential\ncontrollability of Boolean networks, and use it to first establish a crisp\nformalization of the problem, and then to prove that the problem of sequential\ncontrollability is PSPACE-complete. We further claim that Boolean P systems are\na demonstration of how P systems can be used to construct ad hoc formalisms,\ncustom-tailored for reasoning about specific problems, and providing new\nadvantageous points of view.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.00110v1"
    },
    {
        "title": "Isometric Words based on Swap and Mismatch Distance",
        "authors": [
            "Marcella Anselmo",
            "Giuseppa Castiglione",
            "Manuela Flores",
            "Dora Giammarresi",
            "Maria Madonia",
            "Sabrina Mantaci"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  An edit distance is a metric between words that quantifies how two words\ndiffer by counting the number of edit operations needed to transform one word\ninto the other one. A word f is said isometric with respect to an edit distance\nif, for any pair of f-free words u and v, there exists a transformation of\nminimal length from u to v via the related edit operations such that all the\nintermediate words are also f-free. The adjective 'isometric' comes from the\nfact that, if the Hamming distance is considered (i.e., only mismatches), then\nisometric words are connected with definitions of isometric subgraphs of\nhypercubes. We consider the case of edit distance with swap and mismatch. We\ncompare it with the case of mismatch only and prove some properties of\nisometric words that are related to particular features of their overlaps.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.03086v1"
    },
    {
        "title": "Black-box Testing Liveness Properties of Partially Observable Stochastic\n  Systems",
        "authors": [
            "Javier Esparza",
            "Vincent Grande"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study black-box testing for stochastic systems and arbitrary\n$\\omega$-regular specifications, explicitly including liveness properties. We\nare given a finite-state probabilistic system that we can only execute from the\ninitial state. We have no information on the number of reachable states, or on\nthe probabilities; further, we can only partially observe the states. The only\naction we can take is to restart the system. We design restart strategies\nguaranteeing that, if the specification is violated with non-zero probability,\nthen w.p.1 the number of restarts is finite, and the infinite run executed\nafter the last restart violates the specification. This improves on previous\nwork that required full observability. We obtain asymptotically optimal upper\nbounds on the expected number of steps until the last restart. We conduct\nexperiments on a number of benchmarks, and show that our strategies allow one\nto find violations in Markov chains much larger than the ones considered in\nprevious work.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.03292v1"
    },
    {
        "title": "On the Reconstructability and Rediscoverability of Typed Jackson Nets\n  (Extended Version)",
        "authors": [
            "Daniël Barenholz",
            "Marco Montali",
            "Artem Polyvyanyy",
            "Hajo A. Reijers",
            "Andrey Rivkin",
            "Jan Martijn E. M. van der Werf"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A process discovery algorithm aims to construct a model from data generated\nby historical system executions such that the model describes the system well.\nConsequently, one desired property of a process discovery algorithm is\nrediscoverability, which ensures that the algorithm can construct a model that\nis behaviorally equivalent to the original system. A system often\nsimultaneously executes multiple processes that interact through object\nmanipulations. This paper presents a framework for developing process discovery\nalgorithms for constructing models that describe interacting processes based on\ntyped Jackson Nets that use identifiers to refer to the objects they\nmanipulate. Typed Jackson Nets enjoy the reconstructability property which\nstates that the composition of the processes and the interactions of a\ndecomposed typed Jackson Net yields a model that is bisimilar to the original\nsystem. We exploit this property to demonstrate that if a process discovery\nalgorithm ensures rediscoverability, the system of interacting processes is\nrediscoverable.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.10039v1"
    },
    {
        "title": "Bideterministic Weighted Automata",
        "authors": [
            "Peter Kostolányi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A finite automaton is called bideterministic if it is both deterministic and\ncodeterministic -- that is, if it is deterministic and its transpose is\ndeterministic as well. The study of such automata in a weighted setting is\ninitiated. All trim bideterministic weighted automata over integral domains and\nover positive semirings are proved to be minimal. On the contrary, it is\nobserved that this property does not hold over commutative rings in general:\nnon-minimal trim bideterministic weighted automata do exist over all semirings\nthat are not zero-divisor free, and over many such semirings, these automata\nmight not even admit equivalents that are both minimal and bideterministic. The\nproblem of determining whether a given rational series is realised by a\nbideterministic automaton is shown to be decidable over fields and over\ntropical semirings. An example of a positive semiring over which this problem\nbecomes undecidable is given as well.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.10631v3"
    },
    {
        "title": "A Coalgebraic Approach to Reducing Finitary Automata",
        "authors": [
            "Keri D'Angelo",
            "Alexandra Silva",
            "Gerco van Heerdt",
            "Leon Witzman"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Compact representations of automata are important for efficiency. In this\npaper, we study methods to compute reduced automata, in which no two states\naccept the same language. We do this for finitary automata (FA), an abstract\ndefinition that encompasses probabilistic and weighted automata. Our procedure\nmakes use of Milius' locally finite fixpoint. We present a reduction algorithm\nthat instantiates to probabilistic and S-linear weighted automata (WA) for a\nlarge class of semirings. Moreover, we propose a potential connection between\nproperness of a semiring and our provided reduction algorithm for WAs, paving\nthe way for future work in connecting the reduction of automata to the\nproperness of their associated coalgebras.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.14916v3"
    },
    {
        "title": "VDM recursive functions in Isabelle/HOL",
        "authors": [
            "Leo Freitas",
            "Peter Gorm Larsen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  For recursive functions general principles of induction needs to be applied.\nInstead of verifying them directly using the Vienna Development Method\nSpecification Language (VDM-SL), we suggest a translation to Isabelle/HOL. In\nthis paper, the challenges of such a translation for recursive functions are\npresented. This is an extension of an existing translation and a VDM\nmathematical toolbox in Isabelle/HOL enabling support for recursive functions.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.17457v1"
    },
    {
        "title": "Jumping Automata over Infinite Words",
        "authors": [
            "Shaull Almagor",
            "Omer Yizhaq"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Jumping automata are finite automata that read their input in a\nnon-consecutive manner, disregarding the order of the letters in the word. We\nintroduce and study jumping automata over infinite words. Unlike the setting of\nfinite words, which has been well studied, for infinite words it is not clear\nhow words can be reordered. To this end, we consider three semantics: automata\nthat read the infinite word in some order so that no letter is overlooked,\nautomata that can permute the word in windows of a given size k, and automata\nthat can permute the word in windows of an existentially-quantified bound. We\nstudy expressiveness, closure properties and algorithmic properties of these\nmodels.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.01278v1"
    },
    {
        "title": "NL Is Strictly Contained in P",
        "authors": [
            "Santiago Flum",
            "J. Andres Montoya"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove that NL is strictly contained in P. We get this separation as a\ncorollary of the following result: the set of context-free languages is not\ncontained in NL. The reader should recall that CFL is contained in DTIME(n^3)\n",
        "pdf_link": "http://arxiv.org/pdf/2304.04840v4"
    },
    {
        "title": "Reasoning about Regular Properties: A Comparative Study",
        "authors": [
            "Tomáš Fiedor",
            "Lukáš Holík",
            "Martin Hruška",
            "Adam Rogalewicz",
            "Juraj Síč",
            "Pavol Vargovčík"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Several new algorithms for deciding emptiness of Boolean combinations of\nregular languages and of languages of alternating automata (AFA) have been\nproposed recently, especially in the context of analysing regular expressions\nand in string constraint solving. The new algorithms demonstrated a significant\npotential, but they have never been systematically compared, neither among each\nother nor with the state-of-the art implementations of existing\n(non)deterministic automata-based methods. In this paper, we provide the first\nsuch comparison as well as an overview of the existing algorithms and their\nimplementations. We collect a diverse benchmark mostly originating in or\nrelated to practical problems from string constraint solving, analysing LTL\nproperties, and regular model checking, and evaluate collected implementations\non it. The results reveal the best tools and hint on what the best algorithms\nand implementation techniques are. Roughly, although some advanced algorithms\nare fast, such as antichain algorithms and reductions to IC3/PDR, they are not\nas overwhelmingly dominant as sometimes presented and there is no clear winner.\nThe simplest NFA-based technology may be actually the best choice, depending on\nthe problem source and implementation style. Our findings should be highly\nrelevant for development of these techniques as well as for related fields such\nas string constraint solving.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.05064v1"
    },
    {
        "title": "Exact and Approximated Log Alignments for Processes with Inter-case\n  Dependencies",
        "authors": [
            "Dominique Sommers",
            "Natalia Sidorova",
            "Boudewijn F. van Dongen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The execution of different cases of a process is often restricted by\ninter-case dependencies through e.g., queueing or shared resources. Various\nhigh-level Petri net formalisms have been proposed that are able to model and\nanalyze coevolving cases. In this paper, we focus on a formalism tailored to\nconformance checking through alignments, which introduces challenges related to\nconstraints the model should put on interacting process instances and on\nresource instances and their roles. We formulate requirements for modeling and\nanalyzing resource-constrained processes, compare several Petri net extensions\nthat allow for incorporating inter-case constraints. We argue that the Resource\nConstrained $\\nu$-net is an appropriate formalism to be used the context of\nconformance checking, which traditionally aligns cases individually failing to\nexpose deviations on inter-case dependencies. We provide formal mathematical\nfoundations of the globally aligned event log based on theory of partially\nordered sets and propose an approximation technique based on the composition of\nindividually aligned cases that resolves inter-case violations locally.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.05210v1"
    },
    {
        "title": "Completeness Theorems for Kleene algebra with tests and top",
        "authors": [
            "Damien Pous",
            "Jana Wagemaker"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove two completeness results for Kleene algebra with tests and a top\nelement, with respect to guarded string languages and binary relations. While\nthe equational theories of those two classes of models coincide over the\nsignature of Kleene algebra, this is no longer the case when we consider an\nadditional constant ``top'' for the full element. Indeed, the full relation\nsatisfies more laws than the full language, and we show that those additional\nlaws can all be derived from a single additional axiom. We recover that the two\nequational theories coincide if we slightly generalise the notion of relational\nmodel, allowing sub-algebras of relations where top is a greatest element but\nnot necessarily the full relation. We use models of closed languages and\nreductions in order to prove our completeness results, which are relative to\nany axiomatisation of the algebra of regular events. For one of our\nconstructions, we extend the concept of finite monoid recognisability to\nguarded-string languages; this device makes it possible to obtain a PSpace\nalgorithm for the equational theory of binary relations.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.07190v5"
    },
    {
        "title": "On arch factorization and subword universality for words and compressed\n  words",
        "authors": [
            "Philippe Schnoebelen",
            "Julien Veron"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Using arch-jumping functions and properties of the arch factorization of\nwords, we propose a new algorithm for computing the subword circular\nuniversality index of words. We also introduce the subword universality\nsignature for words, that leads to simple algorithms for the universality\nindexes of SLP-compressed words.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.11932v1"
    },
    {
        "title": "Positive Data Languages",
        "authors": [
            "Florian Frank",
            "Stefan Milius",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Positive data languages are languages over an infinite alphabet closed under\npossibly non-injective renamings of data values. Informally, they model\nproperties of data words expressible by assertions about equality, but not\ninequality, of data values occurring in the word. We investigate the class of\npositive data languages recognizable by nondeterministic orbit-finite nominal\nautomata, an abstract form of register automata introduced by Boja\\'nczyk,\nKlin, and Lasota. As our main contribution we provide a number of equivalent\ncharacterizations of that class in terms of positive register automata, monadic\nsecond-order logic with positive equality tests, and finitely presentable\nnondeterministic automata in the categories of nominal renaming sets and of\npresheaves over finite sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.12947v3"
    },
    {
        "title": "A strongly universal cellular automaton on the heptagrif with six states",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we prove that there is a strongly universal cellular automaton\non the heptagrid with six states which is rotation invariant. This improves a\nprevious paper of the author with 7 states. Here, the structures are modified\nand the number of rules is much less.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.13575v2"
    },
    {
        "title": "Maximizing Reachability Probabilities in Rectangular Automata with\n  Random Clocks",
        "authors": [
            "Joanna Delicaris",
            "Stefan Schupp",
            "Erika Ábrahám",
            "Anne Remke"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper proposes an algorithm to maximize reachability probabilities for\nrectangular automata with random clocks via a history-dependent prophetic\nscheduler. This model class incorporates time-induced nondeterminism on\ndiscrete behavior and nondeterminism in the dynamic behavior. After computing\nreachable state sets via a forward flowpipe construction, we use backward\nrefinement to compute maximum reachability probabilities. The feasibility of\nthe presented approach is illustrated on a scalable model.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.14996v3"
    },
    {
        "title": "Adding Reconfiguration to Zielonka's Asynchronous Automata",
        "authors": [
            "Mathieu Lehaut",
            "Nir Piterman"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study an extension of Zielonka's (fixed) asynchronous automata called\nreconfigurable asynchronous automata where processes can dynamically change who\nthey communicate with. We show that reconfigurable asynchronous automata are\nnot more expressive than fixed asynchronous automata by giving translations\nfrom one to the other. However, going from reconfigurable to fixed comes at the\ncost of disseminating communication (and knowledge) to all processes in the\nsystem. We then show that this is unavoidable by describing a language accepted\nby a reconfigurable automaton such that in every equivalent fixed automaton,\nevery process must either be aware of all communication or be irrelevant.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.01425v2"
    },
    {
        "title": "Separability and Non-Determinizability of WSTS",
        "authors": [
            "Wojciech Czerwiński",
            "Eren Keskin",
            "Sławomir Lasota",
            "Roland Meyer",
            "Sebastian Muskalla",
            "K Narayan Kumar",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the languages recognized by well-structured transition systems\n(WSTS) with upward and downward compatibility. Our first result shows that\nevery pair of disjoint WSTS languages is regularly separable: there is a\nregular language containing one of them while being disjoint from the other. As\na consequence, if a language as well as its complement are both recognized by\nWSTS, then they are necessarily regular. Our second result shows that the\nlanguages recognized by deterministic WSTS form a strict subclass of the\nlanguages recognized by all WSTS: we give a non-deterministic WSTS language\nthat we prove cannot be recognized by a deterministic WSTS. The proof relies on\na novel characterization of the languages accepted by deterministic WSTS.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.02736v3"
    },
    {
        "title": "Hypernode Automata",
        "authors": [
            "Ezio Bartocci",
            "Thomas A. Henzinger",
            "Dejan Nickovic",
            "Ana Oliveira da Costa"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce hypernode automata as a new specification formalism for\nhyperproperties of concurrent systems. They are finite automata with nodes\nlabeled with hypernode logic formulas and transitions labeled with actions. A\nhypernode logic formula specifies relations between sequences of variable\nvalues in different system executions. Unlike HyperLTL, hypernode logic takes\nan asynchronous view on execution traces by constraining the values and the\norder of value changes of each variable without correlating the timing of the\nchanges. Different execution traces are synchronized solely through the\ntransitions of hypernode automata. Hypernode automata naturally combine\nasynchronicity at the node level with synchronicity at the transition level. We\nshow that the model-checking problem for hypernode automata is decidable over\naction-labeled Kripke structures, whose actions induce transitions of the\nspecification automaton. For this reason, hypernode automaton is a suitable\nformalism for specifying and verifying asynchronous hyperproperties, such as\ndeclassifying observational determinism in multi-threaded programs.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.02836v2"
    },
    {
        "title": "Closure and Decision Properties for Higher-Dimensional Automata",
        "authors": [
            "Amazigh Amrane",
            "Hugo Bazille",
            "Uli Fahrenberg",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We report some further developments regarding the language theory of\nhigher-dimensional automata (HDAs). Regular languages of HDAs are sets of\nfinite interval partially ordered multisets (pomsets) with interfaces. We show\na pumping lemma which allows us to expose a class of non-regular languages.\nConcerning decision and closure properties, we show that inclusion of regular\nlanguages is decidable (hence is emptiness), and that intersections of regular\nlanguages are again regular. On the other hand, complements of regular\nlanguages are not always regular. We introduce a width-bounded complement and\nshow that width-bounded complements of regular languages are again regular.\n  We also study determinism and ambiguity. We show that it is decidable whether\na regular language is accepted by a deterministic HDA and that there exists\nregular languages with unbounded ambiguity. Finally, we characterize one-letter\ndeterministic languages in terms of utlimately periodic functions.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.02873v3"
    },
    {
        "title": "Regular Methods for Operator Precedence Languages",
        "authors": [
            "Thomas A. Henzinger",
            "Pavol Kebis",
            "Nicolas Mazzocchi",
            "N. Ege Saraç"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The operator precedence languages (OPLs) represent the largest known subclass\nof the context-free languages which enjoys all desirable closure and\ndecidability properties. This includes the decidability of language inclusion,\nwhich is the ultimate verification problem. Operator precedence grammars,\nautomata, and logics have been investigated and used, for example, to verify\nprograms with arithmetic expressions and exceptions (both of which are\ndeterministic pushdown but lie outside the scope of the visibly pushdown\nlanguages). In this paper, we complete the picture and give, for the first\ntime, an algebraic characterization of the class of OPLs in the form of a\nsyntactic congruence that has finitely many equivalence classes exactly for the\noperator precedence languages. This is a generalization of the celebrated\nMyhill-Nerode theorem for the regular languages to OPLs. As one of the\nconsequences, we show that universality and language inclusion for\nnondeterministic operator precedence automata can be solved by an antichain\nalgorithm. Antichain algorithms avoid determinization and complementation\nthrough an explicit subset construction, by leveraging a quasi-order on words,\nwhich allows the pruning of the search space for counterexample words without\nsacrificing completeness. Antichain algorithms can be implemented symbolically,\nand these implementations are today the best-performing algorithms in practice\nfor the inclusion of finite automata. We give a generic construction of the\nquasi-order needed for antichain algorithms from a finite syntactic congruence.\nThis yields the first antichain algorithm for OPLs, an algorithm that solves\nthe \\textsc{ExpTime}-hard language inclusion problem for OPLs in exponential\ntime.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.03447v2"
    },
    {
        "title": "Weighted HOM-Problem for Nonnegative Integers",
        "authors": [
            "Andreas Maletti",
            "Andreea-Teodora Nász",
            "Erik Paul"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The HOM-problem asks whether the image of a regular tree language under a\ngiven tree homomorphism is again regular. It was recently shown to be decidable\nby Godoy, Gim\\'enez, Ramos, and \\`Alvarez. In this paper, the N-weighted\nversion of this problem is considered and its decidability is proved. More\nprecisely, it is decidable in polynomial time whether the image of a regular\nN-weighted tree language under a nondeleting, nonerasing tree homomorphism is\nregular.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.04117v1"
    },
    {
        "title": "Getting More out of Large Language Models for Proofs",
        "authors": [
            "Shizhuo Dylan Zhang",
            "Talia Ringer",
            "Emily First"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Large language models have the potential to simplify formal theorem proving\nand make it more accessible. But how to get the most out of these models is\nstill an open question. To answer this question, we take a step back and\nexplore the failure cases of these models using common prompting-based\ntechniques. Our talk will discuss these failure cases and what they can teach\nus about how to get more out of these models.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.04369v2"
    },
    {
        "title": "Automata with Timers",
        "authors": [
            "Véronique Bruyère",
            "Guillermo A. Pérez",
            "Gaëtan Staquet",
            "Frits W. Vaandrager"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this work, we study properties of deterministic finite-state automata with\ntimers, a subclass of timed automata proposed by Vaandrager et al. as a\ncandidate for an efficiently learnable timed model. We first study the\ncomplexity of the configuration reachability problem for such automata and\nestablish that it is PSPACE-complete. Then, as simultaneous timeouts (we call\nthese, races) can occur in timed runs of such automata, we study the problem of\ndetermining whether it is possible to modify the delays between the actions in\na run, in a way to avoid such races. The absence of races is important for\nmodelling purposes and to streamline learning of automata with timers. We\nprovide an effective characterization of when an automaton is race-avoiding and\nestablish that the related decision problem is in 3EXP and PSPACE-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.07451v1"
    },
    {
        "title": "Separating Automatic Relations",
        "authors": [
            "Pablo Barceló",
            "Diego Figueira",
            "Rémi Morvan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the separability problem for automatic relations (i.e., relations on\nfinite words definable by synchronous automata) in terms of recognizable\nrelations (i.e., finite unions of products of regular languages). This problem\ntakes as input two automatic relations $R$ and $R'$, and asks if there exists a\nrecognizable relation $S$ that contains $R$ and does not intersect $R'$. We\nshow this problem to be undecidable when the number of products allowed in the\nrecognizable relation is fixed. In particular, checking if there exists a\nrecognizable relation $S$ with at most $k$ products of regular languages that\nseparates $R$ from $R'$ is undecidable, for each fixed $k \\geq 2$. Our proofs\nreveal tight connections, of independent interest, between the separability\nproblem and the finite coloring problem for automatic graphs, where colors are\nregular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.08727v2"
    },
    {
        "title": "Transformational Supervisor Localization",
        "authors": [
            "Sander Thuijsman",
            "Kai Cai",
            "Michel Reniers"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Supervisor localization can be applied to distribute a monolithic supervisor\ninto local supervisors. Performing supervisor localization can be\ncomputationally costly. In this work, we consider systems that evolve over\ntime. We study how to reuse the results from a previous supervisor\nlocalization, to more efficiently compute local supervisors when the system is\nadapted. We call this approach transformational supervisor localization, and\npresent algorithms for the procedure. The efficiency of the procedure is\nexperimentally evaluated.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.09384v1"
    },
    {
        "title": "Singly Exponential Translation of Alternating Weak Büchi Automata to\n  Unambiguous Büchi Automata",
        "authors": [
            "Yong Li",
            "Sven Schewe",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce a method for translating an alternating weak B\\\"uchi automaton\n(AWA), which corresponds to a Linear Dynamic Logic (LDL) formula, to an\nunambiguous B\\\"uchi automaton (UBA). Our translations generalise constructions\nfor Linear Temporal Logic (LTL), a less expressive specification language than\nLDL. In classical constructions, LTL formulas are first translated to\nalternating \\emph{very weak} automata (AVAs) -- automata that have only\nsingleton strongly connected components (SCCs); the AVAs are then handled by\nefficient disambiguation procedures. However, general AWAs can have larger\nSCCs, which complicates disambiguation. Currently, the only available\ndisambiguation procedure has to go through an intermediate construction of\nnondeterministic B\\\"uchi automata (NBAs), which would incur an exponential\nblow-up of its own. We introduce a translation from \\emph{general} AWAs to UBAs\nwith a \\emph{singly} exponential blow-up, which also immediately provides a\nsingly exponential translation from LDL to UBAs. Interestingly, the complexity\nof our translation is \\emph{smaller} than the best known disambiguation\nalgorithm for NBAs (broadly $(0.53n)^n$ vs. $(0.76n)^n$), while the input of\nour construction can be exponentially more succinct.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.09966v1"
    },
    {
        "title": "On Semantically-Deterministic Automata",
        "authors": [
            "Bader Abu Radi",
            "Orna Kupferman"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A nondeterministic automaton is semantically deterministic (SD) if different\nnondeterministic choices in the automaton lead to equivalent states. Semantic\ndeterminism is interesting as it is a natural relaxation of determinism, and as\nsome applications of deterministic automata in formal methods can actually use\nautomata with some level of nondeterminism, tightly related to semantic\ndeterminism.\n  In the context of finite words, semantic determinism coincides with\ndeterminism, in the sense that every pruning of an SD automaton to a\ndeterministic one results in an equivalent automaton. We study SD automata on\ninfinite words, focusing on B\\\"uchi, co-B\\\"uchi, and weak automata. We show\nthat there, while semantic determinism does not increase the expressive power,\nthe combinatorial and computational properties of SD automata are very\ndifferent from these of deterministic automata. In particular, SD B\\\"uchi and\nco-B\\\"uchi automata are exponentially more succinct than deterministic ones (in\nfact, also exponentially more succinct than history-deterministic automata),\ntheir complementation involves an exponential blow up, and decision procedures\nfor them like universality and minimization are PSPACE-complete. For weak\nautomata, we show that while an SD weak automaton need not be pruned to an\nequivalent deterministic one, it can be determinized to an equivalent\ndeterministic weak automaton with the same state space, implying also efficient\ncomplementation and decision procedures for SD weak automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.15489v1"
    },
    {
        "title": "Live Programming for Finite Model Finders",
        "authors": [
            "Allison Sullivan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Finite model finders give users the ability to specify properties of a system\nin mathematical logic and then automatically find concrete examples, called\nsolutions, that satisfy the properties. These solutions are often viewed as a\nkey benefit of model finders, as they create an exploratory environment for\ndevelopers to engage with their model. In practice, users find less benefit\nfrom these solutions than expected. For years, researchers believed that the\nproblem was that too many solutions are produced. However, a recent user study\nfound that users actually prefer enumerating a broad set of solutions. Inspired\nby a recent user study on Alloy, a modeling language backed by a finite model\nfinder, we believe that the issue is that solutions are too removed from the\nlogical constraints that generate them to help users build an understanding of\nthe constraints themselves. In this paper, we outline a proof-of-concept for\nlive programming of Alloy models in which writing the model and exploring\nsolutions are intertwined. We highlight how this development environment\nenables more productive feedback loops between the developer, the model and the\nsolutions.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.17317v1"
    },
    {
        "title": "Active Learning of Deterministic Timed Automata with Myhill-Nerode Style\n  Characterization",
        "authors": [
            "Masaki Waga"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present an algorithm to learn a deterministic timed automaton (DTA) via\nmembership and equivalence queries. Our algorithm is an extension of the L*\nalgorithm with a Myhill-Nerode style characterization of recognizable timed\nlanguages, which is the class of timed languages recognizable by DTAs. We first\ncharacterize the recognizable timed languages with a Nerode-style congruence.\nUsing it, we give an algorithm with a smart teacher answering symbolic\nmembership queries in addition to membership and equivalence queries. With a\nsymbolic membership query, one can ask the membership of a certain set of timed\nwords at one time. We prove that for any recognizable timed language, our\nlearning algorithm returns a DTA recognizing it. We show how to answer a\nsymbolic membership query with finitely many membership queries. We also show\nthat our learning algorithm requires a polynomial number of queries with a\nsmart teacher and an exponential number of queries with a normal teacher. We\napplied our algorithm to various benchmarks and confirmed its effectiveness\nwith a normal teacher.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.17742v1"
    },
    {
        "title": "A Unified Model for Real-Time Systems: Symbolic Techniques and\n  Implementation",
        "authors": [
            "S Akshay",
            "Paul Gastin",
            "R Govind",
            "Aniruddha R Joshi",
            "B Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we consider a model of generalized timed automata (GTA) with\ntwo kinds of clocks, history and future, that can express many timed features\nsuccinctly, including timed automata, event-clock automata with and without\ndiagonal constraints, and automata with timers. Our main contribution is a new\nsimulation-based zone algorithm for checking reachability in this unified\nmodel. While such algorithms are known to exist for timed automata, and have\nrecently been shown for event-clock automata without diagonal constraints, this\nis the first result that can handle event-clock automata with diagonal\nconstraints and automata with timers. We also provide a prototype\nimplementation for our model and show experimental results on several\nbenchmarks. To the best of our knowledge, this is the first effective\nimplementation not just for our unified model, but even just for automata with\ntimers or for event-clock automata (with predicting clocks) without going\nthrough a costly translation via timed automata. Last but not least, beyond\nbeing interesting in their own right, generalized timed automata can be used\nfor model-checking event-clock specifications over timed automata models.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.17824v1"
    },
    {
        "title": "About Decisiveness of Dynamic Probabilistic Models",
        "authors": [
            "Alain Finkel",
            "Serge Haddad",
            "Lina Ye"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Decisiveness of infinite Markov chains with respect to some (finite or\ninfinite) target set of states is a key property that allows to compute the\nreachability probability of this set up to an arbitrary precision. Most of the\nexisting works assume constant weights for defining the probability of a\ntransition in the considered models. However numerous probabilistic modelings\nrequire (dynamic) weights that depend on both the current state and the\ntransition. So we introduce a dynamic probabilistic version of counter machine\n(pCM). After establishing that decisiveness is undecidable for pCMs even with\nconstant weights, we study the decidability of decisiveness for subclasses of\npCM. We show that, without restrictions on dynamic weights, decisiveness is\nundecidable with a single state and single counter pCM. On the contrary with\npolynomial weights, decisiveness becomes decidable for single counter pCMs\nunder mild conditions. Then we show that decisiveness of probabilistic Petri\nnets (pPNs) with polynomial weights is undecidable even when the target set is\nupward-closed unlike the case of constant weights. Finally we prove that the\nstandard subclass of pPNs with a regular language is decisive with respect to a\nfinite set whatever the kind of weights.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.19564v1"
    },
    {
        "title": "Optimal Approximate Minimization of One-Letter Weighted Finite Automata",
        "authors": [
            "Clara Lacroce",
            "Borja Balle",
            "Prakash Panangaden",
            "Guillaume Rabusseau"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we study the approximate minimization problem of weighted\nfinite automata (WFAs): to compute the best possible approximation of a WFA\ngiven a bound on the number of states. By reformulating the problem in terms of\nHankel matrices, we leverage classical results on the approximation of Hankel\noperators, namely the celebrated Adamyan-Arov-Krein (AAK) theory.\n  We solve the optimal spectral-norm approximate minimization problem for\nirredundant WFAs with real weights, defined over a one-letter alphabet. We\npresent a theoretical analysis based on AAK theory, and bounds on the quality\nof the approximation in the spectral norm and $\\ell^2$ norm. Moreover, we\nprovide a closed-form solution, and an algorithm, to compute the optimal\napproximation of a given size in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.00135v1"
    },
    {
        "title": "Checking in Polynomial Time whether or not a Regular Tree Language is\n  Deterministic Top-Down",
        "authors": [
            "Sebastian Maneth",
            "Helmut Seidl"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  It is well known that for a given bottom-up tree automaton it can be decided\nwhether or not there exists deterministic top-down tree automaton that\nrecognized the same tree language. Recently it was claimed that such a decision\ncan be carried out in polynomial time (Leupold and Maneth, FCT'2021); but their\nprocedure and corresponding property is wrong. Here we correct this mistake and\npresent a correct property which allows to determine in polynomial time whether\nor not a given tree language can be recognized by a deterministic top-down tree\nautomaton. Furthermore, our new property is stated for arbitrary deterministic\nbottom-up tree automata, and not for minimal such automata (as before).\n",
        "pdf_link": "http://arxiv.org/pdf/2306.00573v1"
    },
    {
        "title": "Duality of Lattices Associated to Left and Right Quotients",
        "authors": [
            "Jason Bell",
            "Daniel Smertnig",
            "Hellis Tamm"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We associate lattices to the sets of unions and intersections of left and\nright quotients of a regular language. For both unions and intersections, we\nshow that the lattices we produce using left and right quotients are dual to\neach other. We also give necessary and sufficient conditions for these lattices\nto have maximal possible complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.02491v2"
    },
    {
        "title": "Deciding minimal distinguishing DFAs is NP-complete",
        "authors": [
            "Jan Martens"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we present a proof of the NP-completeness of computing the\nsmallest Deterministic Finite Automaton (DFA) that distinguishes two given\nregular languages as DFAs. A distinguishing DFA is an automaton that recognizes\na language which is a subset of exactly one of the given languages. We\nestablish the NP-hardness of this decision problem by providing a reduction\nfrom the Boolean Satisfiability Problem (SAT) to deciding the existence of a\ndistinguishing automaton of a specific size.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.03533v1"
    },
    {
        "title": "Deciding whether an Attributed Translation can be realized by a Top-Down\n  Transducer",
        "authors": [
            "Sebastian Maneth",
            "Martin Vu"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove that for a given partial functional attributed tree transducer with\nmonadic output, it is decidable whether or not an equivalent top-down\ntransducer (with or without look-ahead) exists. We present a procedure that\nconstructs an equivalent top-down transducer (with or without look-ahead) if it\nexists.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.04326v3"
    },
    {
        "title": "Optimal Wheeler Language Recognition",
        "authors": [
            "Ruben Becker",
            "Davide Cenzato",
            "Sung-Hwan Kim",
            "Bojana Kodric",
            "Alberto Policriti",
            "Nicola Prezza"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A Wheeler automaton is a finite state automaton whose states admit a total\nWheeler order, reflecting the co-lexicographic order of the strings labeling\nsource-to-node paths. A Wheeler language is a regular language admitting an\naccepting Wheeler automaton. Wheeler languages admit efficient and elegant\nsolutions to hard problems such as automata compression and regular expression\nmatching, therefore deciding whether a regular language is Wheeler is relevant\nin applications requiring efficient solutions to those problems. In this paper,\nwe show that it is possible to decide whether a DFA with n states and m\ntransitions recognizes a Wheeler language in $O(mn)$ time. This is a\nsignificant improvement over the running time $O(n^{13} + m\\log n)$ of the\nprevious polynomial-time algorithm (Alanko et al., Information and Computation\n2021). A proof-of-concept implementation of this algorithm is available in a\npublic repository. We complement this upper bound with a conditional matching\nlower bound stating that, unless the strong exponential time hypothesis (SETH)\nfails, the problem cannot be solved in strongly subquadratic time. The same\nproblem is known to be PSPACE-complete when the input is an NFA (D'Agostino et\nal., Theoretical Computer Science 2023). Together with that result, our paper\nessentially closes the algorithmic problem of Wheeler language recognition.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.04737v2"
    },
    {
        "title": "Surjective Span 6 Cellular Automata",
        "authors": [
            "Hung Anh Vu",
            "Nate Schnitzer",
            "Ethan Ewing"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Using FSA and the construction algorithm, we generated a list of surjective\nspan 6 cellular automata as a modest sample for our FDense program. We wanted\nto experimentally quantify Mike Boyle's conjecture which states that the\njointly periodic points of one-dimensional cellular automata are dense.\nFurthermore, we wanted to know if the cardinality of cellular automata on N\nsymbols is greater than or equal to the square root of N.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.06562v1"
    },
    {
        "title": "Invariants and Home Spaces in Transition Systems and Petri Nets",
        "authors": [
            "Gerard Memmi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This lecture note focuses on comparing the notions of invariance and home\nspaces in Transition Systems and more particularly, in Petri Nets. We also\ndescribe how linear algebra relates to these basic notions in Computer Science,\nhow it can be used for extracting invariant properties from a parallel system\ndescribed by a Labeled Transition System in general and a Petri Net in\nparticular. We endeavor to regroup a number of algebraic results dispersed\nthroughout the Petri Nets literature with the addition of new results around\nthe notions of semiflows and generating sets. \\newline Several extensive\nexamples are given to illustrate how the notion of invariants and home spaces\ncan be methodically utilized through basic arithmetic and algebra to prove\nbehavioral properties of a Petri Net. Some additional thoughts on invariants\nand home spaces will conclude this note.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.07623v4"
    },
    {
        "title": "Checking Refinement of Asynchronous Programs against Context-Free\n  Specifications",
        "authors": [
            "Pascal Baumann",
            "Moses Ganardi",
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In the language-theoretic approach to refinement verification, we check that\nthe language of traces of an implementation all belong to the language of a\nspecification. We consider the refinement verification problem for asynchronous\nprograms against specifications given by a Dyck language. We show that this\nproblem is EXPSPACE-complete -- the same complexity as that of language\nemptiness and for refinement verification against a regular specification. Our\nalgorithm uses several technical ingredients. First, we show that checking if\nthe coverability language of a succinctly described vector addition system with\nstates (VASS) is contained in a Dyck language is EXPSPACE-complete. Second, in\nthe more technical part of the proof, we define an ordering on words and show a\ndownward closure construction that allows replacing the (context-free) language\nof each task in an asynchronous program by a regular language. Unlike downward\nclosure operations usually considered in infinite-state verification, our\nordering is not a well-quasi-ordering, and we have to construct the regular\nlanguage ab initio. Once the tasks can be replaced, we show a reduction to an\nappropriate VASS and use our first ingredient. In addition to the inherent\ntheoretical interest, refinement verification with Dyck specifications captures\ncommon practical resource usage patterns based on reference counting, for which\nfew algorithmic techniques were known.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.13058v1"
    },
    {
        "title": "Synchronization of primitive automata",
        "authors": [
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We exhibit new conditions under which a primitive automaton is synchronizing.\nIn particular, we show that the primitivity of an automaton forces its\nsynchronizability whenever the automaton has either a letter of defect 1 or a\nword of rank 2.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.13317v3"
    },
    {
        "title": "Determining Smallest Path Size of Multiplication Transducers Without a\n  Restricted Digit Set",
        "authors": [
            "Aditya Mittal",
            "Karthik Mittal"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Directed multiplication transducers are a tool for performing non-decimal\nbase multiplication without an additional conversion to base 10. This allows\nfor faster computation and provides easier visualization depending on the\nproblem at hand. By building these multiplication transducers computationally,\nnew patterns can be identified as these transducers can be built with much\nlarger bases and multipliers. Through a recursive approach, we created\nartificial multiplication transducers, allowing for the formation of several\nunique conjectures specifically focused on the smallest closed loop around a\nmultiplication transducer starting and ending at zero. We show a general\nrecursive pattern for this loop; through this recurrence relation, the length\nof the smallest closed loop for a particular transducer base b along with the\nrange of multipliers having this particular length for multiplier m was also\nidentified. This research is expected to be explored further by testing\nreductions of the digit set and determining whether similar properties will\nhold.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.14904v1"
    },
    {
        "title": "Primitive Automata that are Synchronizing",
        "authors": [
            "Igor Rystsov",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A deterministic finite (semi)automaton is primitive if its transition monoid\n(semigroup) acting on the set of states has no non-trivial congruences. It is\nsynchronizing if it contains a constant map (transformation). In analogy to\nsynchronizing groups, we study the possibility of characterizing automata that\nare synchronizing if primitive. We prove that the implication holds for several\nclasses of automata. In particular, we show it for automata whose every letter\ninduce either a permutation or a semiconstant transformation (an idempotent\nwith one point of contraction) unless all letters are of the first type. We\npropose and discuss two conjectures about possible more general\ncharacterizations.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.01302v1"
    },
    {
        "title": "Depth-Bounded Fuzzy Simulations and Bisimulations between Fuzzy Automata",
        "authors": [
            "Linh Anh Nguyen",
            "Ivana Micić",
            "Stefan Stanimirović"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Simulations and bisimulations are well-established notions in crisp/fuzzy\nautomata theory and are widely used to compare the behaviors of automata. Their\nmain drawback is that they compare the behaviors of fuzzy automata in a crisp\nmanner. Recently, fuzzy simulations and fuzzy bisimulations have been defined\nfor fuzzy automata as a kind of approximate simulations and approximate\nbisimulations that compare the behaviors of fuzzy automata in a fuzzy manner.\nHowever, they still suffer from serious shortcomings. First, they still cannot\ncorrelate all fuzzy automata that are intuitively \"more or less\" (bi)similar.\nSecond, the currently known algorithms for computing the greatest fuzzy\nsimulation or bisimulation between two finite fuzzy automata have an\nexponential time complexity when the {\\L}ukasiewicz or product structure of\nfuzzy values is used. This work deals with these problems, providing\napproximations of fuzzy simulations and fuzzy bisimulations. We define such\napproximations via a novel notion of decreasing sequences of fuzzy relations\nwhose infima are, under some conditions, fuzzy simulations (respectively,\nbisimulations). We call such a sequence a depth-bounded fuzzy simulation\n(respectively, bisimulation), as the $n$th element from the sequence compares\nthe behaviors of fuzzy automata, but only for words with a length bounded by\n$n$. We further provide a logical characterization of the greatest\ndepth-bounded fuzzy simulation or bisimulation between two fuzzy automata by\nproving that it satisfies the corresponding Hennessy-Milner property. Finally,\nwe provide polynomial-time algorithms for computing the $n$th component of the\ngreatest depth-bounded fuzzy simulation (respectively, bisimulation) between\ntwo finite fuzzy automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.03318v1"
    },
    {
        "title": "Complexity of Membership and Non-Emptiness Problems in Unbounded Memory\n  Automata",
        "authors": [
            "Clément Bertrand",
            "Cinzia Di Giusto",
            "Hanna Klaudel",
            "Damien Regnault"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the complexity relationship between three models of unbounded memory\nautomata: nu-automata ($\\nu$-A), Layered Memory Automata (LaMA)and\nHistory-Register Automata (HRA). These are all extensions of finite state\nautomata with unbounded memory over infinite alphabets. We prove that the\nmembership problem is NP-complete for all of them, while they fall into\ndifferent classes for what concerns non-emptiness. The problem of non-emptiness\nis known to be Ackermann-complete for HRA, we prove that it is PSPACE-complete\nfor $\\nu$-A.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.03561v1"
    },
    {
        "title": "Chain-Free String Constraints (Technical Report)",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig Bui Phi Diep",
            "Lukáš Holík",
            "Petr Janků"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We address the satisfiability problem for string constraints that combine\nrelational constraints represented by transducers, word equations, and string\nlength constraints. This problem is undecidable in general. Therefore, we\npropose a new decidable fragment of string constraints, called weakly chaining\nstring constraints, for which we show that the satisfiability problem is\ndecidable. This fragment pushes the borders of decidability of string\nconstraints by generalising the existing straight-line as well as the acyclic\nfragment of the string logic. We have developed a prototype implementation of\nour new decision procedure, and integrated it into in an existing framework\nthat uses CEGAR with under-approximation of string constraints based on\nflattening. Our experimental results show the competitiveness and accuracy of\nthe new framework.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.03970v1"
    },
    {
        "title": "Optimizing an LTS-Simulation Algorithm (Technical Report)",
        "authors": [
            "Lukáš Holík",
            "Jiří Šimáček"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  When comparing the fastest algorithm for computing the largest simulation\npreorder over Kripke structures with the one for labeled transition systems\n(LTS), there is a noticeable time and space complexity blow-up proportional to\nthe size of the alphabet of an LTS. In this paper, we present optimizations\nthat suppress this increase of complexity and may turn a large alphabet of an\nLTS to an advantage. Our experimental results show significant speed-ups and\nmemory savings. Moreover, the optimized algorithm allows one to improve\nasymptotic complexity of procedures for computing simulations over tree\nautomata using recently proposed algorithms based on computing simulation over\ncertain special LTS derived from a tree automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.04235v1"
    },
    {
        "title": "Asymptotic Complexity Estimates for Probabilistic Programs and their\n  VASS Abstractions",
        "authors": [
            "Michal Ajdarów",
            "Antonín Kučera"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The standard approach to analyzing the asymptotic complexity of probabilistic\nprograms is based on studying the asymptotic growth of certain expected values\n(such as the expected termination time) for increasing input size. We argue\nthat this approach is not sufficiently robust, especially in situations when\nthe expectations are infinite. We propose new estimates for the asymptotic\nanalysis of probabilistic programs with non-deterministic choice that overcome\nthis deficiency. Furthermore, we show how to efficiently compute/analyze these\nestimates for selected classes of programs represented as Markov decision\nprocesses over vector addition systems with states.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.04707v2"
    },
    {
        "title": "Safety and Liveness of Quantitative Properties and Automata",
        "authors": [
            "Udi Boker",
            "Thomas A. Henzinger",
            "Nicolas Mazzocchi",
            "N. Ege Saraç"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Safety and liveness stand as fundamental concepts in formal languages,\nplaying a key role in verification. The safety-liveness classification of\nboolean properties characterizes whether a given property can be falsified by\nobserving a finite prefix of an infinite computation trace (always for safety,\nnever for liveness). In the quantitative setting, properties are arbitrary\nfunctions from infinite words to partially-ordered domains. Extending this\nparadigm to the quantitative domain, where properties are arbitrary functions\nmapping infinite words to partially-ordered domains, we introduce and study the\nnotions of quantitative safety and liveness. First, we formally define\nquantitative safety and liveness, and prove that our definitions induce\nconservative quantitative generalizations of both the safety-progress hierarchy\nand the safety-liveness decomposition of boolean properties. Consequently, like\ntheir boolean counterparts, quantitative properties can be min-decomposed into\nsafety and liveness parts, or alternatively, max-decomposed into co-safety and\nco-liveness parts. We further establish a connection between quantitative\nsafety and topological continuity and provide alternative characterizations of\nquantitative safety and liveness in terms of their boolean analogs. Second, we\ninstantiate our framework with the specific classes of quantitative properties\nexpressed by automata. These quantitative automata contain finitely many states\nand rational-valued transition weights, and their common value functions Inf,\nSup, LimInf, LimSup, LimInfAvg, LimSupAvg, and DSum map infinite words into the\ntotally-ordered domain of real numbers. For all common value functions, we\nprovide a procedure for deciding whether a given automaton is safe or live, we\nshow how to construct its safety closure, and we present a min-decomposition\ninto safe and live automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.06016v4"
    },
    {
        "title": "Deciding Conjugacy of a Rational Relation",
        "authors": [
            "C. Aiswarya",
            "Amaldev Manuel",
            "Saina Sunny"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The study of rational relations is fundamental to the study of formal\nlanguages and automata theory. A rational relation is conjugate if each pair of\nwords in the relation is conjugate (or cyclic shifts of each other). The notion\nof conjugacy has been central in addressing many important algorithmic\nquestions about rational relations. We address the problem of checking whether\na rational relation is conjugate and show that it is decidable.\n  Towards our decision procedure, we establish a new result that is of\nindependent interest to word combinatorics. We identify a necessary and\nsufficient condition for the set of pairs given by $(a_0,b_0) G_1^* (a_1,b_1)\n\\cdots G_k^*(a_k,b_k), k \\geq 0$ to be conjugate, where $G_i$ is a (not\nnecessarily rational) conjugate relation and $a_i, b_i$ are arbitrary words.\nThis is similar to, and a nontrivial generalisation of, a characterisation\ngiven by Lyndon and Sch\\\"utzenberger in 1962 for the conjugacy of a pair of\nwords.\n  Furthermore, our condition can be evaluated in polynomial time, yielding a\nPTIME procedure for deciding the conjugacy of a rational relation given as a\nsumfree expression. Since any arbitrary rational expression can be expressed as\na sum of sumfree expressions (with an exponential blow-up), decidability of\nconjugacy of rational relations follows.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.06777v3"
    },
    {
        "title": "Decomposing Finite Languages",
        "authors": [
            "Daniel Alexander Spenner"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The paper completely characterizes the primality of acyclic DFAs, where a DFA\n$\\mathcal{A}$ is prime if there do not exist DFAs\n$\\mathcal{A}_1,\\dots,\\mathcal{A}_t$ with $\\mathcal{L}(\\mathcal{A}) =\n\\bigcap_{i=1}^{t} \\mathcal{L}({\\mathcal{A}_i})$ such that each $\\mathcal{A}_i$\nhas strictly less states than the minimal DFA recognizing the same language as\n$\\mathcal{A}$. A regular language is prime if its minimal DFA is prime. Thus,\nthis result also characterizes the primality of finite languages.\n  Further, the $\\mathsf{NL}$-completeness of the corresponding decision problem\n$\\mathsf{PrimeDFA}_{\\text{fin}}$ is proven. The paper also characterizes the\nprimality of acyclic DFAs under two different notions of compositionality,\nunion and union-intersection compositionality.\n  Additionally, the paper introduces the notion of S-primality, where a DFA\n$\\mathcal{A}$ is S-prime if there do not exist DFAs\n$\\mathcal{A}_1,\\dots,\\mathcal{A}_t$ with $\\mathcal{L}(\\mathcal{A}) =\n\\bigcap_{i=1}^{t} \\mathcal{L}(\\mathcal{A}_i)$ such that each $\\mathcal{A}_i$\nhas strictly less states than $\\mathcal{A}$ itself. It is proven that the\nproblem of deciding S-primality for a given DFA is $\\mathsf{NL}$-hard. To do\nso, the $\\mathsf{NL}$-completeness of $\\mathsf{2MinimalDFA}$, the basic problem\nof deciding minimality for a DFA with at most two letters, is proven.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.06802v1"
    },
    {
        "title": "Remarks on Parikh-recognizable omega-languages",
        "authors": [
            "Mario Grobler",
            "Leif Sabellek",
            "Sebastian Siebertz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Several variants of Parikh automata on infinite words were recently\nintroduced by Guha et al. [FSTTCS, 2022]. We show that one of these variants\ncoincides with blind counter machine as introduced by Fernau and Stiebe\n[Fundamenta Informaticae, 2008]. Fernau and Stiebe showed that every\n$\\omega$-language recognized by a blind counter machine is of the form\n$\\bigcup_iU_iV_i^\\omega$ for Parikh recognizable languages $U_i, V_i$, but\nblind counter machines fall short of characterizing this class of\n$\\omega$-languages. They posed as an open problem to find a suitable\nautomata-based characterization. We introduce several additional variants of\nParikh automata on infinite words that yield automata characterizations of\nclasses of $\\omega$-language of the form $\\bigcup_iU_iV_i^\\omega$ for all\ncombinations of languages $U_i, V_i$ being regular or Parikh-recognizable. When\nboth $U_i$ and $V_i$ are regular, this coincides with B\\\"uchi's classical\ntheorem. We study the effect of $\\varepsilon$-transitions in all variants of\nParikh automata and show that almost all of them admit\n$\\varepsilon$-elimination. Finally we study the classical decision problems\nwith applications to model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.07238v2"
    },
    {
        "title": "Priority Downward Closures",
        "authors": [
            "Ashwani Anand",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  When a system sends messages through a lossy channel, then the language\nencoding all sequences of messages can be abstracted by its downward closure,\ni.e. the set of all (not necessarily contiguous) subwords. This is useful\nbecause even if the system has infinitely many states, its downward closure is\na regular language. However, if the channel has congestion control based on\npriorities assigned to the messages, then we need a finer abstraction: The\ndownward closure with respect to the priority embedding. As for subword-based\ndownward closures, one can also show that these priority downward closures are\nalways regular.\n  While computing finite automata for the subword-based downward closure is\nwell understood, nothing is known in the case of priorities. We initiate the\nstudy of this problem and provide algorithms to compute priority downward\nclosures for regular languages, one-counter languages, and context-free\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.07460v2"
    },
    {
        "title": "A novel family of finite automata for recognizing and learning\n  $ω$-regular languages",
        "authors": [
            "Yong Li",
            "Sven Schewe",
            "Qiyi Tang"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Families of DFAs (FDFAs) have recently been introduced as a new\nrepresentation of $\\omega$-regular languages. They target ultimately periodic\nwords, with acceptors revolving around accepting some representation $u\\cdot\nv^\\omega$. Three canonical FDFAs have been suggested, called periodic,\nsyntactic, and recurrent. We propose a fourth one, limit FDFAs, which can be\nexponentially coarser than periodic FDFAs and are more succinct than syntactic\nFDFAs, while they are incomparable (and dual to) recurrent FDFAs. We show that\nlimit FDFAs can be easily used to check not only whether {\\omega}-languages are\nregular, but also whether they are accepted by deterministic B\\\"uchi automata.\nWe also show that canonical forms can be left behind in applications: the limit\nand recurrent FDFAs can complement each other nicely, and it may be a good way\nforward to use a combination of both. Using this observation as a starting\npoint, we explore making more efficient use of Myhill-Nerode's right\ncongruences in aggressively increasing the number of don't-care cases in order\nto obtain smaller progress automata. In pursuit of this goal, we gain\nsuccinctness, but pay a high price by losing constructiveness.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.07490v1"
    },
    {
        "title": "Comparing Two Approaches to Include Stochasticity in Hybrid Automata",
        "authors": [
            "Lisa Willemsen",
            "Anne Remke",
            "Erika Ábrahám"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Different stochastic extensions of hybrid automata have been proposed in the\npast, with unclear expressivity relations between them. To structure and relate\nthese modeling languages, in this paper we formalize two alternative approaches\nto extend hybrid automata with stochastic choices of discrete events and their\ntime points. The first approach, which we call decomposed scheduling, adds\nstochasticity via stochastic races, choosing random time points for the\npossible discrete events and executing a winner with an earliest time. In\ncontrast, composed scheduling first samples the time point of the next event\nand then the event to be executed at the sampled time point. We relate the two\napproaches regarding their expressivity and categorize available stochastic\nextensions of hybrid automata from the literature.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.08052v2"
    },
    {
        "title": "On the Expressive Power of Regular Expressions with Backreferences",
        "authors": [
            "Taisei Nogami",
            "Tachio Terauchi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A rewb is a regular expression extended with a feature called backreference.\nIt is broadly known that backreference is a practical extension of regular\nexpressions, and is supported by most modern regular expression engines, such\nas those in the standard libraries of Java, Python, and more. Meanwhile,\nindexed languages are the languages generated by indexed grammars, a formal\ngrammar class proposed by A.V.Aho. We show that these two models' expressive\npowers are related in the following way: every language described by a rewb is\nan indexed language. As the smallest formal grammar class previously known to\ncontain rewbs is the class of context sensitive languages, our result strictly\nimproves the known upper-bound. Moreover, we prove the following two claims:\nthere exists a rewb whose language does not belong to the class of stack\nlanguages, which is a proper subclass of indexed languages, and the language\ndescribed by a rewb without a captured reference is in the class of nonerasing\nstack languages, which is a proper subclass of stack languages. Finally, we\nshow that the hierarchy investigated in a prior study, which separates the\nexpressive power of rewbs by the notion of nested levels, is within the class\nof nonerasing stack languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.08531v3"
    },
    {
        "title": "Two-way automata and transducers with planar behaviours are aperiodic",
        "authors": [
            "Lê Thành Dũng Nguyên",
            "Camille Noûs",
            "Cécilia Pradic"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider a notion of planarity for two-way finite automata and\ntransducers, inspired by Temperley-Lieb monoids of planar diagrams. We show\nthat this restriction captures star-free languages and first-order\ntransductions.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.11057v1"
    },
    {
        "title": "On the Succinctness of Good-for-MDPs Automata",
        "authors": [
            "Sven Schewe",
            "Qiyi Tang"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Good-for-MDPs and good-for-games automata are two recent classes of\nnondeterministic automata that reside between general nondeterministic and\ndeterministic automata. Deterministic automata are good-for-games, and\ngood-for-games automata are good-for-MDPs, but not vice versa. One of the\nquestion this raises is how these classes relate in terms of succinctness.\nGood-for-games automata are known to be exponentially more succinct than\ndeterministic automata, but the gap between good-for-MDPs and good-for-games\nautomata as well as the gap between ordinary nondeterministic automata and\nthose that are good-for-MDPs have been open. We establish that these gaps are\nexponential, and sharpen this result by showing that the latter gap remains\nexponential when restricting the nondeterministic automata to separating safety\nor unambiguous reachability automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.11483v1"
    },
    {
        "title": "EnPAC: Petri Net Model Checking for Linear Temporal Logic",
        "authors": [
            "Zhijun Ding",
            "Cong He",
            "Shuo Li"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  State generation and exploration (counterexample search) are two cores of\nexplicit-state Petri net model checking for linear temporal logic (LTL).\nTraditional state generation updates a structure to reduce the computation of\nall transitions and frequently encodes/decodes to read each encoded state. We\npresent the optimized calculation of enabled transitions on demand by dynamic\nfireset to avoid such a structure. And we propose direct read/write (DRW)\noperation on encoded markings without decoding and re-encoding to make state\ngeneration faster and reduce memory consumption. To search counterexamples more\nquickly under an on-the-fly framework, we add heuristic information to the\nBuchi automaton to guide the exploration in the direction of accepted states.\nThe above strategies can optimize existing methods for LTL model checking. We\nimplement these optimization strategies in a Petri net model-checking tool\ncalled EnPAC (Enhanced Petri-net Analyser and Checker) for linear temporal\nlogic. Then, we evaluate it on the benchmarks of MCC (Model Checking Contest),\nwhich shows a drastic improvement over the existing methods.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.12324v1"
    },
    {
        "title": "Minimizing Cost Register Automata over a Field",
        "authors": [
            "Yahia Idriss Benalioua",
            "Nathan Lhote",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Weighted automata (WA) are an extension of finite automata that define\nfunctions from words to values in a given semiring. An alternative\ndeterministic model, called Cost Register Automata (CRA), was introduced by\nAlur et al. It enriches deterministic finite automata with a finite number of\nregisters, which store values, updated at each transition using the operations\nof the semiring. It is known that CRA with register updates defined by linear\nmaps have the same expressiveness as WA. Previous works have studied the\nregister minimization problem: given a function computable by a WA and an\ninteger k, is it possible to realize it using a CRA with at most k registers?\nIn this paper, we solve this problem for CRA over a field with linear register\nupdates, using the notion of linear hull, an algebraic invariant of WA\nintroduced recently by Bell and Smertnig. We then generalise the approach to\nsolve a more challenging problem, that consists in minimizing simultaneously\nthe number of states and that of registers. In addition, we also lift our\nresults to the setting of CRA with affine updates. Last, while the linear hull\nwas recently shown to be computable by Bell and Smertnig, no complexity bounds\nwere given. To fill this gap, we provide two new algorithms to compute\ninvariants of WA. This allows us to show that the register (resp.\nstate-register) minimization problem can be solved in 2-ExpTime (resp. in\nNExpTime).\n",
        "pdf_link": "http://arxiv.org/pdf/2307.13505v2"
    },
    {
        "title": "Dimension-Minimality and Primality of Counter Nets",
        "authors": [
            "Shaull Almagor",
            "Guy Avni",
            "Henry Sinclair-Banks",
            "Asaf Yeshurun"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A $k$-Counter Net ($k$-CN) is a finite-state automaton equipped with $k$\ninteger counters that are not allowed to become negative, but do not have\nexplicit zero tests. This language-recognition model can be thought of as\nlabelled vector addition systems with states, some of which are accepting.\nCertain decision problems for $k$-CNs become easier, or indeed decidable, when\nthe dimension $k$ is small. Yet, little is known about the effect that the\ndimension $k$ has on the class of languages recognised by $k$-CNs.\nSpecifically, it would be useful if we could simplify algorithmic reasoning by\nreducing the dimension of a given CN.\n  To this end, we introduce the notion of dimension-primality for $k$-CN,\nwhereby a $k$-CN is prime if it recognises a language that cannot be decomposed\ninto a finite intersection of languages recognised by $d$-CNs, for some $d<k$.\nWe show that primality is undecidable. We also study two related notions:\ndimension-minimality (where we seek a single language-equivalent $d$-CN of\nlower dimension) and language regularity. Additionally, we explore the\ntrade-offs in expressiveness between dimension and non-determinism for CN.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.14492v2"
    },
    {
        "title": "Explicit Hopcroft's Trick in Categorical Partition Refinement",
        "authors": [
            "Takahiro Sanada",
            "Ryota Kojima",
            "Yuichi Komorida",
            "Koko Muroya",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Algorithms for partition refinement are actively studied for a variety of\nsystems, often with the optimisation called Hopcroft's trick. However, the\nlow-level description of those algorithms in the literature often obscures the\nessence of Hopcroft's trick. Our contribution is twofold. Firstly, we present a\nnovel formulation of Hopcroft's trick in terms of general trees with weights.\nThis clean and explicit formulation -- we call it Hopcroft's inequality -- is\ncrucially used in our second contribution, namely a general partition\nrefinement algorithm that is functor-generic (i.e. it works for a variety of\nsystems such as (non-)deterministic automata and Markov chains). Here we build\non recent works on coalgebraic partition refinement but depart from them with\nthe use of fibrations. In particular, our fibrational notion of\n$R$-partitioning exposes a concrete tree structure to which Hopcroft's\ninequality readily applies. It is notable that our fibrational framework\naccommodates such algorithmic analysis on the categorical level of abstraction.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.15261v2"
    },
    {
        "title": "Deciding Linear Height and Linear Size-to-Height Increase for Macro Tree\n  Transducers",
        "authors": [
            "Paul Gallot",
            "Sebastian Maneth",
            "Keisuke Nakano",
            "Charles Peyrat"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present a novel normal form for (total deterministic) macro tree\ntransducers (mtts), called depth proper normal form. If an mtt is in this\nnormal form, then it is guaranteed that each parameter of each state of the mtt\nappears at arbitrary depth in the output trees of that state. Intuitively, if\nsome parameter only appears at certain bounded depths in the output trees of a\nstate, then this parameter can be removed by in-lining the corresponding output\npaths at each call site of that state. We use regular look-ahead in order to\ndetermine which of the paths should be in-lined. As a consequence of changing\nthe lookahead, a parameter that was previously appearing at unbounded depths,\nmay be appearing at bounded depths for some new look-ahead; for this reason,\nour construction has be iterated in order to obtain an mtt in depth-normal\nform. Using the normal form, we can decide whether the translation of an mtt\nhas linear height increase or has linear size-to-height increase.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.16500v4"
    },
    {
        "title": "Two-dimensional Dyck words",
        "authors": [
            "Stefano Crespi Reghizzi",
            "Antonio Restivo",
            "Pierluigi San Pietro"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We propose different ways of lifting the notion of Dyck language from words\nto 2-dimensional (2D) pictures, by means of new definitions of increasing\ncomprehensiveness. Two of the proposals are based on alternative definitions of\na Dyck language, which are equivalent over words but not on pictures. First,\nthe property that any two pairs of matching parentheses are well-nested or\ndisjoint is rephrased for rectangular boxes and leads to the well-nested Dyck,\n$DW_k$. This is a generalization of the known Chinese box language, but, unlike\nthe Chinese boxes, $DW_k$ is not recognizable by a tiling system. Second, the\nDyck cancellation rule is rephrased as a neutralization rule, mapping a\nquadruple of symbols representing the corners of a subpicture onto neutral\nsymbols.The neutralizable Dyck language $DN_k$ is obtained by iterating\nneutralizations, starting from 2-by-2 subpictures, until the picture is wholly\nneutralized. Third, we define the Dyck crossword $DC_k$ as the row-column\ncombination of Dyck word languages, which prescribes that each column and row\nis a Dyck word. The relation between matching parentheses is represented in\n$DC_k$ by an edge of a graph situated on the picture grid. Such edges form a\ncircuit, of path length multiple of four, of alternating row and column\nmatches. Length-four circuits have rectangular shape, while longer ones exhibit\na large variety of forms. A proper subset of $DC_k$, called quaternate, is also\nintroduced by excluding all circuits of length greater than 4. We prove that\n$DN_k$ properly includes $DW_k$, and that it coincides with the quaternate\n$DC_k$ such that the neutralizability relation between subpictures induces a\npartial order. The 2D languages well-nested, neutralizable, quaternate and Dyck\ncrossword are ordered by strict inclusions. This work can be also seen as a\nfirst step towards the definition of context-free picture languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.16522v2"
    },
    {
        "title": "Forgetting 1-Limited Automata",
        "authors": [
            "Giovanni Pighizzini",
            "Luca Prigioniero"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce and investigate forgetting 1-limited automata, which are\nsingle-tape Turing machines that, when visiting a cell for the first time,\nreplace the input symbol in it by a fixed symbol, so forgetting the original\ncontents. These devices have the same computational power as finite automata,\nnamely they characterize the class of regular languages. We study the cost in\nsize of the conversions of forgetting 1-limited automata, in both\nnondeterministic and deterministic cases, into equivalent one-way\nnondeterministic and deterministic automata, providing optimal bounds in terms\nof exponential or superpolynomial functions. We also discuss the size\nrelationships with two-way finite automata. In this respect, we prove the\nexistence of a language for which forgetting 1-limited automata are\nexponentially larger than equivalent minimal deterministic two-way automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.16700v2"
    },
    {
        "title": "The Expansion Problem for Infinite Trees",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study Ramsey like theorems for infinite trees and similar combinatorial\ntools. As an application we consider the expansion problem for tree algebras.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.01174v4"
    },
    {
        "title": "An Easily Checkable Algebraic Characterization of Positive Expansivity\n  for Additive Cellular Automata over a Finite Abelian Group",
        "authors": [
            "Alberto Dennunzio",
            "Enrico Formenti",
            "Luciano Margara"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We provide an easily checkable algebraic characterization of positive\nexpansivity for Additive Cellular Automata over a finite abelian group. First\nof all, an easily checkable characterization of positive expansivity is\nprovided for the non trivial subclass of Linear Cellular Automata over the\nalphabet $(\\Z/m\\Z)^n$. Then, we show how it can be exploited to decide positive\nexpansivity for the whole class of Additive Cellular Automata over a finite\nabelian group.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.03064v2"
    },
    {
        "title": "Synchronized CTL over One-Counter Automata",
        "authors": [
            "Shaull Almagor",
            "Daniel Assa",
            "Udi Boker"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider the model-checking problem of Synchronized Computation-Tree Logic\n(CTL+Sync) over One-Counter Automata (OCAs). CTL+Sync augments CTL with\ntemporal operators that require several paths to satisfy properties in a\nsynchronous manner, e.g., the property \"all paths should eventually see $p$ at\nthe same time\". The model-checking problem for CTL+Sync over finite-state\nKripke structures was shown to be in $\\mathsf{P}^{\\mathsf{NP}^{\\mathsf{NP}}}$.\nOCAs are labelled transition systems equipped with a non-negative counter that\ncan be zero-tested. Thus, they induce infinite-state systems whose computation\ntrees are not regular. The model-checking problem for CTL over OCAs was shown\nto be $\\mathsf{PSPACE}$-complete.\n  We show that the model-checking problem for CTL+Sync over OCAs is decidable.\nHowever, the upper bound we give is non-elementary. We therefore proceed to\nstudy the problem for a central fragment of CTL+Sync, extending CTL with\noperators that require all paths to satisfy properties in a synchronous manner,\nand show that it is in $\\mathsf{EXP}^\\mathsf{NEXP}$ (and in particular in\n$\\mathsf{EXPSPACE}$), by exhibiting a certain \"segmented periodicity\" in the\ncomputation trees of OCAs.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.03308v3"
    },
    {
        "title": "Canonical Algebraic Generators in Automata Learning",
        "authors": [
            "Stefan Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Many methods for the verification of complex computer systems require the\nexistence of a tractable mathematical abstraction of the system, often in the\nform of an automaton. In reality, however, such a model is hard to come up\nwith, in particular manually. Automata learning is a technique that can\nautomatically infer an automaton model from a system -- by observing its\nbehaviour. The majority of automata learning algorithms is based on the\nso-called L* algorithm. The acceptor learned by L* has an important property:\nit is canonical, in the sense that, it is, up to isomorphism, the unique\ndeterministic finite automaton of minimal size accepting a given regular\nlanguage. Establishing a similar result for other classes of acceptors, often\nwith side-effects, is of great practical importance. Non-deterministic finite\nautomata, for instance, can be exponentially more succinct than deterministic\nones, allowing verification to scale. Unfortunately, identifying a canonical\nsize-minimal non-deterministic acceptor of a given regular language is in\ngeneral not possible: it can happen that a regular language is accepted by two\nnon-isomorphic non-deterministic finite automata of minimal size. In\nparticular, it thus is unclear which one of the automata should be targeted by\na learning algorithm. In this thesis, we further explore the issue and identify\n(sub-)classes of acceptors that admit canonical size-minimal representatives.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.04222v1"
    },
    {
        "title": "Sweep Complexity Revisited",
        "authors": [
            "Szilárd Zsolt Fazekas",
            "Robert Mercaş"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the sweep complexity of DFA in one-way jumping mode answering\nseveral questions posed earlier. This measure is the number of times in the\nworst case that such machines have to return to the beginning of their input\nafter having skipped some of the symbols. The class of languages accepted by\nthese machines strictly includes the regular class and constant sweep\ncomplexity allows exactly the acceptance of regular languages. However, we show\nthat there exist machines with higher than constant complexity still only\naccepting regular languages and that in general the sweep complexity of an\nautomaton does not distinguish between accepting regular and non-regular\nlanguages. We establish separation results for asymptotic classes defined by\nthis complexity measure and give a surprising exponential/logarithmic relation\nbetween factors of certain inputs which can be verified by such machines.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.06683v1"
    },
    {
        "title": "Introducing Divergence for Infinite Probabilistic Models",
        "authors": [
            "Alain Finkel",
            "Serge Haddad",
            "Lina Ye"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Computing the reachability probability in infinite state probabilistic models\nhas been the topic of numerous works. Here we introduce a new property called\ndivergence that when satisfied allows to compute reachability probabilities up\nto an arbitrary precision. One of the main interest of divergence is that this\ncomputation does not require the reachability problem to be decidable. Then we\nstudy the decidability of divergence for random walks and the probabilistic\nversions of Petri nets where the weights associated with transitions may also\ndepend on the current state. This should be contrasted with most of the\nexisting works that assume weights independent of the state. Such an extended\nframework is motivated by the modeling of real case studies. Moreover, we\nexhibit some subclasses of channel systems and pushdown automata that are\ndivergent by construction, particularly suited for specifying open distributed\nsystems and networks prone to performance collapsing where probabilities\nrelated to service requirements are needed. where probabilities related to\nservice requirements are needed.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.08842v5"
    },
    {
        "title": "The Fine-Grained Complexity of CFL Reachability",
        "authors": [
            "Paraschos Koutris",
            "Shaleen Deep"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Many problems in static program analysis can be modeled as the context-free\nlanguage (CFL) reachability problem on directed labeled graphs. The CFL\nreachability problem can be generally solved in time $O(n^3)$, where $n$ is the\nnumber of vertices in the graph, with some specific cases that can be solved\nfaster. In this work, we ask the following question: given a specific CFL, what\nis the exact exponent in the monomial of the running time? In other words, for\nwhich cases do we have linear, quadratic or cubic algorithms, and are there\nproblems with intermediate runtimes? This question is inspired by recent\nefforts to classify classic problems in terms of their exact polynomial\ncomplexity, known as {\\em fine-grained complexity}. Although recent efforts\nhave shown some conditional lower bounds (mostly for the class of combinatorial\nalgorithms), a general picture of the fine-grained complexity landscape for CFL\nreachability is missing.\n  Our main contribution is lower bound results that pinpoint the exact running\ntime of several classes of CFLs or specific CFLs under widely believed lower\nbound conjectures (Boolean Matrix Multiplication and $k$-Clique). We\nparticularly focus on the family of Dyck-$k$ languages (which are strings with\nwell-matched parentheses), a fundamental class of CFL reachability problems. We\npresent new lower bounds for the case of sparse input graphs where the number\nof edges $m$ is the input parameter, a common setting in the database\nliterature. For this setting, we show a cubic lower bound for Andersen's\nPointer Analysis which significantly strengthens prior known results.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.09284v1"
    },
    {
        "title": "Formal Analysis and Verification of Max-Plus Linear Systems",
        "authors": [
            "Muhammad Syifa'ul Mufid",
            "Andrea Micheli",
            "Alessandro Abate",
            "Alessandro Cimatti"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Max-Plus Linear (MPL) systems are an algebraic formalism with practical\napplications in transportation networks, manufacturing and biological systems.\nIn this paper, we investigate the problem of automatically analyzing the\nproperties of MPL, taking into account both structural properties such as\ntransient and cyclicity, and the open problem of user-defined temporal\nproperties. We propose Time-Difference LTL (TDLTL), a logic that encompasses\nthe delays between the discrete time events governed by an MPL system, and\ncharacterize the problem of model checking TDLTL over MPL. We first consider a\nframework based on the verification of infinite-state transition systems, and\npropose an approach based on an encoding into model checking. Then, we leverage\nthe specific features of MPL systems to devise a highly optimized,\ncombinational approach based on Satisfiability Modulo Theory (SMT). We\nexperimentally evaluate the features of the proposed approaches on a large set\nof benchmarks. The results show that the proposed approach substantially\noutperforms the state of the art competitors in expressiveness and\neffectiveness, and demonstrate the superiority of the combinational approach\nover the reduction to model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.10587v1"
    },
    {
        "title": "Research Challenges in Orchestration Synthesis",
        "authors": [
            "Davide Basile",
            "Maurice H. ter Beek"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Contract automata allow to formally define the behaviour of service contracts\nin terms of service offers and requests, some of which are moreover optional\nand some of which are necessary. A composition of contracts is said to be in\nagreement if all service requests are matched by corresponding offers. Whenever\na composition of contracts is not in agreement, it can be refined to reach an\nagreement using the orchestration synthesis algorithm. This algorithm is a\nvariant of the synthesis algorithm used in supervisory control theory and it is\nbased on the fact that optional transitions are controllable, whereas necessary\ntransitions are at most semi-controllable and cannot always be controlled. In\nfact, the resulting orchestration is such that as much of the behaviour in\nagreement is maintained. In this paper, we discuss recent developments of the\norchestration synthesis algorithm for contract automata. Notably, we present a\nrefined notion of semi-controllability and compare it with the original notion\nby means of examples. We then discuss the current limits of the orchestration\nsynthesis algorithm and identify a number of research challenges together with\na research roadmap.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.10651v2"
    },
    {
        "title": "Transcendence of Sturmian Numbers over an Algebraic Base",
        "authors": [
            "Florian Luca",
            "Joel Ouaknine",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider numbers of the form\n  $S_\\beta(\\boldsymbol{u}):=\\sum_{n=0}^\\infty \\frac{u_n}{\\beta^n}$ for\n  $\\boldsymbol{u}=\\langle u_n \\rangle_{n=0}^\\infty$ a Sturmian\n  sequence over a binary alphabet and $\\beta$ an algebraic number with\n  $|\\beta|>1$. We show that every such number is transcendental.\n  More generally, for a given base~$\\beta$ and given irrational\n  number~$\\theta$ we characterise the\n  $\\overline{\\mathbb{Q}}$-linear independence of sets of the form\n  $\\left\\{ 1,\n  S_\\beta(\\boldsymbol{u}^{(1)}),\\ldots,S_\\beta(\\boldsymbol{u}^{(k)})\n  \\right\\}$, where $\\boldsymbol{u}^{(1)},\\ldots,\\boldsymbol{u}^{(k)}$ are\n  Sturmian sequences having slope $\\theta$.\n  We give an application of our main result to the theory of dynamical\n  systems, showing that for a contracted rotation on the unit circle\n  with algebraic slope, its limit set is either finite or consists\n  exclusively of transcendental elements other than its endpoints $0$\n  and $1$. This confirms a conjecture of Bugeaud, Kim, Laurent, and\n  Nogueira.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.13657v1"
    },
    {
        "title": "On Decidability and Expressive Power of Fusion Grammars",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove decidability of the non-emptiness problems for fusion grammars and\ndecidability of the membership problem for fusion grammars without markers and\nconnectors. Additionally, we prove the Parikh theorem for connection-preserving\nfusion grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.00954v1"
    },
    {
        "title": "Proceedings of the 16th International Conference on Automata and Formal\n  Languages",
        "authors": [
            "Zsolt Gazdag",
            "Szabolcs Iván",
            "Gergely Kovásznai"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The 16th International Conference on Automata and Formal Languages (AFL 2023)\nwas held in Eger, September 5-7, 2023. It was organized by the Eszterh\\'azy\nK\\'aroly Catholic University of Eger, Hungary, and the University of Szeged,\nHungary. Topics of interest covered the theory and applications of automata and\nformal languages and related areas.\n  This volume contains the texts of the 3 invited presentations and the 18\npapers selected by the International Program Committee from a total of 23\nsubmissions. We would like to thank everybody who submitted a paper to the\nconference.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.01126v1"
    },
    {
        "title": "A Usage-Aware Sequent Calculus for Differential Dynamic Logic",
        "authors": [
            "Myra Dotzel",
            "Stefan Mitsch",
            "André Platzer"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Ensuring that safety-critical applications behave as intended is an important\nyet challenging task. Modeling languages like differential dynamic logic (dL)\nhave proof calculi capable of proving guarantees for such applications.\nHowever, dL programmers may unintentionally over-specify assumptions and\nprogram statements, which results in overly constrained models that yield weak\nor vacuous guarantees. In hybrid systems models, such constraints are\nubiquitous; they may appear as assumptions, conditions on control switches, and\nevolution domain constraints in systems of differential equations which makes\nit nontrivial to systematically detect which ones are over-specified. Existing\napproaches are limited, either lacking formal correctness guarantees or the\ngranularity to detect all kinds of bugs arising in a given formula.\n  As a remedy, we present a novel proof-based technique that detects which\nconstraints in a dL formula are vacuous or over-specified and suggests ways in\nwhich these components could be mutated while preserving correctness proofs.\nWhen properties follow entirely from constraints uninfluenced by program\nstatements, this analysis spots outright flaws in models. Otherwise, it helps\nmake models more flexible by identifying specific ways in which they may be\ngeneralized. The resulting analysis is thorough, catching bugs at a\nfine-grained level and proposing mutations that could be applied in\ncombination. We prove soundness and completeness with respect to dL to ensure\nthe correctness of suggested mutations and general applicability of our\ntechnique.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.01180v3"
    },
    {
        "title": "Reversible Two-Party Computations",
        "authors": [
            "Martin Kutrib",
            "Andreas Malcher"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Deterministic synchronous systems consisting of two finite automata running\nin opposite directions on a shared read-only input are studied with respect to\ntheir ability to perform reversible computations, which means that the automata\nare also backward deterministic and, thus, are able to uniquely step the\ncomputation back and forth. We study the computational capacity of such devices\nand obtain on the one hand that there are regular languages that cannot be\naccepted by such systems. On the other hand, such systems can accept even\nnon-semilinear languages. Since the systems communicate by sending messages, we\nconsider also systems where the number of messages sent during a computation is\nrestricted. We obtain a finite hierarchy with respect to the allowed amount of\ncommunication inside the reversible classes and separations to general, not\nnecessarily reversible, classes. Finally, we study closure properties and\ndecidability questions and obtain that the questions of emptiness, finiteness,\ninclusion, and equivalence are not semidecidable if a superlogarithmic amount\nof communication is allowed.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02747v1"
    },
    {
        "title": "Operations on Boolean and Alternating Finite Automata",
        "authors": [
            "Galina Jirásková"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We examine the complexity of basic regular operations on languages\nrepresented by Boolean and alternating finite automata. We get tight upper\nbounds m+n and m+n+1 for union, intersection, and difference, 2^m+n and 2^m+n+1\nfor concatenation, 2^n+n and 2^n+n+1 for square, m and m+1 for left quotient,\n2^m and 2^m+1 for right quotient. We also show that in both models, the\ncomplexity of complementation and symmetric difference is n and m+n,\nrespectively, while the complexity of star and reversal is 2^n. All our\nwitnesses are described over a unary or binary alphabets, and whenever we use a\nbinary alphabet, it is always optimal.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02748v1"
    },
    {
        "title": "On the Degree of Extension of Some Models Defining Non-Regular Languages",
        "authors": [
            "Victor Mitrana",
            "Mihaela Păun"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This work is a survey of the main results reported for the degree of\nextension of two models defining non-regular languages, namely the context-free\ngrammar and the extended automaton over groups. More precisely, we recall the\nmain results regarding the degree on non-regularity of a context-free grammar\nas well as the degree of extension of finite automata over groups. Finally, we\nconsider a similar measure for the finite automata with translucent letters and\npresent some preliminary results. This measure could be considered for many\nmechanisms that extend a less expressive one.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02749v1"
    },
    {
        "title": "Approximate State Reduction of Fuzzy Finite Automata",
        "authors": [
            "Miroslav Ćirić",
            "Ivana Micić",
            "Stefan Stanimirović",
            "Linh Anh Nguyen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we introduce a new type of approximate state reductions where\nthe behaviors of the reduced and the original automaton do not have to be\nidentical, but they must match on all words of length less than or equal to\nsome given natural number. We provide four methods for performing such\nreductions.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02750v1"
    },
    {
        "title": "Weighted Automata over Vector Spaces",
        "authors": [
            "Nada Damljanović",
            "Miroslav Ćirić",
            "Jelena Ignjatović"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we deal with three models of weighted automata that take\nweights in the field of real numbers. The first of these models are classical\nweighted finite automata, the second one are crisp-deterministic weighted\nautomata, and the third one are weighted automata over a vector space. We\nexplore the interrelationships between weighted automata over a vector space\nand other two models.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02751v1"
    },
    {
        "title": "Freezing 1-Tag Systems with States",
        "authors": [
            "Szilárd Zsolt Fazekas",
            "Shinnosuke Seki"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study 1-tag systems with states obeying the freezing property that only\nallows constant bounded number of rewrites of symbols. We look at examples of\nlanguages accepted by such systems, the accepting power of the model, as well\nas certain closure properties and decision problems. Finally we discuss a\nrestriction of the system where the working alphabet must match the input\nalphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02753v1"
    },
    {
        "title": "When Stars Control a Grammar's Work",
        "authors": [
            "Henning Fernau",
            "Lakshmanan Kuppusamy",
            "Indhumathi Raman"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Graph-controlled insertion-deletion (GCID) systems are regulated extensions\nof insertion-deletion systems. Such a system has several components and each\ncomponent contains some insertion-deletion rules. The components are the\nvertices of a directed control graph. A rule is applied to a string in a\ncomponent and the resultant string is moved to the target component specified\nin the rule. The language of the system is the set of all terminal strings\ncollected in the final component. We impose the restriction in the structure of\nthe underlying graph to be a star structure where there is a central, control\ncomponent which acts like a master and transmits a string (after applying one\nof its rules) to one of the components specified in the (applied) rule. A\ncomponent which receives the string can process the obtained string with any\napplicable rule available in it and sends back the resultant string only to the\ncenter component. With this restriction, we obtain computational completeness\nfor some descriptional complexity measures\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02755v1"
    },
    {
        "title": "Comparative Transition System Semantics for Cause-Respecting Reversible\n  Prime Event Structures",
        "authors": [
            "Nataliya Gribovskaya",
            "Irina Virbitskaite"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Reversible computing is a new paradigm that has emerged recently and extends\nthe traditional forwards-only computing mode with the ability to execute in\nbackwards, so that computation can run in reverse as easily as in forward. Two\napproaches to developing transition system (automaton-like) semantics for event\nstructure models are distinguished in the literature. In the first case, states\nare considered as configurations (sets of already executed events), and\ntransitions between states are built by starting from the initial configuration\nand repeatedly adding executable events. In the second approach, states are\nunderstood as residuals (model fragments that have not yet been executed), and\ntransitions are constructed by starting from the given event structure as the\ninitial state and deleting already executed (and conflicting) parts thereof\nduring execution. The present paper focuses on an investigation of how the two\napproaches are interrelated for the model of prime event structures extended\nwith cause-respecting reversibility. The bisimilarity of the resulting\ntransition systems is proved, taking into account step semantics of the model\nunder consideration.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02756v1"
    },
    {
        "title": "On Minimal Pumping Constants for Regular Languages",
        "authors": [
            "Markus Holzer",
            "Christian Rauch"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The study of the operational complexity of minimal pumping constants started\nin [J. DASSOW and I. JECKER. Operational complexity and pumping lemmas. Acta\nInform., 59:337-355, 2022], where an almost complete picture of the operational\ncomplexity of minimal pumping constants for two different variants of pumping\nlemmata from the literature was given. We continue this research by considering\na pumping lemma for regular languages that allows pumping of sub-words at any\nposition of the considered word, if the sub-word is long enough [S. J. SAVITCH.\nAbstract Machines and Grammars. 1982]. First we improve on the simultaneous\nregulation of minimal pumping constants induced by different pumping lemmata\nincluding Savitch's pumping lemma. In this way we are able to simultaneously\nregulate four different minimal pumping constants. This is a novel result in\nthe field of descriptional complexity. Moreover, for Savitch's pumping lemma we\nare able to completely classify the range of the minimal pumping constant for\nthe operations Kleene star, reversal, complement, prefix- and suffix-closure,\nunion, set-subtraction, concatenation, intersection, and symmetric difference.\nIn this way, we also solve some of the open problems from the paper that\ninitiated the study of the operational complexity of minimal pumping constants\nmentioned above.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02757v1"
    },
    {
        "title": "Pumping Lemmata for Recognizable Weighted Languages over Artinian\n  Semirings",
        "authors": [
            "Andreas Maletti",
            "Nils Oskar Nuernbergk"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Pumping lemmata are the main tool to prove that a certain language does not\nbelong to a class of languages like the recognizable languages or the\ncontext-free languages. Essentially two pumping lemmata exist for the\nrecognizable weighted languages: the classical one for the Boolean semiring\n(i.e., the unweighted case), which can be generalized to zero-sum free\nsemirings, and the one for fields. A joint generalization of these two pumping\nlemmata is provided that applies to all Artinian semirings, over which all\nfinitely generated semimodules have a finite bound on the length of chains of\nstrictly increasing subsemimodules. Since Artinian rings are exactly those that\nsatisfy the Descending Chain Condition, the Artinian semirings include all\nfields and naturally also all finite semirings (like the Boolean semiring). The\nnew pumping lemma thus covers most previously known pumping lemmata for\nrecognizable weighted languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02758v1"
    },
    {
        "title": "State-deterministic Finite Automata with Translucent Letters and Finite\n  Automata with Nondeterministically Translucent Letters",
        "authors": [
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Deterministic and nondeterministic finite automata with translucent letters\nwere introduced by Nagy and Otto more than a decade ago as Cooperative\nDistributed systems of a kind of stateless restarting automata with window size\none. These finite state machines have a surprisingly large expressive power:\nall commutative semi-linear languages and all rational trace languages can be\naccepted by them including various not context-free languages. While the\nnondeterministic variant defines a language class with nice closure properties,\nthe deterministic variant is weaker, however it contains all regular languages,\nsome non-regular context-free languages, as the Dyck language, and also some\nlanguages that are not even context-free. In all those models for each state,\nthe letters of the alphabet could be in one of the following categories: the\nautomaton cannot see the letter (it is translucent), there is a transition\ndefined on the letter (maybe more than one transitions in nondeterministic\ncase) or none of the above categories (the automaton gets stuck by seeing this\nletter at the given state and this computation is not accepting).\n  State-deterministic automata are recent models, where the next state of the\ncomputation determined by the structure of the automata and it is independent\nof the processed letters. In this paper our aim is twofold, on the one hand, we\ninvestigate state-deterministic finite automata with translucent letters. These\nautomata are specially restricted deterministic finite automata with\ntranslucent letters.\n  In the other novel model we present, it is allowed that for a state the set\nof translucent letters and the set of letters for which transition is defined\nare not disjoint. One can interpret this fact that the automaton has a\nnondeterministic choice for each occurrence of such letters to see them (and\nthen erase and make the transition) or not to see that occurrence at that time.\nBased on these semi-translucent letters, the expressive power of the automata\nincreases, i.e., in this way a proper generalization of the previous models is\nobtained.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02759v1"
    },
    {
        "title": "Solving the Weighted HOM-Problem With the Help of Unambiguity",
        "authors": [
            "Andreea-Teodora Nász"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The HOM-problem, which asks whether the image of a regular tree language\nunder a tree homomorphism is again regular, is known to be decidable by [Godoy,\nGim\\'enez, Ramos, \\`Alvarez: The HOM problem is decidable. STOC (2010)].\nResearch on the weighted version of this problem, however, is still in its\ninfancy since it requires customized investigations. In this paper we address\nthe weighted HOM-problem and strive to keep the underlying semiring as general\nas possible. In return, we restrict the input: We require the tree homomorphism\nh to be tetris-free, a condition weaker than injectivity, and for the given\nweighted tree automaton, we propose an ambiguity notion with respect to h.\nThese assumptions suffice to ensure decidability of the thus restricted\nHOM-problem for all zero-sum free semirings by allowing us to reduce it to the\n(decidable) unweighted case.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02761v1"
    },
    {
        "title": "Once-Marking and Always-Marking 1-Limited Automata",
        "authors": [
            "Giovanni Pighizzini",
            "Luca Prigioniero"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Single-tape nondeterministic Turing machines that are allowed to replace the\nsymbol in each tape cell only when it is scanned for the first time are also\nknown as 1-limited automata. These devices characterize, exactly as finite\nautomata, the class of regular languages. However, they can be extremely more\nsuccinct. Indeed, in the worst case the size gap from 1-limited automata to\none-way deterministic finite automata is double exponential.\n  Here we introduce two restricted versions of 1-limited automata, once-marking\n1-limited automata and always-marking 1-limited automata, and study their\ndescriptional complexity. We prove that once-marking 1-limited automata still\nexhibit a double exponential size gap to one-way deterministic finite automata.\nHowever, their deterministic restriction is polynomially related in size to\ntwo-way deterministic finite automata, in contrast to deterministic 1-limited\nautomata, whose equivalent two-way deterministic finite automata in the worst\ncase are exponentially larger. For always-marking 1-limited automata, we prove\nthat the size gap to one-way deterministic finite automata is only a single\nexponential. The gap remains exponential even in the case the given machine is\ndeterministic.\n  We obtain other size relationships between different variants of these\nmachines and finite automata and we present some problems that deserve\ninvestigation.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02763v1"
    },
    {
        "title": "Separating Words from Every Start State with Horner Automata",
        "authors": [
            "Nicholas Tran"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We show that a well-known family of deterministic finite automata can be used\nto distinguish distinct binary strings of the same length from every start\nstate. Further, we establish almost matching lower and upper bounds on the\nnumber of states of such automata necessary to achieve this type of separation.\nOur result improves the currently best known linear upper bound for arbitrary\nDFA.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.02766v1"
    },
    {
        "title": "Cyclic Operator Precedence Grammars for Parallel Parsing",
        "authors": [
            "Michele Chiari",
            "Dino Mandrioli",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Operator precedence languages (OPL) enjoy the local parsability property,\nwhich essentially means that a code fragment enclosed within a pair of markers\n-- playing the role of parentheses -- can be compiled with no knowledge of its\nexternal context. Such a property has been exploited to build parallel\ncompilers for languages formalized as OPLs. It has been observed, however, that\nwhen the syntax trees of the sentences have a linear substructure, its parsing\nmust necessarily proceed sequentially making it impossible to split such a\nsubtree into chunks to be processed in parallel. Such an inconvenience is due\nto the fact that so far much literature on OPLs has assumed the hypothesis that\nequality precedence relation cannot be cyclic. This hypothesis was motivated by\nthe need to keep the mathematical notation as simple as possible.\n  We present an enriched version of operator precedence grammars, called\ncyclic, that allows to use a simplified version of regular expressions in the\nright hand sides of grammar's rules; for this class of operator precedence\ngrammars the acyclicity hypothesis of the equality precedence relation is no\nmore needed to guarantee the algebraic properties of the generated languages.\nThe expressive power of the cyclic grammars is now fully equivalent to that of\nother formalisms defining OPLs such as operator precedence automata, monadic\nsecond order logic and operator precedence expressions. As a result cyclic\noperator precedence grammars now produce also unranked syntax trees and\nsentences with flat unbounded substructures that can be naturally partitioned\ninto chunks suitable for parallel parsing.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.04200v1"
    },
    {
        "title": "Petri Net Classes for Collaboration Mining: Assessment and Design\n  Guidelines",
        "authors": [
            "Janik-Vasily Benzin",
            "Stefanie Rinderle-Ma"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Collaboration mining develops discovery, conformance checking, and\nenhancement techniques for collaboration processes. The collaboration process\nmodel is key to represent the discovery result. As for process mining in\ngeneral, Petri Net classes are candidates for collaboration process models due\nto their analytical power. However, a standard model class to represent\ncollaboration processes is lacking due to the heterogeneity of collaboration\nand, thus, of collaboration mining techniques. Collaboration heterogeneity\nrequires to cover, for example, intra-organizational collaborations as well as\nchoreographies that span a process across multiple organizations. A standard\ncollaboration model class would advance collaboration mining by focusing\ndiscovery through a common target model, supporting comparison, and enabling\nflexible mining pipelines. To find a standard model class, we aim at capturing\ncollaboration heterogeneity in a meta model, assess Petri net classes as\ncandidates for collaboration process models through the meta model, and derive\ndesign guidelines for the collaboration discovery.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.06200v1"
    },
    {
        "title": "Symbolic Path-guided Test Cases for Models with Data and Time",
        "authors": [
            "Boutheina Bannour",
            "Arnault Lapitre",
            "Pascale Le Gall",
            "Thang Nguyen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper focuses on generating test cases from timed symbolic transition\nsystems. At the heart of the generation process are symbolic execution\ntechniques on data and time. Test cases look like finite symbolic trees with\nverdicts on their leaves and are based on a user-specified finite symbolic path\nplaying the role of a test purpose. Generated test cases handle data involved\nin time constraints and uninitialized parameters, leveraging the advantages of\nsymbolic execution techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.06840v1"
    },
    {
        "title": "Proceedings of the 13th International Workshop on Non-Classical Models\n  of Automata and Applications",
        "authors": [
            "Benedek Nagy",
            "Rudolf Freund"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The Thirteenth International Workshop on Non-Classical Models of Automata and\nApplications (NCMA 2023) was held in Famagusta, North Cyprus, on September 18\nand 19, 2023, organized by the Eastern Mediterranean University. The NCMA\nworkshop series was established in 2009 as an annual event for researchers\nworking on non-classical and classical models of automata, grammars or related\ndevices. Such models are investigated both as theoretical models and as formal\nmodels for applications from various points of view.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.07333v1"
    },
    {
        "title": "Reset thresholds of transformation monoids",
        "authors": [
            "Igor Rystsov",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Motivated by the \\v{C}ern\\'y conjecture for automata, we introduce the\nconcept of monoidal automata, which allows the formulation of the \\v{C}ern\\'y\nconjecture for monoids. We show upper bounds on the reset threshold of monoids\nwith certain properties. In particular, we obtain a quadratic upper bound if\nthe transformation monoid contains a primitive group of permutations and a\nsingular of maximal rank with only one point of contraction.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08321v1"
    },
    {
        "title": "Formalizing BPE Tokenization",
        "authors": [
            "Martin Berglund",
            "Brink van der Merwe"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we formalize practical byte pair encoding tokenization as it\nis used in large language models and other NLP systems, in particular we\nformally define and investigate the semantics of the SentencePiece and\nHuggingFace tokenizers, in particular how they relate to each other, depending\non how the tokenization rules are constructed. Beyond this we consider how\ntokenization can be performed in an incremental fashion, as well as doing it\nleft-to-right using an amount of memory constant in the length of the string,\nenabling e.g. using a finite state string-to-string transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08715v1"
    },
    {
        "title": "Deterministic Real-Time Tree-Walking-Storage Automata",
        "authors": [
            "Martin Kutrib",
            "Uwe Meyer"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study deterministic tree-walking-storage automata, which are finite-state\ndevices equipped with a tree-like storage. These automata are generalized stack\nautomata, where the linear stack storage is replaced by a non-linear tree-like\nstack. Therefore, tree-walking-storage automata have the ability to explore the\ninterior of the tree storage without altering the contents, with the possible\nmoves of the tree pointer corresponding to those of tree-walking automata. In\naddition, a tree-walking-storage automaton can append (push) non-existent\ndescendants to a tree node and remove (pop) leaves from the tree. Here we are\nparticularly considering the capacities of deterministic tree-walking-storage\nautomata working in real time. It is shown that even the non-erasing variant\ncan accept rather complicated unary languages as, for example, the language of\nwords whose lengths are powers of two, or the language of words whose lengths\nare Fibonacci numbers. Comparing the computational capacities with automata\nfrom the classical automata hierarchy, we derive that the families of languages\naccepted by real-time deterministic (non-erasing) tree-walking-storage automata\nis located between the regular and the deterministic context-sensitive\nlanguages. There is a context-free language that is not accepted by any\nreal-time deterministic tree-walking-storage automaton. On the other hand,\nthese devices accept a unary language in non-erasing mode that cannot be\naccepted by any classical stack automaton, even in erasing mode and arbitrary\ntime. Basic closure properties of the induced families of languages are shown.\nIn particular, we consider Boolean operations (complementation, union,\nintersection) and AFL operations (union, intersection with regular languages,\nhomomorphism, inverse homomorphism, concatenation, iteration). It turns out\nthat the two families in question have the same properties and, in particular,\nshare all but one of these closure properties with the important family of\ndeterministic context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08716v1"
    },
    {
        "title": "Ordered Context-Free Grammars Revisited",
        "authors": [
            "Brink van der Merwe"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We continue our study of ordered context-free grammars, a grammar formalism\nthat places an order on the parse trees produced by the corresponding\ncontext-free grammar. In particular, we simplify our previous definition of a\nderivation of a string for a given ordered context-free grammar, and present a\nparsing algorithm, using shared packed parse forests, with time complexity\nO(n^4), where n is the length of the input string being parsed.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08717v1"
    },
    {
        "title": "On Languages Generated by Signed Grammars",
        "authors": [
            "Ömer Eğecioğlu",
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider languages defined by signed grammars which are similar to\ncontext-free grammars except productions with signs associated to them are\nallowed. As a consequence, the words generated also have signs. We use the\nstructure of the formal series of yields of all derivation trees over such a\ngrammar as a method of specifying a formal language and study properties of the\nresulting family of languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08718v1"
    },
    {
        "title": "Final Sentential Forms",
        "authors": [
            "Tomáš Kožár",
            "Zbyněk Křivka",
            "Alexander Meduna"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Let G be a context-free grammar with a total alphabet V, and let F be a final\nlanguage over an alphabet W such that W is a subset of V. A final sentential\nform is any sentential form of G that, after omitting symbols from V - W, it\nbelongs to F. The string resulting from the elimination of all nonterminals\nfrom W in a final sentential form is in the language of G finalized by F if and\nonly if it contains only terminals.\n  The language of any context-free grammar finalized by a regular language is\ncontext-free. On the other hand, it is demonstrated that L is a recursively\nenumerable language if and only if there exists a propagating context-free\ngrammar G such that L equals the language of G finalized by {w#w^R | w is a\nstring over a binary alphabet}, where w^R is the reversal of w.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08719v1"
    },
    {
        "title": "Latvian Quantum Finite State Automata for Unary Languages",
        "authors": [
            "Carlo Mereghetti",
            "Beatrice Palano",
            "Priscilla Raucci"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We design Latvian quantum finite state automata (LQFAs for short) recognizing\nunary regular languages with isolated cut point 1/2. From an architectural\npoint of view, we combine two LQFAs recognizing with isolated cut point,\nrespectively, the finite part and the ultimately periodic part of any given\nunary regular language L. In both modules, we use a component addressed in the\nliterature and here suitably adapted to the unary case, to discriminate strings\non the basis of their length. The number of basis states and the isolation\naround the cut point of the resulting LQFA for L exponentially depends on the\nsize of the minimal deterministic finite state automaton for L.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08720v1"
    },
    {
        "title": "Constituency Parsing as an Instance of the M-monoid Parsing Problem",
        "authors": [
            "Richard Mörbitz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider the constituent parsing problem which states: given a final state\nnormalized constituent tree automaton (CTA) and a string, compute the set of\nall constituent trees that are inductively recognized by the CTA and yield the\nstring. We show that this problem is an instance of the M-monoid parsing\nproblem. Moreover, we show that we can employ the generic M-monoid parsing\nalgorithm to solve the constituency parsing problem for a meaningful class of\nCTA.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08722v1"
    },
    {
        "title": "Sweeping Permutation Automata",
        "authors": [
            "Maria Radionova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper introduces sweeping permutation automata, which move over an input\nstring in alternating left-to-right and right-to-left sweeps and have a\nbijective transition function. It is proved that these automata recognize the\nsame family of languages as the classical one-way permutation automata\n(Thierrin, \"Permutation automata\", Mathematical Systems Theory, 1968). An\nn-state two-way permutation automaton is transformed to a one-way permutation\nautomaton with F(n)=\\max_(k+l=n, m <= l) k (l \\choose m) (k - 1 \\choose l - m)\n(l - m)! states. This number of states is proved to be necessary in the worst\ncase, and its growth rate is estimated as F(n) = n^(n/2 - (1 + \\ln 2)/2 \\cdot\nn/(\\ln n) \\cdot (1 + o(1))).\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08723v1"
    },
    {
        "title": "Shuffling posets on trajectories (technical report)",
        "authors": [
            "Luc Edixhoven"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Choreographies describe possible sequences of interactions among a set of\nagents. We aim to join two lines of research on choreographies: the use of the\nshuffle on trajectories operator to design more expressive choreographic\nlanguages, and the use of models featuring partial orders, to compactly\nrepresent concurrency between agents. Specifically, in this paper, we explore\nthe application of the shuffle on trajectories operator to individual posets,\nand we give a characterisation of shuffles of posets which again yield an\nindividual poset.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.09189v1"
    },
    {
        "title": "Synchronous orders on the set of integers",
        "authors": [
            "Christian Choffrut"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A binary relation over a free monoid is synchronous if it can be recognized\nby a synchronous automaton that reads its two tapes simultaneously. We consider\nthe case where the free monoid is generated by a single element (which makes it\nisomorphic to the additive monoid of integers) and where the binary relation\nrecognized is a strict order. Our main results are: given such an automaton it\nis possible to determine whether or not is has infinite chains or antichains;\nwe characterize the orders that are linear; given two linear synchronous orders\nwe show how to determine whether or not they are equivalent.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.09566v2"
    },
    {
        "title": "Characterizing morphic sequences",
        "authors": [
            "Hans Zantema"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Morphic sequences form a natural class of infinite sequences, extending the\nwell-studied class of automatic sequences. Where automatic sequences are known\nto have several equivalent characterizations and the class of automatic\nsequences is known to have several closure properties, for the class of morphic\nsequences similar closure properties are known, but only limited equivalent\ncharacterizations. In this paper we extend the latter. We discuss a known\ncharacterization of morphic sequences based on automata and we give a\ncharacterization of morphic sequences by finiteness of a particular class of\nsubsequences. Moreover, we relate morphic sequences to rationality of infinite\nterms and describe them by infinitary rewriting.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.10562v1"
    },
    {
        "title": "The Lexicographically Least Binary Rich Word Achieving the Repetition\n  Threshold",
        "authors": [
            "James Currie",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We find the lexicographically least infinite binary rich word having critical\nexponent $2+\\sqrt{2}/2$\n",
        "pdf_link": "http://arxiv.org/pdf/2310.07010v1"
    },
    {
        "title": "Non-reducible Modal Transition Systems",
        "authors": [
            "Davide Basile"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Modal Transition Systems (MTS) are a well-known formalism that extend\nLabelled Transition Systems (LTS) with the possibility of specifying necessary\nand permitted behaviour. Modal refinement ($\\preceq_m$) of MTS represents a\nstep of the design process, namely the one in which some optional behaviour is\ndiscarded while other optional behaviour becomes necessary. Whenever two MTS\nare not in modal refinement relation, it could still be the case that the set\nof implementations of one MTS is included in the set of implementations of the\nother.\n  The challenge of devising an alternative notion of modal refinement that is\nboth sound and complete with respect to the set of implementations, without\ndisregarding valuable implementations, remains open. We introduce a subset of\nMTS called Non-reducible Modal Transition Systems (NMTS), together with a novel\nrefinement relation $\\preceq_n$ for NMTS. We illustrate through examples the\nadditional constraints imposed by NMTS. Furthermore, we discuss a property\nholding for NMTS whose implementations are non-deterministic.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.08412v4"
    },
    {
        "title": "Determinization of Integral Discounted-Sum Automata is Decidable",
        "authors": [
            "Shaull Almagor",
            "Neta Dafni"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Nondeterministic Discounted-Sum Automata (NDAs) are nondeterministic finite\nautomata equipped with a discounting factor $\\lambda>1$, and whose transitions\nare labelled by weights. The value of a run of an NDA is the discounted sum of\nthe edge weights, where the $i$-th weight is divided by $\\lambda^{i}$. NDAs are\na useful tool for modelling systems where the values of future events are less\ninfluential than immediate ones.\n  While several problems are undecidable or open for NDA, their deterministic\nfragment (DDA) admits more tractable algorithms. Therefore, determinization of\nNDAs (i.e., deciding if an NDA has a functionally-equivalent DDA) is desirable.\n  Previous works establish that when $\\lambda\\in \\mathbb{N}$, then every\ncomplete NDA, namely an NDA whose states are all accepting and its transition\nfunction is complete, is determinizable. This, however, no longer holds when\nthe completeness assumption is dropped.\n  We show that the problem of whether an NDA has an equivalent DDA is decidable\nwhen $\\lambda\\in \\mathbb{N}$.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.09115v1"
    },
    {
        "title": "Mata, a Fast and Simple Finite Automata Library (Technical Report)",
        "authors": [
            "David Chocholatý",
            "Tomáš Fiedor",
            "Vojtěch Havlena",
            "Lukáš Holík",
            "Martin Hruška",
            "Ondřej Lengál",
            "Juraj Síč"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Mata is a well-engineered automata library written in C++ that offers a\nunique combination of speed and simplicity. It is meant to serve in\napplications such as string constraint solving and reasoning about regular\nexpressions, and as a~reference implementation of automata algorithms. Besides\nbasic algorithms for (non)deterministic automata, it implements a fast\nsimulation reduction and antichain-based language inclusion checking. The\nsimplicity allows a straightforward access to the low-level structures, making\nit relatively easy to extend and modify. Besides the C++ API, the library also\nimplements a Python binding. The library comes with a large benchmark of\nautomata problems collected from relevant applications such as string\nconstraint solving, regular model checking, and reasoning about regular\nexpressions. We show that Mata is on this benchmark significantly faster than\nall libraries from a wide range of automata libraries we collected. Its\nusefulness in string constraint solving is demonstrated by the string solver\nZ3-Noodler, which is based on Mata and outperforms the state of the art in\nstring constraint solving on many standard benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.10136v3"
    },
    {
        "title": "Reduced-Complexity Verification for K-Step and Infinite-Step Opacity in\n  Discrete Event Systems",
        "authors": [
            "Xiaoyan Li",
            "Christoforos N. Hadjicostis",
            "Zhiwu Li"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Opacity is a property that captures security concerns in cyber-physical\nsystems and its verification plays a significant role. This paper investigates\nthe verifications of K-step and infinite-step weak and strong opacity for\npartially observed nondeterministic finite state automata. K-step weak opacity\nis checked by constructing, for some states in the observer, appropriate\nstate-trees, to propose a necessary and sufficient condition. Based on the\nrelation between K-step weak and infinite-step weak opacity, a condition that\ndetermines when a system is not infinite-step weak opaque is presented.\nRegarding K-step and infinite-step strong opacity, we develop a secret-involved\nprojected automaton, based on which we construct secret-unvisited state trees\nto derive a necessary and sufficient condition for K-step strong opacity.\nFurthermore, an algorithm is reported to compute a verifier that can be used to\nobtain a necessary and sufficient condition for infinite-step strong opacity.\nIt is argued that, in some particular cases, the proposed methods achieve\nreduced complexity compared with the state of the art.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.11825v1"
    },
    {
        "title": "Enumerating regular languages in radix order : Revisiting the\n  Ackerman-Shallit algorithm",
        "authors": [
            "Nadime Francis",
            "Victor Marsault"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider the problem of enumerating a regular language $L$ in radix order,\nor more precisely, the equivalent problem of enumerating all words in $L$ of a\ngiven length in lexicographic order. Ackerman and Shallit gave in 2009 the\nprinciples of an efficient solution to this problem, but they did not use the\nenumeration complexity framework for their analysis. We adapt their work into\nan explicit algorithm that fits this framework.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.13309v1"
    },
    {
        "title": "Checking History-Determinism is NP-hard for Parity Automata",
        "authors": [
            "Aditya Prakash"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We show that the problem of checking if a given nondeterministic parity\nautomaton simulates another given nondeterministic parity automaton is NP-hard.\nWe then adapt the techniques used for this result to show that the problem of\nchecking history-determinism for a given parity automaton is NP-hard. This is\nan improvement from Kuperberg and Skrzypczak's previous lower bound of solving\nparity games from 2015. We also show that deciding if Eve wins the one-token\ngame or the two-token game of a given parity automaton is NP-hard. Finally, we\nshow that the problem of deciding if the language of a nondeterministic parity\nautomaton is contained in the language of a history-deterministic parity\nautomaton can be solved in quasi-polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.13498v2"
    },
    {
        "title": "Note on dissecting power of regular languages",
        "authors": [
            "Josef Rukavicka"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Let $c>1$ be a real constant. We say that a language $L$ is\n$c$-\\emph{constantly growing} if for every word $u\\in L$ there is a word $v\\in\nL$ with $\\vert u\\vert<\\vert v\\vert\\leq c+\\vert u\\vert$. We say that a language\n$L$ is $c$-\\emph{geometrically growing} if for every word $u\\in L$ there is a\nword $v\\in L$ with $\\vert u\\vert<\\vert v\\vert\\leq c\\vert u\\vert$. Given a\nlanguage $L$, we say that $L$ is $REG$-\\emph{dissectible} if there is a regular\nlanguage $R$ such that $\\vert L\\setminus R\\vert=\\infty$ and $\\vert L\\cap\nR\\vert=\\infty$. In 2013, it was shown that every $c$-constantly growing\nlanguage $L$ is $REG$-dissectible. In 2023, the following open question has\nbeen presented: \"Is the family of geometrically growing languages\n$REG$-dissectible?\" We construct a $c$-geometrically growing language $L$ that\nis not $REG$-dissectible. Hence we answer negatively to the open question.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.14114v1"
    },
    {
        "title": "A Robust Measure on FDFAs Following Duo-Normalized Acceptance",
        "authors": [
            "Dana Fisman",
            "Emmanuel Goldberg",
            "Oded Zimerman"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Families of DFAs (FDFAs) are a computational model recognizing\n$\\omega$-regular languages. They were introduced in the quest of finding a\nMyhill-Nerode theorem for $\\omega$-regular languages, and obtaining learning\nalgorithms. FDFAs have been shown to have good qualities in terms of the\nresources required for computing Boolean operations on them (complementation,\nunion, and intersection) and answering decision problems (emptiness and\nequivalence); all can be done in non-deterministic logspace. In this paper we\nstudy FDFAs with a new type of acceptance condition, duo-normalization, that\ngeneralizes the traditional normalization acceptance type. We show that\nduo-normalized FDFAs are advantageous to normalized FDFAs in terms of\nsuccinctness as they can be exponentially smaller. Fortunately this added\nsuccinctness doesn't come at the cost of increasing the complexity of Boolean\noperations and decision problems -- they can still be preformed in\nnon-deterministic logspace.\n  An important measure of the complexity of an $\\omega$-regular language, is\nits position in the Wagner hierarchy. It is based on the inclusion measure of\nMuller automata and for the common $\\omega$-automata there exist algorithms\ncomputing their position. We develop a similarly robust measure for\nduo-normalized (and normalized) FDFAs, which we term the diameter measure. We\nshow that the diameter measure corresponds one-to-one to the position on the\nWagner hierarchy. We show that computing it for duo-normalized FDFAs is\nPSPACE-complete, while it can be done in non-deterministic logspace for\ntraditional FDFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.16022v2"
    },
    {
        "title": "Normal Forms for Elements of ${}^*$-Continuous Kleene Algebras\n  Representing the Context-Free Languages",
        "authors": [
            "Mark Hopkins",
            "Hans Leiß"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Within the tensor product $K \\mathop{\\otimes_{\\cal R}} C_2'$ of any\n${}^*$-continuous Kleene algebra $K$ with the polycyclic ${}^*$-continuous\nKleene algebra $C_2'$ over two bracket pairs there is a copy of the fixed-point\nclosure of $K$: the centralizer of $C_2'$ in $K \\mathop{\\otimes_{\\cal R}}\nC_2'$. Using an automata-theoretic representation of elements of\n$K\\mathop{\\otimes_{\\cal R}} C_2'$ \\`a la Kleene, with the aid of normal form\ntheorems that restrict the occurrences of brackets on paths through the\nautomata, we develop a foundation for a calculus of context-free expressions\nwithout variable binders. We also give some results on the bra-ket\n${}^*$-continuous Kleene algebra $C_2$, motivate the ``completeness equation''\nthat distinguishes $C_2$ from $C_2'$, and show that $C_2'$ already validates a\nrelativized form of this equation.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.17295v2"
    },
    {
        "title": "Don's conjecture for binary completely reachable automata: an approach\n  and its limitations",
        "authors": [
            "David Casas",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A deterministic finite automaton in which every non-empty set of states\noccurs as the image of the whole state set under the action of a suitable input\nword is called completely reachable. It was conjectured that in each completely\nreachable automaton with $n$ states, every set of $k>0$ states is the image of\na word of length at most $n(n-k)$. We confirm the conjecture for completely\nreachable automata with two input letters satisfying certain restrictions on\nthe action of the letters.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.00077v2"
    },
    {
        "title": "Expressive Power of Hypergraph Lambek Grammars",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Hypergraph Lambek grammars (HL-grammars) is a novel logical approach to\ngenerating graph languages based on the hypergraph Lambek calculus. In this\npaper, we establish a precise relation between HL-grammars and hypergraph\ngrammars based on the double pushout (DPO) approach: we prove that HL-grammars\ngenerate the same class of languages as DPO grammars with the linear\nrestriction on lengths of derivations. This can be viewed as a complete\ndescription of the expressive power of HL-grammars and also as an analogue of\nthe Pentus theorem, which states that Lambek grammars generate the same class\nof languages as context-free grammars. As a corollary, we prove that\nHL-grammars subsume contextual hyperedge replacement grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.02416v2"
    },
    {
        "title": "Set Augmented Finite Automata over Infinite Alphabets",
        "authors": [
            "Ansuman Banerjee",
            "Kingshuk Chatterjee",
            "Shibashis Guha"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A data language is a set of finite words defined on an infinite alphabet.\nData languages are used to express properties associated with data values\n(domain defined over a countably infinite set). In this paper, we introduce set\naugmented finite automata (SAFA), a new class of automata for expressing data\nlanguages. We investigate the decision problems, closure properties, and\nexpressiveness of SAFA. We also study the deterministic variant of these\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.06514v1"
    },
    {
        "title": "The Weighted HOM-Problem over Fields",
        "authors": [
            "Andreea-Teodora Nász"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The HOM-problem, which asks whether the image of a regular tree language\nunder a tree homomorphism is again regular, is known to be decidable. Since\nthen, weighted versions of this problem for different semirings have also been\ninvestigated. In this paper, we prove the weighted HOM-problem for all fields\ndecidable, provided that the tree homomorphism is tetris-free (a condition that\ngeneralizes injectivity). To this end, we reduce the problem to a property of\nthe device representing the homomorphic image in question; to prove this\nproperty decidable, we then derive a pumping lemma for such devices from the\nwell-known pumping lemma for regular tree series over fields, proved by Berstel\nand Reutenauer in 1982.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.11067v1"
    },
    {
        "title": "Simulation Limitations of Affine Cellular Automata",
        "authors": [
            "Barbora Hudcová",
            "Jakub Krásenský"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Cellular automata are a famous model of computation, yet it is still a\nchallenging task to assess the computational capacity of a given automaton;\nespecially when it comes to showing negative results. In this paper, we focus\non studying this problem via the notion of CA relative simulation. We say that\nautomaton A is simulated by B if each space-time diagram of A can be, after\nsuitable transformations, reproduced by B.\n  We study affine automata - i.e., automata whose local rules are affine\nmappings of vector spaces. This broad class contains the well-studied cases of\nadditive automata. The main result of this paper shows that (almost) every\nautomaton affine over a finite field F_p can only simulate affine automata over\nF_p. We discuss how this general result implies, and widely surpasses,\nlimitations of additive automata previously proved in the literature.\n  We provide a formalization of the simulation notions into algebraic language\nand discuss how this opens a new path to showing negative results about the\ncomputational power of cellular automata using deeper algebraic theorems.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.14477v2"
    },
    {
        "title": "On universality of regular realizability problems",
        "authors": [
            "Alexander Rubtsov",
            "Michael Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove the universality of the regular realizability problems for several\nclasses of filters. The filters are encodings of finite relations on the set of\nnon-negative integers in the format proposed by P. Wolf and H. Fernau. The\nuniversality has proven up to disjunctive truth table polynomial reductions for\nunary relations and polynomial space reductions for invariant binary relations.\nStronger reductions correspond to the results of P. Wolf and H. Fernau about\ndecidability of regular realizability problems for many graph-theoretic\nproperties.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.15381v3"
    },
    {
        "title": "On the piecewise complexity of words and periodic words",
        "authors": [
            "M. Praveen",
            "Philippe Schnoebelen",
            "Isa Vialard",
            "Julien Veron"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The piecewise complexity $h(u)$ of a word is the minimal length of subwords\nneeded to exactly characterise $u$. Its piecewise minimality index $\\rho(u)$ is\nthe smallest length $k$ such that $u$ is minimal among its order-$k$ class\n$[u]_k$ in Simon's congruence.\n  We study these two measures and provide efficient algorithms for computing\n$h(u)$ and $\\rho(u)$. We also provide efficient algorithms for the case where\n$u$ is a periodic word, of the form $u=v^n$\n",
        "pdf_link": "http://arxiv.org/pdf/2311.15431v1"
    },
    {
        "title": "Semantics of Attack-Defense Trees for Dynamic Countermeasures and a New\n  Hierarchy of Star-free Languages",
        "authors": [
            "Thomas Brihaye",
            "Sophie Pinchinat",
            "Alexandre Terefenko"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present a mathematical setting for attack-defense trees, a classic\ngraphical model to specify attacks and countermeasures. We equip attack-defense\ntrees with (trace) language semantics allowing to have an original dynamic\ninterpretation of countermeasures. Interestingly, the expressiveness of\nattack-defense trees coincides with star-free languages, and the nested\ncountermeasures impact the expressiveness of attack-defense trees. With an\nadequate notion of countermeasure-depth, we exhibit a strict hierarchy of the\nstar-free languages that does not coincides with the classic one. Additionally,\ndriven by the use of attack-defense trees in practice, we address the decision\nproblems of trace membership and of non-emptiness, and study their\ncomputational complexities parameterized by the countermeasure-depth.\n",
        "pdf_link": "http://arxiv.org/pdf/2312.00458v1"
    },
    {
        "title": "A Linear-time Simulation of Deterministic $d$-Limited Automata",
        "authors": [
            "Alexander Rubtsov"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A $d$-limited automaton is a Turing machine that uses only the cells with the\ninput word (and end-markers) and rewrites symbols only in the first $d$ visits.\nThis model was introduced by T. Hibbard in 1967 and he showed that $d$-limited\nautomata recognize context-free languages for each $d \\geq 2$. He also proved\nthat languages recognizable by deterministic $d$-limited automata form a\nhierarchy and it was shown later by Pighizzini and Pisoni that it begins with\ndeterministic context-free languages (DCFLs) (for $d=2$).\n  As well-known, DCFLs are widely used in practice, especially in compilers\nsince they are linear-time recognizable and have the corresponding CF-grammars\nsubclass (LR$(1)$-grammars). In this paper we present a linear time recognition\nalgorithm for deterministic $d$-limited automata (in the RAM model) which opens\nan opportunity for their possible practical applications. We also generalize\nthis algorithm to deterministic $d(n)$-limited automata: the extension of\ndeterministic $d$-limited automata, where $d$ is not a constant, but a function\ndepending on the input length $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/2312.01896v1"
    },
    {
        "title": "Finer characterization of bounded languages described by GF(2)-grammars",
        "authors": [
            "Vladislav Makarov",
            "Marat Movsin"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  GF(2)-grammars are a somewhat recently introduced grammar family that have\nsome unusual algebraic properties and are closely connected to unambiguous\ngrammars. In \"Bounded languages described by GF(2)-grammars\", Makarov proved a\nnecessary condition for subsets of $a_1^* a_2^* \\cdots a_k^*$ to be described\nby some GF(2)-grammar. By extending these methods further, we prove an even\nstronger upper bound for these languages. Moreover, we establish a lower bound\nthat closely matches the proven upper bound. Also, we prove the exact\ncharacterization for the special case of linear GF(2)-grammars. Finally, by\nusing the previous result, we show that the class of languages described by\nlinear GF(2)-grammars is not closed under GF(2)-concatenation\n",
        "pdf_link": "http://arxiv.org/pdf/2312.06609v1"
    },
    {
        "title": "3-anti-power uniform morphisms",
        "authors": [
            "Francis Wlazinski"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Words whose three successive factors of the same length are all different\ni.e. 3-anti-power words are a natural extension of square-free words (two\nsuccessive factors of the same length are different). We give a way to verify\nwhether a uniform morphism preserves 3-anti-power words (the image of a\n3-anti-power word is a 3-anti-power word). A consequence of the existence of\nsuch morphisms is the possibility of generating an infinite 3-anti-power word.\n",
        "pdf_link": "http://arxiv.org/pdf/2312.14514v1"
    },
    {
        "title": "Classifying Words with 3-sort Automata",
        "authors": [
            "Tomasz Jastrząb",
            "Frédéric Lardeux",
            "Eric Monfroy"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Grammatical inference consists in learning a language or a grammar from data.\nIn this paper, we consider a number of models for inferring a non-deterministic\nfinite automaton (NFA) with 3 sorts of states, that must accept some words, and\nreject some other words from a given sample. We then propose a transformation\nfrom this 3-sort NFA into weighted-frequency and probabilistic NFA, and we\napply the latter to a classification task. The experimental evaluation of our\napproach shows that the probabilistic NFAs can be successfully applied for\nclassification tasks on both real-life and superficial benchmark data sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.01314v1"
    },
    {
        "title": "On the Boolean Closure of Deterministic Top-Down Tree Automata",
        "authors": [
            "Christof Löding",
            "Wolfgang Thomas"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The class of Boolean combinations of tree languages recognized by\ndeterministic top-down tree automata (also known as deterministic\nroot-to-frontier automata) is studied. The problem of determining for a given\nregular tree language whether it belongs to this class is open. We provide some\nprogress by two results: First, a characterization of this class by a natural\nextension of deterministic top-down tree automata is presented, and as an\napplication we obtain a convenient method to show that certain regular tree\nlanguages are outside this class. In the second result, it is shown that, for\nfixed $k$, it is decidable whether a regular tree language is a Boolean\ncombination of $k$ tree languages recognized by deterministic top-down tree\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.06596v1"
    },
    {
        "title": "Anti-Context-Free languages",
        "authors": [
            "Carles Cardó"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Context-free languages can be characterized in several ways. This article\nstudies projective linearisations of languages of simple dependency trees,\ni.e., dependency trees in which a node can govern at most one node with a given\nsyntactic function. We prove that the projective linearisations of local\nlanguages of simple dependency trees coincide with the context-free languages.\n  Simple dependency trees suggest alternative dual notions of locality and\nprojectivity, which permits defining a dual language for each context-free\nlanguage. We call this new class of languages anti-context-free. These\nlanguages are related to some linguistic constructions exhibiting the so-called\ncross-serial dependencies that were historically important for the development\nof computational linguistics. We propose that this duality could be a relevant\nlinguistic phenomenon.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.07815v1"
    },
    {
        "title": "Extended Stone Duality via Monoidal Adjunctions",
        "authors": [
            "Fabian Lenke",
            "Henning Urbat",
            "Stefan Milius"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Extensions of Stone-type dualities have a long history in algebraic logic and\nhave also been instrumental for proving results in algebraic language theory.\nWe show how to extend abstract categorical dualities via monoidal adjunctions,\nsubsuming various incarnations of classical extended Stone and Priestley\nduality as special cases. Guided by these categorical foundations, we\ninvestigate residuation algebras, which are algebraic models of language\nderivatives, and show the subcategory of derivation algebras to be dually\nequivalent to the category of profinite ordered monoids, restricting to a\nduality between boolean residuation algebras and profinite monoids. We further\nrefine this duality to capture relational morphisms of profinite ordered\nmonoids, which dualize to natural morphisms of residuation algebras. As a\nspecial case of the discrete version of the duality between monoids and\ncomplete residuation algebras, we obtain a novel concrete description for the\ndual of the category of all small categories and functors.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.08219v3"
    },
    {
        "title": "Verification and Enforcement of Strong State-Based Opacity for\n  Discrete-Event Systems",
        "authors": [
            "Xiaoguang Han",
            "Kuize Zhang",
            "Zhiwu Li"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we investigate the verification and enforcement of strong\nstate-based opacity (SBO) in discrete-event systems modeled as\npartially-observed (nondeterministic) finite-state automata, including strong\nK-step opacity (K-SSO), strong current-state opacity (SCSO), strong\ninitial-state opacity (SISO), and strong infinite-step opacity (Inf-SSO). They\nare stronger versions of four widely-studied standard opacity notions,\nrespectively. We firstly propose a new notion of K-SSO, and then we construct a\nconcurrent-composition structure that is a variant of our previously-proposed\none to verify it. Based on this structure, a verification algorithm for the\nproposed notion of K-SSO is designed. Also, an upper bound on K in the proposed\nK-SSO is derived. Secondly, we propose a distinctive opacity-enforcement\nmechanism that has better scalability than the existing ones (such as\nsupervisory control). The basic philosophy of this new mechanism is choosing a\nsubset of controllable transitions to disable before an original system starts\nto run in order to cut off all its runs that violate a notion of strong SBO of\ninterest. Accordingly, the algorithms for enforcing the above-mentioned four\nnotions of strong SBO are designed using the proposed two\nconcurrent-composition structures. In particular, the designed algorithm for\nenforcing Inf-SSO has lower time complexity than the existing one in the\nliterature, and does not depend on any assumption. Finally, we illustrate the\napplications of the designed algorithms using examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.10363v1"
    },
    {
        "title": "On-The-Fly Algorithm for Reachability in Parametric Timed Games\n  (Extended Version)",
        "authors": [
            "Mikael Bisgaard Dahlsen-Jensen",
            "Baptiste Fievet",
            "Laure Petrucci",
            "Jaco van de Pol"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Parametric Timed Games (PTG) are an extension of the model of Timed Automata.\nThey allow for the verification and synthesis of real-time systems, reactive to\ntheir environmeand depending on adjustable parameters. Given a PTG and a\nreachability objective, we synthesize the values of the parameters such that\nthe game is winning for the controller. We adapt and implement the On-The-Fly\nalgorithm for parameter synthesis for PTG. Several pruning heuristics are\nintroduced, to improve termination and speed of the algorithm. We evaluate the\nfeasibility of parameter synthesis for PTG on two large case studies. Finally,\nwe investigate the correctness guarantee of the algorithm: though the problem\nis undecidable, our semi-algorithm produces all correct parameter valuations\n``in the limit''.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.11287v1"
    },
    {
        "title": "Constrained Multi-Tildes: Derived Term and Position Automata",
        "authors": [
            "Samira Attou",
            "Ludovic Mignot",
            "Clément Miklarz",
            "Florent Nicart"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Multi-tildes are regular operators that were introduced to enhance the\nfactorization power of regular expressions, allowing us to add the empty word\nin several factors of a catenation product of languages. In addition to\nmulti-bars, which dually remove the empty word, they allow representing any\nacyclic automaton by a linear-sized expression, whereas the lower bound is\nexponential in the classic case.\n  In this paper, we extend multi-tildes from disjunctive combinations to any\nBoolean combination, allowing us to exponentially enhance the factorization\npower of tildes expressions. Moreover, we show how to convert these expressions\ninto finite automata and give a Haskell implementation of them using advanced\ntechniques of functional programming.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.12111v1"
    },
    {
        "title": "Scalable Tree-based Register Automata Learning",
        "authors": [
            "Simon Dierl",
            "Paul Fiterau-Brostean",
            "Falk Howar",
            "Bengt Jonsson",
            "Konstantinos Sagonas",
            "Fredrik Tåquist"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Existing active automata learning (AAL) algorithms have demonstrated their\npotential in capturing the behavior of complex systems (e.g., in analyzing\nnetwork protocol implementations). The most widely used AAL algorithms generate\nfinite state machine models, such as Mealy machines. For many analysis tasks,\nhowever, it is crucial to generate richer classes of models that also show how\nrelations between data parameters affect system behavior. Such models have\nshown potential to uncover critical bugs, but their learning algorithms do not\nscale beyond small and well curated experiments. In this paper, we present\n$SL^\\lambda$, an effective and scalable register automata (RA) learning\nalgorithm that significantly reduces the number of tests required for inferring\nmodels. It achieves this by combining a tree-based cost-efficient data\nstructure with mechanisms for computing short and restricted tests. We have\nimplemented $SL^\\lambda$ as a new algorithm in RALib. We evaluate its\nperformance by comparing it against $SL^*$, the current state-of-the-art RA\nlearning algorithm, in a series of experiments, and show superior performance\nand substantial asymptotic improvements in bigger systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.14324v1"
    },
    {
        "title": "Bonding Grammars",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce bonding grammars, a graph grammar formalism developed to model\nDNA computation by means of graph transformations. It is a modification of\nfusion grammars introduced by Kreowski, Kuske and Lye in 2017. Bonding is a\ngraph transformation that consists of merging two hyperedges into a single\nlarger one. We show why bonding models interaction between DNA molecules better\nthan fusion. Then, we investigate formal properties of this formalism. Firstly,\nwe study the relation between bonding grammars and hyperedge replacement\ngrammars proving that each of these kinds of grammars generates a language the\nother one cannot generate. Secondly, we prove that bonding grammars naturally\ngeneralise regular sticker systems. Finally, we prove that the membership\nproblem for bonding grammars is NP-complete and, moreover, that some bonding\ngrammar generates an NP-complete set.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.14377v2"
    },
    {
        "title": "Deterministic Parikh automata on infinite words",
        "authors": [
            "Mario Grobler",
            "Sebastian Siebertz"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Various variants of Parikh automata on infinite words have recently been\nintroduced in the literature. However, with some exceptions only their\nnon-deterministic versions have been considered. In this paper we study the\ndeterministic versions of all variants of Parikh automata on infinite words\nthat have not yet been studied. We compare the expressiveness of the\ndeterministic models and investigate their closure properties and decision\nproblems with applications to model checking. The model of deterministic limit\nParikh automata turns out to be most interesting, as it is the only\ndeterministic Parikh model generalizing the $\\omega$-regular languages, the\nonly deterministic Parikh model closed under the Boolean operations and the\nonly deterministic Parikh model for which all common decision problems are\ndecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.14737v2"
    },
    {
        "title": "On the Separability Problem of VASS Reachability Languages",
        "authors": [
            "Eren Keskin",
            "Roland Meyer"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We show that the regular separability problem of VASS reachability languages\nis decidable and $\\mathbf{F}_{\\omega}$-complete. At the heart of our decision\nprocedure are doubly-marked graph transition sequences, a new proof object that\ntracks a suitable product of the VASS we wish to separate. We give a\ndecomposition algorithm for DMGTS that not only achieves perfectness as known\nfrom MGTS, but also a new property called faithfulness. Faithfulness allows us\nto construct, from a regular separator for the $\\mathbb{Z}$-versions of the\nVASS, a regular separator for the $\\mathbb{N}$-versions. Behind faithfulness is\nthe insight that, for separability, it is sufficient to track the counters of\none VASS modulo a large number that is determined by the decomposition.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.16095v2"
    },
    {
        "title": "Dot-depth three, return of the J-class",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We look at concatenation hierarchies of classes of regular languages. Each\nsuch hierarchy is determined by a single class, its basis: level $n$ is built\nby applying the Boolean polynomial closure operator (BPol), $n$ times to the\nbasis. A prominent and difficult open question in automata theory is to decide\nmembership of a regular language in a given level. For instance, for the\nhistorical dot-depth hierarchy, the decidability of membership is only known at\nlevels one and two.\n  We give a generic algebraic characterization of the operator BPol. This\ncharacterization implies that for any concatenation hierarchy, if $n$ is at\nleast two, membership at level $n$ reduces to a more complex problem, called\ncovering, for the previous level, $n-1$. Combined with earlier results on\ncovering, this implies that membership is decidable for dot-depth three and for\nlevel two in most of the prominent hierarchies in the literature. For instance,\nwe obtain that the levels two in both the modulo hierarchy and the group\nhierarchy have decidable membership.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.16195v1"
    },
    {
        "title": "Collaboration Miner: Discovering Collaboration Petri Nets (Extended\n  Version)",
        "authors": [
            "Janik-Vasily Benzin",
            "Stefanie Rinderle-Ma"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Most existing process discovery techniques aim to mine models of process\norchestrations that represent behavior of cases within one business process.\nCollaboration process discovery techniques mine models of collaboration\nprocesses that represent behavior of collaborating cases within multiple\nprocess orchestrations that interact via collaboration concepts such as\norganizations, agents, and services. While workflow nets are mostly mined for\nprocess orchestrations, a standard model for collaboration processes is\nmissing. Hence, in this work, we rely on the newly proposed collaboration Petri\nnets and show that in combination with the newly proposed Collaboration Miner\n(CM), the resulting representational bias is lower than for existing models.\nMoreover, CM can discover heterogeneous collaboration concepts and types such\nas resource sharing and message exchange, resulting in fitting and precise\ncollaboration Petri nets. The evaluation shows that CM achieves its design\ngoals: no assumptions on concepts and types as well as fitting and precise\nmodels, based on 26 artificial and real-world event logs from literature.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.16263v4"
    },
    {
        "title": "Deciding Subtyping for Asynchronous Multiparty Sessions",
        "authors": [
            "Elaine Li",
            "Felix Stutz",
            "Thomas Wies"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Multiparty session types (MSTs) are a type-based approach to verifying\ncommunication protocols, represented as global types in the framework. We\npresent a precise subtyping relation for asynchronous MSTs with communicating\nstate machines (CSMs) as implementation model. We address two problems: when\ncan a local implementation safely substitute another, and when does an\narbitrary CSM implement a global type? We define safety with respect to a given\nglobal type, in terms of subprotocol fidelity and deadlock freedom. Our\nimplementation model subsumes existing work which considers local types with\nrestricted choice. We exploit the connection between MST subtyping and\nrefinement to formulate concise conditions that are directly checkable on the\ncandidate implementations, and use them to show that both problems are\ndecidable in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.16395v1"
    },
    {
        "title": "Backward Responsibility in Transition Systems Using General Power\n  Indices",
        "authors": [
            "Christel Baier",
            "Roxane van den Bossche",
            "Sascha Klüppelholz",
            "Johannes Lehmann",
            "Jakob Piribauer"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  To improve reliability and the understanding of AI systems, there is\nincreasing interest in the use of formal methods, e.g. model checking. Model\nchecking tools produce a counterexample when a model does not satisfy a\nproperty. Understanding these counterexamples is critical for efficient\ndebugging, as it allows the developer to focus on the parts of the program that\ncaused the issue.\n  To this end, we present a new technique that ascribes a responsibility value\nto each state in a transition system that does not satisfy a given safety\nproperty. The value is higher if the non-deterministic choices in a state have\nmore power to change the outcome, given the behaviour observed in the\ncounterexample. For this, we employ a concept from cooperative game theory --\nnamely general power indices, such as the Shapley value -- to compute the\nresponsibility of the states.\n  We present an optimistic and pessimistic version of responsibility that\ndiffer in how they treat the states that do not lie on the counterexample. We\ngive a characterisation of optimistic responsibility that leads to an efficient\nalgorithm for it and show computational hardness of the pessimistic version. We\nalso present a tool to compute responsibility and show how a stochastic\nalgorithm can be used to approximate responsibility in larger models. These\nmethods can be deployed in the design phase, at runtime and at inspection time\nto gain insights on causal relations within the behavior of AI systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.01539v1"
    },
    {
        "title": "Fully Generalized Reactivity(1) Synthesis",
        "authors": [
            "Rüdiger Ehlers",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Generalized Reactivity(1) (GR(1)) synthesis is a reactive synthesis approach\nin which the specification is split into two parts: a symbolic game graph,\ndescribing the safe transitions of a system, a liveness specification in a\nsubset of Linear Temporal Logic (LTL) on top of it. Many specifications can\nnaturally be written in this restricted form, and the restriction gives rise to\na scalable synthesis procedure -- the reasons for the high popularity of the\napproach. For specifications even slightly beyond GR(1), however, the approach\nis inapplicable. This necessitates a transition to synthesizers for full LTL\nspecifications, introducing a huge efficiency drop. This paper proposes a\nsynthesis approach that smoothly bridges the efficiency gap from GR(1) to LTL\nby unifying synthesis for both classes of specifications. The approach\nleverages a recently introduced canonical representation of omega-regular\nlanguages based on a chain of good-for-games co-B\\\"uchi automata (COCOA). By\nconstructing COCOA for the liveness part of a specification, we can then build\na fixpoint formula that can be efficiently evaluated on the symbolic game\ngraph. The COCOA-based synthesis approach outperforms standard approaches and\nretains the efficiency of GR(1) synthesis for specifications in GR(1) form and\nthose with few non-GR(1) specification parts.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.02979v1"
    },
    {
        "title": "Inform: From Compartmental Models to Stochastic Bounded Counter Machines",
        "authors": [
            "Tim Leys",
            "Guillermo A. Perez"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Compartmental models are used in epidemiology to capture the evolution of\ninfectious diseases such as COVID-19 in a population by assigning members of it\nto compartments with labels such as susceptible, infected, and recovered. In a\nstochastic compartmental model the flow of individuals between compartments is\ndetermined probabilistically. We establish that certain stochastic compartment\nmodels can be encoded as probabilistic counter machines where the\nconfigurations are bounded. Based on the latter, we obtain simple descriptions\nof the models in the PRISM language. This enables the analysis of such\ncompartmental models via probabilistic model checkers. Finally, we report on\nexperimental results where we analyze results from a Belgian COVID-19 model\nusing a probabilistic model checkers.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.09121v1"
    },
    {
        "title": "Flattability of Priority Vector Addition Systems",
        "authors": [
            "Roland Guttenberg"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Vector addition systems (VAS), also known as Petri nets, are a popular model\nof concurrent systems. Many problems from many areas reduce to the reachability\nproblem for VAS, which consists of deciding whether a target configuration of a\nVAS is reachable from a given initial configuration. One of the main approaches\nto solve the problem on practical instances is called flattening, intuitively\nremoving nested loops. This technique is known to terminate for semilinear VAS.\nIn this paper, we prove that also for VAS with nested zero tests, called\nPriority VAS, flattening does in fact terminate for all semilinear reachability\nrelations. Furthermore, we prove that Priority VAS admit semilinear inductive\ninvariants. Both of these results are obtained by defining a well-quasi-order\non runs of Priority VAS which has good pumping properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.09185v2"
    },
    {
        "title": "Temporal hierarchies of regular languages",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We classify the regular languages using an operator $\\mathcal{C}\\mapsto\nTL(\\mathcal{C})$. For each input class of languages $\\mathcal{C}$, it builds a\nlarger class $TL(\\mathcal{C})$ consisting of all languages definable in a\nvariant of unary temporal logic whose future/past modalities depend on\n$\\mathcal{C}$. This defines the temporal hierarchy of basis $\\mathcal{C}$:\nlevel $n$ is built by applying this operator $n$ times to $\\mathcal{C}$. This\nhierarchy is closely related to another one, the concatenation hierarchy of\nbasis $\\mathcal{C}$. In particular, the union of all levels in both hierarchies\nis the same.\n  We focus on bases $\\mathcal{G}$ of group languages and natural extensions\nthereof, denoted $\\mathcal{G}^+$. We prove that the temporal hierarchies of\nbases $\\mathcal{G}$ and $\\mathcal{G}^+$ are strictly intertwined, and we\ncompare them to the corresponding concatenation hierarchies. Furthermore, we\nlook at two standard problems on classes of languages: membership (decide if an\ninput language is in the class) and separation (decide, for two input regular\nlanguages $L_1,L_2$, if there is a language $K$ in the class with $L_1\n\\subseteq K$ and $L_2 \\cap K = \\emptyset$). We prove that if separation is\ndecidable for $\\mathcal{G}$, then so is membership for level two in the\ntemporal hierarchies of bases $\\mathcal{G}$ and $\\mathcal{G}^+$. Moreover, we\ntake a closer look at the case where $\\mathcal{G}$ is the trivial class\n$ST=\\{\\emptyset,A^*\\}$. The levels one in the hierarchies of bases $ST$ and\n$ST^+$ are the standard variants of unary temporal logic while the levels two\nwere considered recently using alternate definitions. We prove that for these\ntwo bases, level two has decidable separation. Combined with earlier results\nabout the operator $\\mathcal{G}\\mapsto TL(\\mathcal{G})$, this implies that the\nlevels three have decidable membership.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.10080v1"
    },
    {
        "title": "Kleene Theorems for Lasso Languages and $ω$-Languages",
        "authors": [
            "Mike Cruchten"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Automata operating on pairs of words were introduced as an alternative way of\ncapturing acceptance of regular $\\omega$-languages. Families of DFAs and lasso\nautomata operating on such pairs followed, giving rise to minimisation\nalgorithms, a Myhill-Nerode theorem and language learning algorithms. Yet\nKleene theorems for such a well-established class are still missing. We\nintroduce rational lasso languages and expressions, show a Kleene theorem for\nlasso languages and explore the connection between rational lasso and\n$\\omega$-expressions, which yields a Kleene theorem for $\\omega$-languages with\nrespect to saturated lasso automata. For one direction of the Kleene theorems,\nwe also provide a Brzozowski construction for lasso automata from rational\nlasso expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.13085v2"
    },
    {
        "title": "Regular Languages in the Sliding Window Model",
        "authors": [
            "Moses Ganardi",
            "Danny Hucke",
            "Markus Lohrey",
            "Konstantinos Mamouras",
            "Tatiana Starikovskaya"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the space complexity of the following problem: For a fixed regular\nlanguage $L$, test membership of a sliding window of length $n$ to $L$ over a\ngiven stream of symbols. For deterministic streaming algorithms we prove a\ntrichotomy theorem, namely that the (optimal) space complexity is either\nconstant, logarithmic or linear, measured in the window length $n$.\nAdditionally, we provide natural language-theoretic characterizations of the\nspace classes. We then extend the results to randomized streaming algorithms\nand we show that in this setting, the space complexity of any regular language\nis either constant, doubly logarithmic, logarithmic or linear. Finally, we\nintroduce sliding window testers, which can distinguish whether a window\nbelongs to the language $L$ or has Hamming distance $> \\epsilon n$ to $L$. We\nprove that every regular language has a deterministic (resp., randomized)\nsliding window tester that requires only logarithmic (resp., constant) space.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.13385v1"
    },
    {
        "title": "Around Don's conjecture for binary completely reachable automata",
        "authors": [
            "Yinfeng Zhu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A word $w$ is called a reaching word of a subset $S$ of states in a\ndeterministic finite automaton (DFA) if $S$ is the image of $Q$ under the\naction of $w$. A DFA is called completely reachable if every non-empty subset\nof the state set has a reaching word. A conjecture states that in every\n$n$-state completely reachable DFA, for every $k$-element subset of states,\nthere exists a reaching word of length at most $n(n-k)$. We present infinitely\nmany completely reachable DFAs with two letters that violate this conjecture. A\nsubfamily of completely reachable DFAs with two letters, is called standardized\nDFAs, introduced by Casas and Volkov (2023). We prove that every $k$-element\nsubset of states in an $n$-state standardized DFA has a reaching word of length\n$\\le n(n-k) + n - 1$. Finally, we confirm the conjecture for standardized DFAs\nwith additional properties, thus generalizing a result of Casas and Volkov\n(2023).\n",
        "pdf_link": "http://arxiv.org/pdf/2402.19089v1"
    },
    {
        "title": "Efficient Interaction-Based Offline Runtime Verification of Distributed\n  Systems with Lifeline Removal",
        "authors": [
            "Erwan Mahe",
            "Boutheina Bannour",
            "Christophe Gaston",
            "Pascale Le Gall"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Runtime Verification (RV) refers to a family of techniques in which system\nexecutions are observed and confronted to formal specifications, with the aim\nof identifying faults. In Offline RV, observation is done in a first step and\nverification in a second, on a static artifact collected during observation. In\nthis paper, we define an approach to offline RV of Distributed Systems (DS)\nagainst interactions. Interactions are formal models describing communications\nwithin a DS. DS are composed of subsystems deployed on different machines and\ninteracting via message passing. Therefore, observing executions of a DS\nentails logging a collection of local execution traces, one for each subsystem,\nthat we call a multi-trace. A major challenge in analyzing multi-traces is that\nthere are no practical means to synchronize the ends of observations of all\nlocal traces. We address this via an operation, called lifeline removal, which\nwe apply on-the-fly on the specification during verification once a local trace\nhas been entirely analyzed. This operation removes from the interaction the\nspecification of actions occurring on the subsystem that is no-longer observed.\nThis may allow further execution of the specification via removing deadlocks\ndue to the partial orders of actions. We prove the correctness of the resulting\nRV algorithm and introduce two optimization techniques which we also prove\ncorrect. We implement a Partial Order Reduction (POR) technique via the\nselection of a one-unambiguous action (as a unique first step to a\nlinearization) which existence is determined via another use of the lifeline\nremoval operator. Additionally, Local Analyses (LOC) i.e., the verification of\nlocal traces, can be leveraged during the global multi-trace analysis to prove\nfailure more quickly. Experiments illustrate the application of our RV approach\nand the benefits of our optimizations.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.03057v1"
    },
    {
        "title": "Characterizations of Controlled Generation of Right Linear Grammars with\n  Unknown Behaviors",
        "authors": [
            "Daihei Ise",
            "Satoshi Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper deals with the control generation of right linear grammars with\nunknown behaviors (RLUBs, for short) in which derivation behavior is not\ndetermined completely. In particular, we consider a physical property of\ncontrol devices used in control systems and formulate it as a partial order\nover control alphabet of the control system. We give necessary and sufficient\nconditions for given finite language classes to be generated by RLUBs and their\ncontrol systems using a given partial order over control alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.04301v1"
    },
    {
        "title": "Semidirect Product Decompositions for Periodic Regular Languages",
        "authors": [
            "Yusuke Inoue",
            "Kenji Hashimoto",
            "Hiroyuki Seki"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The definition of period in finite-state Markov chains can be extended to\nregular languages by considering the transitions of DFAs accepting them. For\nexample, the language $(\\Sigma\\Sigma)^*$ has period two because the length of a\nrecursion (cycle) in its DFA must be even. This paper shows that the period of\na regular language appears as a cyclic group within its syntactic monoid.\nSpecifically, we show that a regular language has period $P$ if and only if its\nsyntactic monoid is isomorphic to a submonoid of a semidirect product between a\nspecific finite monoid and the cyclic group of order $P$. Moreover, we explore\nthe relation between the structure of Markov chains and our result, and apply\nthis relation to the theory of probabilities of languages. We also discuss the\nKrohn-Rhodes decomposition of finite semigroups, which is strongly linked to\nour methods.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.05088v1"
    },
    {
        "title": "A short survey around the pumping lemma for context-free languages",
        "authors": [
            "Gabriele Gullà"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Following a seminar the present author gave to an Automata Theory course to\ncomputer science students, it will be presented, in a very synthetic and mostly\nselfcontained way, the principal properties of context free languages (CFL),\nwith particular attention given to the Pumping Lemma (PL), and of grammars\nwhich generate them(CFG). We refer to Chomsky and Schutzenberger for the first\nworks about it. What is known in literature as the Iteration Theorem here will\nbe referred to as the Ogden's Lemma in a fully justified way. All definitions\nnot strictly connected with the notion of context freeness will be omitted (we\nwill give precise references for all of them). The symbology used is\nsubstantially the classical one, but we will replace some symbols to avoid\nconfusion with those used in logic\n",
        "pdf_link": "http://arxiv.org/pdf/2403.15899v1"
    },
    {
        "title": "Presenting Interval Pomsets with Interfaces",
        "authors": [
            "Amazigh Amrane",
            "Hugo Bazille",
            "Emily Clement",
            "Uli Fahrenberg",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Interval-order partially ordered multisets with interfaces (ipomsets) have\nshown to be a versatile model for executions of concurrent systems in which\nboth precedence and concurrency need to be taken into account. In this paper,\nwe develop a presentation of ipomsets as generated by a graph of certain\ndiscrete ipomsets (starters and terminators) under the relation which composes\nsubsequent starters and subsequent terminators. Using this presentation, we\nshow that also subsumptions are generated by elementary relations. We develop a\nsimilar correspondence on the automata side, relating higher-dimensional\nautomata, which generate ipomsets, and ST-automata, which generate step\nsequences, and their respective languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.16626v2"
    },
    {
        "title": "Illustrating Finite Automata with Grail+ and TikZ",
        "authors": [
            "Alastair May",
            "Taylor J. Smith"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this article, we discuss a new software tool that interacts with Grail+, a\nlibrary of automata-theoretic command-line utilities. Our software, the Grail+\nVisualizer, takes the textual representation of a finite automaton produced by\nGrail+ and generates TikZ code to illustrate the finite automaton, with\nautomatic layout of states and transitions. In addition to giving an overview\nof the basics of automata theory and Grail+, we discuss how the Grail+\nVisualizer works in detail and suggest avenues for future work.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.03039v1"
    },
    {
        "title": "Learning Deterministic Multi-Clock Timed Automata",
        "authors": [
            "Yu Teng",
            "Miaomiao Zhang",
            "Jie An"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present an algorithm for active learning of deterministic timed automata\nwith multiple clocks. The algorithm is within the querying framework of\nAngluin's $L^*$ algorithm and follows the idea proposed in existing work on the\nactive learning of deterministic one-clock timed automata. We introduce an\nequivalence relation over the reset-clocked language of a timed automaton and\nthen transform the learning problem into learning the corresponding\nreset-clocked language of the target automaton. Since a reset-clocked language\nincludes the clock reset information which is not observable, we first present\nthe approach of learning from a powerful teacher who can provide reset\ninformation by answering reset information queries from the learner. Then we\nextend the algorithm in a normal teacher situation in which the learner can\nonly ask standard membership query and equivalence query while the learner\nguesses the reset information. We prove that the learning algorithm terminates\nand returns a correct deterministic timed automaton. Due to the need of\nguessing whether the clocks reset at the transitions, the algorithm is of\nexponential complexity in the size of the target automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.07823v2"
    },
    {
        "title": "Exact descriptional complexity of determinization of input-driven\n  pushdown automata",
        "authors": [
            "Olga Martynova"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The number of states and stack symbols needed to determinize nondeterministic\ninput-driven pushdown automata (NIDPDA) working over a fixed alphabet is\ndetermined precisely. It is proved that in the worst case exactly 2^{n^2}\nstates are needed to determinize an n-state NIDPDA, and the proof uses witness\nautomata with a stack alphabet \\Gamma = {0,1} working on strings over a\n4-symbol input alphabet (Only an asymptotic lower bound was known before in the\ncase of a fixed alphabet). Also, the impact of NIDPDA determinization on the\nsize of stack alphabet is determined precisely for the first time: it is proved\nthat s(2^{n^2}-1) stack symbols are necessary in the worst case to determinize\nan n-state NIDPDA working over an input alphabet of size s+5 with s left\nbrackets (The previous lower bound was only asymptotic in the number of states\nand did not depend on the number of left brackets).\n",
        "pdf_link": "http://arxiv.org/pdf/2404.10516v1"
    },
    {
        "title": "On the Representation of Block Languages",
        "authors": [
            "Guilherme Duarte",
            "Nelma Moreira",
            "Luca Prigioniero",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper we consider block languages, namely sets of words having the\nsame length, and we propose a new representation for these languages. In\nparticular, given an alphabet of size $k$ and a length $\\ell$, these languages\ncan be represented by bitmaps of size $k^\\ell$, in which each bit indicates\nwhether the correspondent word, according to the lexicographical order, belongs\nto the language (bit equal to 1) or not (bit equal to 0). This representation\nturns out to be a good tool for the investigation of several properties of\nblock languages, making proofs simpler and reasoning clearer. After showing how\nto convert bitmaps into minimal deterministic and nondeterministic finite\nautomata, we use this representation as a tool to study the deterministic and\nnondeterministic state complexity of block languages, as well as the costs of\nbasic operations on block languages, in terms of the sizes of the equivalent\nfinite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.11746v1"
    },
    {
        "title": "Characterization of Isometric Words based on Swap and Mismatch Distance",
        "authors": [
            "M. Anselmo",
            "G. Castiglione",
            "M. Flores",
            "D. Giammarresi",
            "M. Madonia",
            "S. Mantaci"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper we consider an edit distance with swap and mismatch operations,\ncalled tilde-distance, and introduce the corresponding definition of\ntilde-isometric word. Isometric words are classically defined with respect to\nHamming distance and combine the notion of edit distance with the property that\na word does not appear as factor in other words. A word f is said\ntilde-isometric if, for any pair of f-free words u and v, there exists a\ntransformation from u to v via the related edit operations such that all the\nintermediate words are also f -free. This new setting is here studied giving a\nfull characterization of the tilde-isometric words in terms of overlaps with\nerrors.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.13577v1"
    },
    {
        "title": "Finite Automata for Efficient Graph Recognition",
        "authors": [
            "Frank Drewes",
            "Berthold Hoffmann",
            "Mark Minas"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Engelfriet and Vereijken have shown that linear graph grammars based on\nhyperedge replacement generate graph languages that can be considered as\ninterpretations of regular string languages over typed symbols. In this paper\nwe show that finite automata can be lifted from strings to graphs within the\nsame framework. For the efficient recognition of graphs with these automata, we\nmake them deterministic by a modified powerset construction, and state\nsufficient conditions under which deterministic finite graph automata recognize\ngraphs without the need to use backtracking.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.15052v1"
    },
    {
        "title": "Development of parallel programs on shared data-structures -- Revised\n  version",
        "authors": [
            "Ketil Stølen"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A syntax-directed formal system for the development of totally correct\nprograms with respect to an unfair shared-state parallel while-language is\nproposed. The system can be understood as a compositional reformulation of the\nOwicki/Gries method for verification of parallel programs. Auxiliary variables\nare used both as a specification tool to eliminate undesirable implementations,\nand as a verification tool to make it possible to prove that an already\nfinished program satisfies a particular specification. Auxiliary variables may\nbe of any sort, and it is up to the user to define the auxiliary structure he\nprefers. Moreover, the auxiliary structure is only a part of the logic. This\nmeans that auxiliary variables do not have to be implemented as if they were\nordinary programming variables. The system is proved sound and relatively\ncomplete with respect to an operational semantics and employed to develop three\nnontrivial algorithms: the Dining-Philosophers, the Bubble-Lattice-Sort and the\nSet-Partition algorithms. Finally, a related method for the development of\n(possibly nonterminating) programs with respect to four properties is\ndescribed. This approach is then used to develop Dekker's algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.16624v1"
    },
    {
        "title": "Lookahead Games and Efficient Determinisation of History-Deterministic\n  Büchi Automata",
        "authors": [
            "Rohan Acharya",
            "Marcin Jurdziński",
            "Aditya Prakash"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Our main technical contribution is a polynomial-time determinisation\nprocedure for history-deterministic B\\\"uchi automata, which settles an open\nquestion of Kuperberg and Skrzypczak, 2015. A key conceptual contribution is\nthe lookahead game, which is a variant of Bagnol and Kuperberg's token game, in\nwhich Adam is given a fixed lookahead. We prove that the lookahead game is\nequivalent to the 1-token game. This allows us to show that the 1-token game\ncharacterises history-determinism for semantically-deterministic B\\\"uchi\nautomata, which paves the way to our polynomial-time determinisation procedure.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.17530v1"
    },
    {
        "title": "Monitoring Real-Time Systems under Parametric Delay",
        "authors": [
            "Martin Fränzle",
            "Thomas M. Grosen",
            "Kim G. Larsen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Timed B\\\"uchi automata provide a very expressive formalism for expressing\nrequirements of real-time systems. Online monitoring of embedded real-time\nsystems can then be achieved by symbolic execution of such automata on the\ntrace observed from the system. This direct construction however only is\nfaithful if observation of the trace is immediate in the sense that the monitor\ncan assign exact time stamps to the actions it observes, which is rarely true\nin practice due to the substantial and fluctuating parametric delays introduced\nby the circuitry connecting the observed system to its monitoring device. We\npresent a purely zone-based online monitoring algorithm, which handles such\nparametric delays exactly without recurrence to costly verification procedures\nfor parametric timed automata. We have implemented our monitoring algorithm on\ntop of the real-time model checking tool UPPAAL, and report on encouraging\ninitial results.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.18282v2"
    },
    {
        "title": "Probabilistic Finite Automaton Emptiness is undecidable",
        "authors": [
            "Günter Rote"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  It is undecidable whether the language recognized by a probabilistic finite\nautomaton is empty. Several other undecidability results, in particular\nregarding problems about matrix products, are based on this important theorem.\nWe present three proofs of this theorem from the literature in a self-contained\nway, and we derive some strengthenings. For example, we show that the problem\nremains undecidable for a fixed probabilistic finite automaton with 11 states,\nwhere only the starting distribution is given as input.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.03035v2"
    },
    {
        "title": "Planning with Probabilistic Opacity and Transparency: A Computational\n  Model of Opaque/Transparent Observations",
        "authors": [
            "Sumukha Udupa",
            "Jie Fu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Qualitative opacity of a secret is a security property, which means that a\nsystem trajectory satisfying the secret is observation-equivalent to a\ntrajectory violating the secret. In this paper, we study how to synthesize a\ncontrol policy that maximizes the probability of a secret being made opaque\nagainst an eavesdropping attacker/observer, while subject to other task\nperformance constraints. In contrast to existing belief-based approach for\nopacity-enforcement, we develop an approach that uses the observation function,\nthe secret, and the model of the dynamical systems to construct a so-called\nopaque-observations automaton which accepts the exact set of observations that\nenforce opacity. Leveraging this opaque-observations automaton, we can reduce\nthe optimal planning in Markov decision processes(MDPs) for maximizing\nprobabilistic opacity or its dual notion, transparency, subject to task\nconstraints into a constrained planning problem over an augmented-state MDP.\nFinally, we illustrate the effectiveness of the developed methods in robot\nmotion planning problems with opacity or transparency requirements.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.05408v3"
    },
    {
        "title": "Finite-valued Streaming String Transducers",
        "authors": [
            "Emmanuel Filiot",
            "Ismaël Jecker",
            "Gabriele Puppis",
            "Christof Löding",
            "Anca Muscholl",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A transducer is finite-valued if for some bound k, it maps any given input to\nat most k outputs. For classical, one-way transducers, it is known since the\n80s that finite valuedness entails decidability of the equivalence problem.\nThis decidability result is in contrast to the general case, which makes\nfinite-valued transducers very attractive. For classical transducers, it is\nalso known that finite valuedness is decidable and that any k-valued finite\ntransducer can be decomposed as a union of k single-valued finite transducers.\n  In this paper, we extend the above results to copyless streaming string\ntransducers (SSTs), answering questions raised by Alur and Deshmukh in 2011.\nSSTs strictly extend the expressiveness of one-way transducers via additional\nvariables that store partial outputs. We prove that any k-valued SST can be\neffectively decomposed as a union of k (single-valued) deterministic SSTs. As a\ncorollary, we obtain equivalence of SSTs and two-way transducers in the\nfinite-valued case (those two models are incomparable in general). Another\ncorollary is an elementary upper bound for checking equivalence of\nfinite-valued SSTs. The latter problem was already known to be decidable, but\nthe proof complexity was unknown (it relied on Ehrenfeucht's conjecture).\nFinally, our main result is that finite valuedness of SSTs is decidable. The\ncomplexity is PSpace, and even PTime when the number of variables is fixed.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.08171v5"
    },
    {
        "title": "Techniques for Showing the Decidability of the Boundedness Problem of\n  Language Acceptors",
        "authors": [
            "Oscar H. Ibarra",
            "Ian McQuillan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  There are many types of automata and grammar models that have been studied in\nthe literature, and for these models, it is common to determine whether certain\nproblems are decidable. One problem that has been difficult to answer\nthroughout the history of automata and formal language theory is to decide\nwhether a given system $M$ accepts a bounded language (whether there exist\nwords $w_1, \\ldots,w_k$ such that $L(M) \\subseteq w_1 \\cdots w_k$?).\nDecidability of this problem has gone unanswered for the majority of\nautomata/grammar models in the literature. Boundedness was only known to be\ndecidable for regular and context-free languages until recently when it was\nshown to also be decidable for finite-automata and pushdown automata augmented\nwith reversal-bounded counters, and for vector addition systems with states.\n  In this paper, we develop new techniques to show that the boundedness problem\nis decidable for larger classes of one-way nondeterministic automata and\ngrammar models, by reducing the problem to the decidability of boundedness for\nsimpler classes of automata. One technique involves characterizing the models\nin terms of multi-tape automata. We give new characterizations of finite-turn\nTuring machines, finite-turn Turing machines augmented with various storage\nstructures (like a pushdown, multiple reversal-bounded counters,\npartially-blind counters, etc.), and simple matrix grammars. The\ncharacterizations are then used to show that the boundedness problem for these\nmodels is decidable. Another technique uses the concept of the store language\nof an automaton. This is used to show that the boundedness problem is decidable\nfor pushdown automata that can \"flip\" their pushdown a bounded number of times,\nand boundedness remains decidable even if we augment this device with\nadditional stores.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.08988v2"
    },
    {
        "title": "A Formal Approach for Tuning Stochastic Oscillators",
        "authors": [
            "Paolo Ballarini",
            "Mahmoud Bentriou",
            "Paul-Henry Cournède"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Periodic recurrence is a prominent behavioural of many biological phenomena,\nincluding cell cycle and circadian rhythms. Although deterministic models are\ncommonly used to represent the dynamics of periodic phenomena, it is known that\nthey are little appropriate in the case of systems in which stochastic noise\ninduced by small population numbers is actually responsible for periodicity.\nWithin the stochastic modelling settings automata-based model checking\napproaches have proven an effective means for the analysis of oscillatory\ndynamics, the main idea being that of coupling a period detector automaton with\na continuous-time Markov chain model of an alleged oscillator. In this paper we\naddress a complementary aspect, i.e. that of assessing the dependency of\noscillation related measure (period and amplitude) against the parameters of a\nstochastic oscillator. To this aim we introduce a framework which, by combining\nan Approximate Bayesian Computation scheme with a hybrid automata capable of\nquantifying how distant an instance of a stochastic oscillator is from matching\na desired (average) period, leads us to identify regions of the parameter space\nin which oscillation with given period are highly likely. The method is\ndemonstrated through a couple of case studies, including a model of the popular\nRepressilator circuit.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.09183v1"
    },
    {
        "title": "Extended time Petri nets",
        "authors": [
            "Marcin Radom",
            "Piotr Formanowicz"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In many complex systems that can be modeled using Petri nets time can be a\nvery important factor which should be taken into account during creation and\nanalysis of the model. Time data can describe starting moments of some actions\nor their duration before their immediate effects start to influence some other\nareas of the modeled system. Places in a Petri net often describe static\ncomponents of the system, but they can also describe states. Such a state can\nhave time restrictions, for example, telling how long it can influence other\nelements in the model. Time values describing some system may be inconsistent\nor incomplete, which can cause problems during the creation of the model. In\nthis paper, a new extension of time Petri nets is proposed, which allows the\ncreation of models with different types of time data, which previously were\npossible to be properly used in separate types of well-known time Petri nets.\nThe proposed new time Petri net solves this problem by integrating different\naspects of already existing time Petri nets into one unified net.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.09208v1"
    },
    {
        "title": "Verifying Unboundedness via Amalgamation",
        "authors": [
            "Ashwani Anand",
            "Sylvain Schmitz",
            "Lia Schütze",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Well-structured transition systems (WSTS) are an abstract family of systems\nthat encompasses a vast landscape of infinite-state systems. By requiring a\nwell-quasi-ordering (wqo) on the set of states, a WSTS enables generic\nalgorithms for classic verification tasks such as coverability and termination.\nHowever, even for systems that are WSTS like vector addition systems (VAS), the\nframework is notoriously ill-equipped to analyse reachability (as opposed to\ncoverability). Moreover, some important types of infinite-state systems fall\nout of WSTS' scope entirely, such as pushdown systems (PDS).\n  Inspired by recent algorithmic techniques on VAS, we propose an abstract\nnotion of systems where the set of runs is equipped with a wqo and supports\namalgamation of runs. We show that it subsumes a large class of infinite-state\nsystems, including (reachability languages of) VAS and PDS, and even all\nsystems from the abstract framework of valence systems, except for those\nalready known to be Turing-complete.\n  Moreover, this abstract setting enables simple and general algorithmic\nsolutions to unboundedness problems, which have received much attention in\nrecent years. We present algorithms for the (i) simultaneous unboundedness\nproblem (which implies computability of downward closures and decidability of\nseparability by piecewise testable languages), (ii) computing priority downward\nclosures, (iii) deciding whether a language is bounded, meaning included in\n$w_1^*\\cdots w_k^*$ for some words $w_1,\\ldots,w_k$, and (iv) effective\nregularity of unary languages. This leads to either drastically simpler proofs\nor new decidability results for a rich variety of systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.10296v2"
    },
    {
        "title": "Jumping Automata Must Pay",
        "authors": [
            "Shaull Almagor",
            "Ishai Salgado"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Jumping automata are finite automata that read their input in a\nnon-sequential manner, by allowing a reading head to \"jump\" between positions\non the input, consuming a permutation of the input word. We argue that allowing\nthe head to jump should incur some cost. To this end, we propose three\nquantitative semantics for jumping automata, whereby the jumps of the head in\nan accepting run define the cost of the run. The three semantics correspond to\ndifferent interpretations of jumps: the absolute distance semantics counts the\ndistance the head jumps, the reversal semantics counts the number of times the\nhead changes direction, and the Hamming distance measures the number of\nletter-swaps the run makes.\n  We study these measures, with the main focus being the boundedness problem:\ngiven a jumping automaton, decide whether its (quantitative) languages is\nbounded by some given number k. We establish the decidability and complexity\nfor this problem under several variants.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.11849v2"
    },
    {
        "title": "Nominal Tree Automata With Name Allocation",
        "authors": [
            "Simon Prucker",
            "Lutz Schröder"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Data trees serve as an abstraction of structured data, such as XML documents.\nA number of specification formalisms for languages of data trees have been\ndeveloped, many of them adhering to the paradigm of register automata, which is\nbased on storing data values encountered on the tree in registers for\nsubsequent comparison with further data values. Already on word languages, the\nexpressiveness of such automata models typically increases with the power of\ncontrol (e.g. deterministic, non-deterministic, alternating). Language\ninclusion is typically undecidable for non-deterministic or alternating models\nunless the number of registers is radically restricted, and even then often\nremains non-elementary. We present an automaton model for data trees that\nretains a reasonable level of expressiveness, in particular allows\nnon-determinism and any number of registers, while admitting language inclusion\nchecking in elementary complexity, in fact in parametrized exponential time. We\nphrase the description of our automaton model in the language of nominal sets,\nbuilding on the recently introduced paradigm of explicit name allocation in\nnominal automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.14272v2"
    },
    {
        "title": "The Power of Hard Attention Transformers on Data Sequences: A Formal\n  Language Theoretic Perspective",
        "authors": [
            "Pascal Bergsträßer",
            "Chris Köcher",
            "Anthony Widjaja Lin",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Formal language theory has recently been successfully employed to unravel the\npower of transformer encoders. This setting is primarily applicable in Natural\nLanguage Processing (NLP), as a token embedding function (where a bounded\nnumber of tokens is admitted) is first applied before feeding the input to the\ntransformer. On certain kinds of data (e.g. time series), we want our\ntransformers to be able to handle arbitrary input sequences of numbers (or\ntuples thereof) without a priori limiting the values of these numbers. In this\npaper, we initiate the study of the expressive power of transformer encoders on\nsequences of data (i.e. tuples of numbers). Our results indicate an increase in\nexpressive power of hard attention transformers over data sequences, in stark\ncontrast to the case of strings. In particular, we prove that Unique Hard\nAttention Transformers (UHAT) over inputs as data sequences no longer lie\nwithin the circuit complexity class $AC^0$ (even without positional encodings),\nunlike the case of string inputs, but are still within the complexity class\n$TC^0$ (even with positional encodings). Over strings, UHAT without positional\nencodings capture only regular languages. In contrast, we show that over data\nsequences UHAT can capture non-regular properties. Finally, we show that UHAT\ncapture languages definable in an extension of linear temporal logic with unary\nnumeric predicates and arithmetics.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.16166v2"
    },
    {
        "title": "The CFG Complexity of Singleton Sets",
        "authors": [
            "Lance Fortnow",
            "William Gasarch"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Let G be a context-free grammar (CFG) in Chomsky normal form. We take the\nnumber of rules in G to be the size of G. We also assume all CFGs are in\nChomsky normal form.\n  We consider the question of, given a string w of length n, what is the\nsmallest CFG such that L(G)={w}? We show the following:\n  1) For all w, |w|=n, there is a CFG of size with O(n/log n) rules, such that\nL(G)={w}.\n  2) There exists a string w, |w|=n, such that every CFG G with L(G)={w} is of\nsize Omega(n/log n). We give two proofs of: one nonconstructive, the other\nconstructive.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.20026v2"
    },
    {
        "title": "The generating power of weighted tree automata with initial algebra\n  semantics",
        "authors": [
            "Manfred Droste",
            "Zoltán Fülöp",
            "Andreja Tepavčević",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider the images of the initial algebra semantics of weighted tree\nautomata over strong bimonoids (hence also over semirings). These images are\nsubsets of the carrier set of the underlying strong bimonoid. We consider\nlocally finite, weakly locally finite, and bi-locally finite strong bimonoids.\nWe show that there exists a strong bimonoid which is weakly locally finite and\nnot locally finite. We also show that if the ranked alphabet contains a binary\nsymbol, then for any finitely generated strong bimonoid, weighted tree automata\ncan generate, via their initial algebra semantics, all elements of the strong\nbimonoid. As a consequence of these results, for weakly locally finite strong\nbimonoids which are not locally finite, weighted tree automata can generate\ninfinite images provided that the input ranked alphabet contains at least one\nbinary symbol. This is in sharp contrast to the setting of weighted string\nautomata, where each such image is known to be finite. As a further\nconsequence, for any finitely generated semiring, there exists a weighted tree\nautomaton which generates, via its run semantics, all elements of the semiring.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.20753v1"
    },
    {
        "title": "Linear equations and recursively enumerable sets",
        "authors": [
            "Juha Honkala"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study connections between linear equations over various semigroups and\nrecursively enumerable sets of positive integers. We give variants of the\nuniversal Diophantine representation of recursively enumerable sets of positive\nintegers established by Matiyasevich. These variants use linear equations with\none unkwown instead of polynomial equations with several unknowns. As a\ncorollary we get undecidability results for linear equations over morphism\nsemigoups and over matrix semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.00688v1"
    },
    {
        "title": "Separability in Büchi Vass and Singly Non-Linear Systems of\n  Inequalities",
        "authors": [
            "Pascal Baumann",
            "Eren Keskin",
            "Roland Meyer",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The omega-regular separability problem for B\\\"uchi VASS coverability\nlanguages has recently been shown to be decidable, but with an EXPSPACE lower\nand a non-primitive recursive upper bound -- the exact complexity remained\nopen. We close this gap and show that the problem is EXPSPACE-complete. A\ncareful analysis of our complexity bounds additionally yields a PSPACE\nprocedure in the case of fixed dimension >= 1, which matches a pre-established\nlower bound of PSPACE for one dimensional B\\\"uchi VASS. Our algorithm is a\nnon-deterministic search for a witness whose size, as we show, can be suitably\nbounded. Part of the procedure is to decide the existence of runs in VASS that\nsatisfy certain non-linear properties. Therefore, a key technical ingredient is\nto analyze a class of systems of inequalities where one variable may occur in\nnon-linear (polynomial) expressions.\n  These so-called singly non-linear systems (SNLS) take the form A(x).y >=\nb(x), where A(x) and b(x) are a matrix resp. a vector whose entries are\npolynomials in x, and y ranges over vectors in the rationals. Our main\ncontribution on SNLS is an exponential upper bound on the size of rational\nsolutions to singly non-linear systems. The proof consists of three steps.\nFirst, we give a tailor-made quantifier elimination to characterize all real\nsolutions to x. Second, using the root separation theorem about the distance of\nreal roots of polynomials, we show that if a rational solution exists, then\nthere is one with at most polynomially many bits. Third, we insert the solution\nfor x into the SNLS, making it linear and allowing us to invoke standard\nsolution bounds from convex geometry.\n  Finally, we combine the results about SNLS with several techniques from the\narea of VASS to devise an EXPSPACE decision procedure for omega-regular\nseparability of B\\\"uchi VASS.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.01008v1"
    },
    {
        "title": "Attributed Tree Transducers for Partial Functions",
        "authors": [
            "Sebastian Maneth",
            "Martin Vu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Attributed tree transducers (atts) have been equipped with regular\nlook-around (i.e., a preprocessing via an attributed relabeling) in order to\nobtain a more robust class of translations. Here we give further evidence of\nthis robustness: we show that if the class of translations realized by\nnondeterministic atts with regular look-around is restricted to partial\nfunctions, then we obtain exactly the class of translations realized by\ndeterministic atts with regular look-around.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.06141v2"
    },
    {
        "title": "Learning EFSM Models with Registers in Guards",
        "authors": [
            "Germán Vega",
            "Roland Groz",
            "Catherine Oriat",
            "Michael Foster",
            "Neil Walkinshaw",
            "Adenilso Simão"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper presents an active inference method for Extended Finite State\nMachines, where inputs and outputs are parametrized, and transitions can be\nconditioned by guards involving input parameters and internal variables called\nregisters. The method applies to (software) systems that cannot be reset, so it\nlearns an EFSM model of the system on a single trace.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.07040v1"
    },
    {
        "title": "Database-assisted automata learning",
        "authors": [
            "Hielke Walinga",
            "Robert Baumgartner",
            "Sicco Verwer"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper presents DAALder (Database-Assisted Automata Learning, with Dutch\nsuffix from leerder), a new algorithm for learning state machines, or automata,\nspecifically deterministic finite-state automata (DFA). When learning state\nmachines from log data originating from software systems, the large amount of\nlog data can pose a challenge. Conventional state merging algorithms cannot\nefficiently deal with this, as they require a large amount of memory. To solve\nthis, we utilized database technologies to efficiently query a big trace\ndataset and construct a state machine from it, as databases allow to save large\namounts of data on disk while still being able to query it efficiently.\nBuilding on research in both active learning and passive learning, the proposed\nalgorithm is a combination of the two. It can quickly find a characteristic set\nof traces from a database using heuristics from a state merging algorithm.\nExperiments show that our algorithm has similar performance to conventional\nstate merging algorithms on large datasets, but requires far less memory.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.07208v1"
    },
    {
        "title": "$ω$-regular Expression Synthesis from Transition-Based Büchi\n  Automata",
        "authors": [
            "Charles Pert",
            "Dalal Alrajeh",
            "Alessandra Russo"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A popular method for modelling reactive systems is to use $\\omega$-regular\nlanguages. These languages can be represented as nondeterministic B\\\"uchi\nautomata (NBAs) or $\\omega$-regular expressions. Existing methods synthesise\nexpressions from state-based NBAs. Synthesis from transition-based NBAs is\ntraditionally done by transforming transition-based NBAs into state-based NBAs.\nThis transformation, however, can increase the complexity of the synthesised\nexpressions. This paper proposes a novel method for directly synthesising\n$\\omega$-regular expressions from transition-based NBAs. We prove that the\nmethod is sound and complete. Our empirical results show that the\n$\\omega$-regular expressions synthesised from transition-based NBAs are more\ncompact than those synthesised from state-based NBAs. This is particularly the\ncase for NBAs computed from obligation, reactivity, safety and recurrence-type\nLTL formulas, reporting in the latter case an average reduction of over 50%. We\nalso show that our method successfully synthesises $\\omega$-regular expressions\nfrom more LTL formulas when using a transition-based instead of a state-based\nNBA.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.08136v1"
    },
    {
        "title": "Reversible Transducers over Infinite Words",
        "authors": [
            "Luc Dartois",
            "Paul Gastin",
            "Loïc Germerie Guizouarn",
            "R. Govind",
            "Shankaranarayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Deterministic two-way transducers capture the class of regular functions. The\nefficiency of composing two-way transducers has a direct implication in\nalgorithmic problems related to reactive synthesis, where transformation\nspecifications are converted into equivalent transducers. These specifications\nare presented in a modular way, and composing the resultant machines simulates\nthe full specification. An important result by Dartois et al. shows that\ncomposition of two-way transducers enjoy a polynomial composition when the\nunderlying transducer is reversible, that is, if they are both deterministic\nand co-deterministic. This is a major improvement over general deterministic\ntwo-way transducers, for which composition causes a doubly exponential blow-up\nin the size of the inputs in general. Moreover, they show that reversible\ntwo-way transducers have the same expressiveness as deterministic two-way\ntransducers. However, the question of expressiveness of reversible transducers\nover infinite words is still open. In this article, we introduce the class of\nreversible two-way transducers over infinite words and show that they enjoy the\nsame expressive power as deterministic two-way transducers over infinite words.\nThis is done through a non-trivial, effective construction inducing a single\nexponential blow-up in the set of states. Further, we also prove that composing\ntwo reversible two-way transducers over infinite words incurs only a polynomial\ncomplexity, thereby providing foundations for efficient procedure for\ncomposition of transducers over infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.11488v2"
    },
    {
        "title": "Computing the Bandwidth of Meager Timed Automata",
        "authors": [
            "Eugene Asarin",
            "Aldric Degorre",
            "Catalin Dima",
            "Bernardo Jacobo Inclán"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The bandwidth of timed automata characterizes the quantity of information\nproduced/transmitted per time unit. We previously delimited 3 classes of TA\naccording to the nature of their asymptotic bandwidth: meager, normal, and\nobese. In this paper, we propose a method, based on a finite-state simply-timed\nabstraction, to compute the actual value of the bandwidth of meager automata.\nThe states of this abstraction correspond to barycenters of the faces of the\nsimplices in the region automaton. Then the bandwidth is $\\log 1/|z_0|$ where\n$z_0$ is the smallest root (in modulus) of the characteristic polynomial of\nthis finite-state abstraction.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.12694v2"
    },
    {
        "title": "Quantum automata and languages of finite index",
        "authors": [
            "Andrea Benso",
            "Flavio D'Alessandro",
            "Paolo Papi"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper is a continuation of a previous study on the so-called measure\nonce finite quantum automata model introduced by Moore and Crutchfield in 2000.\nWe investigate conditions assuring that, given a language recognized by such a\ndevice and a language generated by a context-free grammar of finite index or by\na matrix context-free grammar, it is recursively decidable whether or not they\nhave a nonempty intersection.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.13797v2"
    },
    {
        "title": "Information-flow Interfaces and Security Lattices",
        "authors": [
            "Ezio Bartocci",
            "Thomas A. Henzinger",
            "Dejan Nickovic",
            "Ana Oliveira da Costa"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Information-flow interfaces is a formalism recently proposed for specifying,\ncomposing, and refining system-wide security requirements. In this work, we\nshow how the widely used concept of security lattices provides a natural\nsemantic interpretation for information-flow interfaces.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.14374v1"
    },
    {
        "title": "Computational Model for Parsing Expression Grammars",
        "authors": [
            "Alexander Rubtsov",
            "Nikita Chudinov"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a computational model for Parsing Expression Grammars (PEGs). The\npredecessor of PEGs top-down parsing languages (TDPLs) were discovered by A.\nBirman and J. Ullman in the 1960-s, B. Ford showed in 2004 that both formalisms\nrecognize the same class named Parsing Expression Languages (PELs). A. Birman\nand J. Ullman established such important properties like TDPLs generate any\nDCFL and some non-context-free languages like $a^nb^nc^n$, a linear-time\nparsing algorithm was constructed as well. But since this parsing algorithm was\nimpractical in the 60-s TDPLs were abandoned and then upgraded by B. Ford to\nPEGs, so the parsing algorithm was improved (from the practical point of view)\nas well. Now PEGs are actively used in compilers (eg., Python replaced\nLL(1)-parser with a PEG one) so as for text processing as well. In this paper,\nwe present a computational model for PEG, obtain structural properties of PELs,\nnamely proof that PELs contain Boolean closure of regular closure of DCFLs and\nPELs are closed over left concatenation with regular closure of DCFLs. We\npresent an extension of the PELs class based on the extension of our\ncomputational model. Our model is an upgrade of deterministic pushdown automata\n(DPDA) such that during the pop of a symbol it is allowed to return the head to\nthe position of the push of the symbol. We provide a linear-time simulation\nalgorithm for the 2-way version of this model, which is similar to the famous\nS. Cook linear-time simulation algorithm of 2-way DPDA.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.14911v2"
    },
    {
        "title": "Global One-Counter Tree Automata",
        "authors": [
            "Luisa Herrmann",
            "Richard Mörbitz"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce global one-counter tree automata (GOCTA) which deviate from\nusual counter tree automata by working on only one counter which is passed\nthrough the tree in lexicographical order, rather than duplicating the counter\nat every branching position. We compare the capabilities of GOCTA to those of\ncounter tree automata and obtain that their classes of recognizable tree\nlanguages are incomparable. Moreover, we show that the emptiness problem of\nGOCTA is undecidable while, in stark contrast, their membership problem is in\nP.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.15090v1"
    },
    {
        "title": "Unveiling the connection between the Lyndon factorization and the\n  Canonical Inverse Lyndon factorization via a border property",
        "authors": [
            "Paola Bonizzoni",
            "Clelia De Felice",
            "Brian Riccardi",
            "Rocco Zaccagnino",
            "Rosalba Zizza"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The notion of Lyndon word and Lyndon factorization has shown to have\nunexpected applications in theory as well in developing novel algorithms on\nwords. A counterpart to these notions are those of inverse Lyndon word and\ninverse Lyndon factorization. Differently from the Lyndon words, the inverse\nLyndon words may be bordered. The relationship between the two factorizations\nis related to the inverse lexicographic ordering, and has only been recently\nexplored. More precisely, a main open question is how to get an inverse Lyndon\nfactorization from a classical Lyndon factorization under the inverse\nlexicographic ordering, named CFLin. In this paper we reveal a strong\nconnection between these two factorizations where the border plays a relevant\nrole. More precisely, we show two main results. We say that a factorization has\nthe border property if a nonempty border of a factor cannot be a prefix of the\nnext factor. First we show that there exists a unique inverse Lyndon\nfactorization having the border property. Then we show that this unique\nfactorization with the border property is the so-called canonical inverse\nLyndon factorization, named ICFL. By showing that ICFL is obtained by\ncompacting factors of the Lyndon factorization over the inverse lexicographic\nordering, we provide a linear time algorithm for computing ICFL from CFLin.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.18473v2"
    },
    {
        "title": "Regular Expressions with Backreferences on Multiple Context-Free\n  Languages, and the Closed-Star Condition",
        "authors": [
            "Taisei Nogami",
            "Tachio Terauchi"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Backreference is a well-known practical extension of regular expressions and\nmost modern programming languages, such as Java, Python, JavaScript and more,\nsupport regular expressions with backreferences (rewb) in their standard\nlibraries for string processing. A difficulty of backreference is\nnon-regularity: unlike some other extensions, backreference strictly enhances\nthe expressive power of regular expressions and thus rewbs can describe\nnon-regular (in fact, even non-context-free) languages. In this paper, we\ninvestigate the expressive power of rewbs by comparing rewbs to multiple\ncontext-free languages (MCFL) and parallel multiple context-free languages\n(PMCFL). First, we prove that the language class of rewbs is a proper subclass\nof unary-PMCFLs. The class of unary-PMCFLs coincides with that of EDT0L\nlanguages, and our result strictly improves the known upper bound of rewbs.\nAdditionally, we show that, however, the language class of rewbs is not\ncontained in that of MCFLs even when restricted to rewbs with only one\ncapturing group and no captured references. Therefore, in general, the\nparallelism seems essential for rewbs. Backed by these results, we define a\nnovel syntactic condition on rewbs that we call closed-star and observe that it\nprovides an upper bound on the number of times a rewb references the same\ncaptured string. The closed-star condition allows dispensing with the\nparallelism: that is, we prove that the language class of closed-star rewbs\nfalls inside the class of unary-MCFLs, which is equivalent to that of EDT0L\nsystems of finite index. Furthermore, as additional evidence for the robustness\nof the condition, we show that the language class of closed-star rewbs also\nfalls inside the class of nonerasing stack languages (NESL).\n",
        "pdf_link": "http://arxiv.org/pdf/2406.18918v1"
    },
    {
        "title": "On Transition Constructions for Automata -- A Categorical Perspective",
        "authors": [
            "Mike Cruchten"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We investigate the transition monoid construction for deterministic automata\nin a categorical setting and establish it as an adjunction. We pair this\nadjunction with two other adjunctions to obtain two endofunctors on\ndeterministic automata, a comonad and a monad, which are closely related,\nrespectively, to the largest set of equations and the smallest set of\ncoequations satisfied by an automaton. Furthermore, we give similar transition\nalgebra constructions for lasso and {\\Omega}-automata, and show that they form\nadjunctions. We present some initial results on sets of equations and\ncoequations for lasso automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.19312v1"
    },
    {
        "title": "Some Remarks on First-Order Definable Tree Languages",
        "authors": [
            "Achim Blumensath"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the question of whether a given regular language of finite trees can\nbe defined in first-order logic. We develop an algebraic approach to address\nthis question and we use it to derive several necessary and sufficient\nconditions for definability (but unfortunately no condition that is both). The\nmain difference of our results to those from the literature is that our\nconditions are decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.01169v1"
    },
    {
        "title": "On Shuffling and Splitting Automata",
        "authors": [
            "Ignacio Mollo Cunningham"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider a class of finite state three-tape transducers which models the\noperation of shuffling and splitting words. We present them as automata over\nthe so-called Shuffling Monoid. These automata can be seen as either shufflers\nor splitters interchangeably. We prove that functionality is decidable for\nsplitters, and we also show that the equivalence between functional splitters\nis decidable. Moreover, in the deterministic case, the algorithm for\nequivalence is polynomial on the number of states of the splitter.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.02660v1"
    },
    {
        "title": "Monads, Comonads, and Transducers",
        "authors": [
            "Rafał Stefański"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper proposes a definition of recognizable transducers over monads and\ncomonads, which bridges two important ongoing efforts in the current research\non regularity. The first effort is the study of regular transductions, which\nextends the notion of regularity from languages into word-to-word functions.\nThe other important effort is generalizing the notion of regular languages from\nwords to arbitrary monads, introduced in arXiv:1502.04898. In this paper, we\npresent a number of examples of transducer classes that fit the proposed\nframework. In particular we show that our class generalizes the classes of\nMealy machines and rational transductions. We also present examples of\nrecognizable transducers for infinite words and a specific type of trees called\nterms. The main result of this paper is a theorem, which states the class of\nrecognizable transductions is closed under composition, subject to some\ncoherence axioms between the structure of a monad and the structure of a\ncomonad. Due to its complexity, we formalize the proof of the theorem in Coq\nProof Assistant. In the proof, we introduce the concepts of a context and a\ngeneralized wreath product for Eilenberg-Moore algebras, which could be\nvaluable tools for studying these algebras.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.02704v1"
    },
    {
        "title": "Generalized Parikh Matrices For Tracking Subsequence Occurrences",
        "authors": [
            "Szilárd Zsolt Fazekas",
            "Xinhao Huang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce and study a generalized Parikh matrix mapping based on tracking\nthe occurrence counts of special types of subsequences. These matrices retain\nmore information about a word than the original Parikh matrix mapping while\npreserving the homomorphic property. We build the generalization by first\nintroducing the Parikh factor matrix mapping and extend it to the Parikh\nsequence matrix mapping. We establish an interesting connection between the\ngeneralized Parikh matrices and the original ones and use it to prove that\ncertain important minors of a Parikh sequence matrix have nonnegative\ndeterminant. Finally, we generalize the concept of subword histories and show\nthat each generalized subword history is equivalent to a linear one.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.04462v1"
    },
    {
        "title": "More on Maximally Permissive Similarity Control of Discrete Event\n  Systems",
        "authors": [
            "Yu Wang",
            "Zhaohui Zhu",
            "Rob van Glabbeek",
            "Jinjin Zhang",
            "Lixing Tan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Takai proposed a method for constructing a maximally permissive supervisor\nfor the similarity control problem (IEEE Transactions on Automatic Control,\n66(7):3197-3204, 2021). This paper points out flaws in his results by providing\na counterexample. Inspired by Takai's construction, the notion of a (saturated)\n(G, R)-automaton is introduced and metatheorems concerning (maximally\npermissive) supervisors for the similarity control problem are provided in\nterms of this notion. As an application of these metatheorems, the flaws in\nTakai's work are corrected.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.08068v1"
    },
    {
        "title": "A quadratic upper bound on the reset thresholds of synchronizing\n  automata containing a transitive permutation group",
        "authors": [
            "Yinfeng Zhu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  For any synchronizing $n$-state deterministic automaton, \\v{C}ern\\'{y}\nconjectures the existence of a synchronizing word of length at most $(n-1)^2$.\nWe prove that there exists a synchronizing word of length at most $2n^2 - 7n +\n7$ for every synchronizing $n$-state deterministic automaton that satisfies the\nfollowing two properties: 1. The image of the action of each letter contains at\nleast $n-1$ states; 2. The actions of bijective letters generate a transitive\npermutation group on the state set.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.08135v1"
    },
    {
        "title": "MITL Model Checking via Generalized Timed Automata and a New Liveness\n  Algorithm",
        "authors": [
            "S. Akshay",
            "Paul Gastin",
            "R. Govind",
            "B. Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The translation of Metric Interval Temporal Logic (MITL) to timed automata is\na topic that has been extensively studied. A key challenge here is the\nconversion of future modalities into equivalent automata. Typical conversions\nequip the automata with a guess-and-check mechanism to ascertain the truth of\nfuture modalities. Guess-and-check can be naturally implemented via\nalternation. However, since timed automata tools do not handle alternation,\nexisting methods perform an additional step of converting the alternating timed\nautomata into timed automata. This de-alternation step proceeds by an intricate\nfinite abstraction of the space of configurations of the alternating automaton.\n  Recently, a model of generalized timed automata (GTA) has been proposed. The\nmodel comes with several powerful additional features, and yet, the best known\nzone-based reachability algorithms for timed automata have been extended to the\nGTA model, with the same complexity for all the zone operations. We provide a\nnew concise translation from MITL to GTA. In particular, for the timed until\nmodality, our translation offers an exponential improvement w.r.t. the\nstate-of-the-art.\n  Thanks to this conversion, MITL model checking reduces to checking liveness\nfor GTAs. However, no liveness algorithm is known for GTAs. Due to the presence\nof future clocks, there is no finite time-abstract bisimulation (region\nequivalence) for GTAs, whereas liveness algorithms for timed automata crucially\nrely on the presence of the finite region equivalence. As our second\ncontribution, we provide a new zone-based algorithm for checking Buchi\nnon-emptiness in GTAs, which circumvents this fundamental challenge.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.08452v1"
    },
    {
        "title": "History-Determinism vs Fair Simulation",
        "authors": [
            "Udi Boker",
            "Thomas A. Henzinger",
            "Karoliina Lehtinen",
            "Aditya Prakash"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  An automaton is history-deterministic if its nondeterminism can be resolved\non the fly, only using the prefix of the word read so far. This mild form of\nnondeterminism has attracted particular attention for its applications in\nsynthesis problems. An automaton $A$ is guidable with respect to a class $C$ of\nautomata if it can fairly simulate every automaton in $C$ whose language is\ncontained in that of $A$. In other words, guidable automata are those for which\ninclusion and simulation coincide, making them particularly interesting for\nmodel-checking.\n  We study the connection between these two notions, and specifically the\nquestion of when they coincide. For classes of automata on which they do,\ndeciding guidability, an otherwise challenging decision problem, reduces to\ndeciding history-determinism, a problem that is starting to be well-understood\nfor many classes.\n  We provide a selection of sufficient criteria for a class of automata to\nguarantee the coincidence of the notions, and use them to show that the notions\ncoincide for the most common automata classes, among which are $\\omega$-regular\nautomata and many infinite-state automata with safety and reachability\nacceptance conditions, including vector addition systems with states,\none-counter nets, pushdown-, Parikh-, and timed-automata.\n  We also demonstrate that history-determinism and guidability do not always\ncoincide, for example, for the classes of timed automata with a fixed number of\nclocks.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.08620v1"
    },
    {
        "title": "Blow-up in Non-Deterministic Automata",
        "authors": [
            "Ivan Baburin",
            "Ryan Cotterell"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper we examine the difficulty of finding an equivalent\ndeterministic automaton when confronted with a non-deterministic one. While for\nsome automata the exponential blow-up in their number of states is unavoidable,\nwe show that in general, any approximation of state complexity with polynomial\nprecision remains PSPACE-hard. The same is true when using the subset\nconstruction to determinize the NFA, meaning that it is PSPACE-hard to predict\nwhether subset construction will produce an exponential ''blow-up'' in the\nnumber of states or not. To give an explanation for its behaviour, we propose\nthe notion of subset complexity, which serves as an upper bound on the size of\nsubset construction. Due to it simple and intuitive nature it allows to\nidentify large classes of automata which can have limited non-determinism and\ncompletely avoid the ''blow-up''. Subset complexity also remains invariant\nunder NFA reversal and allows to predict how the introduction or removal of\ntransitions from the NFA will affect its size.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.09891v2"
    },
    {
        "title": "On state complexity for subword-closed languages",
        "authors": [
            "Jérôme Guyot"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper investigates the state complexities of subword-closed and\nsuperword-closed languages, comparing them to regular languages. We focus on\nthe square root operator and the substitution operator. We establish an\nexponential lower bound for superword-closed languages for the k-th root. For\nsubword-closed languages we analyze in detail a specific instance of the square\nroot problem for which a quadratic complexity is proven. For the substitution\noperator, we show an exponential lower bound for the general substitution. We\nthen find some conditions for which we prove a quadratic upper bound.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.10355v1"
    },
    {
        "title": "Dual Adjunction Between $Ω$-Automata and Wilke Algebra Quotients",
        "authors": [
            "Anton Chernev",
            "Helle Hvid Hansen",
            "Clemens Kupke"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  $\\Omega$-automata and Wilke algebras are formalisms for characterising\n$\\omega$-regular languages via their ultimately periodic words.\n$\\Omega$-automata read finite representations of ultimately periodic words,\ncalled lassos, and they are a subclass of lasso automata. We introduce lasso\nsemigroups as a generalisation of Wilke algebras that mirrors how lasso\nautomata generalise $\\Omega$-automata, and we show that finite lasso semigroups\ncharacterise regular lasso languages. We then show a dual adjunction between\nlasso automata and quotients of the free lasso semigroup with a recognising\nset, and as our main result we show that this dual adjunction restricts to one\nbetween $\\Omega$-automata and quotients of the free Wilke algebra with a\nrecognising set.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.14115v2"
    },
    {
        "title": "On the Minimisation of Deterministic and History-Deterministic\n  Generalised (co)Büchi Automata",
        "authors": [
            "Antonio Casares",
            "Olivier Idir",
            "Denis Kuperberg",
            "Corto Mascle",
            "Aditya Prakash"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a polynomial-time algorithm minimising the number of states of\nhistory-deterministic generalised coB\\\"uchi automata, building on the work of\nAbu Radi and Kupferman on coB\\\"uchi automata. On the other hand, we establish\nthat the minimisation problem for both deterministic and history-deterministic\ngeneralised B\\\"uchi automata is NP-complete, as well as the problem of\nminimising at the same time the number of states and colours of\nhistory-deterministic generalised coB\\\"uchi automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.18090v2"
    },
    {
        "title": "Reachability for Multi-Priced Timed Automata with Positive and Negative\n  Rates",
        "authors": [
            "Andrew Scoones",
            "Mahsa Shirmohammadi",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Multi-priced timed automata (MPTA) are timed automata with observer\n  variables whose derivatives can change from one location to another.\n  Observers are write-only variables, that is, they do not affect the control\n  flow of the automaton; thus MPTA lie between timed and hybrid\n  automata in expressiveness. Previous work considered observers with\n  non-negative slope in every location. In this paper we treat\n  observers that have both positive and negative rates. Our\n  main result is an algorithm to decide a gap version of the\n  reachability problem for this variant of MPTA. We translate the\n  gap reachability problem into a gap satisfiability problem for mixed\n  integer-real systems of nonlinear constraints. Our main technical\n  contribution -- a result of independent interest -- is a procedure\n  to solve such contraints via a combination of branch-and-bound\n  and relaxation-and-rounding.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.18131v1"
    },
    {
        "title": "RE#: High Performance Derivative-Based Regex Matching with Intersection,\n  Complement and Lookarounds",
        "authors": [
            "Ian Erik Varatalu",
            "Margus Veanes",
            "Juhan-Peep Ernits"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a tool and theory RE# for regular expression matching that is\nbuilt on symbolic derivatives, does not use backtracking, and, in addition to\nthe classical operators, also supports complement, intersection and\nlookarounds. We develop the theory formally and show that the main matching\nalgorithm has input-linear complexity both in theory as well as experimentally.\nWe apply thorough evaluation on popular benchmarks that show that RE# is over\n71% faster than the next fastest regex engine in Rust on the baseline, and\noutperforms all state-of-the-art engines on extensions of the benchmarks often\nby several orders of magnitude.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.20479v1"
    },
    {
        "title": "Regular Grammars for Graph Sets of Tree-Width $\\leq2$",
        "authors": [
            "Marius Bozga",
            "Radu Iosif",
            "Florian Zuleger"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Regular and context-free languages form a central pillar of formal language\ntheory. This is because a variety of formalisms are known that define these\nclasses of languages. For example, we have that finite automata, monoids,\nalgebraic recognizability, regular expressions, regular grammars,\nmonadic-second order logic, etc., can be used to represent regular word\nlanguages. However, the situation is less clear for formal languages over\ngraphs, and open problems persist. This is because generalizing notions from\nwords to graphs has been more successful for some of the cited formalisms than\nfor the other ones. Bruno Courcelle has introduced hyper-edge replacement (\\hr)\nalgebras for generalizing the notion of context-free languages from words to\ngraphs. At the same time, \\hr-algebras support the generalization of algebraic\nrecognizability from words to graphs, a notion that has been proven to be\nequivalent to definability in (counting) monadic-second order logic (\\cmso)\nover graphs of bounded tree-width. In this paper, we deal with generalizing\nregular word grammars to graphs. We propose regular grammars for (unordered and\nunranked) trees, series-parallel graphs, and graphs of tree-width $\\le 2$,\nwhere the qualifier regular is justified because these grammars define exactly\nthe recognizable resp. \\cmso-definable subsets of the respective graph classes.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.01226v2"
    },
    {
        "title": "A Tree Sampler for Bounded Context-Free Languages",
        "authors": [
            "Breandan Considine"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In the following paper, we present a simple method for sampling trees with or\nwithout replacement from BCFLs. A BCFL is a context-free language (CFL)\ncorresponding to an incomplete string with holes, which can be completed by\nvalid terminals. To solve this problem, we introduce an algebraic datatype that\ncompactly represents candidate parse forests for porous strings. Once\nconstructed, sampling trees is a straightforward matter of sampling integers\nuniformly without replacement, then lazily decoding them into trees.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.01849v2"
    },
    {
        "title": "Alternating Nominal Automata with Name Allocation",
        "authors": [
            "Florian Frank",
            "Daniel Hausmann",
            "Stefan Milius",
            "Lutz Schröder",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Formal languages over infinite alphabets serve as abstractions of structures\nand processes carrying data. Automata models over infinite alphabets, such as\nclassical register automata or, equivalently, nominal orbit-finite automata,\ntend to have computationally hard or even undecidable reasoning problems unless\nstringent restrictions are imposed on either the power of control or the number\nof registers. This has been shown to be ameliorated in automata models with\nname allocation such as regular nondeterministic nominal automata, which allow\nfor deciding language inclusion in elementary complexity even with unboundedly\nmany registers while retaining a reasonable level of expressiveness. In the\npresent work, we demonstrate that elementary complexity survives under\nextending the power of control to alternation: We introduce regular alternating\nnominal automata (RANAs), and show that their non-emptiness and inclusion\nproblems have elementary complexity even when the number of registers is\nunbounded. Moreover, we show that RANAs allow for nearly complete\nde-alternation, specifically de-alternation up to a single deadlocked universal\nstate.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.03658v1"
    },
    {
        "title": "Parameterized Verification of Timed Networks with Clock Invariants",
        "authors": [
            "Étienne André",
            "Swen Jacobs",
            "Shyam Lal Karra",
            "Ocan Sankur"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider parameterized verification problems for networks of timed\nautomata (TAs) that communicate via disjunctive guards or lossy broadcast. To\nthis end, we first consider disjunctive timed networks (DTNs), i.e., networks\nof TAs that communicate via location guards that enable a transition only if\nthere is another process in a certain location. We solve for the first time the\ngeneral case with clock invariants, and establish the decidability of the\nparameterized verification problem for local trace properties and for\nreachability of global configurations; Moreover, we prove that, surprisingly\nand unlike in other settings, this model is equivalent to lossy broadcast\nnetworks.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.05190v1"
    },
    {
        "title": "Parameterized Verification of Systems with Precise (0,1)-Counter\n  Abstraction",
        "authors": [
            "Paul Eichler",
            "Swen Jacobs",
            "Chana Weil-Kennedy"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce a new framework for verifying systems with a parametric number\nof concurrently running processes. The systems we consider are well-structured\nwith respect to a specific well-quasi order. This allows us to decide a wide\nrange of verification problems, including control-state reachability,\ncoverability, and target, in a fixed finite abstraction of the infinite\nstate-space, called a 01-counter system. We show that several systems from the\nparameterized verification literature fall into this class, including\nreconfigurable broadcast networks (or systems with lossy broadcast),\ndisjunctive systems, synchronizations and systems with a fixed number of shared\nfinite-domain variables. Our framework provides a simple and unified\nexplanation for the properties of these systems, which have so far been\ninvestigated separately. Additionally, it extends and improves on a range of\nthe existing results, and gives rise to other systems with similar properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.05954v2"
    },
    {
        "title": "[Draft] High-order observers and high-order state-estimation-based\n  properties of discrete-event systems",
        "authors": [
            "Kuize Zhang",
            "Xiaoguang Han",
            "Alessandro Giua",
            "Carla Seatzu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  State-estimation-based properties are central properties in discrete-event\nsystems modeled by labeled finite-state automata studied over the past 3\ndecades. Most existing results are based on a single agent who knows the\nstructure of a system and can observe a subset of events and estimate the\nsystem's state based on the system's structure and the agent's observation to\nthe system. The main tool used to do state estimation and verify\nstate-estimation-based properties is called \\emph{observer} which is the\npowerset construction originally proposed by Rabin and Scott in 1959, used to\ndeterminize a nondeterministic finite automaton with $\\varepsilon$-transitions.\n  In this paper, we consider labeled finite-state automata, extend the\nstate-estimation-based properties from a single agent to a finite ordered set\nof agents and also extend the original observer to \\emph{high-order observer}\nbased on the original observer and our \\emph{concurrent composition}. As a\nresult, a general framework on high-order state-estimation-based properties\nhave been built and a basic tool has also been built to verify such properties.\nThis general framework contains many basic properties as its members such as\nstate-based opacity, critical observability, determinism, high-order opacity,\netc. Special cases for which verification can be done more efficiently are also\ndiscussed.\n  In our general framework, the system's structure is publicly known to all\nagents $A_1,\\dots,A_n$, each agent $A_i$ has its own observable event set\n$E_i$, and additionally knows all its preceding agents' observable events but\ncan only observe its own observable events. The intuitive meaning of our\nhigh-order observer is what agent $A_n$ knows about what $A_{n-1}$ knows about\n\\dots what $A_2$ knows about $A_1$'s state estimate of the system.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.06141v2"
    },
    {
        "title": "Exploring Complexity: An Extended Study of Formal Properties for Process\n  Model Complexity Measures",
        "authors": [
            "Patrizia Schalk",
            "Adam Burke",
            "Robert Lorenz"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A good process model is expected not only to reflect the behavior of the\nprocess, but also to be as easy to read and understand as possible. Because\npreferences vary across different applications, numerous measures provide ways\nto reflect the complexity of a model with a numeric score. However, this\nabundance of different complexity measures makes it difficult to select one for\nanalysis. Furthermore, most complexity measures are defined for BPMN or EPC,\nbut not for workflow nets.\n  This paper is an extended analysis of complexity measures and their formal\nproperties. It adapts existing complexity measures to the world of workflow\nnets. It then compares these measures with a set of properties originally\ndefined for software complexity, as well as new extensions to it. We discuss\nthe importance of the properties in theory by evaluating whether matured\ncomplexity measures should fulfill them or whether they are optional. We find\nthat not all inspected properties are mandatory, but also demonstrate that the\nbehavior of evolutionary process discovery algorithms is influenced by some of\nthese properties. Our findings help analysts to choose the right complexity\nmeasure for their use-case.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.09871v2"
    },
    {
        "title": "Distribution of Reconfiguration Languages maintaining Tree-like\n  Communication Topology",
        "authors": [
            "Daniel Hausmann",
            "Mathieu Lehaut",
            "Nir Piterman"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study how to distribute trace languages in a setting where processes\ncommunicate via reconfigurable communication channels. That is, the different\nprocesses can connect and disconnect from channels at run time. We restrict\nattention to communication via tree-like communication architectures. These\nallow channels to connect more than two processes in a way that maintains an\nunderlying spanning tree and keeps communication continuous on the tree. We\nmake the reconfiguration explicit in the language allowing both a centralized\nautomaton as well as the distributed processes to share relevant information\nabout the current communication configuration. We show that Zielonka's seminal\nresult regarding distribution of regular languages for asynchronous automata\ncan be generalized in this setting, incorporating both reconfiguration and more\nthan binary tree architectures.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.10708v1"
    },
    {
        "title": "Greybox Learning of Languages Recognizable by Event-Recording Automata",
        "authors": [
            "Anirban Majumdar",
            "Sayan Mukherjee",
            "Jean-François Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we revisit the active learning of timed languages recognizable\nby event-recording automata. Our framework employs a method known as greybox\nlearning, which enables the learning of event-recording automata with a minimal\nnumber of control states. This approach avoids learning the region automaton\nassociated with the language, contrasting with existing methods. We have\nimplemented our greybox learning algorithm with various heuristics to maintain\nlow computational complexity. The efficacy of our approach is demonstrated\nthrough several examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.12551v1"
    },
    {
        "title": "Imposing Rules in Process Discovery: an Inductive Mining Approach",
        "authors": [
            "Ali Norouzifar",
            "Marcus Dees",
            "Wil van der Aalst"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Process discovery aims to discover descriptive process models from event\nlogs. These discovered process models depict the actual execution of a process\nand serve as a foundational element for conformance checking, performance\nanalyses, and many other applications. While most of the current process\ndiscovery algorithms primarily rely on a single event log for model discovery,\nadditional sources of information, such as process documentation and domain\nexperts' knowledge, remain untapped. This valuable information is often\noverlooked in traditional process discovery approaches. In this paper, we\npropose a discovery technique incorporating such knowledge in a novel inductive\nmining approach. This method takes a set of user-defined or discovered rules as\ninput and utilizes them to discover enhanced process models. Our proposed\nframework has been implemented and tested using several publicly available\nreal-life event logs. Furthermore, to showcase the framework's effectiveness in\na practical setting, we conducted a case study in collaboration with UWV, the\nDutch employee insurance agency.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.17326v1"
    },
    {
        "title": "Attractor Basins in Concurrent Systems",
        "authors": [
            "Giann Karlo Aguirre Samboni",
            "Stefan Haar",
            "Loic Paulevé",
            "Stefan Schwoon",
            "Nick Würdemann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A crucial question in analyzing a concurrent system is to determine its\nlong-run behaviour, and in particular, whether there are irreversible choices\nin its evolution, leading into parts of the reachability space from which there\nis no return to other parts. Casting this problem in the unifying framework of\nsafe Petri nets, our previous work has provided techniques for identifying\nattractors, i.e. terminal strongly connected components of the reachability\nspace. What we aim at is to determine the attraction basins associated to those\nattractors; that is, those states from where all infinite runs are doomed to\nend in the given attractor, as opposed to those that are free to evolve\ndifferently. Here, we provide a solution for the case of safe Petri nets. Our\nalgorithm uses net unfoldings and provides a map of all of those configurations\n(concurrent executions of the system) that lead onto cliff-edges, i.e. any\nmaximal extension for those configurations lies in some basin that is\nconsidered fatal.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.01079v1"
    },
    {
        "title": "Two or three things I know about tree transducers",
        "authors": [
            "Lê Thành Dũng Nguyên"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  You might know that the name \"tree transducers\" refers to various kinds of\nautomata that compute functions on ranked trees, i.e. terms over a first-order\nsignature.\n  But have you ever wondered about how to remember what a macro tree transducer\ndoes? Or what are the connections between top-down tree(-to-string)\ntransducers, multi bottom-up tree(-to-string) transducers, tree-walking\ntransducers, (invisible) pebble tree transducers, monadic second-order\ntransductions, unfoldings of rooted directed acyclic graphs (i.e. term graphs)\n-- and what happens when the functions that they compute are composed?\n  The answers may be found in old papers (mostly coauthored by Engelfriet), but\nmaybe you can save some time by first looking at this short note.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.03169v2"
    },
    {
        "title": "QuAK: Quantitative Automata Kit",
        "authors": [
            "Marek Chalupa",
            "Thomas A. Henzinger",
            "Nicolas Mazzocchi",
            "N. Ege Saraç"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  System behaviors are traditionally evaluated through binary classifications\nof correctness, which do not suffice for properties involving quantitative\naspects of systems and executions. Quantitative automata offer a more nuanced\napproach, mapping each execution to a real number by incorporating weighted\ntransitions and value functions generalizing acceptance conditions. In this\npaper, we introduce QuAK, the first tool designed to automate the analysis of\nquantitative automata. QuAK currently supports a variety of quantitative\nautomaton types, including Inf, Sup, LimInf, LimSup, LimInfAvg, and LimSupAvg\nautomata, and implements decision procedures for problems such as emptiness,\nuniversality, inclusion, equivalence, as well as for checking whether an\nautomaton is safe, live, or constant. Additionally, QuAK is able to compute\nextremal values when possible, construct safety-liveness decompositions, and\nmonitor system behaviors. We demonstrate the effectiveness of QuAK through\nexperiments focusing on the inclusion, constant-function check, and monitoring\nproblems.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.03569v1"
    },
    {
        "title": "Exploiting Assumptions for Effective Monitoring of Real-Time Properties\n  under Partial Observability",
        "authors": [
            "Alessandro Cimatti",
            "Thomas M. Grosen",
            "Kim G. Larsen",
            "Stefano Tonetta",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Runtime verification of temporal properties over timed sequences of\nobservations is crucial in various applications within cyber-physical systems\nranging from autonomous vehicles over smart grids to medical devices. In this\npaper, we are addressing the challenge of effectively predicting the failure or\nsuccess of properties in a continuous real-time setting. Our approach allows\npredictions to exploit assumptions on the system being monitored and supports\npredictions of non-observable system behaviour (e.g. internal faults). More\nconcretely, in our approach properties are expressed in Metric Interval\nTemporal Logic (MITL), assumptions on the monitored system are specified in\nterms of Timed Automata, and observations are to be provided in terms of\nsequences of timed constraints. We present an assumption-based runtime\nverification algorithm and its implementation on top of the real-time\nverification tool UPPAAL. We show experimentally that assumptions can be\neffective in anticipating the satisfaction/violation of timed properties and in\nhandling monitoring properties that predicate over unobservable events.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.05456v1"
    },
    {
        "title": "State estimation of timed automata under partial observation [Draft\n  version]",
        "authors": [
            "Chao Gao",
            "Dimitri Lefebvre",
            "Carla Seatzu",
            "Zhiwu Li",
            "Alessandro Giua"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we consider partially observable timed automata endowed with a\nsingle clock. A time interval is associated with each transition specifying at\nwhich clock values it may occur. In addition, a resetting condition associated\nto a transition specifies how the clock value is updated upon its occurrence.\nThis work deals with the estimation of the current state given a timed\nobservation, i.e., a succession of pairs of an observable event and the time\ninstant at which the event has occurred. The problem of state reachability in\nthe timed automaton is reduced to the reachability analysis of the associated\nzone automaton, which provides a purely discrete event description of the\nbehaviour of the timed automaton. An algorithm is formulated to provide an\noffline approach for state estimation of a timed automaton based on the\nassumption that the clock is reset upon the occurrence of each observable\ntransition.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.05810v1"
    },
    {
        "title": "Determinism in Multi-Soliton Automata",
        "authors": [
            "Henning Bordihn",
            "Helena Schulz"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Soliton automata are mathematical models of soliton switching in chemical\nmolecules. Several concepts of determinism for soliton automata have been\ndefined. The concept of strong determinism has been investigated for the case\nin which only a single soliton can be present in a molecule. In the present\npaper, several different concepts of determinism are explored for the\nmulti-soliton case. It is shown that the degree of non-determinism is a\nconnected measure of descriptional complexity for multi-soliton automata. A\ncharacterization of the class of strongly deterministic multi-soliton automata\nis presented. Finally, the concept of perfect determinism, forming a natural\nextension of strong determinism, is introduced and considered for multi-soliton\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06969v1"
    },
    {
        "title": "Operational State Complexity of Block Languages",
        "authors": [
            "Guilherme Duarte",
            "Nelma Moreira",
            "Luca Prigioniero",
            "Rogério Reis"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper we consider block languages, namely sets of words having the\nsame length, and study the deterministic and nondeterministic state complexity\nof several operations on these languages. Being a subclass of finite languages,\nthe upper bounds of operational state complexity known for finite languages\napply for block languages as well. However, in several cases, smaller values\nwere found. Block languages can be represented as bitmaps, which are a good\ntool to study their minimal finite automata and their operations, as we\nillustrate here.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06970v1"
    },
    {
        "title": "How to Demonstrate Metalinearness and Regularity by Tree-Restricted\n  General Grammars",
        "authors": [
            "Martin Havel",
            "Zbyněk Křivka",
            "Alexander Meduna"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper introduces derivation trees for general grammars. Within these\ntrees, it defines context-dependent pairs of nodes, corresponding to rewriting\ntwo neighboring symbols using a non context-free rule. It proves that the\nlanguage generated by a linear core general grammar with a slow-branching\nderivation tree is k-linear if there is a constant u such that every sentence w\nin the generated language is the frontier of a derivation tree in which any\npair of neighboring paths contains u or fewer context-dependent pairs of nodes.\nNext, it proves that the language generated by a general grammar with a regular\ncore is regular if there is a constant u such that every sentence w in the\ngenerated language is the frontier of a derivation tree in which any pair of\nneighboring paths contains u or fewer context-dependent pairs of nodes. The\npaper explains that this result is a powerful tool for showing that certain\nlanguages are k-linear or regular.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06972v1"
    },
    {
        "title": "Non-Global Parikh Tree Automata",
        "authors": [
            "Luisa Herrmann",
            "Johannes Osterholzer"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Parikh (tree) automata are an expressive and yet computationally well-behaved\nextension of finite automata -- they allow to increment a number of counters\nduring their computations, which are finally tested by a semilinear constraint.\nIn this work, we introduce and investigate a new perspective on Parikh tree\nautomata (PTA): instead of testing one counter configuration that results from\nthe whole input tree, we implement a non-global automaton model. Here, we copy\nand distribute the current configuration at each node to all its children,\nincrementing the counters pathwise, and check the arithmetic constraint at each\nleaf. We obtain that the classes of tree languages recognizable by global PTA\nand non-global PTA are incomparable. In contrast to global PTA, the\nnon-emptiness problem is undecidable for non-global PTA if we allow the\nautomata to work with at least three counters, whereas the membership problem\nstays decidable. However, for a restriction of the model, where counter\nconfigurations are passed in a linear fashion to at most one child node, we can\nprove decidability of the non-emptiness problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06973v1"
    },
    {
        "title": "Various Types of Comet Languages and their Application in External\n  Contextual Grammars",
        "authors": [
            "Marvin Ködding",
            "Bianca Truthe"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we continue the research on the power of contextual grammars\nwith selection languages from subfamilies of the family of regular languages.\nWe investigate various comet-like types of languages and compare such language\nfamilies to some other subregular families of languages (finite, monoidal,\nnilpotent, combinational, (symmetric) definite, ordered, non-counting,\npower-separating, suffix-closed, commutative, circular, or union-free\nlanguages). Further, we compare the language families defined by these types\nfor the selection with each other and with the families of the hierarchy\nobtained for external contextual grammars. In this way, we extend the existing\nhierarchy by new language families.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06974v1"
    },
    {
        "title": "Repetitive Finite Automata With Translucent Letters",
        "authors": [
            "František Mráz",
            "Friedrich Otto"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Here we propose an extension of the (deterministic and the nondeterministic)\nfinite automaton with translucent letters (DFAwtl and NFAwtl), which lies\nbetween these automata and their non-returning variants (that is, the nr-DFAwtl\nand the nr-NFAwtl). This new model works like a DFAwtl or an NFAwtl, but on\nseeing the end-of-tape marker, it may change its internal state and continue\nwith its computation instead of just ending it, accepting or rejecting. This\nnew type of automaton is called a repetitive deterministic or nondeterministic\nfinite automaton with translucent letters (RDFAwtl or RNFAwtl). In the\ndeterministic case, the new model is strictly more expressive than the DFAwtl,\nbut less expressive than the nr-DFAwtl, while in the nondeterministic case, the\nnew model is equivalent to the NFAwtl.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06975v1"
    },
    {
        "title": "5' -> 3' Watson-Crick Automata accepting Necklaces",
        "authors": [
            "Benedek Nagy"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Watson-Crick (WK) finite automata work on a Watson-Crick tape representing a\nDNA molecule. They have two reading heads. In 5'->3' WK automata, the heads\nmove and read the input in opposite physical directions. In this paper, we\nconsider such inputs which are necklaces, i.e., they represent circular DNA\nmolecules. In sensing 5'->3' WK automata, the computation on the input is\nfinished when the heads meet. As the original model is capable of accepting the\nlinear context-free languages, the necklace languages we are investigating here\nhave strong relations to that class. Here, we use these automata in two\ndifferent acceptance modes. On the one hand, in weak acceptance mode the heads\nare starting nondeterministically at any point of the input, like the necklace\nis cut at a nondeterministically chosen point), and if the input is accepted,\nit is in the accepted necklace language. These languages can be seen as the\nlanguages obtained from the linear context-free languages by taking their\nclosure under cyclic shift operation. On the other hand, in strong acceptance\nmode, it is required that the input is accepted starting the heads in the\ncomputation from every point of the cycle. These languages can be seen as the\nmaximal cyclic shift closed languages included in a linear language. On the\nother hand, as it will be shown, they have a kind of locally testable property.\nWe present some hierarchy results based on restricted variants of the WK\nautomata, such as stateless or all-final variants.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06976v1"
    },
    {
        "title": "$\\mathbb{N}$-polyregular functions arise from well-quasi-orderings",
        "authors": [
            "Aliaume Lopez"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A fundamental construction in formal language theory is the Myhill-Nerode\ncongruence on words, whose finitedness characterizes regular language. This\nconstruction was generalized to functions from $\\Sigma^*$ to $\\mathbb{Z}$ by\nColcombet, Dou\\'eneau-Tabot, and Lopez to characterize the class of so-called\n$\\mathbb{Z}$-polyregular functions. In this paper, we relax the notion of\nequivalence relation to quasi-ordering in order to study the class of\n$\\mathbb{N}$-polyregular functions, that plays the role of\n$\\mathbb{Z}$-polyregular functions among functions from $\\Sigma^*$ to\n$\\mathbb{N}$. The analogue of having a finite index is then being a\nwell-quasi-ordering. This provides a canonical object to describe\n$\\mathbb{N}$-polyregular functions, together with a powerful new\ncharacterization of this class.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.07882v1"
    },
    {
        "title": "Subshifts defined by nondeterministic and alternating plane-walking\n  automata",
        "authors": [
            "Benjamin Hellouin de Menibus",
            "Pacôme Perrotin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Plane-walking automata were introduced by Salo & T\\\"orma to recognise\nlanguages of two-dimensional infinite words (subshifts), the counterpart of\n$4$-way finite automata for two-dimensional finite words. We extend the model\nto allow for nondeterminism and alternation of quantifiers. We prove that the\nrecognised subshifts form a strict subclass of sofic subshifts, and that the\nclasses corresponding to existential and universal nondeterminism are\nincomparable and both larger that the deterministic class. We define a\nhierarchy of subshifts recognised by plane-walking automata with alternating\nquantifiers, which we conjecture to be strict.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.08024v2"
    },
    {
        "title": "Run supports and initial algebra supports of weighted automata",
        "authors": [
            "Manfred Droste",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider weighted automata over words and over trees where the weight\nalgebras are strong bimonoids, i.e., semirings which may lack distributivity.\nIt is well known that, for each such weighted automaton, its run semantics and\nits initial algebra semantics can be different, due to the presence of\nnondeterminism and the absence of distributivity. Here we investigate the\nquestion under which conditions on the strong bimonoid the support of the run\nsemantics equals the support of the initial algebra semantics. We prove a\ncharacterization of this equality in terms of strongly zero-sum-free strong\nbimonoids (for weighted automata over words) and in terms of bi-strongly\nzero-sum-free strong bimonoids (for weighted automata over trees). We also\nconsider shortly the images of the two semantics functions.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.08727v1"
    },
    {
        "title": "Well-Behaved (Co)algebraic Semantics of Regular Expressions in Dafny",
        "authors": [
            "Stefan Zetzsche",
            "Wojciech Rozowski"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Regular expressions are commonly understood in terms of their denotational\nsemantics, that is, through formal languages -- the regular languages. This\nview is inductive in nature: two primitives are equivalent if they are\nconstructed in the same way. Alternatively, regular expressions can be\nunderstood in terms of their operational semantics, that is, through\ndeterministic finite automata. This view is coinductive in nature: two\nprimitives are equivalent if they are deconstructed in the same way. It is\nimplied by Kleene's famous theorem that both views are equivalent: regular\nlanguages are precisely the formal languages accepted by deterministic finite\nautomata. In this paper, we use Dafny, a verification-aware programming\nlanguage, to formally verify, for the first time, what has been previously\nestablished only through proofs-by-hand: the two semantics of regular\nexpressions are well-behaved, in the sense that they are in fact one and the\nsame, up to pointwise bisimilarity. At each step of our formalisation, we\npropose an interpretation in the language of Coalgebra. We found that Dafny is\nparticularly well suited for the task due to its inductive and coinductive\nfeatures and hope our approach serves as a blueprint for future generalisations\nto other theories.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.09889v1"
    },
    {
        "title": "Query Learning of Advice and Nominal Automata",
        "authors": [
            "Kevin Zhou"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Learning automata by queries is a long-studied area initiated by Angluin in\n1987 with the introduction of the $L^*$ algorithm to learn regular languages,\nwith a large body of work afterwards on many different variations and\ngeneralizations of DFAs. Recently, Chase and Freitag introduced a novel\napproach to proving query learning bounds by computing combinatorial complexity\nmeasures for the classes in question, which they applied to the setting of DFAs\nto obtain qualitatively different results compared to the $L^*$ algorithm.\nUsing this approach, we prove new query learning bounds for two generalizations\nof DFAs. The first setting is that of advice DFAs, which are DFAs augmented\nwith an advice string that informs the DFA's transition behavior at each step.\nFor advice DFAs, we give the first known upper bounds for query complexity. The\nsecond setting is that of nominal DFAs, which generalize DFAs to infinite\nalphabets which admit some structure via symmetries. For nominal DFAs, we make\nqualitative improvements over prior results.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.10822v1"
    },
    {
        "title": "Completely Reachable Almost Group Automata",
        "authors": [
            "David Fernando Casas Torres"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider finite deterministic automata such that their alphabets consist\nof exactly one letter of defect 1 and a set of permutations of the state set.\nWe study under which conditions such an automaton is completely reachable. We\nfocus our attention on the case when the set of permutations generates a\ntransitive imprimitive group.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.19172v1"
    },
    {
        "title": "Conway's cosmological theorem and automata theory",
        "authors": [
            "Pierre Lairez",
            "Aleksandr Storozhenko"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  John Conway proved that every audioactive sequence (a.k.a. look-and-say)\ndecays into a compound of 94~elements, a statement he termed the cosmological\ntheorem. The underlying audioactive process can be modeled by a finite-state\nmachine, mapping one sequence of integers to another. Leveraging automata\ntheory, we propose a new proof of Conway's theorem based on a few simple\nmachines, using a computer to compose and minimize them.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.20341v1"
    },
    {
        "title": "The complexity of separability for semilinear sets and Parikh automata",
        "authors": [
            "Elias Rojas Collins",
            "Chris Köcher",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In a separability problem, we are given two sets $K$ and $L$ from a class\n$\\mathcal{C}$, and we want to decide whether there exists a set $S$ from a\nclass $\\mathcal{S}$ such that $K\\subseteq S$ and $S\\cap L=\\emptyset$. In this\ncase, we speak of separability of sets in $\\mathcal{C}$ by sets in\n$\\mathcal{S}$.\n  We study two types of separability problems. First, we consider separability\nof semilinear sets by recognizable sets of vectors (equivalently, by sets\ndefinable by quantifier-free monadic Presburger formulas). Second, we consider\nseparability of languages of Parikh automata by regular languages. A Parikh\nautomaton is a machine with access to counters that can only be incremented,\nand have to meet a semilinear constraint at the end of the run. Both of these\nseparability problems are known to be decidable with elementary complexity.\n  Our main results are that both problems are coNP-complete. In the case of\nsemilinear sets, coNP-completeness holds regardless of whether the input sets\nare specified by existential Presburger formulas, quantifier-free formulas, or\nsemilinear representations. Our results imply that recognizable separability of\nrational subsets of $\\Sigma^*\\times\\mathbb{N}^d$ (shown decidable by Choffrut\nand Grigorieff) is coNP-complete as well. Another application is that\nregularity of deterministic Parikh automata (where the target set is specified\nusing a quantifier-free Presburger formula) is coNP-complete as well.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.00548v1"
    },
    {
        "title": "A Naturally-Colored Translation from LTL to Parity and COCOA",
        "authors": [
            "Rüdiger Ehlers",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Chains of co-B\\\"uchi automata (COCOA) have recently been introduced as a new\ncanonical representation of omega-regular languages. The co-B\\\"uchi automata in\na chain assign to each omega-word its natural color, which depends only on the\nlanguage itself and not on its automaton representation. The automata in such a\nchain can be minimized in polynomial time and are good-for-games, making the\nrepresentation attractive for verification and reactive synthesis applications.\nHowever, since in such applications, a specification is usually given in linear\ntemporal logic (LTL), to make COCOA useful, the specification first has to be\ntranslated into such a chain of automata. The only currently known translation\nprocedure goes through deterministic parity automata (LTL to DPW to COCOA),\nwhere the first step neglects the natural colors and requires intricate\nconstructions by Safra or Esparza et al. This observation raises the question\nwhether with the help of the definition of the natural color of words, such\ncomplex constructions can be avoided, leading to a more direct translation from\nLTL to COCOA.\n  In this paper, we describe a surprisingly simple yet optimal translation from\nLTL to COCOA and a variant of it that translates from LTL to deterministic\nparity automata. It constitutes a novel path for translating from LTL to DPW as\nthe translation procedure does not use any of the aforementioned intricate\nconstructions. Instead, our procedure relies on standard operations on weak\nalternating automata, Miyano/Hayashi's breakpoint construction, an augmented\nsubset construction, and some simple graph algorithms. With weak alternating\nautomata as starting point, the procedure can also be applied to specifications\nin linear dynamic logic. The translation procedure runs in\nasymptotically-optimal doubly-exponential time and computes automata of\nasymptotically optimal size.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.01021v1"
    },
    {
        "title": "Active Learning of Deterministic Transducers with Outputs in Arbitrary\n  Monoids",
        "authors": [
            "Quentin Aristote"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study monoidal transducers, transition systems arising as deterministic\nautomata whose transitions also produce outputs in an arbitrary monoid, for\ninstance allowing outputs to commute or to cancel out. We use the categorical\nframework for minimization and learning of Colcombet, Petri\\c{s}an and Stabile\nto recover the notion of minimal transducer recognizing a language, and give\nnecessary and sufficient conditions on the output monoid for this minimal\ntransducer to exist and be unique (up to isomorphism). The categorical\nframework then provides an abstract algorithm for learning it using membership\nand equivalence queries, and we discuss practical aspects of this algorithm's\nimplementation.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.01590v1"
    },
    {
        "title": "Execution-time opacity problems in one-clock parametric timed automata",
        "authors": [
            "Étienne André",
            "Johan Arcile",
            "Engel Lefaucheux"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Parametric timed automata (PTAs) extend the concept of timed automata, by\nallowing timing delays not only specified by concrete values but also by\nparameters, allowing the analysis of systems with uncertainty regarding timing\nbehaviors. The full execution-time opacity is defined as the problem in which\nan attacker must never be able to deduce whether some private location was\nvisited, by only observing the execution time. The problem of full ET-opacity\nemptiness (i.e., the emptiness over the parameter valuations for which full\nexecution-time opacity is satisfied) is known to be undecidable for general\nPTAs. We therefore focus here on one-clock PTAs with integer-valued parameters\nover dense time. We show that the full ET-opacity emptiness is undecidable for\na sufficiently large number of parameters, but is decidable for a single\nparameter, and exact synthesis can be effectively achieved. Our proofs rely on\na novel construction as well as on variants of Presburger arithmetics. We\nfinally prove an additional decidability result on an existential variant of\nexecution-time opacity.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.01659v1"
    },
    {
        "title": "A Myhill-Nerode style Characterization for Timed Automata With Integer\n  Resets",
        "authors": [
            "Kyveli Doveri",
            "Pierre Ganty",
            "B. Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The well-known Nerode equivalence for finite words plays a fundamental role\nin our understanding of the class of regular languages. The equivalence leads\nto the Myhill-Nerode theorem and a canonical automaton, which in turn, is the\nbasis of several automata learning algorithms. A Nerode-like equivalence has\nbeen studied for various classes of timed languages.\n  In this work, we focus on timed automata with integer resets. This class is\nknown to have good automata-theoretic properties and is also useful for\npractical modeling. Our main contribution is a Nerode-style equivalence for\nthis class that depends on a constant K. We show that the equivalence leads to\na Myhill-Nerode theorem and a canonical one-clock integer-reset timed automaton\nwith maximum constant K. Based on the canonical form, we develop an\nAngluin-style active learning algorithm whose query complexity is polynomial in\nthe size of the canonical form.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.02464v1"
    },
    {
        "title": "Non-deterministic asynchronous automata games and their undecidability",
        "authors": [
            "Bharat Adsul",
            "Nehul Jain"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We propose a new model of a distributed game, called an ATS game, which is\nplayed on a non-deterministic asynchronous transition system -- a natural\ndistributed finite-state device working on Mazurkiewicz traces. This new\npartial-information game is played between an environment and a distributed\nsystem comprising multiple processes.\n  A distributed strategy uses causal past to make the next move. The key\nalgorithmic question is to solve the game, that is, to decide the existence of\na distributed winning strategy.\n  It turns out ATS games are equivalent to asynchronous games, which are known\nto be undecidable. We prove that ATS games are undecidable in this article.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.04420v1"
    },
    {
        "title": "On the Complexity of Computing the Co-lexicographic Width of a Regular\n  Language",
        "authors": [
            "Ruben Becker",
            "Davide Cenzato",
            "Sung-Hwan Kim",
            "Tomasz Kociumaka",
            "Bojana Kodric",
            "Alberto Policriti",
            "Nicola Prezza"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Co-lex partial orders were recently introduced in (Cotumaccio et al., SODA\n2021 and JACM 2023) as a powerful tool to index finite state automata, with\napplications to regular expression matching. They generalize Wheeler orders\n(Gagie et al., Theoretical Computer Science 2017) and naturally reflect the\nco-lexicographic order of the strings labeling source-to-node paths in the\nautomaton. Briefly, the co-lex width $p$ of a finite-state automaton measures\nhow sortable its states are with respect to the co-lex order among the strings\nthey accept. Automata of co-lex width $p$ can be compressed to $O(\\log p)$ bits\nper edge and admit regular expression matching algorithms running in time\nproportional to $p^2$ per matched character.\n  The deterministic co-lex width of a regular language $\\mathcal L$ is the\nsmallest width of such a co-lex order, among all DFAs recognizing $\\mathcal L$.\nSince languages of small co-lex width admit efficient solutions to automata\ncompression and pattern matching, computing the co-lex width of a language is\nrelevant in these applications. The paper introducing co-lex orders determined\nthat the deterministic co-lex width $p$ of a language $\\mathcal L$ can be\ncomputed in time proportional to $m^{O(p)}$, given as input any DFA $\\mathcal\nA$ for $\\mathcal L$, of size (number of transitions) $m =|\\mathcal A|$.\n  In this paper, using new techniques, we show that it is possible to decide in\n$O(m^p)$ time if the deterministic co-lex width of the language recognized by a\ngiven minimum DFA is strictly smaller than some integer $p\\ge 2$. We complement\nthis upper bound with a matching conditional lower bound based on the Strong\nExponential Time Hypothesis. The problem is known to be PSPACE-complete when\nthe input is an NFA (D'Agostino et al., Theoretical Computer Science 2023);\nthus, together with that result, our paper essentially settles the complexity\nof the problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.04771v1"
    },
    {
        "title": "Synthesis from LTL with Reward Optimization in Sampled Oblivious\n  Environments",
        "authors": [
            "Jean-François Raskin",
            "Yun Chen Tsai"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper addresses the synthesis of reactive systems that enforce hard\nconstraints while optimizing for quality-based soft constraints. We build on\nrecent advancements in combining reactive synthesis with example-based guidance\nto handle both types of constraints in stochastic, oblivious environments\naccessible only through sampling. Our approach constructs examples that satisfy\nLTL-based hard constraints while maximizing expected rewards-representing the\nsoft constraints-on samples drawn from the environment. We formally define this\nsynthesis problem, prove it to be NP-complete, and propose an SMT-based\nsolution, demonstrating its effectiveness with a case study.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.08599v1"
    },
    {
        "title": "Expressivity of Linear Temporal Logic for Pomset Languages of Higher\n  Dimensional Automata",
        "authors": [
            "Emily Clement",
            "Enzo Erlich",
            "Jérémy Ledent"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Temporal logics are a powerful tool to specify properties of computational\nsystems. For concurrent programs, Higher Dimensional Automata (HDA) are a very\nexpressive model of non-interleaving concurrency. HDA recognize languages of\npartially ordered multisets, or pomsets. Recent work has shown that Monadic\nSecond Order (MSO) logic is as expressive as HDA for pomset languages. In this\npaper, we investigate the class of pomset languages that are definable in First\nOrder (FO) logic. As expected, this is a strict subclass of MSO-definable\nlanguages. In the case of words, Kamp's theorem states that FO is as expressive\nas Linear Temporal Logic (LTL). Our aim is to prove a variant of Kamp's theorem\nfor pomset languages. Thus, we define a temporal logic called Sparse Pomset\nTemporal Logic (SPTL), and show that it is equivalent to FO, when there is no\nautoconcurrency.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.12493v1"
    },
    {
        "title": "Algebraic Language Theory with Effects",
        "authors": [
            "Fabian Birkmann",
            "Stefan Milius",
            "Henning Urbat",
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Regular languages - the languages accepted by deterministic finite automata -\nare known to be precisely the languages recognized by finite monoids. This\ncharacterization is the origin of algebraic language theory. In the present\npaper, we generalize this result to automata with computational effects given\nby a monad, thereby providing the foundations of an effectful algebraic\nlanguage theory. Our prime application is a novel algebraic approach to\nlanguages computed by probabilistic finite automata, which are shown to\ncoincide with (1) languages recognized by finite monoids via probabilistic\nmonoid morphisms, and (2) languages recognized by convex monoids based on\nfinitely generated convex sets. Further characterizations are derived for\nnondeterministic probabilistic finite automata, and weighted finite automata\nover arbitrary semirings.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.12569v1"
    },
    {
        "title": "Computing measures of weak-MSO definable sets of trees",
        "authors": [
            "Damian Niwiński",
            "Marcin Przybyłko",
            "Michał Skrzypczak"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  his work addresses the problem of computing measures of recognisable sets of\ninfinite trees. An algorithm is provided to compute the probability measure of\na tree language recognisable by a weak alternating automaton, or equivalently\ndefinable in weak monadic second-order logic. The measure is the uniform\ncoin-flipping measure or more generally it is generated by a~branching\nstochastic process. The class of tree languages in consideration, although\nsmaller than all regular tree languages, comprises in particular the languages\ndefinable in the alternation-free mu-calculus or in temporal logic CTL. Thus,\nthe new algorithm may enhance the toolbox of probabilistic model checking.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.13479v1"
    },
    {
        "title": "A Uniform Framework for Problems on Context-Free Grammars",
        "authors": [
            "Javier Esparza",
            "Peter Rossmanith",
            "Stefan Schwoon"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In a paper published in Information Processing Letters in 2000, Bouajjani et\nal. presented an automata-based approach to a number of elementary problems on\ncontext-free grammars. This approach is of pedagogical interest since it\nprovides a uniform solution to decision procedures usually solved by\nindependent algorithms in textbooks. This paper improves upon the work by\nBouajjani et al. in a number of ways. We present a new algorithm which not only\nhas a better space complexity but is also (in our opinion) easier to read and\nunderstand. Moreover, a closer inspection reveals that the new algorithm is\ncompetitive to well-known solutions for most (but not all) standard problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.19386v1"
    },
    {
        "title": "Deterministic Suffix-reading Automata",
        "authors": [
            "R Keerthan",
            "B Srivathsan",
            "R Venkatesh",
            "Sagar Verma"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce deterministic suffix-reading automata (DSA), a new automaton\nmodel over finite words. Transitions in a DSA are labeled with words. From a\nstate, a DSA triggers an outgoing transition on seeing a word ending with the\ntransition's label. Therefore, rather than moving along an input word letter by\nletter, a DSA can jump along blocks of letters, with each block ending in a\nsuitable suffix. This feature allows DSAs to recognize regular languages more\nconcisely, compared to DFAs. In this work, we focus on questions around finding\na \"minimal\" DSA for a regular language. The number of states is not a faithful\nmeasure of the size of a DSA, since the transition-labels contain strings of\narbitrary length. Hence, we consider total-size (number of states + number of\nedges + total length of transition-labels) as the size measure of DSAs.\n  We start by formally defining the model and providing a DSA-to-DFA conversion\nthat allows to compare the expressiveness and succinctness of DSA with related\nautomata models. Our main technical contribution is a method to derive DSAs\nfrom a given DFA: a DFA-to-DSA conversion. We make a surprising observation\nthat the smallest DSA derived from the canonical DFA of a regular language L\nneed not be a minimal DSA for L. This observation leads to a fundamental\nbottleneck in deriving a minimal DSA for a regular language. In fact, we prove\nthat given a DFA and a number k, the problem of deciding if there exists an\nequivalent DSA of total-size at most k is NP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.22761v1"
    },
    {
        "title": "Two-Way One-Counter Nets Revisited",
        "authors": [
            "Shaull Almagor",
            "Michaël Cadilhac",
            "Asaf Yeshurun"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  One Counter Nets (OCNs) are finite-state automata equipped with a counter\nthat cannot become negative, but cannot be explicitly tested for zero. Their\nclose connection to various other models (e.g., PDAs, Vector Addition Systems,\nand Counter Automata) make them an attractive modeling tool. The two-way\nvariant of OCNs (2-OCNs) was introduced in the 1980's and shown to be more\nexpressive than OCNs, so much so that the emptiness problem is undecidable\nalready in the deterministic model (2-DOCNs). In a first part, we study the\nemptiness problem of natural restrictions of 2-OCNs, under the light of modern\nresults about Vector Addition System with States (VASS). We show that emptiness\nis decidable for 2-OCNs over \\emph{bounded languages} i.e., languages contained\nin $a_1^*a_2^*\\cdots a_k^*$), and decidable and Ackermann-complete for\n\\emph{sweeping} 2-OCNs, where the head direction only changes at the\nend-markers. Both decidability results revolve around reducing the problem to\nVASS reachability, but they rely on strikingly different approaches.\n  In a second part, we study the expressive power of 2-OCNs, showing an array\nof connections between bounded languages, sweeping 2-OCNs, and semilinear\nlanguages. Most noteworthy among these connections, is that the bounded\nlanguages recognized by sweeping 2-OCNs are precisely those that are\nsemilinear. Finally, we establish an intricate pumping lemma for 2-DOCNs and\nuse it to show that there are OCN languages that are not 2-DOCN recognizable,\nimproving on the known result that there are such 2-OCN languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.22845v2"
    },
    {
        "title": "Explorable Parity Automata",
        "authors": [
            "Emile Hazard",
            "Olivier Idir",
            "Denis Kuperberg"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We define the class of explorable automata on finite or infinite words. This\nis a generalization of History-Deterministic (HD) automata, where this time\nnon-deterministic choices can be resolved by building finitely many\nsimultaneous runs instead of just one. We show that recognizing HD parity\nautomata of fixed index among explorable ones is in PTime, thereby giving a\nstrong link between the two notions. We then show that recognizing explorable\nautomata is ExpTime-complete, in the case of finite words or parity automata up\nto index [0, 2]. Additionally, we define the notion of {\\omega}-explorable\nautomata on infinite words, where countably many runs can be used to resolve\nthe non-deterministic choices. We show ExpTime-completeness for\n{\\omega}-explorability of automata on infinite words for the safety and\ncoB\\\"uchi acceptance conditions. We finally characterize the expressivity of\n({\\omega}-)explorable automata with respect to the parity index hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.23187v1"
    },
    {
        "title": "Static Analysis Framework for Detecting Use-After-Free Bugs in C++",
        "authors": [
            "Vlad-Alexandru Teodorescu",
            "Dorel Lucanu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Pointers are a powerful, but dangerous feature provided by the C and C++\nprogramming languages, and incorrect use of pointers is a common source of bugs\nand security vulnerabilities. Making secure software is crucial, as\nvulnerabilities exploited by malicious actors not only lead to monetary losses,\nbut possibly loss of human lives. Fixing these vulnerabilities is costly if\nthey are found at the end of development, and the cost will be even higher if\nfound after deployment. That is why it is desirable to find the bugs as early\nin the development process as possible. We propose a framework that can\nstatically find use-after-free bugs at compile-time and report the errors to\nthe users. It works by tracking the lifetime of objects and memory locations\npointers might point to and, using this information, a possibly invalid\ndereferencing of a pointer can be detected. The framework was tested on over\n100 handwritten small tests, as well as 5 real-world projects, and has shown\ngood results detecting errors, while at the same time highlighting some\nscenarios where false positive reports may occur. Based on the results, it was\nconcluded that our framework achieved its goals, as it is able to detect\nmultiple patterns of use-after-free bugs, and correctly report the errors to\nthe programmer.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.23764v1"
    },
    {
        "title": "Reachability in One-Dimensional Pushdown Vector Addition Systems is\n  Decidable",
        "authors": [
            "Clotilde Bizière",
            "Wojciech Czerwiński"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We consider the model of one-dimensional Pushdown Vector Addition Systems\n(1-PVAS), a fundamental computational model simulating both recursive and\nconcurrent behaviours. Our main result is decidability of the reachability\nproblem for 1-PVAS, an important open problem investigated for at least a\ndecade. In the algorithm we actually consider an equivalent model of Grammar\nVector Addition Systems (GVAS). We prove the main result by showing that for\nevery one-dimensional GVAS (1-GVAS) one can compute another 1-GVAS, which has\nthe same reachability relation as the original one and additionally has the\nso-called thin property. Due to the work of Atig and Ganty from 2011, thin\n1-GVAS have decidable reachability problem, therefore our construction implies\ndecidability of the problem for all 1-GVAS. Moreover, we also show that if\nreachability in thin 1-GVAS can be decided in elementary time then also\nreachability in all 1-GVAS can be decided in elementary time.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.02386v1"
    },
    {
        "title": "Equivalence of Deterministic Weighted Real-time One-Counter Automata",
        "authors": [
            "Prince Mathew",
            "Vincent Penelle",
            "Prakash Saivasan",
            "A. V. Sreejith"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper introduces deterministic weighted real-time one-counter automaton\n(DWROCA). A DWROCA is a deterministic real-time one-counter automaton whose\ntransitions are assigned a weight from a field. Two DWROCAs are equivalent if\nevery word accepted by one is accepted by the other with the same weight.\nDWROCA is a sub-class of weighted one-counter automata with\ncounter-determinacy. It is known that the equivalence problem for this model is\nin P. This paper gives a simpler proof and a better polynomial-time algorithm\nfor checking the equivalence of two DWROCAs.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.03066v2"
    },
    {
        "title": "Hybrid Rebeca Revisited",
        "authors": [
            "Saeed Zhiany",
            "Fatemeh Ghassemi",
            "Nesa Abbasimoghadam",
            "Ali Hodaei",
            "Ali Ataollahi",
            "József Kovács",
            "Erika Ábrahám",
            "Marjan Sirjani"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Hybrid Rebeca is introduced for modeling asynchronous event-based\nCyber-Physical Systems (CPSs). In this work, we extend Hybrid Rebeca to allow\nthe modeling of non-deterministic time behavior. We provide a set of rules to\ndefine the semantic model of Hybrid Rebeca models in terms of Time Transition\nSystems which represents an over-approximation of the reachable states of a\nHybrid Rebeca model. Then, we adapt the reachability analysis algorithm of\nFlow$^*$ for Hybrid Rebeca models leveraging our semantic rules. This improves\nthe analysis significantly because the previous technique relied on the\nreachability analysis of hybrid automata by deriving a monolithic hybrid\nautomaton from a given Hybrid Rebeca model, leading to a huge hybrid automaton.\nWe illustrate the applicability of our approach through a case study.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.03160v1"
    },
    {
        "title": "Vulnerabilities Analysis and Secure Controlling for Unmanned Aerial\n  System Based on Reactive Synthesis",
        "authors": [
            "Dong Yang",
            "Wei Dong",
            "Wei Lu",
            "Yanqi Dong",
            "Sirui Liu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Complex Cyber-Physical System (CPS) such as Unmanned Aerial System (UAS) got\nrapid development these years, but also became vulnerable to GPS spoofing,\npackets injection, buffer-overflow and other malicious attacks. Ensuring the\nbehaviors of UAS always keeping secure no matter how the environment changes,\nwould be a prospective direction for UAS security. This paper aims at\nintroducing a pattern-based framework to describe the security properties of\nUAS, and presenting a reactive synthesis-based approach to implement the\nautomatic generation of secure UAS controller. First, we study the operating\nmechanism of UAS and construct a high-level model consisting of actuator and\nmonitor. Besides, we analyze the security threats of UAS from the perspective\nof hardware, software and cyber physics, and then summarize the corresponding\nspecification patterns of security properties with LTL formulas. With the UAS\nmodel and security specification patterns, automatons for controller can be\nconstructed by General Reactivity of Rank 1 (GR(1)) synthesis algorithm, which\nis a two-player game process between Unmanned Aerial Vehicle (UAV) and its\nenvironment. Finally, we experimented under the Ardupilot simulation platform\nto test the effectiveness of our method.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.07741v2"
    },
    {
        "title": "Learning real-time one-counter automata using polynomially many queries",
        "authors": [
            "Prince Mathew",
            "Vincent Penelle",
            "A. V. Sreejith"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we introduce a novel method for active learning of\ndeterministic real-time one-counter automata (DROCA). The existing techniques\nfor learning DROCA rely on observing the behaviour of the DROCA up to\nexponentially large counter-values. Our algorithm eliminates this need and\nrequires only a polynomial number of queries. Additionally, our method differs\nfrom existing techniques as we learn a minimal counter-synchronous DROCA,\nresulting in much smaller counter-examples on equivalence queries. Learning a\nminimal counter-synchronous DROCA cannot be done in polynomial time unless P =\nNP, even in the case of visibly one-counter automata. We use a SAT solver to\novercome this difficulty. The solver is used to compute a minimal separating\nDFA from a given set of positive and negative samples.\n  We prove that the equivalence of two counter-synchronous DROCAs can be\nchecked significantly faster than that of general DROCAs. For visibly\none-counter automata, we have discovered an even faster algorithm for\nequivalence checking. We implemented the proposed learning algorithm and tested\nit on randomly generated DROCAs. Our evaluations show that the proposed method\noutperforms the existing techniques on the test set.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.08815v1"
    },
    {
        "title": "A hierarchy of reversible finite automata",
        "authors": [
            "Maria Radionova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, different variants of reversible finite automata are compared,\nand their hierarchy by the expressive power is established. It is shown that\none-way reversible automata with multiple initial states (MRFA) recognize\nstrictly more languages than sweeping reversible automata (sRFA), which are in\nturn stronger than one-way reversible automata with a single initial state\n(1RFA). The latter recognize strictly more languages than one-way permutation\nautomata (1PerFA). It is also shown that the hierarchy of sRFA by the number of\npasses over the input string collapses: it turns out that three passes are\nalways enough. On the other hand, MRFA form a hierarchy by the number of\ninitial states: their subclass with at most $k$ initial states (MRFA$^k$)\nrecognize strictly fewer languages than MRFA$^{k + 1}$, and also MRFA$^k$ are\nincomparable with sRFA. In the unary case, sRFA, MRFA$^k$ and MRFA become equal\nin their expressive power, and the inclusion of 1RFA into sRFA remains proper.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.14538v1"
    },
    {
        "title": "On Computational Completeness of Semi-Conditional Matrix Grammars",
        "authors": [
            "Henning Fernau",
            "Lakshmanan Kuppusamy",
            "Indhumathi Raman"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Matrix grammars are one of the first approaches ever proposed in regulated\nrewriting, prescribing that rules have to be applied in a certain order.\nOriginally, they have been introduced by \\'Abrah\\'am on linguistic grounds. In\ntraditional regulated rewriting, the most interesting case shows up when all\nrules are context-free. Typical descriptional complexity measures incorporate\nthe number of nonterminals or the matrix length, i.e., the number of rules per\nmatrix. When viewing matrices as program fragments, it becomes natural to\nconsider additional applicability conditions for such matrices. Here, we focus\non attaching a permitting and a forbidden string to every matrix in a matrix\ngrammar. The matrix is applicable to a sentential form~$w$ only if the\npermitting string is a subword in~$w$ and the forbidden string is not a subword\nin~$w$. We call such a grammar, where the application of a matrix is\nconditioned as described, a semi-conditional matrix grammar. We consider $(1)$\nthe maximal lengths of permitting and forbidden strings, $(2)$ the number of\nnonterminals, $(3)$ the number of conditional matrices, $(4)$ the maximal\nlength of any matrix and $(5)$ the number of conditional matrices with nonempty\npermitting and forbidden strings, as the resources (descriptional complexity\nmeasures) of a semi-conditional matrix grammar.\n  In this paper, we show that certain semi-conditional matrix grammar families\ndefined by restricting resources can generate all of the recursively enumerable\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.15338v1"
    },
    {
        "title": "Nondeterministic tree-walking automata are not closed under\n  complementation",
        "authors": [
            "Olga Martynova",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  It is proved that the family of tree languages recognized by nondeterministic\ntree-walking automata is not closed under complementation, solving a problem\nraised by Boja\\'nczyk and Colcombet (\"Tree-walking automata do not recognize\nall regular languages\", SIAM J. Comp. 38 (2008) 658--701). In addition, it is\nshown that nondeterministic tree-walking automata are stronger than unambiguous\ntree-walking automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.02618v1"
    },
    {
        "title": "Responsibility in Actor-Based Systems",
        "authors": [
            "Christel Baier",
            "Sascha Klüppelholz",
            "Johannes Lehmann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The enormous growth of the complexity of modern computer systems leads to an\nincreasing demand for techniques that support the comprehensibility of systems.\nThis has motivated the very active research field of formal methods that\nenhance the understanding of why systems behave the way they do. One important\nline of research within the verification community relies on formal notions\nthat measure the degree of responsibility of different actors. In this paper,\nwe first provide a uniform presentation of recent work on responsibility\nnotions based on Shapley values for reactive systems modeled by transition\nsystems and considering safety properties. The paper then discusses how to use\nthese formal responsibility notions and corresponding algorithms for three\ndifferent types of actor sets: the module-based notion serves to reason about\nthe impact of system components on the satisfaction or violation of a safety\nproperty. Responsibility values for value-based actor sets and action-based\nactors allow for the identification of program instructions and control points\nthat have the most influence on a specification violation. Beyond the\ntheoretical considerations, this paper reports on experimental results that\nprovide initial insights into applicability and scalability.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.05162v1"
    },
    {
        "title": "Probabilistic Finite Automaton Emptiness is Undecidable for a Fixed\n  Automaton",
        "authors": [
            "Günter Rote"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We construct a probabilistic finite automaton (PFA) with 7 states and an\ninput alphabet of 5 symbols for which the PFA Emptiness Problem is undecidable.\nThe only input for the decision problem is the starting distribution. For the\nproof, we use reductions from special instances of the Post Correspondence\nProblem.\n  We also consider some variations: The input alphabet of the PFA can be\nrestricted to a binary alphabet at the expense of a larger number of states. If\nwe allow a rational output value for each state instead of a yes-no acceptance\ndecision, the number of states can even be reduced to 6.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.05198v1"
    },
    {
        "title": "Digging for Decision Trees: A Case Study in Strategy Sampling and\n  Learning",
        "authors": [
            "Carlos E. Budde",
            "Pedro R. D'Argenio",
            "Arnd Hartmanns"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce a formal model of transportation in an open-pit mine for the\npurpose of optimising the mine's operations. The model is a network of Markov\nautomata (MA); the optimisation goal corresponds to maximising a time-bounded\nexpected reward property. Today's model checking algorithms exacerbate the\nstate space explosion problem by applying a discretisation approach to such\nproperties on MA. We show that model checking is infeasible even for small mine\ninstances. Instead, we propose statistical model checking with lightweight\nstrategy sampling or table-based Q-learning over untimed strategies as an\nalternative to approach the optimisation task, using the Modest Toolset's modes\ntool. We add support for partial observability to modes so that strategies can\nbe based on carefully selected model features, and we implement a connection\nfrom modes to the dtControl tool to convert sampled or learned strategies into\ndecision trees. We experimentally evaluate the adequacy of our new tooling on\nthe open-pit mine case study. Our experiments demonstrate the limitations of\nQ-learning, the impact of feature selection, and the usefulness of decision\ntrees as an explainable representation.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.05476v1"
    },
    {
        "title": "A lower bound on the state complexity of transforming two-way\n  nondeterministic finite automata to unambiguous finite automata",
        "authors": [
            "Semyon Petrov",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper establishes a lower bound on the number of states necessary in the\nworst case to simulate an $n$-state two-way nondeterministic finite automaton\n(2NFA) by a one-way unambiguous finite automaton (UFA). It is proved that for\nevery $n$, there is a language recognized by an $n$-state 2NFA that requires a\nUFA with at least $\\sum_{k=1}^{n} (k - 1)! \\cdot k! \\cdot \\mathrm{stirling2}(n,\nk) \\cdot \\mathrm{stirling2}(n+1, k)$ = $\\Omega \\big( n^{2n+2} / e^{2n} \\big)$\nstates, where $\\mathrm{stirling2}(n, k)$ denotes Stirling's numbers of the\nsecond kind. This result is proved by estimating the rank of a certain matrix,\nwhich is constructed for the universal language for $n$-state 2NFAs, and\ndescribes every possible behaviour of these automata during their computation.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.06283v1"
    },
    {
        "title": "Checking Timed Bisimilarity with Virtual Clocks",
        "authors": [
            "Alexander Lieb",
            "Hendrik Göttmann",
            "Lars Luthmann",
            "Malte Lochau",
            "Andy Schürr"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Timed automata are a widely used formalism for specifying\ndiscrete-state/continuous-time behaviors of time-critical reactive systems.\nConcerning the fundamental verification problem of comparing a candidate\nimplementation against a specification, both given as timed automata over the\nsame alphabet, it has been shown that timed trace equivalence is undecidable,\nwhereas timed bisimulation equivalence is decidable. The corresponding\ndecidability proof utilizes region graphs, a finite but often unnecessarily\nspace-consuming characterization of timed automata semantics. In practice, most\nverification tools use zone graphs instead, a symbolic and, on average, more\nspace-efficient representation of timed automata semantics. However, zone\ngraphs only provide sound results for those verification tasks being reducible\nto plain location-reachability problems thus being too imprecise for\ntimed-bisimilarity checking. In particular, potentially distinctive effects of,\nby definition invisible, clock resets on the subsequent branching behaviors in\na timed run may be abstracted away in a zone graph representation if this does\nnot harm global reachability properties. As a consequence, to the best of our\nknowledge, no practical tool is currently available for automated\ntimed-bisimilarity checking. In this paper, we propose a new representation of\ntimed automata semantics to enable sound and complete timed bisimilarity\nchecking, yet still guaranteeing a finite representation. To this end, we\nextend zone graphs by so-called virtual clocks to memorize previous delays,\nwhich is usually not possible due to clock resets. Our zone-based construction\nis, on average, significantly smaller than the corresponding region-graph\nrepresentation. We also present experimental results gained from applying our\ntool implementation to TA models, which are frequently used in the evaluation\nof TA analysis techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.15799v1"
    },
    {
        "title": "On the piecewise complexity of words",
        "authors": [
            "Philippe Schnoebelen",
            "Isa Vialard"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The piecewise complexity $h(u)$ of a word is the minimal length of subwords\nneeded to exactly characterise $u$. Its piecewise minimality index $\\rho(u)$ is\nthe smallest length $k$ such that $u$ is minimal among its order-$k$ class\n$[u]_k$ in Simon's congruence. We initiate a study of these two descriptive\ncomplexity measures. Among other results we provide efficient algorithms for\ncomputing $h(u)$ and $\\rho(u)$ for a given word $u$.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.16560v1"
    },
    {
        "title": "Mostowski Index via extended register games",
        "authors": [
            "Olivier Idir",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The parity index problem of tree automata asks, given a regular tree language\nL, what is the least number of priorities of a nondeterministic parity tree\nautomaton that recognises L. This is a long-standing open problem, also known\nas the Mostowski or Rabin-Mostowski index problem, of which only a few\nsub-cases and variations are known to be decidable. In a significant step,\nColcombet and L\\\"oding reduced the problem to the uniform universality of\ndistance-parity automata. In this brief note, we present a similar result, with\na simplified proof, based on on the games in Lehtinen's quasipolynomial\nalgorithm for parity games.\n  We define an extended version of these games, which we call parity\ntransduction games, which take as parameters a parity index J and an integer\nbound N. We show that the language of a guidable automaton A is recognised by a\nnondeterministic automaton of index J if and only if there is a bound N such\nthat the parity transduction game with parameters J and N captures membership\nof the language, that is, for all trees t, Eve wins the parity transduction\ngame on the acceptance parity game of t in A if and only in t is in L(A).\n",
        "pdf_link": "http://arxiv.org/pdf/2412.16793v1"
    },
    {
        "title": "Asynchronism in Cellular Automata",
        "authors": [
            "Virendra Kumar Gautam"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  This study introduces Skewed Fully Asynchronous Cellular Automata (SACA), a\nnovel update scheme in cellular automata that updates the states of only two\nconsecutive and adjacent cells, such as ci and ci+1, simultaneously at each\ntime step. The behavior and dynamics of elementary cellular automata (ECA)\nunder this scheme are analyzed and compared with those of synchronous and fully\nasynchronous update methods. The comparative analysis highlights a range of\nphenomena, including transitions in ECAs from convergent or non-reversible\ndynamics to reversible, divergent behavior. The divisibility of lattice size by\n2 or 4 is shown to have significant effects on the system dynamics, linked to\nthe presence or absence of atomicity. The study also explores the convergence\nof ECAs to all-zero or all-one point attractors under SACA, providing\ntheoretical insights that align with experimental findings.\n  Additionally, the research investigates the application of fully asynchronous\ncellular automata in solving clustering problems. Clustering is defined as\ngrouping objects with similar properties. The proposed method employs\nreversible asynchronous cellular automata to merge clusters iteratively based\non their closeness, continuing until the desired number of clusters is\nachieved. This approach leverages a small set of rules, leading to faster\nconvergence and efficiency in clustering tasks. The findings underscore the\npotential of asynchronous cellular automata as a versatile and effective\nframework for studying complex system dynamics and solving practical problems\nsuch as clustering.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.02578v1"
    },
    {
        "title": "Active Learning Techniques for Pomset Recognizers",
        "authors": [
            "Adrien Pommellet",
            "Amazigh Amrane",
            "Edgar Delaporte"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  Pomsets are a promising formalism for concurrent programs based on partially\nordered sets. Among this class, series-parallel pomsets admit a convenient\nlinear representation and can be recognized by simple algebraic structures\nknown as pomset recognizers. Active learning consists in inferring a formal\nmodel of a recognizable language by asking membership and equivalence queries\nto a minimally adequate teacher (MAT). We improve existing learning algorithms\nfor pomset recognizers by 1. introducing a new counter-example analysis\nprocedure that is in the best case scenario exponentially more efficient than\nexisting methods 2. adapting the state-of-the-art $L^{\\lambda}$ algorithm to\nminimize the impact of exceedingly verbose counter-examples and remove\nredundant queries 3. designing a suitable finite test suite that ensures\ngeneral equivalence between two pomset recognizers by extending the well-known\nW-method.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.03914v1"
    },
    {
        "title": "An Automata-Based Method to Formalize Psychological Theories -- The Case\n  Study of Lazarus and Folkman's Stress Theory",
        "authors": [
            "Alain Finkel",
            "Gaspard Fougea",
            "Stéphane Le Roux"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  Formal models are important for theory-building, enhancing the precision of\npredictions and promoting collaboration. Researchers have argued that there is\na lack of formal models in psychology. We present an automata-based method to\nformalize psychological theories, i.e. to transform verbal theories into formal\nmodels. This approach leverages the tools of theoretical computer science for\nformal theory development, for verification, comparison, collaboration, and\nmodularity. We exemplify our method on Lazarus and Folkman's theory of stress,\nshowcasing a step-by-step modeling of the theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.05185v1"
    },
    {
        "title": "Well-Quasi-Orderings on Word Languages",
        "authors": [
            "Nathan Lhote",
            "Aliaume Lopez",
            "Lia Schütze"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  The set of finite words over a well-quasi-ordered set is itself\nwell-quasi-ordered. This seminal result by Higman is a cornerstone of the\ntheory of well-quasi-orderings and has found numerous applications in computer\nscience. However, this result is based on a specific choice of ordering on\nwords, the (scattered) subword ordering. In this paper, we describe to what\nextent other natural orderings (prefix, suffix, and infix) on words can be used\nto derive Higman-like theorems. More specifically, we are interested in\ncharacterizing languages of words that are well-quasi-ordered under these\norderings. We show that a simple characterization is possible for the prefix\nand suffix orderings, and that under extra regularity assumptions, this also\nextends to the infix ordering. We furthermore provide decision procedures for a\nlarge class of languages, that contains regular and context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.07428v1"
    },
    {
        "title": "Uniform Membership for Hyperedge Replacement Grammars and Related\n  Decision Problems",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  We investigate complexity of the uniform membership problem for hyperedge\nreplacement grammars in comparison with other mildly context-sensitive grammar\nformalisms. It turns out that the complexity of the problem considered depends\nheavily on how one defines a hypergraph. There are two commonly used\ndefinitions in the field which differ in whether repetitions of attachment\nnodes of a hyperedge are allowed in a hypergraph or not. We show that, if\nrepetitions are allowed, then the problem under consideration is\nEXPTIME-complete even for string-generating hyperedge replacement grammars\nwhile it is NP-complete if repetitions are disallowed. We also prove that\nchecking whether a hyperedge replacement grammar is string-generating is\nEXPTIME-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.08082v1"
    },
    {
        "title": "Mining Diamonds in labeled Transition Systems",
        "authors": [
            "P. H. M. van Spaendonck",
            "K. H. J. Jilissen"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  Labeled transition systems can be a great way to visualize the complex\nbehavior of parallel and communicating systems. However, if, during a\nparticular timeframe, no synchronization or communication between processes\noccurs, then multiple parallel sequences of actions are able to interleave\narbitrarily, and the resulting graph quickly becomes too complex for the human\neye to understand easily. With that in mind, we propose an exact formalization\nof these arbitrary interleavings, and an algorithm to find all said\ninterleavings in deterministic LTSs, to reduce the visual complexity of labeled\ntransition systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.08689v1"
    },
    {
        "title": "Decidability of the Equivalence of Multi-Letter Quantum Finite Automata",
        "authors": [
            "Daowen Qiu",
            "Xiangfu Zou",
            "Lvzhou Li",
            "Paulo Mateus"
        ],
        "category": "cs.FL",
        "published_year": "2008",
        "summary": "  Multi-letter {\\it quantum finite automata} (QFAs) were a quantum variant of\nclassical {\\it one-way multi-head finite automata} (J. Hromkovi\\v{c}, Acta\nInformatica 19 (1983) 377-384), and it has been shown that this new one-way\nQFAs (multi-letter QFAs) can accept with no error some regular languages\n$(a+b)^{*}b$ that are unacceptable by the previous one-way QFAs. In this paper,\nwe study the decidability of the equivalence of multi-letter QFAs, and the main\ntechnical contributions are as follows: (1) We show that any two automata, a\n$k_{1}$-letter QFA ${\\cal A}_1$ and a $k_{2}$-letter QFA ${\\cal A}_2$, over the\nsame input alphabet $\\Sigma$ are equivalent if and only if they are\n$(n^2m^{k-1}-m^{k-1}+k)$-equivalent, where $m=|\\Sigma|$ is the cardinality of\n$\\Sigma$, $k=\\max(k_{1},k_{2})$, and $n=n_{1}+n_{2}$, with $n_{1}$ and $n_{2}$\nbeing the numbers of states of ${\\cal A}_{1}$ and ${\\cal A}_{2}$, respectively.\nWhen $k=1$, we obtain the decidability of equivalence of measure-once QFAs in\nthe literature. It is worth mentioning that our technical method is essentially\ndifferent from that for the decidability of the case of single input alphabet\n(i.e., $m=1$). (2) However, if we determine the equivalence of multi-letter\nQFAs by checking all strings of length not more than $ n^2m^{k-1}-m^{k-1}+k$,\nthen the worst time complexity is exponential, i.e.,\n$O(n^6m^{n^2m^{k-1}-m^{k-1}+2k-1})$. Therefore, we design a polynomial-time\n$O(m^{2k-1}n^{8}+km^kn^{6})$ algorithm for determining the equivalence of any\ntwo multi-letter QFAs. Here, the time complexity is concerning the number of\nstates in the multi-letter QFAs, and $k$ is thought of as a constant.\n",
        "pdf_link": "http://arxiv.org/pdf/0812.1061v6"
    },
    {
        "title": "Weak Mso with the Unbounding Quantifier",
        "authors": [
            "Mikolaj Bojanczyk"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A new class of languages of infinite words is introduced, called the\nmax-regular languages, extending the class of $\\omega$-regular languages. The\nclass has two equivalent descriptions: in terms of automata (a type of\ndeterministic counter automaton), and in terms of logic (weak monadic\nsecond-order logic with a bounding quantifier). Effective translations between\nthe logic and automata are given.\n",
        "pdf_link": "http://arxiv.org/pdf/0902.1042v1"
    },
    {
        "title": "Ambiguity and Communication",
        "authors": [
            "Juraj Hromkovic",
            "Georg Schnitger"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The ambiguity of a nondeterministic finite automaton (NFA) N for input size n\nis the maximal number of accepting computations of N for an input of size n.\nFor all k, r 2 N we construct languages Lr,k which can be recognized by NFA's\nwith size k poly(r) and ambiguity O(nk), but Lr,k has only NFA's with\nexponential size, if ambiguity o(nk) is required. In particular, a hierarchy\nfor polynomial ambiguity is obtained, solving a long standing open problem\n(Ravikumar and Ibarra, 1989, Leung, 1998).\n",
        "pdf_link": "http://arxiv.org/pdf/0902.2140v1"
    },
    {
        "title": "Büchi complementation made tight",
        "authors": [
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The precise complexity of complementing B\\\"uchi automata is an intriguing and\nlong standing problem. While optimal complementation techniques for finite\nautomata are simple - it suffices to determinize them using a simple subset\nconstruction and to dualize the acceptance condition of the resulting automaton\n- B\\\"uchi complementation is more involved. Indeed, the construction of an\nEXPTIME complementation procedure took a quarter of a century from the\nintroduction of B\\\"uchi automata in the early 60s, and stepwise narrowing the\ngap between the upper and lower bound to a simple exponent (of (6e)n for\nB\\\"uchi automata with n states) took four decades. While the distance between\nthe known upper (O'(0.96 n)n') and lower ('(0.76 n)n') bound on the required\nnumber of states has meanwhile been significantly reduced, an exponential\nfactor remains between them. Also, the upper bound on the size of the\ncomplement automaton is not linear in the bound of its state space. These gaps\nare unsatisfactory from a theoretical point of view, but also because B\\\"uchi\ncomplementation is a useful tool in formal verification, in particular for the\nlanguage containment problem. This paper proposes a B\\\"uchi complementation\nalgorithm whose complexity meets, modulo a quadratic (O(n2)) factor, the known\nlower bound for B\\\"uchi complementation. It thus improves over previous\nconstructions by an exponential factor and concludes the quest for optimal\nB\\\"uchi complementation algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/0902.2152v1"
    },
    {
        "title": "Pseudorandom Generators Against Advised Context-Free Languages",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Pseudorandomness has played a central role in modern cryptography, finding\ntheoretical and practical applications to various fields of computer science. A\nfunction that generates pseudorandom strings from shorter but truly random\nseeds is known as a pseudorandom generator. Our generators are designed to fool\nlanguages (or equivalently, Boolean-valued functions). In particular, our\ngenerator fools advised context-free languages, namely, context-free languages\nassisted by external information known as advice, and moreover our generator is\nmade almost one-to-one, stretching $n$-bit seeds to $n+1$ bits. We explicitly\nconstruct such a pseudorandom generator, which is computed by a deterministic\nTuring machine using logarithmic space and also belongs to CFLMV(2)/n---a\nfunctional extension of the 2-conjunctive closure of CFL with the help of\nappropriate deterministic advice. In contrast, we show that there is no almost\none-to-one pseudorandom generator against context-free languages if we demand\nthat it should be computed by a nondeterministic pushdown automaton equipped\nwith a write-only output tape. Our generator naturally extends known\npseudorandom generators against advised regular languages. Our proof of the\nCFL/n-pseudorandomness of the generator is quite elementary, and in particular,\none part of the proof utilizes a special feature of the behaviors of\nnondeterministic pushdown automata, called a swapping property, which is\ninteresting in its own right, generalizing the swapping lemma for context-free\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/0902.2774v4"
    },
    {
        "title": "A new universal cellular automaton on the ternary heptagrid",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper, we construct a new weakly universal cellular automaton on the\nternary heptagrid. The previous result, obtained by the same author and Y. Song\nrequired six states only. This time, the number of states is four. This is the\nbest result up to date for cellular automata in the hyperbolic plane.\n",
        "pdf_link": "http://arxiv.org/pdf/0903.2108v1"
    },
    {
        "title": "Nondeterministic one-tape off-line Turing machines and their time\n  complexity",
        "authors": [
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper we consider the time and the crossing sequence complexities of\none-tape off-line Turing machines. We show that the running time of each\nnondeterministic machine accepting a nonregular language must grow at least as\nn\\log n, in the case all accepting computations are considered (accept\nmeasure). We also prove that the maximal length of the crossing sequences used\nin accepting computations must grow at least as \\log n. On the other hand, it\nis known that if the time is measured considering, for each accepted string,\nonly the faster accepting computation (weak measure), then there exist\nnonregular languages accepted in linear time. We prove that under this measure,\neach accepting computation should exhibit a crossing sequence of length at\nleast \\log\\log n. We also present efficient implementations of algorithms\naccepting some unary nonregular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/0905.1271v1"
    },
    {
        "title": "Lexicographically least words in the orbit closure of the Rudin-Shapiro\n  word",
        "authors": [
            "James D. Currie"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We give an effective characterization of the lexicographically least word in\nthe orbit closure of the Rudin-Shapiro word w having a specified prefix. In\nparticular, the lexicographically least word in the orbit closure of the\nRudin-Shapiro word is 0w. This answers a question Allouche et al.\n",
        "pdf_link": "http://arxiv.org/pdf/0905.4923v3"
    },
    {
        "title": "Fragments of first-order logic over infinite words",
        "authors": [
            "Volker Diekert",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We give topological and algebraic characterizations as well as language\ntheoretic descriptions of the following subclasses of first-order logic FO[<]\nfor omega-languages: Sigma_2, FO^2, the intersection of FO^2 and Sigma_2, and\nDelta_2 (and by duality Pi_2 and the intersection of FO^2 and Pi_2). These\ndescriptions extend the respective results for finite words. In particular, we\nrelate the above fragments to language classes of certain (unambiguous)\npolynomials. An immediate consequence is the decidability of the membership\nproblem of these classes, but this was shown before by Wilke and Bojanczyk and\nis therefore not our main focus. The paper is about the interplay of algebraic,\ntopological, and language theoretic properties.\n",
        "pdf_link": "http://arxiv.org/pdf/0906.2995v2"
    },
    {
        "title": "The computational complexity of universality problems for prefixes,\n  suffixes, factors, and subwords of regular languages",
        "authors": [
            "N. Rampersad",
            "J. Shallit",
            "Z. Xu"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper we consider the computational complexity of the following\nproblems: given a DFA or NFA representing a regular language L over a finite\nalphabet Sigma is the set of all prefixes (resp., suffixes, factors, subwords)\nof all words of L equal to Sigma*? In the case of testing universality for\nfactors of languages represented by DFA's, we find an interesting connection to\nCerny's conjecture on synchronizing words.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.0159v3"
    },
    {
        "title": "Algebraic Ordinals",
        "authors": [
            "S. L. Bloom",
            "Z. Esik"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  An algebraic tree T is one determined by a finite system of fixed point\nequations. The frontier \\Fr(T) of an algebraic tree t is linearly ordered by\nthe lexicographic order \\lex. When (\\Fr(T),\\lex) is well-ordered, its order\ntype is an \\textbf{algebraic ordinal}. We prove that the algebraic ordinals are\nexactly the ordinals less than $\\omega^{\\omega^\\omega}$.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.0877v3"
    },
    {
        "title": "Wave propagation in filamental cellular automata",
        "authors": [
            "Alan Gibbons",
            "Martyn Amos"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Motivated by questions in biology and distributed computing, we investigate\nthe behaviour of particular cellular automata, modelled as one-dimensional\narrays of identical finite automata. We investigate what sort of\nself-stabilising cooperative behaviour these can induce in terms of waves of\ncellular state changes along a filament of cells. We discover what the minimum\nrequirements are, in terms of numbers of states and the range of communication\nbetween automata, to observe this for individual filaments. We also discover\nthat populations of growing filaments may have useful features that the\nindividual filament does not have, and we give the results of numerical\nsimulations.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.3246v2"
    },
    {
        "title": "Primitive Recursive Presentations of Automata and their Products",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Methods for specifying Moore type state machines (transducers) abstractly via\nprimitive recursive functions and for defining parallel composition via\nsimultaneous primitive recursion are discussed. The method is mostly of\ninterest as a concise and convenient way of working with the complex state\nsystems found in computer programming and engineering, but a short section\nindicates connections to algebraic automata theory and the theorem of Krohn and\nRhodes.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4169v2"
    },
    {
        "title": "On Descriptional Complexity of the Planarity Problem for Gauss Words",
        "authors": [
            "Vitaliy Kurlin",
            "Alexei Lisitsa",
            "Igor Potapov",
            "Rafiq Saleh"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper we investigate the descriptional complexity of knot theoretic\nproblems and show upper bounds for planarity problem of signed and unsigned\nknot diagrams represented by Gauss words. Since a topological equivalence of\nknots can involve knot diagrams with arbitrarily many crossings then Gauss\nwords will be considered as strings over an infinite (unbounded) alphabet. For\nestablishing the upper bounds on recognition of knot properties, we study these\nproblems in a context of automata models over an infinite alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4180v1"
    },
    {
        "title": "The Nondeterministic Waiting Time Algorithm: A Review",
        "authors": [
            "John Jack",
            "Andrei Paun"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We present briefly the Nondeterministic Waiting Time algorithm. Our technique\nfor the simulation of biochemical reaction networks has the ability to mimic\nthe Gillespie Algorithm for some networks and solutions to ordinary\ndifferential equations for other networks, depending on the rules of the\nsystem, the kinetic rates and numbers of molecules. We provide a full\ndescription of the algorithm as well as specifics on its implementation. Some\nresults for two well-known models are reported. We have used the algorithm to\nexplore Fas-mediated apoptosis models in cancerous and HIV-1 infected T cells.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.4554v1"
    },
    {
        "title": "Bounded Languages Meet Cellular Automata with Sparse Communication",
        "authors": [
            "Martin Kutrib",
            "Andreas Malcher"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Cellular automata are one-dimensional arrays of interconnected interacting\nfinite automata. We investigate one of the weakest classes, the real-time\none-way cellular automata, and impose an additional restriction on their\ninter-cell communication by bounding the number of allowed uses of the links\nbetween cells. Moreover, we consider the devices as acceptors for bounded\nlanguages in order to explore the borderline at which non-trivial decidability\nproblems of cellular automata classes become decidable. It is shown that even\ndevices with drastically reduced communication, that is, each two neighboring\ncells may communicate only constantly often, accept bounded languages that are\nnot semilinear. If the number of communications is at least logarithmic in the\nlength of the input, several problems are undecidable. The same result is\nobtained for classes where the total number of communications during a\ncomputation is linearly bounded.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5128v1"
    },
    {
        "title": "Small Universal Accepting Networks of Evolutionary Processors with\n  Filtered Connections",
        "authors": [
            "Remco Loos",
            "Florin Manea",
            "Victor Mitrana"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper, we present some results regarding the size complexity of\nAccepting Networks of Evolutionary Processors with Filtered Connections\n(ANEPFCs). We show that there are universal ANEPFCs of size 10, by devising a\nmethod for simulating 2-Tag Systems. This result significantly improves the\nknown upper bound for the size of universal ANEPFCs which is 18.\n  We also propose a new, computationally and descriptionally efficient\nsimulation of nondeterministic Turing machines by ANEPFCs. More precisely, we\ndescribe (informally, due to space limitations) how ANEPFCs with 16 nodes can\nsimulate in O(f(n)) time any nondeterministic Turing machine of time complexity\nf(n). Thus the known upper bound for the number of nodes in a network\nsimulating an arbitrary Turing machine is decreased from 26 to 16.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5130v1"
    },
    {
        "title": "Proceedings Eleventh International Workshop on Descriptional Complexity\n  of Formal Systems",
        "authors": [
            "Jürgen Dassow",
            "Giovanni Pighizzini",
            "Bianca Truthe"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The 11th workshop, Descriptional Complexity of Formal Systems 2009, is taking\nplace in Magdeburg, Germany, on July 6-9, 2009. It is jointly organized by the\nIFIP Working Group 1.2 on Descriptional Complexity and by the Faculty of\nComputer Science at the Otto von Guericke University Magdeburg. This volume\ncontains the papers of the invited lectures and the accepted contributions.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5257v1"
    },
    {
        "title": "Approximating the minimum length of synchronizing words is hard",
        "authors": [
            "M. V. Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We prove that, unless $\\mathrm{P}=\\mathrm{NP}$, no polynomial algorithm can\napproximate the minimum length of \\sws for a given \\san within a constant\nfactor.\n",
        "pdf_link": "http://arxiv.org/pdf/0909.3787v2"
    },
    {
        "title": "Mutual Mobile Membranes with Timers",
        "authors": [
            "Bogdan Aman",
            "Gabriel Ciobanu"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A feature of current membrane systems is the fact that objects and membranes\nare persistent. However, this is not true in the real world. In fact, cells and\nintracellular proteins have a well-defined lifetime. Inspired from these\nbiological facts, we define a model of systems of mobile membranes in which\neach membrane and each object has a timer representing their lifetime. We show\nthat systems of mutual mobile membranes with and without timers have the same\ncomputational power. An encoding of timed safe mobile ambients into systems of\nmutual mobile membranes with timers offers a relationship between two\nformalisms used in describing biological systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.1217v1"
    },
    {
        "title": "The Complexity of Translation Membership for Macro Tree Transducers",
        "authors": [
            "Kazuhiro Inaba",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Macro tree transducers (mtts) are a useful formal model for XML query and\ntransformation languages. In this paper one of the fundamental decision\nproblems on translations, namely the \"translation membership problem\" is\nstudied for mtts. For a fixed translation, the translation membership problem\nasks whether a given input/output pair is element of the translation. For\ncall-by-name mtts this problem is shown to be NP-complete. The main result is\nthat translation membership for call-by-value mtts is in polynomial time. For\nseveral extensions, such as addition of regular look-ahead or the\ngeneralization to multi-return mtts, it is shown that translation membership\nstill remains in PTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/0910.2315v1"
    },
    {
        "title": "Entropy sensitivity of languages defined by infinite automata, via\n  Markov chains with forbidden transitions",
        "authors": [
            "Wilfried Huss",
            "Ecaterina Sava",
            "Wolfgang Woess"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A language L over a finite alphabet is growth-sensitive (or entropy\nsensitive) if forbidding any set of subwords F yields a sub-language L^F whose\nexponential growth rate (entropy) is smaller than that of L. Let (X, E, l) be\nan infinite, oriented, labelled graph. Considering the graph as an (infinite)\nautomaton, we associate with any pair of vertices x,y in X the language\nconsisting of all words that can be read as the labels along some path from x\nto y. Under suitable, general assumptions we prove that these languages are\ngrowth-sensitive. This is based on using Markov chains with forbidden\ntransitions.\n",
        "pdf_link": "http://arxiv.org/pdf/0911.0142v2"
    },
    {
        "title": "Almost Linear Büchi Automata",
        "authors": [
            "Tomáš Babiak",
            "Vojtěch Řehák",
            "Jan Strejček"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We introduce a new fragment of Linear temporal logic (LTL) called LIO and a\nnew class of Buechi automata (BA) called Almost linear Buechi automata (ALBA).\nWe provide effective translations between LIO and ALBA showing that the two\nformalisms are expressively equivalent. While standard translations of LTL into\nBA use some intermediate formalisms, the presented translation of LIO into ALBA\nis direct. As we expect applications of ALBA in model checking, we compare the\nexpressiveness of ALBA with other classes of Buechi automata studied in this\ncontext and we indicate possible applications.\n",
        "pdf_link": "http://arxiv.org/pdf/0911.2033v1"
    },
    {
        "title": "A Tighter Bound for the Determinization of Visibly Pushdown Automata",
        "authors": [
            "Nguyen Van Tang"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Visibly pushdown automata (VPA), introduced by Alur and Madhusuan in 2004, is\na subclass of pushdown automata whose stack behavior is completely determined\nby the input symbol according to a fixed partition of the input alphabet. Since\nits introduce, VPAs have been shown to be useful in various context, e.g., as\nspecification formalism for verification and as automaton model for processing\nXML streams. Due to high complexity, however, implementation of formal\nverification based on VPA framework is a challenge. In this paper we consider\nthe problem of implementing VPA-based model checking algorithms. For doing so,\nwe first present an improvement on upper bound for determinization of VPA.\nNext, we propose simple on-the-fly algorithms to check universality and\ninclusion problems of this automata class. Then, we implement the proposed\nalgorithms in a prototype tool. Finally, we conduct experiments on randomly\ngenerated VPAs. The experimental results show that the proposed algorithms are\nconsiderably faster than the standard ones.\n",
        "pdf_link": "http://arxiv.org/pdf/0911.3275v1"
    },
    {
        "title": "Undecidability Results for Finite Interactive Systems",
        "authors": [
            "Alexandru Sofronia",
            "Alexandru Popa",
            "Gheorghe Stefanescu"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  A new approach to the design of massively parallel and interactive\nprogramming languages has been recently proposed using rv-systems (interactive\nsystems with registers and voices) and Agapia programming. In this paper we\npresent a few theoretical results on FISs (finite interactive systems), the\nunderlying mechanism used for specifying control and interaction in these\nsystems. First, we give a proof for the undecidability of the emptiness problem\nfor FISs, by reduction to the Post Correspondence Problem. Next, we use the\nconstruction in this proof to get other undecidability results, e.g., for the\naccessibility of a transition in a FIS, or for the finiteness of the language\nrecognized by a FIS. Finally, we present a simple proof of the equivalence\nbetween FISs and tile systems, making explicit that they precisely capture\nrecognizable two-dimensional languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.0143v1"
    },
    {
        "title": "Evolving MultiAlgebras unify all usual sequential computation models",
        "authors": [
            "Serge Grigorieff",
            "Pierre Valarcher"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  It is well-known that Abstract State Machines (ASMs) can simulate\n\"step-by-step\" any type of machines (Turing machines, RAMs, etc.). We aim to\novercome two facts: 1) simulation is not identification, 2) the ASMs simulating\nmachines of some type do not constitute a natural class among all ASMs. We\nmodify Gurevich's notion of ASM to that of EMA (\"Evolving MultiAlgebra\") by\nreplacing the program (which is a syntactic object) by a semantic object: a\nfunctional which has to be very simply definable over the static part of the\nASM. We prove that very natural classes of EMAs correspond via \"literal\nidentifications\" to slight extensions of the usual machine models and also to\ngrammar models. Though we modify these models, we keep their computation\napproach: only some contingencies are modified. Thus, EMAs appear as the\nmathematical model unifying all kinds of sequential computation paradigms.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.2160v2"
    },
    {
        "title": "On equations over sets of integers",
        "authors": [
            "Artur Jeż",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Systems of equations with sets of integers as unknowns are considered. It is\nshown that the class of sets representable by unique solutions of equations\nusing the operations of union and addition $S+T=\\makeset{m+n}{m \\in S, \\: n \\in\nT}$ and with ultimately periodic constants is exactly the class of\nhyper-arithmetical sets. Equations using addition only can represent every\nhyper-arithmetical set under a simple encoding. All hyper-arithmetical sets can\nalso be represented by equations over sets of natural numbers equipped with\nunion, addition and subtraction $S \\dotminus T=\\makeset{m-n}{m \\in S, \\: n \\in\nT, \\: m \\geqslant n}$. Testing whether a given system has a solution is\n$\\Sigma^1_1$-complete for each model. These results, in particular, settle the\nexpressive power of the most general types of language equations, as well as\nequations over subsets of free groups.\n",
        "pdf_link": "http://arxiv.org/pdf/1001.2932v2"
    },
    {
        "title": "Enumeration Order Reducibility",
        "authors": [
            "Ali Akbar Safilian",
            "Farzad Didehvar"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this article we define a new reducibility based on the enumeration orders\nof r.e. sets.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.0063v2"
    },
    {
        "title": "Construction of minimal DFAs from biological motifs",
        "authors": [
            "Tobias Marschall"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Deterministic finite automata (DFAs) are constructed for various purposes in\ncomputational biology. Little attention, however, has been given to the\nefficient construction of minimal DFAs. In this article, we define simple\nnon-deterministic finite automata (NFAs) and prove that the standard subset\nconstruction transforms NFAs of this type into minimal DFAs. Furthermore, we\nshow how simple NFAs can be constructed from two types of patterns popular in\nbioinformatics, namely (sets of) generalized strings and (generalized) strings\nwith a Hamming neighborhood.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.1298v2"
    },
    {
        "title": "About the embedding of one dimensional cellular automata into hyperbolic\n  cellular automata",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this paper, we look at two ways to implement determinisitic one\ndimensional cellular automata into hyperbolic cellular automata in three\ncontexts: the pentagrid, the heptagrid and the dodecagrid, these tilings being\nclassically denoted by $\\{5,4\\}$, $\\{7,3\\}$ and $\\{5,3,4\\}$ respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.1830v1"
    },
    {
        "title": "Computing Critical Pairs in 2-Dimensional Rewriting Systems",
        "authors": [
            "Samuel Mimram"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Rewriting systems on words are very useful in the study of monoids. In good\ncases, they give finite presentations of the monoids, allowing their\nmanipulation by a computer. Even better, when the presentation is confluent and\nterminating, they provide one with a notion of canonical representative for the\nelements of the presented monoid. Polygraphs are a higher-dimensional\ngeneralization of this notion of presentation, from the setting of monoids to\nthe much more general setting of n-categories. Here, we are interested in\nproving confluence for polygraphs presenting 2-categories, which can be seen as\na generalization of term rewriting systems. For this purpose, we propose an\nadaptation of the usual algorithm for computing critical pairs. Interestingly,\nthis framework is much richer than term rewriting systems and requires the\nelaboration of a new theoretical framework for representing critical pairs,\nbased on contexts in compact 2-categories.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.3135v1"
    },
    {
        "title": "The Complexity of Finding Reset Words in Finite Automata",
        "authors": [
            "Jörg Olschewski",
            "Michael Ummels"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We study several problems related to finding reset words in deterministic\nfinite automata. In particular, we establish that the problem of deciding\nwhether a shortest reset word has length k is complete for the complexity class\nDP. This result answers a question posed by Volkov. For the search problems of\nfinding a shortest reset word and the length of a shortest reset word, we\nestablish membership in the complexity classes FP^NP and FP^NP[log],\nrespectively. Moreover, we show that both these problems are hard for\nFP^NP[log]. Finally, we observe that computing a reset word of a given length\nis FNP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1004.3246v2"
    },
    {
        "title": "Rankers over Infinite Words",
        "authors": [
            "Luc Dartois",
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider the four fragments FO2, the intersection of Sigma2 and FO2, the\nintersection of Pi2 and FO2, and Delta2 of first-order logic FO[<] over finite\nand infinite words. For all four fragments, we give characterizations in terms\nof rankers. In particular, we generalize the notion of a ranker to infinite\nwords in two possible ways. Both extensions are natural in the sense that over\nfinite words, they coincide with classical rankers and over infinite words,\nthey both have the full expressive power of FO2. Moreover, the first extension\nof rankers admits a characterization of the intersection of Sigma2 and FO2\nwhile the other leads to a characterization of the intersection of Pi2 and FO2.\nBoth versions of rankers yield characterizations of the fragment Delta2. As a\nbyproduct, we also obtain characterizations based on unambiguous temporal logic\nand unambiguous interval temporal logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1005.0505v1"
    },
    {
        "title": "The Cerny conjecture for one-cluster automata with prime length cycle",
        "authors": [
            "Benjamin Steinberg"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We prove the Cerny conjecture for one-cluster automata with prime length\ncycle. Consequences are given for the hybrid Road-coloring-Cerny conjecture for\ndigraphs with a proper cycle of prime length.\n",
        "pdf_link": "http://arxiv.org/pdf/1005.1835v1"
    },
    {
        "title": "Partially Ordered Two-way Büchi Automata",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We introduce partially ordered two-way B\\\"uchi automata and characterize\ntheir expressive power in terms of fragments of first-order logic FO[<].\nPartially ordered two-way B\\\"uchi automata are B\\\"uchi automata which can\nchange the direction in which the input is processed with the constraint that\nwhenever a state is left, it is never re-entered again. Nondeterministic\npartially ordered two-way B\\\"uchi automata coincide with the first-order\nfragment Sigma2. Our main contribution is that deterministic partially ordered\ntwo-way B\\\"uchi automata are expressively complete for the first-order fragment\nDelta2. As an intermediate step, we show that deterministic partially ordered\ntwo-way B\\\"uchi automata are effectively closed under Boolean operations.\n  A small model property yields coNP-completeness of the emptiness problem and\nthe inclusion problem for deterministic partially ordered two-way B\\\"uchi\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.2719v2"
    },
    {
        "title": "A Saturation Method for the Modal Mu-Calculus with Backwards Modalities\n  over Pushdown Systems",
        "authors": [
            "M. Hague",
            "C. -H. L. Ong"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We present an extension of an algorithm for computing directly the denotation\nof a mu-calculus formula X over the configuration graph of a pushdown system to\nallow backwards modalities. Our method gives the first extension of the\nsaturation technique to the full mu-calculus with backwards modalities.\n",
        "pdf_link": "http://arxiv.org/pdf/1006.5906v1"
    },
    {
        "title": "A measure of state transition of collective of stateless automata in\n  discrete environment",
        "authors": [
            "Oleksiy Kurganskyy",
            "Igor Potapov"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this work a collective of interacting stateless automata in a discrete\ngeometric environment is considered as an integral automata-like computational\ndynamic object. For such distributed on the environment object different\napproaches to definition of the measure of state transition are possible. We\npropose a geometric approach for defining what a state is.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.2353v1"
    },
    {
        "title": "The Roles of Advice to One-Tape Linear-Time Turing Machines and Finite\n  Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We discuss the power and limitation of various \"advice,\" when it is given\nparticularly to weak computational models of one-tape linear-time Turing\nmachines and one-way finite (state) automata. Of various advice types, we\nconsider deterministically-chosen advice (not necessarily algorithmically\ndetermined) and randomly-chosen advice (according to certain probability\ndistributions). In particular, we show that certain weak machines can be\nsignificantly enhanced in computational power when randomized advice is\nprovided in place of deterministic advice.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.3021v1"
    },
    {
        "title": "A state of a dynamic computational structure distributed in an\n  environment: a model and its corollaries",
        "authors": [
            "Oleksiy Kurgansky"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Currently there is great interest in computational models consisting of\nunderlying regular computational environments, and built on them distributed\ncomputational structures. Examples of such models are cellular automata,\nspatial computation and space-time crystallography. For any computational model\nit is natural to define a functional equivalence of different but related\ncomputational structures. In the finite automata theory an example of such\nequivalence is automata homomorphism and, in particular, automata isomorphism.\nIf we continue to stick to the finite automata theory, a fundamental question\narise, what a state of a distributed computational structure is. This work is\ndevoted to particular solution of the issue.\n",
        "pdf_link": "http://arxiv.org/pdf/1007.3836v1"
    },
    {
        "title": "Inverse Star, Borders, and Palstars",
        "authors": [
            "Narad Rampersad",
            "Jeffrey Shallit",
            "Ming-wei Wang"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  A language L is closed if L = L*. We consider an operation on closed\nlanguages, L-*, that is an inverse to Kleene closure. It is known that if L is\nclosed and regular, then L-* is also regular. We show that the analogous result\nfails to hold for the context-free languages. Along the way we find a new\nrelationship between the unbordered words and the prime palstars of Knuth,\nMorris, and Pratt. We use this relationship to enumerate the prime palstars,\nand we prove that neither the language of all unbordered words nor the language\nof all prime palstars is context-free.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.2440v2"
    },
    {
        "title": "Tree Languages Defined in First-Order Logic with One Quantifier\n  Alternation",
        "authors": [
            "Mikolaj Bojanczyk",
            "Luc Segoufin"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We study tree languages that can be defined in \\Delta_2 . These are tree\nlanguages definable by a first-order formula whose quantifier prefix is forall\nexists, and simultaneously by a first-order formula whose quantifier prefix is\n. For the quantifier free part we consider two signatures, either the\ndescendant relation alone or together with the lexicographical order relation\non nodes. We provide an effective characterization of tree and forest languages\ndefinable in \\Delta_2 . This characterization is in terms of algebraic\nequations. Over words, the class of word languages definable in \\Delta_2 forms\na robust class, which was given an effective algebraic characterization by Pin\nand Weil.\n",
        "pdf_link": "http://arxiv.org/pdf/1009.2854v2"
    },
    {
        "title": "Numerical values of the growth rates of power-free languages",
        "authors": [
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We present upper and two-sided bounds of the exponential growth rate for a\nwide range of power-free languages. All bounds are obtained with the use of\nalgorithms previously developed by the author.\n",
        "pdf_link": "http://arxiv.org/pdf/1009.4415v2"
    },
    {
        "title": "Canonizable Partial Order Generators and Regular Slice Languages",
        "authors": [
            "Mateus de Oliveira Oliveira"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In a previous work we introduced slice graphs as a way to specify both\ninfinite languages of directed acyclic graphs (DAGs) and infinite languages of\npartial orders. Therein we focused on the study of Hasse diagram generators,\ni.e., slice graphs that generate only transitive reduced DAGs, and showed that\nthey could be used to solve several problems related to the partial order\nbehavior of p/t-nets. In the present work we show that both slice graphs and\nHasse diagram generators are worth studying on their own. First, we prove that\nany slice graph SG can be effectively transformed into a Hasse diagram\ngenerator HG representing the same set of partial orders. Thus from an\nalgorithmic standpoint we introduce a method of transitive reducing infinite\nfamilies of DAGs specified by slice graphs. Second, we identify the class of\nsaturated slice graphs. By using our transitive reduction algorithm, we prove\nthat the class of partial order languages representable by saturated slice\ngraphs is closed under union, intersection and even under a suitable notion of\ncomplementation (cut-width complementation). Furthermore partial order\nlanguages belonging to this class can be tested for inclusion and admit\ncanonical representatives in terms of Hasse diagram generators. As an\napplication of our results, we give stronger forms of some results in our\nprevious work, and establish some unknown connections between the partial order\nbehavior of $p/t$-nets and other well known formalisms for the specification of\ninfinite families of partial orders, such as Mazurkiewicz trace languages and\nmessage sequence chart (MSC) languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1009.5341v4"
    },
    {
        "title": "On interleaving in {P,A}-Time Petri nets with strong semantics",
        "authors": [
            "Hanifa Boucheneb",
            "Kamel Barkaoui"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper deals with the reachability analysis of {P,A}-Time Petri nets\n({P,A}-TPN in short) in the context of strong semantics. It investigates the\nconvexity of the union of state classes reached by different interleavings of\nthe same set of transitions. In BB08, the authors have considered the T-TPN\nmodel and its Contracted State Class Graph (CSCG) and shown that this union is\nnot necessarily convex. They have however established some sufficient\nconditions which ensure convexity. This paper shows that for the CSCG of\n{P,A}-TPN, this union is convex and can be computed without computing\nintermediate state classes. These results allow to improve the forward\nreachability analysis by agglomerating, in the same state class, all state\nclasses reached by different interleavings of the same set of transitions\n(abstraction by convex-union).\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0218v1"
    },
    {
        "title": "On Zone-Based Analysis of Duration Probabilistic Automata",
        "authors": [
            "Oded Maler",
            "Kim G. Larsen",
            "Bruce H. Krogh"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We propose an extension of the zone-based algorithmics for analyzing timed\nautomata to handle systems where timing uncertainty is considered as\nprobabilistic rather than set-theoretic. We study duration probabilistic\nautomata (DPA), expressing multiple parallel processes admitting memoryfull\ncontinuously-distributed durations. For this model we develop an extension of\nthe zone-based forward reachability algorithm whose successor operator is a\ndensity transformer, thus providing a solution to verification and performance\nevaluation problems concerning acyclic DPA (or the bounded-horizon behavior of\ncyclic DPA).\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0219v1"
    },
    {
        "title": "A Decidable Characterization of a Graphical Pi-calculus with Iterators",
        "authors": [
            "Frédéric Peschanski",
            "Hanna Klaudel",
            "Raymond Devillers"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper presents the Pi-graphs, a visual paradigm for the modelling and\nverification of mobile systems. The language is a graphical variant of the\nPi-calculus with iterators to express non-terminating behaviors. The\noperational semantics of Pi-graphs use ground notions of labelled transition\nand bisimulation, which means standard verification techniques can be applied.\nWe show that bisimilarity is decidable for the proposed semantics, a result\nobtained thanks to an original notion of causal clock as well as the automatic\ngarbage collection of unused names.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0220v1"
    },
    {
        "title": "Implicit Real Vector Automata",
        "authors": [
            "Bernard Boigelot",
            "Julien Brusten",
            "Jean-François Degbomont"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper addresses the symbolic representation of non-convex real\npolyhedra, i.e., sets of real vectors satisfying arbitrary Boolean combinations\nof linear constraints. We develop an original data structure for representing\nsuch sets, based on an implicit and concise encoding of a known structure, the\nReal Vector Automaton. The resulting formalism provides a canonical\nrepresentation of polyhedra, is closed under Boolean operators, and admits an\nefficient decision procedure for testing the membership of a vector.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0221v1"
    },
    {
        "title": "Probabilistic regular graphs",
        "authors": [
            "Nathalie Bertrand",
            "Christophe Morvan"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Deterministic graph grammars generate regular graphs, that form a structural\nextension of configuration graphs of pushdown systems. In this paper, we study\na probabilistic extension of regular graphs obtained by labelling the terminal\narcs of the graph grammars by probabilities. Stochastic properties of these\ngraphs are expressed using PCTL, a probabilistic extension of computation tree\nlogic. We present here an algorithm to perform approximate verification of PCTL\nformulae. Moreover, we prove that the exact model-checking problem for PCTL on\nprobabilistic regular graphs is undecidable, unless restricting to qualitative\nproperties. Our results generalise those of EKM06, on probabilistic pushdown\nautomata, using similar methods combined with graph grammars techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0222v1"
    },
    {
        "title": "IMITATOR II: A Tool for Solving the Good Parameters Problem in Timed\n  Automata",
        "authors": [
            "Étienne André"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We present here Imitator II, a new version of Imitator, a tool implementing\nthe \"inverse method\" for parametric timed automata: given a reference valuation\nof the parameters, it synthesizes a constraint such that, for any valuation\nsatisfying this constraint, the system behaves the same as under the reference\nvaluation in terms of traces, i.e., alternating sequences of locations and\nactions. Imitator II also implements the \"behavioral cartography algorithm\",\nallowing us to solve the following good parameters problem: find a set of\nvaluations within a given bounded parametric domain for which the system\nbehaves well. We present new features and optimizations of the tool, and give\nresults of applications to various examples of asynchronous circuits and\ncommunication protocols.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0223v1"
    },
    {
        "title": "On Three Alternative Characterizations of Combined Traces",
        "authors": [
            "Dai Tri Man Le"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The combined trace (i.e., comtrace) notion was introduced by Janicki and\nKoutny in 1995 as a generalization of the Mazurkiewicz trace notion. Comtraces\nare congruence classes of step sequences, where the congruence relation is\ndefined from two relations simultaneity and serializability on events. They\nalso showed that comtraces correspond to some class of labeled stratified order\nstructures, but left open the question of what class of labeled stratified\norders represents comtraces. In this work, we proposed a class of labeled\nstratified order structures that captures exactly the comtrace notion. Our main\ntechnical contributions are representation theorems showing that comtrace\nquotient monoid, combined dependency graph (Kleijn and Koutny 2008) and our\nlabeled stratified order structure characterization are three different and yet\nequivalent ways to represent comtraces. This paper is a revised and expanded\nversion of L\\^e (in Proceedings of PETRI NETS 2010, LNCS 6128, pp. 104-124).\n",
        "pdf_link": "http://arxiv.org/pdf/1011.1030v4"
    },
    {
        "title": "Orbits of linear maps and regular languages",
        "authors": [
            "S. Tarasov",
            "M. Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We settle the equivalence between the problem of hitting a polyhedral set by\nthe orbit of a linear map and the intersection of a regular language and a\nlanguage of permutations of binary words (the permutation filter realizability\nproblem). The decidability of the both problems is presently unknown and the\nfirst one is a straightforward generalization of the famous Skolem problem and\nthe nonnegativity problem in the theory of linear recurrent sequences. To show\na `borderline' status of the permutation filter realizability problem with\nrespect to computability we present some decidable and undecidable problems\nclosely related to it.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.1842v2"
    },
    {
        "title": "Probabilistic Arithmetic Automata and their Applications",
        "authors": [
            "Tobias Marschall",
            "Inke Herms",
            "Hans-Michael Kaltenbach",
            "Sven Rahmann"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We present probabilistic arithmetic automata (PAAs), a general model to\ndescribe chains of operations whose operands depend on chance, along with two\ndifferent algorithms to exactly calculate the distribution of the results\nobtained by such probabilistic calculations. PAAs provide a unifying framework\nto approach many problems arising in computational biology and elsewhere. Here,\nwe present five different applications, namely (1) pattern matching statistics\non random texts, including the computation of the distribution of occurrence\ncounts, waiting time and clump size under HMM background models; (2) exact\nanalysis of window-based pattern matching algorithms; (3) sensitivity of\nfiltration seeds used to detect candidate sequence alignments; (4) length and\nmass statistics of peptide fragments resulting from enzymatic cleavage\nreactions; and (5) read length statistics of 454 sequencing reads. The\ndiversity of these applications indicates the flexibility and unifying\ncharacter of the presented framework.\n  While the construction of a PAA depends on the particular application, we\nsingle out a frequently applicable construction method for pattern statistics:\nWe introduce deterministic arithmetic automata (DAAs) to model deterministic\ncalculations on sequences, and demonstrate how to construct a PAA from a given\nDAA and a finite-memory random text model. We show how to transform a finite\nautomaton into a DAA and then into the corresponding PAA.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.5778v1"
    },
    {
        "title": "Relating timed and register automata",
        "authors": [
            "Diego Figueira",
            "Piotr Hofman",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Timed automata and register automata are well-known models of computation\nover timed and data words respectively. The former has clocks that allow to\ntest the lapse of time between two events, whilst the latter includes registers\nthat can store data values for later comparison. Although these two models\nbehave in appearance differently, several decision problems have the same\n(un)decidability and complexity results for both models. As a prominent\nexample, emptiness is decidable for alternating automata with one clock or\nregister, both with non-primitive recursive complexity. This is not by chance.\n  This work confirms that there is indeed a tight relationship between the two\nmodels. We show that a run of a timed automaton can be simulated by a register\nautomaton, and conversely that a run of a register automaton can be simulated\nby a timed automaton. Our results allow to transfer complexity and decidability\nresults back and forth between these two kinds of models. We justify the\nusefulness of these reductions by obtaining new results on register automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.6432v1"
    },
    {
        "title": "An introduction to finite automata and their connection to logic",
        "authors": [
            "Howard Straubing",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This is a tutorial on finite automata. We present the standard material on\ndeterminization and minimization, as well as an account of the equivalence of\nfinite automata and monadic second-order logic. We conclude with an\nintroduction to the syntactic monoid, and as an application give a proof of the\nequivalence of first-order definability and aperiodicity.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.6491v2"
    },
    {
        "title": "A collective of stateless automata in a $n$-dimensional environment as a\n  distributed dynamic automaton-like object: a model and its corollaries",
        "authors": [
            "Oleksiy Kurganskyy"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  In this work a collective of interacting stateless automata in a discrete\ngeometric $n$-dimenstional environment is considered as an integral\nautomaton-like computational dynamic object. For such distributed on the\nenvironment object different approaches to definition of the measure of state\ntransition are possible. We propose an approach for defining what a state is.\nThe approach is based on the concept of relativity in Poincar\\'e's\ninterpretation.\n",
        "pdf_link": "http://arxiv.org/pdf/1012.2203v1"
    },
    {
        "title": "First-order Fragments with Successor over Infinite Words",
        "authors": [
            "Jakub Kallas",
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We consider fragments of first-order logic and as models we allow finite and\ninfinite words simultaneously. The only binary relations apart from equality\nare order comparison < and the successor predicate +1. We give\ncharacterizations of the fragments Sigma2 = Sigma2[<,+1] and FO2 = FO2[<,+1] in\nterms of algebraic and topological properties. To this end we introduce the\nfactor topology over infinite words. It turns out that a language L is in the\nintersection of FO2 and Sigma2 if and only if L is the interior of an FO2\nlanguage. Symmetrically, a language is in the intersection of FO2 and Pi2 if\nand only if it is the topological closure of an FO2 language. The fragment\nDelta2, which by definition is the intersection of Sigma2 and Pi2 contains\nexactly the clopen languages in FO2. In particular, over infinite words Delta2\nis a strict subclass of FO2. Our characterizations yield decidability of the\nmembership problem for all these fragments over finite and infinite words; and\nas a corollary we also obtain decidability for infinite words. Moreover, we\ngive a new decidable algebraic characterization of dot-depth 3/2 over finite\nwords. Decidability of dot-depth 3/2 over finite words was first shown by\nGla{\\ss}er and Schmitz in STACS 2000, and decidability of the membership\nproblem for FO2 over infinite words was shown 1998 by Wilke in his habilitation\nthesis whereas decidability of Sigma2 over infinite words was not known before.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.0115v1"
    },
    {
        "title": "Determinization of $ω$-automata unified",
        "authors": [
            "Hrishikesh Karmarkar",
            "Supratik Chakraborty"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We describe a uniform construction for converting $\\omega$-automata with\narbitrary acceptance conditions (based on the notion of infinity sets i.e. the\nset of states visited infinitely often in a run of the automaton) to equivalent\ndeterministic parity automata (DPW). Given a non-deterministic automaton with\n$n$ states, our construction gives a DPW with at most $2^{O(n^2 \\log n)}$\nstates and $O(n^2)$ parity indices. The corresponding bounds when the original\nautomaton is deterministic are O(n!) and O(n), respectively. Our algorithm\ngives better asymptotic bounds on the number of states and parity indices\nvis-a-vis the best known technique when determinizing Rabin or Streett automata\nwith $\\Omega{(2^n)}$ acceptance pairs, where $n > 1$. We demonstrate this by\ndescribing a family of Streett (and Rabin) automata with $2^{n}$ non-redundant\nacceptance pairs, for which the best known determinization technique gives a\nDPW with at least $\\Omega{(2^{(n^3)})}$ states, while our construction\nconstructs a DRW/DPW with $2^{O(n^2\\log n)}$ states. An easy corollary of our\nconstruction is that an $\\omega$-language with Rabin index $k$ cannot be\nrecognized by any $\\omega$-automaton (deterministic or non-deterministic) with\nfewer than $O(\\sqrt{k})$ states.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.1841v2"
    },
    {
        "title": "Languages of Dot-depth One over Infinite Words",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Over finite words, languages of dot-depth one are expressively complete for\nalternation-free first-order logic. This fragment is also known as the Boolean\nclosure of existential first-order logic. Here, the atomic formulas comprise\norder, successor, minimum, and maximum predicates. Knast (1983) has shown that\nit is decidable whether a language has dot-depth one. We extend Knast's result\nto infinite words. In particular, we describe the class of languages definable\nin alternation-free first-order logic over infinite words, and we give an\neffective characterization of this fragment. This characterization has two\ncomponents. The first component is identical to Knast's algebraic property for\nfinite words and the second component is a topological property, namely being a\nBoolean combination of Cantor sets.\n  As an intermediate step we consider finite and infinite words simultaneously.\nWe then obtain the results for infinite words as well as for finite words as\nspecial cases. In particular, we give a new proof of Knast's Theorem on\nlanguages of dot-depth one over finite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.4152v2"
    },
    {
        "title": "It Is NL-complete to Decide Whether a Hairpin Completion of Regular\n  Languages Is Regular",
        "authors": [
            "Volker Diekert",
            "Steffen Kopecki"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The hairpin completion is an operation on formal languages which is inspired\nby the hairpin formation in biochemistry. Hairpin formations occur naturally\nwithin DNA-computing. It has been known that the hairpin completion of a\nregular language is linear context-free, but not regular, in general. However,\nfor some time it is was open whether the regularity of the hairpin completion\nof a regular language is is decidable. In 2009 this decidability problem has\nbeen solved positively by providing a polynomial time algorithm. In this paper\nwe improve the complexity bound by showing that the decision problem is\nactually NL-complete. This complexity bound holds for both, the one-sided and\nthe two-sided hairpin completions.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.4824v1"
    },
    {
        "title": "Jancar's formal system for deciding bisimulation of first-order grammars\n  and its non-soundness",
        "authors": [
            "Géraud Sénizergues"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We construct an example of proof within the main formal system from\narXiv:1010.4760v3, which is intended to capture the bisimulation equivalence\nfor non-deterministic first-order grammars, and show that its conclusion is\nsemantically false. We then locate and analyze the flawed argument in the\nsoundness (meta)-proof of the above reference.\n",
        "pdf_link": "http://arxiv.org/pdf/1101.5046v1"
    },
    {
        "title": "Synthese des Controleurs Optimaux pour les Systemes a Evenements\n  Discrets",
        "authors": [
            "Jean Marie Moanda Ndeko",
            "Junior Jugis Bakola Mongo"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper, we introduce the problem of synthesizing optimal controllers\nfor discrete event systems and we propose a procedure for solving this problem,\nwhere the method and specifications are represented by finite state automata\nand with increasing complexity. We will subscribe to the synthetic methodology\nby the control theory initiated by supervision by Ramadge and Wonham. For an\nillustration on a simple example, then a model with a complexity high. In this\nspirit, languages, methods and tools development used to specify and\ndevelopment must reach a level of quality to meet the requirements expressed.\nFace this situation, we are helping in this work the systematic use of formal\nmethods in systems development cycles in the equipping and adapting the UML\n(Unified Modeling Language) which is the most exploited in industrial projects.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.0371v1"
    },
    {
        "title": "Isomorphism of regular trees and words",
        "authors": [
            "Markus Lohrey",
            "Christian Mathissen"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The computational complexity of the isomorphism problem for regular trees,\nregular linear orders, and regular words is analyzed. A tree is regular if it\nis isomorphic to the prefix order on a regular language. In case regular\nlanguages are represented by NFAs (DFAs), the isomorphism problem for regular\ntrees turns out to be EXPTIME-complete (resp. P-complete). In case the input\nautomata are acyclic NFAs (acyclic DFAs), the corresponding trees are\n(succinctly represented) finite trees, and the isomorphism problem turns out to\nbe PSPACE-complete (resp. P-complete). A linear order is regular if it is\nisomorphic to the lexicographic order on a regular language. A polynomial time\nalgorithm for the isomorphism problem for regular linear orders (and even\nregular words, which generalize the latter) given by DFAs is presented. This\nsolves an open problem by Esik and Bloom.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.2782v1"
    },
    {
        "title": "Traced communication complexity of cellular automata",
        "authors": [
            "Eric Goles",
            "Pierre Guillon",
            "Ivan Rapaport"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We study cellular automata with respect to a new communication complexity\nproblem: each of two players know half of some finite word, and must be able to\ntell whether the state of the central cell will follow a given evolution, by\ncommunicating as little as possible between each other. We present some links\nwith classical dynamical concepts, especially equicontinuity, expansiveness,\nentropy and give the asymptotic communication complexity of most elementary\ncellular automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.3522v1"
    },
    {
        "title": "Almost overlap-free words and the word problem for the free Burnside\n  semigroup satisfying x^2=x^3",
        "authors": [
            "A. N. Plyushchenko",
            "A. M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we investigate the word problem of the free Burnside semigroup\nsatisfying x^2=x^3 and having two generators. Elements of this semigroup are\nclasses of equivalent words. A natural way to solve the word problem is to\nselect a unique \"canonical\" representative for each equivalence class. We prove\nthat overlap-free words and so-called almost overlap-free words (this notion is\nsome generalization of the notion of overlap-free words) can serve as canonical\nrepresentatives for corresponding equivalence classes. We show that such a word\nin a given class, if any, can be efficiently found. As a result, we construct a\nlinear-time algorithm that partially solves the word problem for the semigroup\nunder consideration.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.4315v1"
    },
    {
        "title": "Reduction of fuzzy automata by means of fuzzy quasi-orders",
        "authors": [
            "Aleksandar Stamenković",
            "Miroslav Ćirić",
            "Jelena Ignjatović"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In our recent paper we have established close relationships between state\nreduction of a fuzzy recognizer and resolution of a particular system of fuzzy\nrelation equations. In that paper we have also studied reductions by means of\nthose solutions which are fuzzy equivalences. In this paper we will see that in\nsome cases better reductions can be obtained using the solutions of this system\nthat are fuzzy quasi-orders. Generally, fuzzy quasi-orders and fuzzy\nequivalences are equally good in the state reduction, but we show that right\nand left invariant fuzzy quasi-orders give better reductions than right and\nleft invariant fuzzy equivalences. We also show that alternate reductions by\nmeans of fuzzy quasi-orders give better results than alternate reductions by\nmeans of fuzzy equivalences. Furthermore we study a more general type of fuzzy\nquasi-orders, weakly right and left invariant ones, and we show that they are\nclosely related to determinization of fuzzy recognizers. We also demonstrate\nsome applications of weakly left invariant fuzzy quasi-orders in conflict\nanalysis of fuzzy discrete event systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.5451v1"
    },
    {
        "title": "Bisimulations for fuzzy automata",
        "authors": [
            "Miroslav Ćirić",
            "Jelena Ignjatović",
            "Nada Damljanović",
            "Milan Bašić"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Bisimulations have been widely used in many areas of computer science to\nmodel equivalence between various systems, and to reduce the number of states\nof these systems, whereas uniform fuzzy relations have recently been introduced\nas a means to model the fuzzy equivalence between elements of two possible\ndifferent sets. Here we use the conjunction of these two concepts as a powerful\ntool in the study of equivalence between fuzzy automata. We prove that a\nuniform fuzzy relation between fuzzy automata $\\cal A$ and $\\cal B$ is a\nforward bisimulation if and only if its kernel and co-kernel are forward\nbisimulation fuzzy equivalences on $\\cal A$ and $\\cal B$ and there is a special\nisomorphism between factor fuzzy automata with respect to these fuzzy\nequivalences. As a consequence we get that fuzzy automata $\\cal A$ and $\\cal B$\nare UFB-equivalent, i.e., there is a uniform forward bisimulation between them,\nif and only if there is a special isomorphism between the factor fuzzy automata\nof $\\cal A$ and $\\cal B$ with respect to their greatest forward bisimulation\nfuzzy equivalences. This result reduces the problem of testing UFB-equivalence\nto the problem of testing isomorphism of fuzzy automata, which is closely\nrelated to the well-known graph isomorphism problem. We prove some similar\nresults for backward-forward bisimulations, and we point to fundamental\ndifferences. Because of the duality with the studied concepts, backward and\nforward-backward bisimulations are not considered separately. Finally, we give\na comprehensive overview of various concepts on deterministic,\nnondeterministic, fuzzy, and weighted automata, which are related to\nbisimulations.\n",
        "pdf_link": "http://arxiv.org/pdf/1102.5452v2"
    },
    {
        "title": "Around Dot-depth One",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The dot-depth hierarchy is a classification of star-free languages. It is\nrelated to the quantifier alternation hierarchy of first-order logic over\nfinite words. We consider fragments of languages with dot-depth 1/2 and\ndot-depth 1 obtained by prohibiting the specification of prefixes or suffixes.\nAs it turns out, these language classes are in one-to-one correspondence with\nfragments of existential first-order logic without min- or max-predicate. For\nall fragments, we obtain effective algebraic characterizations. Moreover, we\ngive new combinatorial proofs for the decidability of the membership problem\nfor dot-depth 1/2 and dot-depth 1.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.1353v1"
    },
    {
        "title": "On the capabilities of grammars, automata, and transducers controlled by\n  monoids",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  During the last decades, classical models in language theory have been\nextended by control mechanisms defined by monoids. We study which monoids cause\nthe extensions of context-free grammars, finite automata, or finite state\ntransducers to exceed the capacity of the original model. Furthermore, we\ninvestigate when, in the extended automata model, the nondeterministic variant\ndiffers from the deterministic one in capacity. We show that all these\nconditions are in fact equivalent and present an algebraic characterization. In\nparticular, the open question of whether every language generated by a valence\ngrammar over a finite monoid is context-free is provided with a positive\nanswer.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.3361v1"
    },
    {
        "title": "Algorithms for computing the greatest simulations and bisimulations\n  between fuzzy automata",
        "authors": [
            "Miroslav Ćirić",
            "Jelena Ignjatović",
            "Ivana Jančić",
            "Nada Damljanović"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Recently, two types of simulations (forward and backward simulations) and\nfour types of bisimulations (forward, backward, forward-backward, and\nbackward-forward bisimulations) between fuzzy automata have been introduced. If\nthere is at least one simulation/bisimulation of some of these types between\nthe given fuzzy automata, it has been proved that there is the greatest\nsimulation/bisimulation of this kind. In the present paper, for any of the\nabove-mentioned types of simulations/bisimulations we provide an effective\nalgorithm for deciding whether there is a simulation/bisimulation of this type\nbetween the given fuzzy automata, and for computing the greatest one, whenever\nit exists. The algorithms are based on the method developed in [J.\nIgnjatovi\\'c, M. \\'Ciri\\'c, S. Bogdanovi\\'c, On the greatest solutions to\ncertain systems of fuzzy relation inequalities and equations, Fuzzy Sets and\nSystems 161 (2010) 3081-3113], which comes down to the computing of the\ngreatest post-fixed point, contained in a given fuzzy relation, of an isotone\nfunction on the lattice of fuzzy relations.\n",
        "pdf_link": "http://arxiv.org/pdf/1103.5078v1"
    },
    {
        "title": "Streaming Tree Transducers",
        "authors": [
            "Rajeev Alur",
            "Loris D'Antoni"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Theory of tree transducers provides a foundation for understanding\nexpressiveness and complexity of analysis problems for specification languages\nfor transforming hierarchically structured data such as XML documents. We\nintroduce streaming tree transducers as an analyzable, executable, and\nexpressive model for transforming unranked ordered trees in a single pass.\nGiven a linear encoding of the input tree, the transducer makes a single\nleft-to-right pass through the input, and computes the output in linear time\nusing a finite-state control, a visibly pushdown stack, and a finite number of\nvariables that store output chunks that can be combined using the operations of\nstring-concatenation and tree-insertion. We prove that the expressiveness of\nthe model coincides with transductions definable using monadic second-order\nlogic (MSO). Existing models of tree transducers either cannot implement all\nMSO-definable transformations, or require regular look ahead that prohibits\nsingle-pass implementation. We show a variety of analysis problems such as\ntype-checking and checking functional equivalence are solvable for our model.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.2599v5"
    },
    {
        "title": "Deciding the Value 1 Problem of Probabilistic Leaktight Automata",
        "authors": [
            "Nathanaël Fijalkow",
            "Hugo Gimbert",
            "Youssouf Oualhadj"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The value 1 problem is a decision problem for probabilistic automata over\nfinite words: given a probabilistic automaton A, are there words accepted by A\nwith probability arbitrarily close to 1? This problem was proved undecidable\nrecently. We sharpen this result, showing that the undecidability result holds\neven if the probabilistic automata have only one probabilistic transition. Our\nmain contribution is to introduce a new class of probabilistic automata, called\nleaktight automata, for which the value 1 problem is shown decidable (and\nPSPACE-complete). We construct an algorithm based on the computation of a\nmonoid abstracting the behaviours of the automaton, and rely on algebraic\ntechniques developed by Simon for the correctness proof. The class of leaktight\nautomata is decidable in PSPACE, subsumes all subclasses of probabilistic\nautomata whose value 1 problem is known to be decidable (in particular\ndeterministic automata), and is closed under two natural composition operators.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.3055v5"
    },
    {
        "title": "On Direct Product and Quotient of Strongly Connected Automata",
        "authors": [
            "Zino H. Hu"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Let $A \\ \\times \\ B$ be the direct product of a strongly connected\npermutation automaton $A$ and a strongly connected synchronizing (reset)\nautomaton $B$, then $A \\ \\times \\ B$ is strongly connected and $$\\boldsymbol{A\n\\cong (A \\times B)/\\pi}$$ $$\\boldsymbol{B \\cong (A \\times B)/\\rho}$$\n$$\\boldsymbol{(A \\times B) \\ \\cong \\ (A \\times B)/\\pi \\ \\times \\ (A \\times\nB)/\\rho}$$ where $\\pi$ and $\\rho$ are automaton congruence relations defined in\nthis paper, $(A \\times B)/\\pi$ and $(A \\times B)/\\rho$ are quotient automata\nconstructed by $\\pi$ and $\\rho$ respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.3314v11"
    },
    {
        "title": "Selected Operations, Algorithms, and Applications of n-Tape Weighted\n  Finite-State Machines",
        "authors": [
            "André Kempe"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  A weighted finite-state machine with n tapes (n-WFSM) defines a rational\nrelation on n strings. It is a generalization of weighted acceptors (one tape)\nand transducers (two tapes).\n  After recalling some basic definitions about n-ary weighted rational\nrelations and n-WFSMs, we summarize some central operations on these relations\nand machines, such as join and auto-intersection. Unfortunately, due to Post's\nCorrespondence Problem, a fully general join or auto-intersection algorithm\ncannot exist. We recall a restricted algorithm for a class of n-WFSMs.\n  Through a series of practical applications, we finally investigate the\naugmented descriptive power of n-WFSMs and their join, compared to classical\ntransducers and their composition. Some applications are not feasible with the\nlatter. The series includes: the morphological analysis of Semitic languages,\nthe preservation of intermediate results in transducer cascades, the induction\nof morphological rules from corpora, the alignment of lexicon entries, the\nautomatic extraction of acronyms and their meaning from corpora, and the search\nfor cognates in a bilingual lexicon.\n  All described operations and applications have been implemented with Xerox's\nWFSC tool.\n",
        "pdf_link": "http://arxiv.org/pdf/1104.5362v2"
    },
    {
        "title": "Computational Aspects of Asynchronous CA",
        "authors": [
            "Jérôme Chandesris",
            "Alberto Dennunzio",
            "Enrico Formenti",
            "Luca Manzoni"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  This work studies some aspects of the computational power of fully\nasynchronous cellular automata (ACA). We deal with some notions of simulation\nbetween ACA and Turing Machines. In particular, we characterize the updating\nsequences specifying which are \"universal\", i.e., allowing a (specific family\nof) ACA to simulate any TM on any input. We also consider the computational\ncost of such simulations.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.0065v1"
    },
    {
        "title": "Approximating Petri Net Reachability Along Context-free Traces",
        "authors": [
            "Mohamed Faouzi Atig",
            "Pierre Ganty"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We investigate the problem asking whether the intersection of a context-free\nlanguage (CFL) and a Petri net language (PNL) is empty. Our contribution to\nsolve this long-standing problem which relates, for instance, to the\nreachability analysis of recursive programs over unbounded data domain, is to\nidentify a class of CFLs called the finite-index CFLs for which the problem is\ndecidable. The k-index approximation of a CFL can be obtained by discarding all\nthe words that cannot be derived within a budget k on the number of occurrences\nof non-terminals. A finite-index CFL is thus a CFL which coincides with its\nk-index approximation for some k. We decide whether the intersection of a\nfinite-index CFL and a PNL is empty by reducing it to the reachability problem\nof Petri nets with weak inhibitor arcs, a class of systems with infinitely many\nstates for which reachability is known to be decidable. Conversely, we show\nthat the reachability problem for a Petri net with weak inhibitor arcs reduces\nto the emptiness problem of a finite-index CFL intersected with a PNL.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.1657v3"
    },
    {
        "title": "On the Finiteness Problem for Automaton (Semi)groups",
        "authors": [
            "Ali Akhavi",
            "Ines Klimann",
            "Sylvain Lombardy",
            "Jean Mairesse",
            "Matthieu Picantin"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  This paper addresses a decision problem highlighted by Grigorchuk,\nNekrashevich, and Sushchanskii, namely the finiteness problem for automaton\n(semi)groups.\n  For semigroups, we give an effective sufficient but not necessary condition\nfor finiteness and, for groups, an effective necessary but not sufficient\ncondition. The efficiency of the new criteria is demonstrated by testing all\nMealy automata with small stateset and alphabet. Finally, for groups, we\nprovide a necessary and sufficient condition that does not directly lead to a\ndecision procedure.\n",
        "pdf_link": "http://arxiv.org/pdf/1105.4725v1"
    },
    {
        "title": "Reactive Safety",
        "authors": [
            "Rüdiger Ehlers",
            "Bernd Finkbeiner"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The distinction between safety and liveness properties is a fundamental\nclassification with immediate implications on the feasibility and complexity of\nvarious monitoring, model checking, and synthesis problems. In this paper, we\nrevisit the notion of safety for reactive systems, i.e., for systems whose\nbehavior is characterized by the interplay of uncontrolled environment inputs\nand controlled system outputs. We show that reactive safety is a strictly\nlarger class of properties than standard safety. We provide algorithms for\nchecking if a property, given as a temporal formula or as a word or tree\nautomaton, is a reactive safety property and for translating such properties\ninto safety automata. Based on this construction, the standard verification and\nsynthesis algorithms for safety properties immediately extend to the larger\nclass of reactive safety.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.1240v1"
    },
    {
        "title": "A Game-Theoretic approach to Fault Diagnosis of Hybrid Systems",
        "authors": [
            "Davide Bresolin",
            "Marta Capiluppi"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Physical systems can fail. For this reason the problem of identifying and\nreacting to faults has received a large attention in the control and computer\nscience communities. In this paper we study the fault diagnosis problem for\nhybrid systems from a game-theoretical point of view. A hybrid system is a\nsystem mixing continuous and discrete behaviours that cannot be faithfully\nmodeled neither by using a formalism with continuous dynamics only nor by a\nformalism including only discrete dynamics. We use the well known framework of\nhybrid automata for modeling hybrid systems, and we define a Fault Diagnosis\nGame on them, using two players: the environment and the diagnoser. The\nenvironment controls the evolution of the system and chooses whether and when a\nfault occurs. The diagnoser observes the external behaviour of the system and\nannounces whether a fault has occurred or not. Existence of a winning strategy\nfor the diagnoser implies that faults can be detected correctly, while\ncomputing such a winning strategy corresponds to implement a diagnoser for the\nsystem. We will show how to determine the existence of a winning strategy, and\nhow to compute it, for some decidable classes of hybrid automata like o-minimal\nhybrid automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.1244v1"
    },
    {
        "title": "Fixed points avoiding Abelian $k$-powers",
        "authors": [
            "James D. Currie",
            "Narad Rampersad"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We show that the problem of whether the fixed point of a morphism avoids\nAbelian $k$-powers is decidable under rather general conditions\n",
        "pdf_link": "http://arxiv.org/pdf/1106.1842v2"
    },
    {
        "title": "Quantum Finite Automata and Probabilistic Reversible Automata: R-trivial\n  Idempotent Languages",
        "authors": [
            "Marats Golovkins",
            "Maksim Kravtsev",
            "Vasilijs Kravcevs"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We study the recognition of R-trivial idempotent (R1) languages by various\nmodels of \"decide-and-halt\" quantum finite automata (QFA) and probabilistic\nreversible automata (DH-PRA). We introduce bistochastic QFA (MM-BQFA), a model\nwhich generalizes both Nayak's enhanced QFA and DH-PRA. We apply tools from\nalgebraic automata theory and systems of linear inequalities to give a complete\ncharacterization of R1 languages recognized by all these models. We also find\nthat \"forbidden constructions\" known so far do not include all of the languages\nthat cannot be recognized by measure-many QFA.\n",
        "pdf_link": "http://arxiv.org/pdf/1106.2530v1"
    },
    {
        "title": "Computing Distances between Probabilistic Automata",
        "authors": [
            "Mathieu Tracol",
            "Josée Desharnais",
            "Abir Zhioua"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We present relaxed notions of simulation and bisimulation on Probabilistic\nAutomata (PA), that allow some error epsilon. When epsilon is zero we retrieve\nthe usual notions of bisimulation and simulation on PAs. We give logical\ncharacterisations of these notions by choosing suitable logics which differ\nfrom the elementary ones, L with negation and L without negation, by the modal\noperator. Using flow networks, we show how to compute the relations in PTIME.\nThis allows the definition of an efficiently computable non-discounted distance\nbetween the states of a PA. A natural modification of this distance is\nintroduced, to obtain a discounted distance, which weakens the influence of\nlong term transitions. We compare our notions of distance to others previously\ndefined and illustrate our approach on various examples. We also show that our\ndistance is not expansive with respect to process algebra operators. Although L\nwithout negation is a suitable logic to characterise epsilon-(bi)simulation on\ndeterministic PAs, it is not for general PAs; interestingly, we prove that it\ndoes characterise weaker notions, called a priori epsilon-(bi)simulation, which\nwe prove to be NP-difficult to decide.\n",
        "pdf_link": "http://arxiv.org/pdf/1107.1206v1"
    },
    {
        "title": "Non-uniform cellular automata and distributions of rules",
        "authors": [
            "Julien Provillard",
            "Enrico Formenti",
            "Alberto Dennunzio"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In this paper we study $\\nu$-CA on one-dimensional lattice defined over a\nfinite set of local rules. The main goal is to determine how the local rules\ncan be mixed to ensure the produced $\\nu$-CA has some properties. In a first\npart, we give some background for the study of $\\nu$-CA. Then surjectivity and\ninjectivity are studied using a variant of DeBruijn graphs. The next part is\ndedicated to the number-conserving property.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.1419v1"
    },
    {
        "title": "Circular words and applications",
        "authors": [
            "Benoît Rittaud",
            "Laurent Vivier"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We define the notion of circular words, then consider on such words a\nconstraint derived from the Fibonacci condition. We give several results on the\nstructure of these circular words, then mention possible applications to\nvarious situations: periodic expansion of numbers in numeration systems,\n\"gcd-property\" of integer sequences, partition of the prefix of the fixed point\nof the Fibonacci substitution, spanning trees of a wheel. Eventually, we\nmention some open questions.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3618v1"
    },
    {
        "title": "Monoids and Maximal Codes",
        "authors": [
            "Fabio Burderi"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In recent years codes that are not Uniquely Decipherable (UD) are been\nstudied partitioning them in classes that localize the ambiguities of the code.\nA natural question is how we can extend the notion of maximality to codes that\nare not UD. In this paper we give an answer to this question. To do this we\nintroduce a partial order in the set of submonoids of a monoid showing the\nexistence, in this poset, of maximal elements that we call full monoids. Then a\nset of generators of a full monoid is, by definition, a maximal code. We show\nhow this definition extends, in a natural way, the existing definition\nconcerning UD codes and we find a characteristic property of a monoid generated\nby a maximal UD code.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3624v1"
    },
    {
        "title": "Dynamical generalizations of the Lagrange spectrum",
        "authors": [
            "Sébastien Ferenczi"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We compute two invariants of topological conjugacy, the upper and lower\nlimits of the inverse of Boshernitzan's ne_n, where e_n is the smallest measure\nof a cylinder of length n, for three families of symbolic systems, the natural\ncodings of rotations and three-interval exchanges and the Arnoux-Rauzy systems.\nThe sets of values of these invariants for a given family of systems generalize\nthe Lagrange spectrum, which is what we get for the family of rotations with\nthe upper limit of 1/ne_n.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3628v1"
    },
    {
        "title": "A Classification of Trapezoidal Words",
        "authors": [
            "Gabriele Fici"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Trapezoidal words are finite words having at most n+1 distinct factors of\nlength n, for every n>=0. They encompass finite Sturmian words. We distinguish\ntrapezoidal words into two disjoint subsets: open and closed trapezoidal words.\nA trapezoidal word is closed if its longest repeated prefix has exactly two\noccurrences in the word, the second one being a suffix of the word. Otherwise\nit is open. We show that open trapezoidal words are all primitive and that\nclosed trapezoidal words are all Sturmian. We then show that trapezoidal\npalindromes are closed (and therefore Sturmian). This allows us to characterize\nthe special factors of Sturmian palindromes. We end with several open problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.3629v1"
    },
    {
        "title": "Feasible Automata for Two-Variable Logic with Successor on Data Words",
        "authors": [
            "Ahmet Kara",
            "Thomas Schwentick",
            "Tony Tan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We introduce an automata model for data words, that is words that carry at\neach position a symbol from a finite alphabet and a value from an unbounded\ndata domain. The model is (semantically) a restriction of data automata,\nintroduced by Bojanczyk, et. al. in 2006, therefore it is called weak data\nautomata. It is strictly less expressive than data automata and the expressive\npower is incomparable with register automata. The expressive power of weak data\nautomata corresponds exactly to existential monadic second order logic with\nsuccessor +1 and data value equality \\sim, EMSO2(+1,\\sim). It follows from\nprevious work, David, et. al. in 2010, that the nonemptiness problem for weak\ndata automata can be decided in 2-NEXPTIME. Furthermore, we study weak B\\\"uchi\nautomata on data omega-strings. They can be characterized by the extension of\nEMSO2(+1,\\sim) with existential quantifiers for infinite sets. Finally, the\nsame complexity bound for its nonemptiness problem is established by a\nnondeterministic polynomial time reduction to the nonemptiness problem of weak\ndata automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.1221v1"
    },
    {
        "title": "Two-Way Automata Making Choices Only at the Endmarkers",
        "authors": [
            "Viliam Geffert",
            "Bruno Guillon",
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The question of the state-size cost for simulation of two-way\nnondeterministic automata (2NFAs) by two-way deterministic automata (2DFAs) was\nraised in 1978 and, despite many attempts, it is still open. Subsequently, the\nproblem was attacked by restricting the power of 2DFAs (e.g., using a\nrestricted input head movement) to the degree for which it was already possible\nto derive some exponential gaps between the weaker model and the standard\n2NFAs. Here we use an opposite approach, increasing the power of 2DFAs to the\ndegree for which it is still possible to obtain a subexponential conversion\nfrom the stronger model to the standard 2DFAs. In particular, it turns out that\nsubexponential conversion is possible for two-way automata that make\nnondeterministic choices only when the input head scans one of the input tape\nendmarkers. However, there is no restriction on the input head movement. This\nimplies that an exponential gap between 2NFAs and 2DFAs can be obtained only\nfor unrestricted 2NFAs using capabilities beyond the proposed new model. As an\nadditional bonus, conversion into a machine for the complement of the original\nlanguage is polynomial in this model. The same holds for making such machines\nself-verifying, halting, or unambiguous. Finally, any superpolynomial lower\nbound for the simulation of such machines by standard 2DFAs would imply L<>NL.\nIn the same way, the alternating version of these machines is related to L =?\nNL =? P, the classical computational complexity problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.1263v1"
    },
    {
        "title": "Graph Reachability and Pebble Automata over Infinite Alphabets",
        "authors": [
            "Tony Tan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Let D denote an infinite alphabet -- a set that consists of infinitely many\nsymbols. A word w = a_0 b_0 a_1 b_1 ... a_n b_n of even length over D can be\nviewed as a directed graph G_w whose vertices are the symbols that appear in w,\nand the edges are (a_0,b_0),(a_1,b_1),...,(a_n,b_n). For a positive integer m,\ndefine a language R_m such that a word w = a_0 b_0 ... a_n b_n is in R_m if and\nonly if there is a path in the graph G_w of length <= m from the vertex a_0 to\nthe vertex b_n.\n  We establish the following hierarchy theorem for pebble automata over\ninfinite alphabet. For every positive integer k, (i) there exists a k-pebble\nautomaton that accepts the language R_{2^k-1}; (ii) there is no k-pebble\nautomaton that accepts the language R_{2^{k+1} - 2}. Based on this result, we\nestablish a number of previously unknown relations among some classes of\nlanguages over infinite alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/1110.2776v2"
    },
    {
        "title": "Regular Functions, Cost Register Automata, and Generalized Min-Cost\n  Problems",
        "authors": [
            "Rajeev Alur",
            "Loris D'Antoni",
            "Jyotirmoy V. Deshmukh",
            "Mukund Raghothaman",
            "Yifei Yuan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Motivated by the successful application of the theory of regular languages to\nformal verification of finite-state systems, there is a renewed interest in\ndeveloping a theory of analyzable functions from strings to numerical values\nthat can provide a foundation for analyzing {\\em quantitative} properties of\nfinite-state systems. In this paper, we propose a deterministic model for\nassociating costs with strings that is parameterized by operations of interest\n(such as addition, scaling, and $\\min$), a notion of {\\em regularity} that\nprovides a yardstick to measure expressiveness, and study decision problems and\ntheoretical properties of resulting classes of cost functions. Our definition\nof regularity relies on the theory of string-to-tree transducers, and allows\nassociating costs with events that are conditional upon regular properties of\nfuture events. Our model of {\\em cost register automata} allows computation of\nregular functions using multiple \"write-only\" registers whose values can be\ncombined using the allowed set of operations. We show that classical\nshortest-path algorithms as well as algorithms designed for computing {\\em\ndiscounted costs}, can be adopted for solving the min-cost problems for the\nmore general classes of functions specified in our model. Cost register\nautomata with $\\min$ and increment give a deterministic model that is\nequivalent to {\\em weighted automata}, an extensively studied nondeterministic\nmodel, and this connection results in new insights and new open problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1111.0670v2"
    },
    {
        "title": "The Rank and Hanna Neumann Property of Some Submonoids of a Free Monoid",
        "authors": [
            "Shubh Narayan Singh",
            "K. V. Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  This work aims at further investigations on the work of Giambruno and Restivo\nto find the rank of the intersection of two finitely generated submonoids of a\nfree monoid. In this connection, we obtain the rank of a finitely generated\nsubmonoid of a free monoid that is accepted by semi-flower automaton with two\nbpi's. Further, when the product automaton of two deterministic semi-flower\nautomata with a unique bpi is semi-flower with two bpi's, we obtain a\nsufficient condition on the product automaton in order to satisfy the Hanna\nNeumann property.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.4250v1"
    },
    {
        "title": "Automata finiteness criterion in terms of van der Put series of automata\n  functions",
        "authors": [
            "Vladimir Anashin"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  In the paper we develop the $p$-adic theory of discrete automata. Every\nautomaton $\\mathfrak A$ (transducer) whose input/output alphabets consist of\n$p$ symbols can be associated to a continuous (in fact, 1-Lipschitz) map from\n$p$-adic integers to $p$ integers, the automaton function $f_\\mathfrak A$. The\n$p$-adic theory (in particular, the $p$-adic ergodic theory) turned out to be\nvery efficient in a study of properties of automata expressed via properties of\nautomata functions. In the paper we prove a criterion for finiteness of the\nnumber of states of automaton in terms of van der Put series of the automaton\nfunction. The criterion displays connections between $p$-adic analysis and the\ntheory of automata sequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1112.5089v1"
    },
    {
        "title": "Lattices of Logical Fragments over Words",
        "authors": [
            "Manfred Kufleitner",
            "Alexander Lauser"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper introduces an abstract notion of fragments of monadic second-order\nlogic. This concept is based on purely syntactic closure properties. We show\nthat over finite words, every logical fragment defines a lattice of languages\nwith certain closure properties. Among these closure properties are residuals\nand inverse C-morphisms. Here, depending on certain closure properties of the\nfragment, C is the family of arbitrary, non-erasing, length-preserving,\nlength-multiplying, or length-reducing morphisms. In particular, definability\nin a certain fragment can often be characterized in terms of the syntactic\nmorphism. This work extends a result of Straubing in which he investigated\ncertain restrictions of first-order logic formulae. In contrast to Straubing's\nmodel-theoretic approach, our notion of a logical fragment is purely syntactic\nand it does not rely on Ehrenfeucht-Fraisse games.\n  As motivating examples, we present (1) a fragment which captures the\nstutter-invariant part of piecewise-testable languages and (2) an acyclic\nfragment of Sigma_2. As it turns out, the latter has the same expressive power\nas two-variable first-order logic FO^2.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.3355v2"
    },
    {
        "title": "The Dissecting Power of Regular Languages",
        "authors": [
            "Tomoyuki Yamakami",
            "Yuichi Kato"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  A recent study on structural properties of regular and context-free languages\nhas greatly promoted our basic understandings of the complex behaviors of those\nlanguages. We continue the study to examine how regular languages behave when\nthey need to cut numerous infinite languages. A particular interest rests on a\nsituation in which a regular language needs to \"dissect\" a given infinite\nlanguage into two subsets of infinite size. Every context-free language is\ndissected by carefully chosen regular languages (or it is REG-dissectible). In\na larger picture, we show that constantly-growing languages and semi-linear\nlanguages are REG-dissectible. Under certain natural conditions, complements\nand finite intersections of semi-linear languages also become REG-dissectible.\nRestricted to bounded languages, the intersections of finitely many\ncontext-free languages and, more surprisingly, the entire Boolean hierarchy\nover bounded context-free languages are REG-dissectible. As an immediate\napplication of the REG-dissectibility, we show another structural property, in\nwhich an appropriate bounded context-free language can \"separate with infinite\nmargins\" two given nested infinite bounded context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1202.4883v3"
    },
    {
        "title": "Finitely presented monoids with linear Dehn function need not have\n  regular cross-sections",
        "authors": [
            "Alan J. Cain",
            "Victor Maltcev"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper shows that a finitely presented monoid with linear Dehn function\nneed not have a regular cross-section, strengthening the previously-known\nresult that such a monoid need not be presented by a finite complete string\nrewriting system, and contrasting the fact that finitely presented groups with\nlinear Dehn function always have regular cross-sections.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.0473v1"
    },
    {
        "title": "How much could we cover a set by c.e sets?",
        "authors": [
            "Farzad Didehvar",
            "Mohsen Mansouri",
            "Zahra Taheri"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  \"How much c.e. sets could cover a given set?\" in this paper we are going to\nanswer this question. Also, in this approach some old concepts come into a new\narrangement. The major goal of this article is to introduce an appropriate\ndefinition for this purpose. Introduction In Computability Theory (Recursion\nTheory) in the first step we wish to recognize the sets which could be\nenumerated by Turing machines (equivalently, algorithms) and in the next step\nwe will compare these sets by some reasonable order (Like Turing degree). Also\nsometimes with some extra information (Oracles) a class of non c.e. sets show\nthe same behavior as c.e. sets (Post hierarchy and related theorems). Here we\ntry another approach: \"Let A be an arbitrary set and we wish to recognize how\nmuch this set might be covered by a c.e. set?\" Although in some sense this\napproach could be seen in some definitions of Recursion Theory, but at the best\nof our knowledge it didn't considered as an approach yet, even though it is\nable to shed a light on some subjects of Computability of sets. Defining this\napproach is not quite straightforward and there are some obstacles to define\nthem. To overcome these difficulties we modify the definitions. We have an\nalternative problem here when we consider recursive sets and not c.e. sets. In\nthis case, the problem would be: \"Let A be an arbitrary set and we wish to know\nthat how much this set might be covered by a recursive Set?\" Here, we try the\nfirst definition and the first problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.0841v1"
    },
    {
        "title": "Enumeration and Structure of Trapezoidal Words",
        "authors": [
            "Michelangelo Bucci",
            "Alessandro De Luca",
            "Gabriele Fici"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Trapezoidal words are words having at most $n+1$ distinct factors of length\n$n$ for every $n\\ge 0$. They therefore encompass finite Sturmian words. We give\ncombinatorial characterizations of trapezoidal words and exhibit a formula for\ntheir enumeration. We then separate trapezoidal words into two disjoint\nclasses: open and closed. A trapezoidal word is closed if it has a factor that\noccurs only as a prefix and as a suffix; otherwise it is open. We investigate\nopen and closed trapezoidal words, in relation with their special factors. We\nprove that Sturmian palindromes are closed trapezoidal words and that a closed\ntrapezoidal word is a Sturmian palindrome if and only if its longest repeated\nprefix is a palindrome. We also define a new class of words, \\emph{semicentral\nwords}, and show that they are characterized by the property that they can be\nwritten as $uxyu$, for a central word $u$ and two different letters $x,y$.\nFinally, we investigate the prefixes of the Fibonacci word with respect to the\nproperty of being open or closed trapezoidal words, and show that the sequence\nof open and closed prefixes of the Fibonacci word follows the Fibonacci\nsequence.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.1203v2"
    },
    {
        "title": "Tree Regular Model Checking for Lattice-Based Automata",
        "authors": [
            "Thomas Genet",
            "Tristan Le Gall",
            "Axel Legay",
            "Valerie Murat"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Tree Regular Model Checking (TRMC) is the name of a family of techniques for\nanalyzing infinite-state systems in which states are represented by terms, and\nsets of states by Tree Automata (TA). The central problem in TRMC is to decide\nwhether a set of bad states is reachable. The problem of computing a TA\nrepresenting (an over- approximation of) the set of reachable states is\nundecidable, but efficient solutions based on completion or iteration of tree\ntransducers exist. Unfortunately, the TRMC framework is unable to efficiently\ncapture both the complex structure of a system and of some of its features. As\nan example, for JAVA programs, the structure of a term is mainly exploited to\ncapture the structure of a state of the system. On the counter part, integers\nof the java programs have to be encoded with Peano numbers, which means that\nany algebraic operation is potentially represented by thousands of applications\nof rewriting rules. In this paper, we propose Lattice Tree Automata (LTAs), an\nextended version of tree automata whose leaves are equipped with lattices. LTAs\nallow us to represent possibly infinite sets of interpreted terms. Such terms\nare capable to represent complex domains and related operations in an efficient\nmanner. We also extend classical Boolean operations to LTAs. Finally, as a\nmajor contribution, we introduce a new completion-based algorithm for computing\nthe possibly infinite set of reachable interpreted terms in a finite amount of\ntime.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.1495v1"
    },
    {
        "title": "Recompression: a simple and powerful technique for word equations",
        "authors": [
            "Artur Jeż"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this paper we present an application of a simple technique of local\nrecompression, previously developed by the author in the context of compressed\nmembership problems and compressed pattern matching, to word equations. The\ntechnique is based on local modification of variables (replacing X by aX or Xa)\nand iterative replacement of pairs of letters appearing in the equation by a\n`fresh' letter, which can be seen as a bottom-up compression of the solution of\nthe given word equation, to be more specific, building an SLP (Straight-Line\nProgramme) for the solution of the word equation.\n  Using this technique we give a new, independent and self-contained proofs of\nmost of the known results for word equations. To be more specific, the\npresented (nondeterministic) algorithm runs in O(n log n) space and in time\npolynomial in log N, where N is the size of the length-minimal solution of the\nword equation. The presented algorithm can be easily generalised to a generator\nof all solutions of the given word equation (without increasing the space\nusage). Furthermore, a further analysis of the algorithm yields a doubly\nexponential upper bound on the size of the length-minimal solution. The\npresented algorithm does not use exponential bound on the exponent of\nperiodicity. Conversely, the analysis of the algorithm yields an independent\nproof of the exponential bound on exponent of periodicity.\n  We believe that the presented algorithm, its idea and analysis are far\nsimpler than all previously applied. Furthermore, thanks to it we can obtain a\nunified and simple approach to most of known results for word equations.\n  As a small additional result we show that for O(1) variables (with arbitrary\nmany appearances in the equation) word equations can be solved in linear space,\ni.e. they are context-sensitive.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.3705v3"
    },
    {
        "title": "Automatic Theorem-Proving in Combinatorics on Words",
        "authors": [
            "Dane Henshall",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We describe a technique for mechanically proving certain kinds of theorems in\ncombinatorics on words, using automata and a package for manipulating them. We\nillustrate our technique by solving, purely mechanically, an open problem of\nCurrie and Saari on the lengths of unbordered factors in the Thue-Morse\nsequence.\n",
        "pdf_link": "http://arxiv.org/pdf/1203.3758v2"
    },
    {
        "title": "Asynchronous Games over Tree Architectures",
        "authors": [
            "Blaise Genest",
            "Hugo Gimbert",
            "Anca Muscholl",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We consider the task of controlling in a distributed way a Zielonka\nasynchronous automaton. Every process of a controller has access to its causal\npast to determine the next set of actions it proposes to play. An action can be\nplayed only if every process controlling this action proposes to play it. We\nconsider reachability objectives: every process should reach its set of final\nstates. We show that this control problem is decidable for tree architectures,\nwhere every process can communicate with its parent, its children, and with the\nenvironment. The complexity of our algorithm is l-fold exponential with l being\nthe height of the tree representing the architecture. We show that this is\nunavoidable by showing that even for three processes the problem is\nEXPTIME-complete, and that it is non-elementary in general.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.0077v3"
    },
    {
        "title": "Logic Characterization of Floyd Languages",
        "authors": [
            "Violetta Lonati",
            "Dino Mandrioli",
            "Matteo Pradella"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Floyd languages (FL), alias Operator Precedence Languages, have recently\nreceived renewed attention thanks to their closure properties and local\nparsability which allow one to apply automatic verification techniques (e.g.\nmodel checking) and parallel and incremental parsing. They properly include\nvarious other classes, noticeably Visual Pushdown languages. In this paper we\nprovide a characterization of FL in terms a monadic second order logic (MSO),\nin the same style as Buchi's one for regular languages. We prove the\nequivalence between automata recognizing FL and the MSO formalization.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.4639v1"
    },
    {
        "title": "Enumerating regular expressions and their languages",
        "authors": [
            "Hermann Gruber",
            "Jonathan Lee",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this chapter we discuss the problem of enumerating distinct regular\nexpressions by size and the regular languages they represent. We discuss\nvarious notions of the size of a regular expression that appear in the\nliterature and their advantages and disadvantages. We consider a formal\ndefinition of regular expressions using a context-free grammar.\n  We then show how to enumerate strings generated by an unambiguous\ncontext-free grammar using the Chomsky-Sch\\\"utzenberger theorem. This theorem\nallows one to construct an algebraic equation whose power series expansion\nprovides the enumeration. Classical tools from complex analysis, such as\nsingularity analysis, can then be used to determine the asymptotic behavior of\nthe enumeration.\n  We use these algebraic and analytic methods to obtain asymptotic estimates on\nthe number of regular expressions of size n. A single regular language can\noften be described by several regular expressions, and we estimate the number\nof distinct languages denoted by regular expressions of size n. We also give\nasymptotic estimates for these quantities. For the first few values, we provide\nexact enumeration results.\n",
        "pdf_link": "http://arxiv.org/pdf/1204.4982v1"
    },
    {
        "title": "Minimizing Expected Termination Time in One-Counter Markov Decision\n  Processes",
        "authors": [
            "Tomáš Brázdil",
            "Antonín Kučera",
            "Petr Novotný",
            "Dominik Wojtczak"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We consider the problem of computing the value and an optimal strategy for\nminimizing the expected termination time in one-counter Markov decision\nprocesses. Since the value may be irrational and an optimal strategy may be\nrather complicated, we concentrate on the problems of approximating the value\nup to a given error epsilon > 0 and computing a finite representation of an\nepsilon-optimal strategy. We show that these problems are solvable in\nexponential time for a given configuration, and we also show that they are\ncomputationally hard in the sense that a polynomial-time approximation\nalgorithm cannot exist unless P=NP.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.1473v1"
    },
    {
        "title": "P(l)aying for Synchronization",
        "authors": [
            "Födor Fominykh",
            "Pavel Martyugin",
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Two topics are presented: synchronization games and synchronization costs. In\na synchronization game on a deterministic finite automaton, there are two\nplayers, Alice and Bob, whose moves alternate. Alice wants to synchronize the\ngiven automaton, while Bob aims to make her task as hard as possible. We answer\na few natural questions related to such games. Speaking about synchronization\ncosts, we consider deterministic automata in which each transition has a\ncertain price. The problem is whether or not a given automaton can be\nsynchronized within a given budget. We determine the complexity of this\nproblem. We also formulate a few open questions.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.2174v2"
    },
    {
        "title": "BPA Bisimilarity is EXPTIME-hard",
        "authors": [
            "Stefan Kiefer"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Given a basic process algebra (BPA) and two stack symbols, the BPA\nbisimilarity problem asks whether the two stack symbols are bisimilar. We show\nthat this problem is EXPTIME-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/1205.7041v2"
    },
    {
        "title": "On hybrid models of quantum finite automata",
        "authors": [
            "Lvzhou Li",
            "Yuan Feng"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In the literature, there exist several quantum finite automata (QFA) models\nwith both quantum and classical states. These models are of particular\ninterest,as they show praiseworthy advantages over the fully quantum models in\nsome nontrivial aspects. This paper characterizes these models in a uniform\nframework by proposing a general hybrid model consisting of a quantum component\nand a classical one which can interact with each other. The existing hybrid QFA\ncan be naturally regarded as the general model with specific communication\npatterns (classical-quantum, quantum-classical, and two-way, respectively). We\nfurther clarify the relationship between these hybrid QFA and some other\nquantum models. In particular, it is shown that hybrid QFA can be simulated\nexactly by QFA with quantum operations, which in turn has a close relationship\nwith two early proposed models: {\\it ancialla QFA} and {\\it quantum sequential\nmachines}.\n",
        "pdf_link": "http://arxiv.org/pdf/1206.2131v2"
    },
    {
        "title": "Game Characterizations of Timed Relations for Timed Automata Processes",
        "authors": [
            "Shibashis Guha",
            "Shankara Narayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this work, we design the game semantics for timed equivalences and\npreorders of timed processes. The timed games corresponding to the various\ntimed relations form a hierarchy. These games are similar to Stirling's\nbisimulation games. If it is the case that the existence of a winning strategy\nfor the defender in a game ${\\cal G}_1$ implies that there exists a winning\nstrategy for the defender in another game ${\\cal G}_2$, then the relation that\ncorresponds to ${\\cal G}_1$ is stronger than the relation corresponding to\n${\\cal G}_2$. The game hierarchy also throws light into several timed relations\nthat are not considered in this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1206.6565v1"
    },
    {
        "title": "The Complexity of Learning Principles and Parameters Grammars",
        "authors": [
            "Jacob Andreas"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate models for learning the class of context-free and\ncontext-sensitive languages (CFLs and CSLs). We begin with a brief discussion\nof some early hardness results which show that unrestricted language learning\nis impossible, and unrestricted CFL learning is computationally infeasible; we\nthen briefly survey the literature on algorithms for learning restricted\nsubclasses of the CFLs. Finally, we introduce a new family of subclasses, the\nprincipled parametric context-free grammars (and a corresponding family of\nprincipled parametric context-sensitive grammars), which roughly model the\n\"Principles and Parameters\" framework in psycholinguistics. We present three\nhardness results: first, that the PPCFGs are not efficiently learnable given\nequivalence and membership oracles, second, that the PPCFGs are not efficiently\nlearnable from positive presentations unless P = NP, and third, that the PPCSGs\nare not efficiently learnable from positive presentations unless integer\nfactorization is in P.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.0052v3"
    },
    {
        "title": "On Periodically Iterated Morphisms",
        "authors": [
            "Joerg Endrullis",
            "Dimitri Hendriks"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate the computational power of periodically iterated morphisms,\nalso known as D0L systems with periodic control, PD0L systems for short. These\nsystems give rise to a class of one-sided infinite sequences, called PD0L\nwords.\n  We construct a PD0L word with exponential subword complexity, thereby\nanswering a question raised by Lepisto (1993) on the existence of such words.\nWe solve another open problem concerning the decidability of the first-order\ntheories of PD0L words; we show it is already undecidable whether a certain\nletter occurs in a PD0L word. This stands in sharp contrast to the situation\nfor D0L words (purely morphic words), which are known to have at most quadratic\nsubword complexity, and for which the monadic theory is decidable.\n  The main result of our paper, leading to these answers, is that every\ncomputable word w over an alphabet Sigma can be embedded in a PD0L word u over\nan extended alphabet Gamma in the following two ways: (i) such that every\nfinite prefix of w is a subword of u, and (ii) such that w is obtained from u\nby erasing all letters from Gamma not in Sigma. The PD0L system generating such\na word u is constructed by encoding a Fractran program that computes the word\nw; Fractran is a programming language as powerful as Turing Machines.\n  As a consequence of (ii), if we allow the application of finite state\ntransducers to PD0L words, we obtain the set of all computable words. Thus the\nset of PD0L words is not closed under finite state transduction, whereas the\nset of D0L words is. It moreover follows that equality of PD0L words (given by\ntheir PD0L system) is undecidable. Finally, we show that if erasing morphisms\nare admitted, then the question of productivity becomes undecidable, that is,\nthe question whether a given PD0L system defines an infinite word.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.2336v1"
    },
    {
        "title": "Infinite ternary square-free words concatenated from permutations of a\n  single word",
        "authors": [
            "James D. Currie"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We answer a question of Harju: An infinite square-free ternary word with an\n$n$-stem factorization exists for any $n\\ge 13$. We show that there are uniform\nternary morphisms of length $k$ for every $k\\ge 23$. This resolves almost\ncompletely a problem of the author and Rampersad.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.3445v2"
    },
    {
        "title": "Primitive Words and Lyndon Words in Automatic and Linearly Recurrent\n  Sequences",
        "authors": [
            "Daniel Goc",
            "Kalle Saari",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We investigate questions related to the presence of primitive words and\nLyndon words in automatic and linearly recurrent sequences. We show that the\nLyndon factorization of a k-automatic sequence is itself k-automatic. We also\nshow that the function counting the number of primitive factors (resp., Lyndon\nfactors) of length n in a k-automatic sequence is k-regular. Finally, we show\nthat the number of Lyndon factors of a linearly recurrent sequence is bounded.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.5124v3"
    },
    {
        "title": "Complexity of testing morphic primitivity",
        "authors": [
            "Vojtěch Matocha",
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We analyze the algorithm in [Holub, 2009], which decides whether a given word\nis a fixed point of a nontrivial morphism. We show that it can be implemented\nto have complexity in O(mn), where n is the length of the word and m the size\nof the alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.5690v1"
    },
    {
        "title": "Finite Automata with Time-Delay Blocks (Extended Version)",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Vinayak S. Prabhu"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The notion of delays arises naturally in many computational models, such as,\nin the design of circuits, control systems, and dataflow languages. In this\nwork, we introduce \\emph{automata with delay blocks} (ADBs), extending finite\nstate automata with variable time delay blocks, for deferring individual\ntransition output symbols, in a discrete-time setting. We show that the ADB\nlanguages strictly subsume the regular languages, and are incomparable in\nexpressive power to the context-free languages. We show that ADBs are closed\nunder union, concatenation and Kleene star, and under intersection with regular\nlanguages, but not closed under complementation and intersection with other ADB\nlanguages. We show that the emptiness and the membership problems are decidable\nin polynomial time for ADBs, whereas the universality problem is undecidable.\nFinally we consider the linear-time model checking problem, i.e., whether the\nlanguage of an ADB is contained in a regular language, and show that the model\nchecking problem is PSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1207.7019v4"
    },
    {
        "title": "On distributed monitoring of asynchronous systems",
        "authors": [
            "Volker Diekert",
            "Anca Muscholl"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Distributed systems are notoriously difficult to understand and analyze in\norder to assert their correction w.r.t. given properties. They often exhibit a\nhuge number of different behaviors, as soon as the active entities (peers,\nagents, processes, etc) behave in an asynchronous manner. Already the\nmodelization of such systems is a non-trivial task, let alone their formal\nverification.\n  The purpose of this paper is to discuss the problem of distributed monitoring\non a simple model of finite-state distributed automata based on shared actions,\ncalled asynchronous automata. Monitoring is a question related to runtime\nverification: assume that we have to check a property $L$ against an unknown or\nvery complex system $A$, so that classical static analysis is not possible.\nTherefore instead of model-checking a monitor is used, that checks the property\non the underlying system at runtime.\n  We are interested here in monitoring distributed systems modeled as\nasynchronous automata. It is natural to require that monitors should be of the\nsame kind as the underlying system, so we consider here distributed monitoring.\nA distributed monitor does not have a global view of the system, therefore we\npropose the notion of locally monitorable trace language. Our main result shows\nthat if the distributed alphabet of actions is connected and if $L$ is a set of\ninfinite traces such that both $L$ and its complement $L^c$ are countable\nunions of locally safety languages, then $L$ is locally monitorable. We also\nshow that over infinite traces, recognizable countable unions of locally safety\nlanguages are precisely the complements of deterministic languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2125v1"
    },
    {
        "title": "Two-Way Finite Automata: Old and Recent Results",
        "authors": [
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The notion of two-way automata was introduced at the very beginning of\nautomata theory. In 1959, Rabin and Scott and, independently, Shepherdson,\nproved that these models, both in the deterministic and in the nondeterministic\nversions, have the same power of one-way automata, namely, they characterize\nthe class of regular languages.\n  In 1978, Sakoda and Sipser posed the question of the cost, in the number of\nthe states, of the simulation of one-way and two-way nondeterministic automata\nby two-way deterministic automata. They conjectured that these costs are\nexponential. In spite of all attempts to solve it, this question is still open.\n  In the last ten years the problem of Sakoda and Sipser was widely\nreconsidered and many new results related to it have been obtained. In this\nwork we discuss some of them. In particular, we focus on the restriction to the\nunary case and on the connections with open questions in space complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2755v1"
    },
    {
        "title": "Fixed Parameter Undecidability for Wang Tilesets",
        "authors": [
            "Emmanuel Jeandel",
            "Nicolas Rolin"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Deciding if a given set of Wang tiles admits a tiling of the plane is\ndecidable if the number of Wang tiles (or the number of colors) is bounded, for\na trivial reason, as there are only finitely many such tilesets. We prove\nhowever that the tiling problem remains undecidable if the difference between\nthe number of tiles and the number of colors is bounded by 43.\n  One of the main new tool is the concept of Wang bars, which are equivalently\ninflated Wang tiles or thin polyominoes.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2769v1"
    },
    {
        "title": "Characterizing Weighted MSO for Trees by Branching Transitive Closure\n  Logics",
        "authors": [
            "Zoltán Fülöp",
            "Heiko Vogler"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We introduce the branching transitive closure operator on weighted monadic\nsecond-order logic formulas where the branching corresponds in a natural way to\nthe branching inherent in trees. For arbitrary commutative semirings, we prove\nthat weighted monadic second order logics on trees is equivalent to the\ndefinability by formulas which start with one of the following operators: (i) a\nbranching transitive closure or (ii) an existential second-order quantifier\nfollowed by one universal first-order quantifier; in both cases the operator is\napplied to step-formulas over (a) Boolean first-order logic enriched by modulo\ncounting or (b) Boolean monadic-second order logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.5317v2"
    },
    {
        "title": "The finiteness of a group generated by a 2-letter invertible-reversible\n  Mealy automaton is decidable",
        "authors": [
            "Ines Klimann"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We prove that a semigroup generated by a reversible two-state Mealy automaton\nis either finite or free of rank 2. This fact leads to the decidability of\nfiniteness for groups generated by two-state or two-letter\ninvertible-reversible Mealy automata and to the decidability of freeness for\nsemigroups generated by two-state invertible-reversible Mealy automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.6324v2"
    },
    {
        "title": "A Two Step Perspective for Kripke Structure Reduction",
        "authors": [
            "Arpit Sharma"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper presents a novel theoretical framework for the state space\nreduction of Kripke structures. We define two equivalence relations, Kripke\nminimization equivalence (KME) and weak Kripke minimization equivalence (WKME).\nWe define the quotient system under these relations and show that these\nrelations are strictly coarser than strong (bi)simulation and\ndivergence-sensitive stutter (bi)simulation, respectively. We prove that the\nquotient system obtained under KME and WKME preserves linear-time and\nstutter-insensitive linear-time properties. Finally, we show that KME is\ncompositional w.r.t. synchronous parallel composition.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.0408v1"
    },
    {
        "title": "Bisimilarity of Probabilistic Pushdown Automata",
        "authors": [
            "Vojtech Forejt",
            "Petr Jancar",
            "Stefan Kiefer",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study the bisimilarity problem for probabilistic pushdown automata (pPDA)\nand subclasses thereof. Our definition of pPDA allows both probabilistic and\nnon-deterministic branching, generalising the classical notion of pushdown\nautomata (without epsilon-transitions). Our first contribution is a general\nconstruction that reduces checking bisimilarity of probabilistic transition\nsystems to checking bisimilarity of non-deterministic transition systems. This\nconstruction directly yields decidability of bisimilarity for pPDA, as well as\nan elementary upper bound for the bisimilarity problem on the subclass of\nprobabilistic basic process algebras, i.e., single-state pPDA. We further show\nthat, with careful analysis, the general reduction can be used to prove an\nEXPTIME upper bound for bisimilarity of probabilistic visibly pushdown\nautomata. Here we also provide a matching lower bound, establishing\nEXPTIME-completeness. Finally we prove that deciding bisimilarity of\nprobabilistic one-counter automata, another subclass of pPDA, is\nPSPACE-complete. Here we use a more specialised argument to obtain optimal\ncomplexity bounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2273v1"
    },
    {
        "title": "Modelling Implicit Communication in Multi-Agent Systems with Hybrid\n  Input/Output Automata",
        "authors": [
            "Marta Capiluppi",
            "Roberto Segala"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We propose an extension of Hybrid I/O Automata (HIOAs) to model agent systems\nand their implicit communication through perturbation of the environment, like\nlocalization of objects or radio signals diffusion and detection. To this end\nwe decided to specialize some variables of the HIOAs whose values are functions\nboth of time and space. We call them world variables. Basically they are\ntreated similarly to the other variables of HIOAs, but they have the function\nof representing the interaction of each automaton with the surrounding\nenvironment, hence they can be output, input or internal variables. Since these\nspecial variables have the role of simulating implicit communication, their\ndynamics are specified both in time and space, because they model the\nperturbations induced by the agent to the environment, and the perturbations of\nthe environment as perceived by the agent. Parallel composition of world\nvariables is slightly different from parallel composition of the other\nvariables, since their signals are summed. The theory is illustrated through a\nsimple example of agents systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2448v1"
    },
    {
        "title": "Deciding KAT and Hoare Logic with Derivatives",
        "authors": [
            "Ricardo Almeida",
            "Sabine Broda",
            "Nelma Moreira"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Kleene algebra with tests (KAT) is an equational system for program\nverification, which is the combination of Boolean algebra (BA) and Kleene\nalgebra (KA), the algebra of regular expressions. In particular, KAT subsumes\nthe propositional fragment of Hoare logic (PHL) which is a formal system for\nthe specification and verification of programs, and that is currently the base\nof most tools for checking program correctness. Both the equational theory of\nKAT and the encoding of PHL in KAT are known to be decidable. In this paper we\npresent a new decision procedure for the equivalence of two KAT expressions\nbased on the notion of partial derivatives. We also introduce the notion of\nderivative modulo particular sets of equations. With this we extend the\nprevious procedure for deciding PHL. Some experimental results are also\npresented.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2456v1"
    },
    {
        "title": "A Myhill-Nerode theorem for automata with advice",
        "authors": [
            "Alex Kruckman",
            "Sasha Rubin",
            "John Sheridan",
            "Ben Zax"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  An automaton with advice is a finite state automaton which has access to an\nadditional fixed infinite string called an advice tape. We refine the\nMyhill-Nerode theorem to characterize the languages of finite strings that are\naccepted by automata with advice. We do the same for tree automata with advice.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2462v1"
    },
    {
        "title": "Starting a Dialog between Model Checking and Fault-tolerant Distributed\n  Algorithms",
        "authors": [
            "Annu John",
            "Igor Konnov",
            "Ulrich Schmid",
            "Helmut Veith",
            "Josef Widder"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Fault-tolerant distributed algorithms are central for building reliable\nspatially distributed systems. Unfortunately, the lack of a canonical precise\nframework for fault-tolerant algorithms is an obstacle for both verification\nand deployment. In this paper, we introduce a new domain-specific framework to\ncapture the behavior of fault-tolerant distributed algorithms in an adequate\nand precise way. At the center of our framework is a parameterized system model\nwhere control flow automata are used for process specification. To account for\nthe specific features and properties of fault-tolerant distributed algorithms\nfor message-passing systems, our control flow automata are extended to model\nthreshold guards as well as the inherent non-determinism stemming from\nasynchronous communication, interleavings of steps, and faulty processes.\n  We demonstrate the adequacy of our framework in a representative case study\nwhere we formalize a family of well-known fault-tolerant broadcasting\nalgorithms under a variety of failure assumptions. Our case study is supported\nby model checking experiments with safety and liveness specifications for a\nfixed number of processes. In the experiments, we systematically varied the\nassumptions on both the resilience condition and the failure model. In all\ncases, our experiments coincided with the theoretical results predicted in the\ndistributed algorithms literature. This is giving clear evidence for the\nadequacy of our model.\n  In a companion paper, we are addressing the new model checking techniques\nnecessary for parametric verification of the distributed algorithms captured in\nour framework.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.3839v1"
    },
    {
        "title": "From Regexes to Parsing Expression Grammars",
        "authors": [
            "Sérgio Medeiros",
            "Fabio Mascarenhas",
            "Roberto Ierusalimschy"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Most scripting languages nowadays use regex pattern-matching libraries. These\nregex libraries borrow the syntax of regular expressions, but have an informal\nsemantics that is different from the semantics of regular expressions, removing\nthe commutativity of alternation and adding ad-hoc extensions that cannot be\nexpressed by formalisms for efficient recognition of regular languages, such as\ndeterministic finite automata.\n  Parsing Expression Grammars are a formalism that can describe all\ndeterministic context-free languages and has a simple computational model. In\nthis paper, we present a formalization of regexes via transformation to Parsing\nExpression Grammars. The proposed transformation easily accommodates several of\nthe common regex extensions, giving a formal meaning to them. It also provides\na clear computational model that helps to estimate the efficiency of\nregex-based matchers, and a basis for specifying provably correct optimizations\nfor them.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.4992v1"
    },
    {
        "title": "Bisimilarity of Pushdown Systems is Nonelementary",
        "authors": [
            "Michael Benedikt",
            "Stefan Göller",
            "Stefan Kiefer",
            "Andrzej S. Murawski"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Given two pushdown systems, the bisimilarity problem asks whether they are\nbisimilar. While this problem is known to be decidable our main result states\nthat it is nonelementary, improving EXPTIME-hardness, which was the previously\nbest known lower bound for this problem. Our lower bound result holds for\nnormed pushdown systems as well.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.7686v1"
    },
    {
        "title": "Repetition Avoidance in Circular Factors",
        "authors": [
            "Hamoon Mousavi",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We consider the following novel variation on a classical avoidance problem\nfrom combinatorics on words: instead of avoiding repetitions in all factors of\na word, we avoid repetitions in all factors where each individual factor is\nconsidered as a \"circular word\", i.e., the end of the word wraps around to the\nbeginning. We determine the best possible avoidance exponent for alphabet size\n2 and 3, and provide a lower bound for larger alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.0052v3"
    },
    {
        "title": "The Grammar Hammer of 2012",
        "authors": [
            "Vadim Zaytsev"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This document is a case study in aggressive self-archiving. It collects all\ninitiatives undertaken by its author in 2012, including unpublished ones,\nexplains their relevance and relation with one another. Discussed topics\ninclude guided convergence of formal grammars in a broad sense, programmable\ngrammar transformation operator suites, metasyntactic specifications and\nmethods of their manipulation, tolerant (soft computing) methods in parsing\ntheory, megamodelling as modelling linguistic architecture of software systems,\nrepositories of grammatical knowledge, open notebook computer science, as well\nas the number of minor topics (new parsing algorithms, visualisation\ntechniques, etc). A brief overview of involved venues is also included in the\nreport.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.4446v1"
    },
    {
        "title": "Balance properties of Arnoux-Rauzy words",
        "authors": [
            "Valérie Berthé",
            "Julien Cassaigne",
            "Wolfgang Steiner"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  The paper deals with balances and imbalances in Arnoux-Rauzy words. We\nprovide sufficient conditions for $C$-balancedness, but our results indicate\nthat even a characterization of 2-balanced Arnoux-Rauzy words on a 3-letter\nalphabet is not immediate.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.5106v1"
    },
    {
        "title": "On an algorithm for multiperiodic words",
        "authors": [
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We consider an algorithm by Tijdeman and Zamboni constructing a word of a\ngiven length that has a given set of periods, and the richest possible\nalphabet. We show that this algorithm can be easily stated and its correctness\nbriefly proved using the class equivalence approach.\n",
        "pdf_link": "http://arxiv.org/pdf/1212.6609v2"
    },
    {
        "title": "On the transition reduction problem for finite automata",
        "authors": [
            "el Houcein el Abdalaoui",
            "Mohamed Dahmoune",
            "Djelloul Ziadi"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We are interested in the problem of transition reduction of nondeterministic\nautomata. We present some results on the reduction of the automata recognizing\nthe language $L(E_n)$ denoted by the regular expression $E_n=(1+\\varepsilon)...\n(2+\\varepsilon)... (3+\\varepsilon)... (n+\\varepsilon)$. These results can be\nused in the general case of the transition reduction problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.3751v1"
    },
    {
        "title": "Binary Patterns in Binary Cube-Free Words: Avoidability and Growth",
        "authors": [
            "Robert Mercas",
            "Pascal Ochem",
            "Alexei V. Samsonov",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The avoidability of binary patterns by binary cube-free words is investigated\nand the exact bound between unavoidable and avoidable patterns is found. All\navoidable patterns are shown to be D0L-avoidable. For avoidable patterns, the\ngrowth rates of the avoiding languages are studied. All such languages, except\nfor the overlap-free language, are proved to have exponential growth. The exact\ngrowth rates of languages avoiding minimal avoidable patterns are approximated\nthrough computer-assisted upper bounds. Finally, a new example of a\npattern-avoiding language of polynomial growth is given.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.4682v1"
    },
    {
        "title": "From Two-Way to One-Way Finite State Transducers",
        "authors": [
            "Emmanuel Filiot",
            "Olivier Gauwin",
            "Pierre-Alain Reynier",
            "Frédéric Servais"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Any two-way finite state automaton is equivalent to some one-way finite state\nautomaton. This well-known result, shown by Rabin and Scott and independently\nby Shepherdson, states that two-way finite state automata (even\nnon-deterministic) characterize the class of regular languages. It is also\nknown that this result does not extend to finite string transductions:\n(deterministic) two-way finite state transducers strictly extend the expressive\npower of (functional) one-way transducers. In particular deterministic two-way\ntransducers capture exactly the class of MSO-transductions of finite strings.\nIn this paper, we address the following definability problem: given a function\ndefined by a two-way finite state transducer, is it definable by a one-way\nfinite state transducer? By extending Rabin and Scott's proof to transductions,\nwe show that this problem is decidable. Our procedure builds a one-way\ntransducer, which is equivalent to the two-way transducer, whenever one exists.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.5197v2"
    },
    {
        "title": "Computable Component-wise Reducibility",
        "authors": [
            "Egor Ianovski"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We consider equivalence relations and preorders complete for various levels\nof the arithmetical hierarchy under computable, component-wise reducibility. We\nshow that implication in first order logic is a complete preorder for $\\SI 1$,\nthe $\\le^P_m$ relation on EXPTIME sets for $\\SI 2$ and the embeddability of\ncomputable subgroups of $(\\QQ,+)$ for $\\SI 3$. In all cases, the symmetric\nfragment of the preorder is complete for equivalence relations on the same\nlevel. We present a characterisation of $\\PI 1$ equivalence relations which\nallows us to establish that equality of polynomial time functions and inclusion\nof polynomial time sets are complete for $\\PI 1$ equivalence relations and\npreorders respectively. We also show that this is the limit of the enquiry: for\n$n\\geq 2$ there are no $\\PI n$ nor $\\DE n$-complete equivalence relations.\n",
        "pdf_link": "http://arxiv.org/pdf/1301.7112v1"
    },
    {
        "title": "Analysis of Evidence Using Formal Event Reconstruction",
        "authors": [
            "Joshua I. James",
            "Pavel Gladyshev",
            "Mohd Taufik Abdullah",
            "Yuandong Zhu"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper expands upon the finite state machine approach for the formal\nanalysis of digital evidence. The proposed method may be used to support the\nfeasibility of a given statement by testing it against a relevant system model.\nTo achieve this, a novel method for modeling the system and evidential\nstatements is given. The method is then examined in a case study example.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.2308v1"
    },
    {
        "title": "Generic Strategies for Chemical Space Exploration",
        "authors": [
            "Jakob L. Andersen",
            "Christoph Flamm",
            "Daniel Merkle",
            "Peter F. Stadler"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Computational approaches to exploring \"chemical universes\", i.e., very large\nsets, potentially infinite sets of compounds that can be constructed by a\nprescribed collection of reaction mechanisms, in practice suffer from a\ncombinatorial explosion. It quickly becomes impossible to test, for all pairs\nof compounds in a rapidly growing network, whether they can react with each\nother. More sophisticated and efficient strategies are therefore required to\nconstruct very large chemical reaction networks.\n  Undirected labeled graphs and graph rewriting are natural models of chemical\ncompounds and chemical reactions. Borrowing the idea of partial evaluation from\nfunctional programming, we introduce partial applications of rewrite rules.\nBinding substrate to rules increases the number of rules but drastically prunes\nthe substrate sets to which it might match, resulting in dramatically reduced\nresource requirements. At the same time, exploration strategies can be guided,\ne.g. based on restrictions on the product molecules to avoid the explicit\nenumeration of very unlikely compounds. To this end we introduce here a generic\nframework for the specification of exploration strategies in graph-rewriting\nsystems. Using key examples of complex chemical networks from sugar chemistry\nand the realm of metabolic networks we demonstrate the feasibility of a\nhigh-level strategy framework.\n  The ideas presented here can not only be used for a strategy-based chemical\nspace exploration that has close correspondence of experimental results, but\nare much more general. In particular, the framework can be used to emulate\nhigher-level transformation models such as illustrated in a small puzzle game.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.4006v2"
    },
    {
        "title": "Optimal Scheduling for Linear-Rate Multi-Mode Systems",
        "authors": [
            "Dominik Wojtczak"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Linear-Rate Multi-Mode Systems is a model that can be seen both as a subclass\nof switched linear systems with imposed global safety constraints and as hybrid\nautomata with no guards on transitions. We study the existence and design of a\ncontroller for this model that keeps the state of the system within a given\nsafe set for the whole time. A sufficient and necessary condition is given for\nsuch a controller to exist as well as an algorithm that finds one in polynomial\ntime. We further generalise the model by adding costs on modes and present an\nalgorithm that constructs a safe controller which minimises the peak cost, the\naverage-cost or any cost expressed as a weighted sum of these two. Finally, we\npresent numerical simulation results based on our implementation of these\nalgorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.4406v1"
    },
    {
        "title": "Basic Classes of Grammars with Prohibition",
        "authors": [
            "Mark Burgin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A practical tool for natural language modeling and development of\nhuman-machine interaction is developed in the context of formal grammars and\nlanguages. A new type of formal grammars, called grammars with prohibition, is\nintroduced. Grammars with prohibition provide more powerful tools for natural\nlanguage generation and better describe processes of language learning than the\nconventional formal grammars. Here we study relations between languages\ngenerated by different grammars with prohibition based on conventional types of\nformal grammars such as context-free or context sensitive grammars. Besides, we\ncompare languages generated by different grammars with prohibition and\nlanguages generated by conventional formal grammars. In particular, it is\ndemonstrated that they have essentially higher computational power and\nexpressive possibilities in comparison with the conventional formal grammars.\nThus, while conventional formal grammars are recursive and subrecursive\nalgorithms, many classes of grammars with prohibition are superrecursive\nalgorithms. Results presented in this work are aimed at the development of\nhuman-machine interaction, modeling natural languages, empowerment of\nprogramming languages, computer simulation, better software systems, and theory\nof recursion.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.5181v1"
    },
    {
        "title": "Stochastic Context-Free Grammars, Regular Languages, and Newton's Method",
        "authors": [
            "Kousha Etessami",
            "Alistair Stewart",
            "Mihalis Yannakakis"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study the problem of computing the probability that a given stochastic\ncontext-free grammar (SCFG), G, generates a string in a given regular language\nL(D) (given by a DFA, D). This basic problem has a number of applications in\nstatistical natural language processing, and it is also a key necessary step\ntowards quantitative \\omega-regular model checking of stochastic context-free\nprocesses (equivalently, 1-exit recursive Markov chains, or stateless\nprobabilistic pushdown processes).\n  We show that the probability that G generates a string in L(D) can be\ncomputed to within arbitrary desired precision in polynomial time (in the\nstandard Turing model of computation), under a rather mild assumption about the\nSCFG, G, and with no extra assumption about D. We show that this assumption is\nsatisfied for SCFG's whose rule probabilities are learned via the well-known\ninside-outside (EM) algorithm for maximum-likelihood estimation (a standard\nmethod for constructing SCFGs in statistical NLP and biological sequence\nanalysis). Thus, for these SCFGs the algorithm always runs in P-time.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.6411v1"
    },
    {
        "title": "Enumerating Abelian Returns to Prefixes of Sturmian Words",
        "authors": [
            "Zuzana Masáková",
            "Edita Pelantová"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We follow the works of Puzynina and Zamboni, and Rigo et al. on abelian\nreturns in Sturmian words. We determine the cardinality of the set\n$\\mathcal{APR}_u$ of abelian returns of all prefixes of a Sturmian word $u$ in\nterms of the coefficients of the continued fraction of the slope, dependingly\non the intercept. We provide a simple algorithm for finding the set\n$\\mathcal{APR}_u$ and we determine it for the characteristic Sturmian words.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.0969v1"
    },
    {
        "title": "Oracle Pushdown Automata, Nondeterministic Reducibilities, and the CFL\n  Hierarchy over the Family of Context-Free Languages",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  To expand a fundamental theory of context-free languages, we equip\nnondeterministic one-way pushdown automata with additional oracle mechanisms,\nwhich naturally induce various nondeterministic reducibilities among formal\nlanguages. As a natural restriction of NP-reducibility, we introduce a notion\nof many-one CFL reducibility and conduct a ground work to formulate a coherent\nframework for further expositions. Two more powerful reducibilities--bounded\ntruth-table and Turing CFL-reducibilities--are also discussed in comparison.\nThe Turing CFL-reducibility, in particular, helps us introduce an exquisite\nhierarchy, called the CFL hierarchy, built over the family CFL of context-free\nlanguages. For each level of this hierarchy, its basic structural properties\nare proven and three alternative characterizations are presented. The second\nlevel is not included in NC(2) unless NP= NC(2). The first and second levels of\nthe hierarchy are different. The rest of the hierarchy (more strongly, the\nBoolean hierarchy built over each level of the hierarchy) is also infinite\nunless the polynomial hierarchy over NP collapses. This follows from a\ncharacterization of the Boolean hierarchy over the k-th level of the polynomial\nhierarchy in terms of the Boolean hierarchy over the k+1st level of the CFL\nhierarchy using log-space many-one reductions. Similarly, the complexity class\nTheta(k) is related to the closure of the k-th level of the CFL hierarchy under\nlog-space truth-table reductions. We also argue that the CFL hierarchy\ncoincides with a hierarchy over CFL built by application of many-one\nCFL-reductions. We show that BPCFL--a bounded-error probabilistic version of\nCFL--is not included in CFL even in the presence of advice. Employing a known\ncircuit lower bound and a switching lemma, we exhibit a relativized world where\nBPCFL is not located within the second level of the CFL hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.1717v2"
    },
    {
        "title": "Weak morphisms of higher dimensional automata",
        "authors": [
            "Thomas Kahl"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We introduce weak morphisms of higher dimensional automata and use them to\ndefine preorder relations for HDAs, among which homeomorphic abstraction and\ntrace equivalent abstraction. It is shown that homeomorphic abstraction is\nessentially always stronger than trace equivalent abstraction. We also define\nthe trace language of an HDA and show that, for a large class of HDAs, it is\ninvariant under trace equivalent abstraction.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.2003v1"
    },
    {
        "title": "Effective Characterizations of Simple Fragments of Temporal Logic Using\n  Carton--Michel Automata",
        "authors": [
            "Preugschat Sebastian",
            "Thomas Wilke"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We present a framework for obtaining effective characterizations of simple\nfragments of future temporal logic (LTL) with the natural numbers as time\ndomain. The framework is based on a form of strongly unambiguous automata, also\nknown as prophetic automata or complete unambiguous B\\\"uchi automata and\nreferred to as Carton-Michel automata in this paper. These automata enjoy\nstrong structural properties, in particular, they separate the \"finitary\nfraction\" of a regular language of infinite words from its \"infinitary\nfraction\" in a natural fashion. Within our framework, we provide\ncharacterizations of several natural fragments of temporal logic, where, in\nsome cases, no effective characterization had been known previously, and give\nlower and upper bounds for their computational complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.5956v2"
    },
    {
        "title": "Real-Time Vector Automata",
        "authors": [
            "Özlem Salehi",
            "Abuzer Yakaryılmaz",
            "A. C. Cem Say"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study the computational power of real-time finite automata that have been\naugmented with a vector of dimension k, and programmed to multiply this vector\nat each step by an appropriately selected $k \\times k$ matrix. Only one entry\nof the vector can be tested for equality to 1 at any time. Classes of languages\nrecognized by deterministic, nondeterministic, and \"blind\" versions of these\nmachines are studied and compared with each other, and the associated classes\nfor multicounter automata, automata with multiplication, and generalized finite\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1303.6129v1"
    },
    {
        "title": "Structures Without Scattered-Automatic Presentation",
        "authors": [
            "Alexander Kartzow",
            "Philipp Schlicht"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Bruyere and Carton lifted the notion of finite automata reading infinite\nwords to finite automata reading words with shape an arbitrary linear order L.\nAutomata on finite words can be used to represent infinite structures, the\nso-called word-automatic structures. Analogously, for a linear order L there is\nthe class of L-automatic structures. In this paper we prove the following\nlimitations on the class of L-automatic structures for a fixed L of finite\ncondensation rank 1+\\alpha. Firstly, no scattered linear order with finite\ncondensation rank above \\omega^(\\alpha+1) is L-\\alpha-automatic. In particular,\nevery L-automatic ordinal is below \\omega^\\omega^(\\alpha+1). Secondly, we\nprovide bounds on the (ordinal) height of well-founded order trees that are\nL-automatic. If \\alpha is finite or L is an ordinal, the height of such a tree\nis bounded by \\omega^{\\alpha+1}. Finally, we separate the class of\ntree-automatic structures from that of L-automatic structures for any ordinal\nL: the countable atomless boolean algebra is known to be tree-automatic, but we\nshow that it is not L-automatic.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.0912v1"
    },
    {
        "title": "Multiparty Compatibility in Communicating Automata: Characterisation and\n  Synthesis of Global Session Types",
        "authors": [
            "Pierre-Malo Deniélou",
            "Nobuko Yoshida"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Multiparty session types are a type system that can ensure the safety and\nliveness of distributed peers via the global specification of their\ninteractions. To construct a global specification from a set of distributed\nuncontrolled behaviours, this paper explores the problem of fully\ncharacterising multiparty session types in terms of communicating automata. We\nequip global and local session types with labelled transition systems (LTSs)\nthat faithfully represent asynchronous communications through unbounded\nbuffered channels. Using the equivalence between the two LTSs, we identify a\nclass of communicating automata that exactly correspond to the projected local\ntypes. We exhibit an algorithm to synthesise a global type from a collection of\ncommunicating automata. The key property of our findings is the notion of\nmultiparty compatibility which non-trivially extends the duality condition for\nbinary session types.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.1902v1"
    },
    {
        "title": "On MITL and alternating timed automata",
        "authors": [
            "Thomas Brihaye",
            "Morgane Estiévenart",
            "Gilles Geeraerts"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  One clock alternating timed automata OCATA have been recently introduced as\nnatural extension of (one clock) timed automata to express the semantics of MTL\n(Ouaknine, Worrell 2005). We consider the application of OCATA to problem of\nmodel-checking MITL formulas (a syntactic fragment of MTL) against timed\nautomata. We introduce a new semantics for OCATA where, intuitively, clock\nvaluations are intervals instead of single real values. Thanks to this new\nsemantics, we show that we can bound the number of clock copies that are\nnecessary to allow an OCATA to recognise the models of an MITL formula.\nEquipped with this technique, we propose a new algorithm to translate an MITL\nformula into a timed automaton, and we sketch several ideas to define new model\nchecking algorithms for MITL.\n",
        "pdf_link": "http://arxiv.org/pdf/1304.2814v1"
    },
    {
        "title": "Words with unbounded periodicity complexity",
        "authors": [
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  If an infinite non-periodic word is uniformly recurrent or is of bounded\nrepetition, then the limit of its periodicity complexity is infinity. Moreover,\nthere are uniformly recurrent words with the periodicity complexity arbitrarily\nhigh at infinitely many positions.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.3123v2"
    },
    {
        "title": "Semilinearity and Context-Freeness of Languages Accepted by Valence\n  Automata",
        "authors": [
            "P. Buckheister",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Valence automata are a generalization of various models of automata with\nstorage. Here, each edge carries, in addition to an input word, an element of a\nmonoid. A computation is considered valid if multiplying the monoid elements on\nthe visited edges yields the identity element. By choosing suitable monoids, a\nvariety of automata models can be obtained as special valence automata.\n  This work is concerned with the accepting power of valence automata.\nSpecifically, we ask for which monoids valence automata can accept only\ncontext-free languages or only languages with semilinear Parikh image,\nrespectively.\n  First, we present a characterization of those graph products (of monoids) for\nwhich valence automata accept only context-free languages. Second, we provide a\nnecessary and sufficient condition for a graph product of copies of the\nbicyclic monoid and the integers to yield only languages with semilinear Parikh\nimage when used as a storage mechanism in valence automata. Third, we show that\nall languages accepted by valence automata over torsion groups have a\nsemilinear Parikh image.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.3260v2"
    },
    {
        "title": "Effective Translation of LTL to Deterministic Rabin Automata: Beyond the\n  (F,G)-Fragment",
        "authors": [
            "Tomáš Babiak",
            "František Blahoudek",
            "Mojmír Křetínský",
            "Jan Strejček"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Some applications of linear temporal logic (LTL) require to translate\nformulae of the logic to deterministic omega-automata. There are currently two\ntranslators producing deterministic automata: ltl2dstar working for the whole\nLTL and Rabinizer applicable to LTL(F,G) which is the LTL fragment using only\nmodalities F and G. We present a new translation to deterministic Rabin\nautomata via alternating automata and deterministic transition-based\ngeneralized Rabin automata. Our translation applies to a fragment that is\nstrictly larger than LTL(F,G). Experimental results show that our algorithm can\nproduce significantly smaller automata compared to Rabinizer and ltl2dstar,\nespecially for more complex LTL formulae.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.4636v5"
    },
    {
        "title": "Lexical State Analyzer",
        "authors": [
            "Kartik Gupta",
            "V. Krishna Nandivada"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Lexical states provide a powerful mechanism to scan regular expressions in a\ncontext sensitive manner. At the same time, lexical states also make it hard to\nreason about the correctness of the grammar. We first categorize the related\ncorrectness issues into two classes: errors and warnings, and then present a\ncontext sensitive and a context insensitive analysis to identify errors and\nwarnings in context-free-grammars (CFGs). We also present a comparative study\nof these analyses. A standalone tool (LSA) has also been implemented by us that\ncan identify errors and warnings in JavaCC grammars. The LSA tool outputs a\ngraph that depicts the grammar and the error transitions. It can also generates\ncounter example strings that can be used to establish the errors. We have used\nLSA to analyze a host of open-source JavaCC grammar files to good effect.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.3156v1"
    },
    {
        "title": "Undecidability of MM-QFAs Language Equivalence Problem",
        "authors": [
            "Tianrong Lin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Let $L_{>\\lambda}(\\mathcal{A})$ and $L_{\\geq\\lambda}(\\mathcal{A})$ be the\nlanguages recognized by {\\em measure many 1-way quantum finite automata\n(MM-QFA)} (or,{\\em enhanced 1-way quantum finite automata(EQFA)}) $\\mathcal{A}$\nwith strict and non-strict cut-point $\\lambda$, respectively. We consider the\nlanguage equivalence problem and show the following\n  1. both strict and non-strict language equivalence are undecidable;\n  2. we provide an another proof of the undecidability of non-strict and strict\nemptiness of MM-QFA and EQFA, and then reducing the language equivalence\nproblem to emptiness problem;\n  3. lastly, we obtain some other properties which can be derived from the\nabove results.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.3301v15"
    },
    {
        "title": "On the Generative Power of Omega-Grammars and Omega-Automata",
        "authors": [
            "Zhe Chen"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  An \\omega-grammar is a formal grammar used to generate \\omega-words (i.e.\ninfinite length words), while an \\omega-automaton is an automaton used to\nrecognize \\omega-words. This paper gives clean and uniform definitions for\n\\omega-grammars and \\omega-automata, provides a systematic study of the\ngenerative power of \\omega-grammars with respect to \\omega-automata, and\npresents a complete set of results for various types of \\omega-grammars and\nacceptance modes. We use the tuple (\\sigma,\\rho,\\pi) to denote various\nacceptance modes, where \\sigma denotes that some designated elements should\nappear at least once or infinitely often, \\rho denotes some binary relation\nbetween two sets, and \\pi denotes normal or leftmost derivations. Technically,\nwe propose (\\sigma,\\rho,\\pi)-accepting \\omega-grammars, and systematically\nstudy their relative generative power with respect to (\\sigma,\\rho)-accepting\n\\omega-automata. We show how to construct some special forms of\n\\omega-grammars, such as \\epsilon-production-free \\omega-grammars. We study the\nequivalence or inclusion relations between \\omega$-grammars and \\omega-automata\nby establishing the translation techniques. In particular, we show that, for\nsome acceptance modes, the generative power of \\omega-CFG is strictly weaker\nthan \\omega-PDA, and the generative power of \\omega-CSG is equal to \\omega-TM\n(rather than linear-bounded \\omega-automata-like devices). Furthermore, we\nraise some remaining open problems for two of the acceptance modes.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.4516v1"
    },
    {
        "title": "World Automata: a compositional approach to model implicit communication\n  in hierarchical Hybrid Systems",
        "authors": [
            "Marta Capiluppi",
            "Roberto Segala"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We propose an extension of Hybrid I/O Automata (HIOAs) to model agent systems\nand their implicit communication through perturbation of the environment, like\nlocalization of objects or radio signals diffusion and detection. The new\nobject, called World Automaton (WA), is built in such a way to preserve as much\nas possible of the compositional properties of HIOAs and its underlying theory.\nFrom the formal point of view we enrich classical HIOAs with a set of world\nvariables whose values are functions both of time and space. World variables\nare treated similarly to local variables of HIOAs, except in parallel\ncomposition, where the perturbations produced by world variables are summed. In\nsuch way, we obtain a structure able to model both agents and environments,\nthus inducing a hierarchy in the model and leading to the introduction of a new\noperator. Indeed this operator, called inplacement, is needed to represent the\npossibility of an object (WA) of living inside another object/environment (WA).\n",
        "pdf_link": "http://arxiv.org/pdf/1308.5335v1"
    },
    {
        "title": "Balancedness of Arnoux-Rauzy and Brun words",
        "authors": [
            "Vincent Delecroix",
            "Tomáš Hejda",
            "Wolfgang Steiner"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We study balancedness properties of words given by the Arnoux-Rauzy and Brun\nmulti-dimensional continued fraction algorithms. We show that almost all Brun\nwords on 3 letters and Arnoux-Rauzy words over arbitrary alphabets are finitely\nbalanced; in particular, boundedness of the strong partial quotients implies\nbalancedness. On the other hand, we provide examples of unbalanced Brun words\non 3 letters.\n",
        "pdf_link": "http://arxiv.org/pdf/1308.6694v1"
    },
    {
        "title": "Infinitary Axiomatization of the Equational Theory of Context-Free\n  Languages",
        "authors": [
            "Niels Bjørn Bugge Grathwohl",
            "Fritz Henglein",
            "Dexter Kozen"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We give a natural complete infinitary axiomatization of the equational theory\nof the context-free languages, answering a question of Lei{\\ss} (1992).\n",
        "pdf_link": "http://arxiv.org/pdf/1309.0893v1"
    },
    {
        "title": "Proceedings Machines, Computations and Universality 2013",
        "authors": [
            "Turlough Neary",
            "Matthew Cook"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This volume contains the papers presented at the 6th conference on Machines,\nComputations and Universality (MCU 2013). MCU 2013 was held in Zurich,\nSwitzerland, September 9-11, 2013. The MCU series began in Paris in 1995 and\nhas since been concerned with gaining a deeper understanding of computation\nthrough the study of models of general purpose computation. This volume\ncontinues in this tradition and includes new simple universal models of\ncomputation, and other results that clarify the relationships between models.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1043v1"
    },
    {
        "title": "Parsing methods streamlined",
        "authors": [
            "Luca Breveglieri",
            "Stefano Crespi Reghizzi",
            "Angelo Morzenti"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper has the goals (1) of unifying top-down parsing with shift-reduce\nparsing to yield a single simple and consistent framework, and (2) of producing\nprovably correct parsing methods, deterministic as well as tabular ones, for\nextended context-free grammars (EBNF) represented as state-transition networks.\nDeparting from the traditional way of presenting as independent algorithms the\ndeterministic bottom-up LR(1), the top-down LL(1) and the general tabular\n(Earley) parsers, we unify them in a coherent minimalist framework. We present\na simple general construction method for EBNF ELR(1) parsers, where the new\ncategory of convergence conflicts is added to the classical shift-reduce and\nreduce-reduce conflicts; we prove its correctness and show two implementations\nby deterministic push-down machines and by vector-stack machines, the latter to\nbe also used for Earley parsers. Then the Beatty's theoretical characterization\nof LL(1) grammars is adapted to derive the extended ELL(1 parsing method, first\nby minimizing the ELR(1) parser and then by simplifying its state information.\nThrough using the same notations in the ELR(1) case, the extended Earley parser\nis obtained. Since all the parsers operate on compatible representations, it is\nfeasible to combine them into mixed mode algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.7584v1"
    },
    {
        "title": "The reachability problem for vector addition systems with a stack is not\n  elementary",
        "authors": [
            "Ranko Lazic"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  By adapting the iterative yardstick construction of Stockmeyer, we show that\nthe reachability problem for vector addition systems with a stack does not have\nelementary complexity. As a corollary, the same lower bound holds for the\nsatisfiability problem for a two-variable first-order logic on trees in which\nunbounded data may label only leaf nodes. Whether the two problems are\ndecidable remains an open question.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.1767v1"
    },
    {
        "title": "A decidable class of (nominal) omega-regular languages over an infinite\n  alphabet",
        "authors": [
            "Vincenzo Ciancia",
            "Matteo Sammartino"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We define a class of languages of infinite words over infinite alphabets, and\nthe corresponding automata. The automata used for recognition are a\ngeneralisation of deterministic Muller automata to the setting of nominal sets.\nRemarkably, the obtained languages are determined by their ultimately periodic\nfragments, as in the classical case. Closure under complement, union and\nintersection, and decidability of emptiness and equivalence are preserved by\nthe generalisation. This is shown by using finite representations of the\n(otherwise infinite-state) defined class of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.3945v1"
    },
    {
        "title": "Avoiding 2-binomial squares and cubes",
        "authors": [
            "M. Rao",
            "M. Rigo",
            "P. Salimov"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Two finite words $u,v$ are 2-binomially equivalent if, for all words $x$ of\nlength at most 2, the number of occurrences of $x$ as a (scattered) subword of\n$u$ is equal to the number of occurrences of $x$ in $v$. This notion is a\nrefinement of the usual abelian equivalence. A 2-binomial square is a word $uv$\nwhere $u$ and $v$ are 2-binomially equivalent.\n  In this paper, considering pure morphic words, we prove that 2-binomial\nsquares (resp. cubes) are avoidable over a 3-letter (resp. 2-letter) alphabet.\nThe sizes of the alphabets are optimal.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.4743v1"
    },
    {
        "title": "Implementing Computations in Automaton (Semi)groups",
        "authors": [
            "Ines Klimann",
            "Jean Mairesse",
            "Matthieu Picantin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We consider the growth, order, and finiteness problems for automaton\n(semi)groups. We propose new implementations and compare them with the existing\nones. As a result of extensive experimentations, we propose some conjectures on\nthe order of finite automaton (semi)groups.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.4856v1"
    },
    {
        "title": "One Quantifier Alternation in First-Order Logic with Modular Predicates",
        "authors": [
            "Manfred Kufleitner",
            "Tobias Walter"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Adding modular predicates yields a generalization of first-order logic FO\nover words. The expressive power of FO[<,MOD] with order comparison $x<y$ and\npredicates for $x \\equiv i \\mod n$ has been investigated by Barrington,\nCompton, Straubing and Therien. The study of FO[<,MOD]-fragments was initiated\nby Chaubard, Pin and Straubing. More recently, Dartois and Paperman showed that\ndefinability in the two-variable fragment FO2[<,MOD] is decidable. In this\npaper we continue this line of work.\n  We give an effective algebraic characterization of the word languages in\nSigma2[<,MOD]. The fragment Sigma2 consists of first-order formulas in prenex\nnormal form with two blocks of quantifiers starting with an existential block.\nIn addition we show that Delta2[<,MOD], the largest subclass of Sigma2[<,MOD]\nwhich is closed under negation, has the same expressive power as two-variable\nlogic FO2[<,MOD]. This generalizes the result FO2[<] = Delta2[<] of Therien and\nWilke to modular predicates. As a byproduct, we obtain another decidable\ncharacterization of FO2[<,MOD].\n",
        "pdf_link": "http://arxiv.org/pdf/1310.5043v3"
    },
    {
        "title": "The (Nested) Word Problem",
        "authors": [
            "Christopher S. Henry"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In this article we provide a new perspective on the word problem of a group\nby using languages of nested words. These were introduced by Alur and\nMadhusudan as a way to model programming languages such as HTML. We demonstrate\nhow a class of nested word languages called visibly pushdown can be used to\nstudy the word problem of virtually free groups in a natural way.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.6283v3"
    },
    {
        "title": "A characterization of those automata that structurally generate finite\n  groups",
        "authors": [
            "Ines Klimann",
            "Matthieu Picantin"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Antonenko and Russyev independently have shown that any Mealy automaton with\nno cycles with exit--that is, where every cycle in the underlying directed\ngraph is a sink component--generates a fi- nite (semi)group, regardless of the\nchoice of the production functions. Antonenko has proved that this constitutes\na characterization in the non-invertible case and asked for the invertible\ncase, which is proved in this paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1310.7137v1"
    },
    {
        "title": "Unary languages recognized by two-way one-counter automata",
        "authors": [
            "Marzio De Biasi",
            "Abuzer Yakaryilmaz"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A two-way deterministic finite state automaton with one counter (2D1CA) is a\nfundamental computational model that has been examined in many different\naspects since sixties, but we know little about its power in the case of unary\nlanguages. Up to our knowledge, the only known unary nonregular languages\nrecognized by 2D1CAs are those formed by strings having exponential length,\nwhere the exponents form some trivial unary regular language. In this paper, we\npresent some non-trivial subsets of these languages. By using the input head as\na second counter, we present simulations of two-way deterministic finite\nautomata with linearly bounded counters and linear--space Turing machines. We\nalso show how a fixed-size quantum register can help to simplify some of these\nlanguages. Finally, we compare unary 2D1CAs with two--counter machines and\nprovide some insights about the limits of their computational power.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.0849v2"
    },
    {
        "title": "Senescent Ground Tree Rewrite Systems",
        "authors": [
            "Matthew Hague"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Ground Tree Rewrite Systems with State are known to have an undecidable\ncontrol state reachability problem. Taking inspiration from the recent\nintroduction of scope-bounded multi-stack pushdown systems, we define Senescent\nGround Tree Rewrite Systems. These are a restriction of ground tree rewrite\nsystems with state such that nodes of the tree may no longer be rewritten after\nhaving witnessed an a priori fixed number of control state changes. As well as\ngeneralising scope-bounded multi-stack pushdown systems, we show --- via\nreductions to and from reset Petri-nets --- that these systems have an\nAckermann-complete control state reachability problem. However, reachability of\na regular set of trees remains undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.4915v1"
    },
    {
        "title": "On Constructing Constrained Tree Automata Recognizing Ground Instances\n  of Constrained Terms",
        "authors": [
            "Naoki Nishida",
            "Masahiko Sakai",
            "Yasuhiro Nakano"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  An inductive theorem proving method for constrained term rewriting systems,\nwhich is based on rewriting induction, needs a decision procedure for\nreduction-completeness of constrained terms. In addition, the sufficient\ncomplete property of constrained term rewriting systems enables us to relax the\nside conditions of some inference rules in the proving method. These two\nproperties can be reduced to intersection emptiness problems related to sets of\nground instances for constrained terms. This paper proposes a method to\nconstruct deterministic, complete, and constraint-complete constrained tree\nautomata recognizing ground instances of constrained terms.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5567v1"
    },
    {
        "title": "Node Query Preservation for Deterministic Linear Top-Down Tree\n  Transducers",
        "authors": [
            "Kazuki Miyahara",
            "Kenji Hashimoto",
            "Hiroyuki Seki"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper discusses the decidability of node query preservation problems for\nXML document transformations. We assume a transformation given by a\ndeterministic linear top-down data tree transducer (abbreviated as DLT^V) and\nan n-ary query based on runs of a tree automaton. We say that a DLT^V Tr\nstrongly preserves a query Q if there is a query Q' such that for every\ndocument t, the answer set of Q' for Tr(t) is equal to the answer set of Q for\nt. Also we say that Tr weakly preserves Q if there is a query Q' such that for\nevery t_d in the range of Tr, the answer set of Q' for t_d is equal to the\nunion of the answer set of Q for t such that t_d = Tr(t). We show that the weak\npreservation problem is coNP-complete and the strong preservation problem is in\n2-EXPTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5572v1"
    },
    {
        "title": "Synchronous Context-Free Grammars and Optimal Linear Parsing Strategies",
        "authors": [
            "Pierluigi Crescenzi",
            "Daniel Gildea",
            "Andrea Marino",
            "Gianluca Rossi",
            "Giorgio Satta"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Synchronous Context-Free Grammars (SCFGs), also known as syntax-directed\ntranslation schemata, are unlike context-free grammars in that they do not have\na binary normal form. In general, parsing with SCFGs takes space and time\npolynomial in the length of the input strings, but with the degree of the\npolynomial depending on the permutations of the SCFG rules. We consider linear\nparsing strategies, which add one nonterminal at a time. We show that for a\ngiven input permutation, the problems of finding the linear parsing strategy\nwith the minimum space and time complexity are both NP-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.6421v1"
    },
    {
        "title": "Enhancing Approximations for Regular Reachability Analysis",
        "authors": [
            "Alois Dreyfus",
            "Pierre-Cyrille Heam",
            "Olga Kouchnarenko"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This paper introduces two mechanisms for computing over-approximations of\nsets of reachable states, with the aim of ensuring termination of state-space\nexploration. The first mechanism consists in over-approximating the automata\nrepresenting reachable sets by merging some of their states with respect to\nsimple syntactic criteria, or a combination of such criteria. The second\napproximation mechanism consists in manipulating an auxiliary automaton when\napplying a transducer representing the transition relation to an automaton\nencoding the initial states. In addition, for the second mechanism we propose a\nnew approach to refine the approximations depending on a property of interest.\nThe proposals are evaluated on examples of mutual exclusion protocols.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.6605v1"
    },
    {
        "title": "Analysis and synthesis of nonlinear reversible cellular automata in\n  linear time",
        "authors": [
            "Sukanta Das",
            "Biplab K Sikdar"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Cellular automata (CA) have been found as an attractive modeling tool for\nvarious applications, such as, pattern recognition, image processing, data\ncompression, encryption, and specially for VLSI design & test. For such\napplications, mostly a special class of CA, called as linear/additive CA, have\nbeen utilized. Since linear/additive CA refer a limited number of candidate CA,\nwhile searching for solution to a problem, the best result may not be expected.\nThe nonlinear CA can be a better alternative to linear/additive CA for\nachieving desired solutions in different applications. However, the nonlinear\nCA are yet to be characterized to fit the design for modeling an application.\nThis work targets characterization of the nonlinear CA to utilize the huge\nsearch space of nonlinear CA while developing applications in VLSI domain. An\nanalytical framework is developed to explore the properties of CA rules. The\ncharacterization is directed to deal with the reversibility, as the reversible\nCA are primarily targeted for VLSI applications. The reported characterization\nenables us to design two algorithms of linear time complexities -- one for\nidentification and nother for synthesis of nonlinear reversible CA. Finally,\nthe CA rules are classified into 6 classes for developing further efficient\nsynthesis algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.6879v1"
    },
    {
        "title": "Partial actions and automata",
        "authors": [
            "M. Dokuchaev",
            "B. Novikov",
            "G. Zholtkevych"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We use the notion of a partial action of a monoid to introduce a\ngeneralization of automata, which we call \"a preautomaton\". We study properties\nof preautomata and of languages recognized by preautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.1528v1"
    },
    {
        "title": "On two Algorithmic Problems about Synchronizing Automata",
        "authors": [
            "Mikhail V. Berlinkov"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Under the assumption $\\mathcal{P} \\neq \\mathcal{NP}$, we prove that two\nnatural problems from the theory of synchronizing automata cannot be solved in\npolynomial time. The first problem is to decide whether a given reachable\npartial automaton is synchronizing. The second one is, given an $n$-state\nbinary complete synchronizing automaton, to compute its reset threshold within\nperformance ratio less than $d \\ln{(n)}$ for a specific constant $d>0$.\n",
        "pdf_link": "http://arxiv.org/pdf/1312.2226v4"
    },
    {
        "title": "Separating Regular Languages with First-Order Logic",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Given two languages, a separator is a third language that contains the first\none and is disjoint from the second one. We investigate the following decision\nproblem: given two regular input languages of finite words, decide whether\nthere exists a first-order definable separator. We prove that in order to\nanswer this question, sufficient information can be extracted from semigroups\nrecognizing the input languages, using a fixpoint computation. This yields an\nEXPTIME algorithm for checking first-order separability. Moreover, the\ncorrectness proof of this algorithm yields a stronger result, namely a\ndescription of a possible separator. Finally, we generalize this technique to\nanswer the same question for regular languages of infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3277v3"
    },
    {
        "title": "Turing degrees of limit sets of cellular automata",
        "authors": [
            "Alex Borello",
            "Julien Cervelle",
            "Pascal Vanier"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Cellular automata are discrete dynamical systems and a model of computation.\nThe limit set of a cellular automaton consists of the configurations having an\ninfinite sequence of preimages. It is well known that these always contain a\ncomputable point and that any non-trivial property on them is undecidable. We\ngo one step further in this article by giving a full characterization of the\nsets of Turing degrees of cellular automata: they are the same as the sets of\nTuring degrees of effectively closed sets containing a computable point.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3766v1"
    },
    {
        "title": "Proceedings 15th International Workshop on Verification of\n  Infinite-State Systems",
        "authors": [
            "Lukas Holik",
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This volume contains the proceedings of Infinity'13, the 15th International\nWorkshop on Verification of Infinite-State Systems, which was held in Hanoi,\nVietnam on the 14th of October 2013 as a satellite event of ATVA'13. The aim of\nthe INFINITY workshop is to provide a forum for researchers interested in the\ndevelopment of formal methods and algorithmic techniques for the analysis of\nsystems with infinitely many states, and their application in automated\nverification of complex software and hardware systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.6610v1"
    },
    {
        "title": "Lattice structures for bisimilar Probabilistic Automata",
        "authors": [
            "Johann Schuster",
            "Markus Siegle"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The paper shows that there is a deep structure on certain sets of bisimilar\nProbabilistic Automata (PA). The key prerequisite for these structures is a\nnotion of compactness of PA. It is shown that compact bisimilar PA form\nlattices. These results are then used in order to establish normal forms not\nonly for finite automata, but also for infinite automata, as long as they are\ncompact.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.6782v1"
    },
    {
        "title": "A Finite Exact Representation of Register Automata Configurations",
        "authors": [
            "Yu-Fang Chen",
            "Bow-Yaw Wang",
            "Di-De Yen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A register automaton is a finite automaton with finitely many registers\nranging from an infinite alphabet. Since the valuations of registers are\ninfinite, there are infinitely many configurations. We describe a technique to\nclassify infinite register automata configurations into finitely many exact\nrepresentative configurations. Using the finitary representation, we give an\nalgorithm solving the reachability problem for register automata. We moreover\ndefine a computation tree logic for register automata and solve its model\nchecking problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.6783v1"
    },
    {
        "title": "Synthesizing Finite-state Protocols from Scenarios and Requirements",
        "authors": [
            "Rajeev Alur",
            "Milo Martin",
            "Mukund Raghothaman",
            "Christos Stergiou",
            "Stavros Tripakis",
            "Abhishek Udupa"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Scenarios, or Message Sequence Charts, offer an intuitive way of describing\nthe desired behaviors of a distributed protocol. In this paper we propose a new\nway of specifying finite-state protocols using scenarios: we show that it is\npossible to automatically derive a distributed implementation from a set of\nscenarios augmented with a set of safety and liveness requirements, provided\nthe given scenarios adequately \\emph{cover} all the states of the desired\nimplementation. We first derive incomplete state machines from the given\nscenarios, and then synthesis corresponds to completing the transition relation\nof individual processes so that the global product meets the specified\nrequirements. This completion problem, in general, has the same complexity,\nPSPACE, as the verification problem, but unlike the verification problem, is\nNP-complete for a constant number of processes. We present two algorithms for\nsolving the completion problem, one based on a heuristic search in the space of\npossible completions and one based on OBDD-based symbolic fixpoint computation.\nWe evaluate the proposed methodology for protocol specification and the\neffectiveness of the synthesis algorithms using the classical alternating-bit\nprotocol.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.7150v1"
    },
    {
        "title": "Unary Pushdown Automata and Straight-Line Programs",
        "authors": [
            "Dmitry Chistikov",
            "Rupak Majumdar"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider decision problems for deterministic pushdown automata over a\nunary alphabet (udpda, for short). Udpda are a simple computation model that\naccept exactly the unary regular languages, but can be exponentially more\nsuccinct than finite-state automata. We complete the complexity landscape for\nudpda by showing that emptiness (and thus universality) is P-hard, equivalence\nand compressed membership problems are P-complete, and inclusion is\ncoNP-complete. Our upper bounds are based on a translation theorem between\nudpda and straight-line programs over the binary alphabet (SLPs). We show that\nthe characteristic sequence of any udpda can be represented as a pair of\nSLPs---one for the prefix, one for the lasso---that have size linear in the\nsize of the udpda and can be computed in polynomial time. Hence, decision\nproblems on udpda are reduced to decision problems on SLPs. Conversely, any SLP\ncan be converted in logarithmic space into a udpda, and this forms the basis\nfor our lower bound proofs. We show coNP-hardness of the ordered matching\nproblem for SLPs, from which we derive coNP-hardness for inclusion. In\naddition, we complete the complexity landscape for unary nondeterministic\npushdown automata by showing that the universality problem is $\\Pi_2 \\mathrm\nP$-hard, using a new class of integer expressions. Our techniques have\napplications beyond udpda. We show that our results imply $\\Pi_2 \\mathrm\nP$-completeness for a natural fragment of Presburger arithmetic and coNP lower\nbounds for compressed matching problems with one-character wildcards.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.0509v1"
    },
    {
        "title": "Towards Focus on Time",
        "authors": [
            "Maria Spichkova"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This short paper introduces a model for the specification and verification of\nreal-time system design: timed state transition diagrams.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.1006v1"
    },
    {
        "title": "Algebraic properties of word equations",
        "authors": [
            "Štěpán Holub",
            "Jan Žemlička"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The question about maximal size of independent system of word equations is\none of the most striking problems in combinatorics on words. Recently, Aleksi\nSaarela has introduced a new approach to the problem that is based on\nlinear-algebraic properties of polynomials encoding the equations and their\nsolutions. In this paper we develop further this approach and take into account\nother algebraic properties of polynomials, namely their factorization. This, in\nparticular, allows to improve the bound for the number of independent equations\nwith maximal rank from quadratic to linear.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.1951v2"
    },
    {
        "title": "Probabilistic Bisimulations for PCTL Model Checking of Interval MDPs",
        "authors": [
            "Vahid Hashemi",
            "Hassan Hatefi",
            "Jan Krčál"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Verification of PCTL properties of MDPs with convex uncertainties has been\ninvestigated recently by Puggelli et al. However, model checking algorithms\ntypically suffer from state space explosion. In this paper, we address\nprobabilistic bisimulation to reduce the size of such an MDPs while preserving\nPCTL properties it satisfies. We discuss different interpretations of\nuncertainty in the models which are studied in the literature and that result\nin two different definitions of bisimulations. We give algorithms to compute\nthe quotients of these bisimulations in time polynomial in the size of the\nmodel and exponential in the uncertain branching. Finally, we show by a case\nstudy that large models in practice can have small branching and that a\nsubstantial state space reduction can be achieved by our approach.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.2864v3"
    },
    {
        "title": "Automata Theory Meets Barrier Certificates: Temporal Logic Verification\n  of Nonlinear Systems",
        "authors": [
            "Tichakorn Wongpiromsarn",
            "Ufuk Topcu",
            "Andrew Lamperski"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider temporal logic verification of (possibly nonlinear) dynamical\nsystems evolving over continuous state spaces. Our approach combines\nautomata-based verification and the use of so-called barrier certificates.\nAutomata-based verification allows the decomposition the verification task into\na finite collection of simpler constraints over the continuous state space. The\nsatisfaction of these constraints in turn can be (potentially conservatively)\nproved by appropriately constructed barrier certificates. As a result, our\napproach, together with optimization-based search for barrier certificates,\nallows computational verification of dynamical systems against temporal logic\nproperties while avoiding explicit abstractions of the dynamics as commonly\ndone in literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1403.3524v1"
    },
    {
        "title": "From algebra to logic: there and back again -- the story of a hierarchy",
        "authors": [
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This is an extended survey of the results concerning a hierarchy of languages\nthat is tightly connected with the quantifier alternation hierarchy within the\ntwo-variable fragment of first order logic of the linear order.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.1035v1"
    },
    {
        "title": "State of Büchi Complementation",
        "authors": [
            "Ming-Hsien Tsai",
            "Seth Fogarty",
            "Moshe Y. Vardi",
            "Yih-Kuen Tsay"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Complementation of B\\\"uchi automata has been studied for over five decades\nsince the formalism was introduced in 1960. Known complementation constructions\ncan be classified into Ramsey-based, determinization-based, rank-based, and\nslice-based approaches. Regarding the performance of these approaches, there\nhave been several complexity analyses but very few experimental results. What\nespecially lacks is a comparative experiment on all of the four approaches to\nsee how they perform in practice. In this paper, we review the four approaches,\npropose several optimization heuristics, and perform comparative\nexperimentation on four representative constructions that are considered the\nmost efficient in each approach. The experimental results show that (1) the\ndeterminization-based Safra-Piterman construction outperforms the other three\nin producing smaller complements and finishing more tasks in the allocated time\nand (2) the proposed heuristics substantially improve the Safra-Piterman and\nthe slice-based constructions.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.4575v2"
    },
    {
        "title": "Optimal Strategy Synthesis for Request-Response Games",
        "authors": [
            "Florian Horn",
            "Wolfgang Thomas",
            "Nico Wallmeier",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We show the existence and effective computability of optimal winning\nstrategies for request-response games in case the quality of a play is measured\nby the limit superior of the mean accumulated waiting times between requests\nand their responses.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.4648v1"
    },
    {
        "title": "Improved Undecidability Results for Reachability Games on Recursive\n  Timed Automata",
        "authors": [
            "Shankara Narayanan Krishna",
            "Lakshmi Manasa",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study reachability games on recursive timed automata (RTA) that generalize\nAlur-Dill timed automata with recursive procedure invocation mechanism similar\nto recursive state machines. It is known that deciding the winner in\nreachability games on RTA is undecidable for automata with two or more clocks,\nwhile the problem is decidable for automata with only one clock. Ouaknine and\nWorrell recently proposed a time-bounded theory of real-time verification by\nclaiming that restriction to bounded-time recovers decidability for several key\ndecision problem related to real-time verification. We revisited games on\nrecursive timed automata with time-bounded restriction in the hope of\nrecovering decidability. However, we found that the problem still remains\nundecidable for recursive timed automata with three or more clocks. Using\nsimilar proof techniques we characterize a decidability frontier for a\ngeneralization of RTA to recursive stopwatch automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.5968v1"
    },
    {
        "title": "The Power of Proofs: New Algorithms for Timed Automata Model Checking\n  (with Appendix)",
        "authors": [
            "Peter Fontana",
            "Rance Cleaveland"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper presents the first model-checking algorithm for an expressive\nmodal mu-calculus over timed automata, $L^{\\mathit{rel},\n\\mathit{af}}_{\\nu,\\mu}$, and reports performance results for an implementation.\nThis mu-calculus contains extended time-modality operators and can express all\nof TCTL. Our algorithmic approach uses an \"on-the-fly\" strategy based on proof\nsearch as a means of ensuring high performance for both positive and negative\nanswers to model-checking questions. In particular, a set of proof rules for\nsolving model-checking problems are given and proved sound and complete; we\nencode our algorithm in these proof rules and model-check a property by\nconstructing a proof (or showing none exists) using these rules. One noteworthy\naspect of our technique is that we show that verification performance can be\nimproved with \\emph{derived rules}, whose correctness can be inferred from the\nmore primitive rules on which they are based. In this paper, we give the basic\nproof rules underlying our method, describe derived proof rules to improve\nperformance, and compare our implementation of this model checker to the UPPAAL\ntool.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.6104v3"
    },
    {
        "title": "Promise problems solved by quantum and classical finite automata",
        "authors": [
            "Shenggen Zheng",
            "Lvzhou Li",
            "Daowen Qiu",
            "Jozef Gruska"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The concept of promise problems was introduced and started to be\nsystematically explored by Even, Selman, Yacobi, Goldreich, and other scholars.\nIt has been argued that promise problems should be seen as partial decision\nproblems and as such that they are more fundamental than decision problems and\nformal languages that used to be considered as the basic ones for complexity\ntheory. The main purpose of this paper is to explore the promise problems\naccepted by classical, quantum and also semi-quantum finite automata. More\nspecifically, we first introduce two acceptance modes of promise problems,\nrecognizability and solvability, and explore their basic properties.\nAfterwards, we show several results concerning descriptional complexity on\npromise problems. In particular, we prove: (1) there is a promise problem that\ncan be recognized exactly by measure-once one-way quantum finite automata\n(MO-1QFA), but no deterministic finite automata (DFA) can recognize it; (2)\nthere is a promise problem that can be solved with error probability\n$\\epsilon\\leq 1/3$ by one-way finite automaton with quantum and classical\nstates (1QCFA), but no one-way probability finite automaton (PFA) can solve it\nwith error probability $\\epsilon\\leq 1/3$; and especially, (3) there are\npromise problems $A(p)$ with prime $p$ that can be solved {\\em with any error\nprobability} by MO-1QFA with only two quantum basis states, but they can not be\nsolved exactly by any MO-1QFA with two quantum basis states; in contrast, the\nminimal PFA solving $A(p)$ with any error probability (usually smaller than\n$1/2$) has $p$ states. Finally, we mention a number of problems related to\npromise for further study.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.3870v3"
    },
    {
        "title": "FREC 14: FRontiers of RECognizability",
        "authors": [
            "Géraud Sénizergues"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  These proceedings are gathering twelve different research papers developping\nthe theory of recognizability for various kinds of discrete objects: words.\nterms, graphs, etc...\n",
        "pdf_link": "http://arxiv.org/pdf/1411.5611v3"
    },
    {
        "title": "On Streaming String Transducers and HDT0L Systems",
        "authors": [
            "Emmanuel Filiot",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Copyless streaming string transducers (copyless SST) have been introduced by\nR. Alur and P. Cerny in 2010 as a one-way deterministic automata model to\ndefine transformations of finite strings. Copyless SST extend deterministic\nfinite state automata with a set of registers in which to store intermediate\noutput strings, and those registers can be combined and updated all along the\nrun, in a linear manner, i.e., no register content can be copied on\ntransitions. It is known that copyless SST capture exactly the class of\nMSO-definable string-to-string transformations, as defined by B. Courcelle, and\nare equi-expressive to deterministic two-way transducers. They enjoy good\nalgorithmic properties. Most notably, they have decidable equivalence problem\n(in PSpace). In this paper, we show that they still have decidable equivalence\nproblem even without the copyless restriction. The proof reduces to the HDT0L\nsequence equivalence problem, which is known to be decidable. We also show that\nthis latter problem is as difficult as the SST equivalence problem, modulo\nlinear time reduction.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.0537v1"
    },
    {
        "title": "J2 Radical in Automata Nearrings",
        "authors": [
            "Tim Boykett",
            "Gerhard Wendt"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Looking at the automata defined over a group alphabet as a nearring, we see\nthat they are a highly complicated structure. As with ring theory, one method\nto deal with complexity is to look at semisimplicity modulo radical structures.\nWe find some bounds on the Jacobson 2-radical and show that in certain groups,\nthis radical can be explicitly found and the semisimple image determined.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.1736v1"
    },
    {
        "title": "PaREM: A Novel Approach for Parallel Regular Expression Matching",
        "authors": [
            "Suejb Memeti",
            "Sabri Pllana"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Regular expression matching is essential for many applications, such as\nfinding patterns in text, exploring substrings in large DNA sequences, or\nlexical analysis. However, sequential regular expression matching may be\ntime-prohibitive for large problem sizes. In this paper, we describe a novel\nalgorithm for parallel regular expression matching via deterministic finite\nautomata. Furthermore, we present our tool PaREM that accepts regular\nexpressions and finite automata as input and automatically generates the\ncorresponding code for our algorithm that is amenable for parallel execution on\nshared-memory systems. We evaluate our parallel algorithm empirically by\ncomparing it with a commonly used algorithm for sequential regular expression\nmatching. Experiments on a dual-socket shared-memory system with 24 physical\ncores show speed-ups of up to 21x for 48 threads.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.1741v2"
    },
    {
        "title": "Search of Complex Binary Cellular Automata Using Behavioral Metrics",
        "authors": [
            "Juan C. López-González",
            "Antonio Rueda-Toicen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We propose the characterization of binary cellular automata using a set of\nbehavioral metrics that are applied to the minimal Boolean form of a cellular\nautomaton's transition function. These behavioral metrics are formulated to\nsatisfy heuristic criteria derived from elementary cellular automata. Behaviors\ncharacterized through these metrics are growth, decrease, chaoticity, and\nstability. From these metrics, two measures of global behavior are calculated:\n1) a static measure that considers all possible input patterns and counts the\noccurrence of the proposed metrics in the truth table of the minimal Boolean\nform of the automaton; 2) a dynamic measure, corresponding to the mean of the\nbehavioral metrics in $n$ executions of the automaton, starting from $n$ random\ninitial states. We use these measures to characterize a cellular automaton and\nguide a genetic search algorithm, which selects cellular automata similar to\nthe Game of Life. Using this method, we found an extensive set of complex\nbinary cellular automata with interesting properties, including\nself-replication.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.2287v3"
    },
    {
        "title": "Functional Automata - Formal Languages for Computer Science Students",
        "authors": [
            "Marco T. Morazán",
            "Rosario Antunez"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  An introductory formal languages course exposes advanced undergraduate and\nearly graduate students to automata theory, grammars, constructive proofs,\ncomputability, and decidability. Programming students find these topics to be\nchallenging or, in many cases, overwhelming and on the fringe of Computer\nScience. The existence of this perception is not completely absurd since\nstudents are asked to design and prove correct machines and grammars without\nbeing able to experiment nor get immediate feedback, which is essential in a\nlearning context. This article puts forth the thesis that the theory of\ncomputation ought to be taught using tools for actually building computations.\nIt describes the implementation and the classroom use of a library, FSM,\ndesigned to provide students with the opportunity to experiment and test their\ndesigns using state machines, grammars, and regular expressions. Students are\nable to perform random testing before proceeding with a formal proof of\ncorrectness. That is, students can test their designs much like they do in a\nprogramming course. In addition, the library easily allows students to\nimplement the algorithms they develop as part of the constructive proofs they\nwrite. Providing students with this ability ought to be a new trend in the\nformal languages classroom.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.4878v1"
    },
    {
        "title": "Lower bounds on the size of semi-quantum finite automata",
        "authors": [
            "Lvzhou Li",
            "Daowen Qiu"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In the literature, there exist several interesting hybrid models of finite\nautomata which have both quantum and classical states. We call them\nsemi-quantum automata. In this paper, we compare the descriptional power of\nthese models with that of DFA. Specifically, we present a uniform method that\ngives a lower bound on the size of the three existing main models of\nsemi-quantum automata, and this bound shows that semi-quantum automata can be\nat most exponentially more concise than DFA. Compared with a recent work\n(Bianchi, Mereghetti, Palano, Theoret. Comput. Sci., 551(2014), 102-115), our\nmethod shows the following two advantages: (i) our method is much more concise;\nand (ii) our method is universal, since it is applicable to the three existing\nmain models of semi-quantum automata, instead of only a specific model.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.02839v2"
    },
    {
        "title": "Transducer Descriptions of DNA Code Properties and Undecidability of\n  Antimorphic Problems",
        "authors": [
            "Lila Kari",
            "Stavros Konstantinidis",
            "Steffen Kopecki"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This work concerns formal descriptions of DNA code properties, and builds on\nprevious work on transducer descriptions of classic code properties and on\ntrajectory descriptions of DNA code properties. This line of research allows us\nto give a property as input to an algorithm, in addition to any regular\nlanguage, which can then answer questions about the language and the property.\nHere we define DNA code properties via transducers and show that this method is\nstrictly more expressive than that of trajectories, without sacrificing the\nefficiency of deciding the satisfaction question. We also show that the\nmaximality question can be undecidable. Our undecidability results hold not\nonly for the fixed DNA involution but also for any fixed antimorphic\npermutation. Moreover, we also show the undecidability of the antimorphic\nversion of the Post Corresponding Problem, for any fixed antimorphic\npermutation.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.00035v1"
    },
    {
        "title": "Decidable Horn Systems with Difference Constraints Arithmetic",
        "authors": [
            "Radu Iosif"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This paper tackles the problem of the existence of solutions for recursive\nsystems of Horn clauses with second-order variables interpreted as integer\nrelations, and harnessed by quantifier-free difference bounds arithmetic. We\nstart by proving the decidability of the problem \"does the system have a\nsolution ?\" for a simple class of Horn systems with one second-order variable\nand one non-linear recursive rule. The proof relies on a construction of a tree\nautomaton recognizing all cycles in the weighted graph corresponding to every\nunfolding tree of the Horn system. We constrain the tree to recognize only\ncycles of negative weight by adding a Presburger formula that harnesses the\nnumber of times each rule is fired, and reduce our problem to the universality\nof a Presburger-constrained tree automaton. We studied the complexity of this\nproblem and found it to be in \\textsc{NEXPtime} with an \\textsc{EXPtime}-hard\nlower bound. Second, we drop the univariate restriction and consider\nmultivariate second-order Horn systems with a structural restriction, called\n\\emph{flatness}. This more general class of Horn systems is found to be\ndecidable, within the same complexity bounds. Finally, we encode the\nreachability problem for Alternating Branching Vector Addition Systems (ABVASS)\nusing Horn systems and prove that, for flat ABVASS, this problem is in\nco-\\textsc{NEXPtime}.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.00258v3"
    },
    {
        "title": "Timed pushdown automata revisited",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This paper contains two results on timed extensions of pushdown automata\n(PDA). As our first result we prove that the model of dense-timed PDA of\nAbdulla et al. collapses: it is expressively equivalent to dense-timed PDA with\ntimeless stack. Motivated by this result, we advocate the framework of\nfirst-order definable PDA, a specialization of PDA in sets with atoms, as the\nright setting to define and investigate timed extensions of PDA. The general\nmodel obtained in this way is Turing complete. As our second result we prove\nNEXPTIME upper complexity bound for the non-emptiness problem for an expressive\nsubclass. As a byproduct, we obtain a tight EXPTIME complexity bound for a more\nrestrictive subclass of PDA with timeless stack, thus subsuming the complexity\nbound known for dense-timed PDA.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.02422v2"
    },
    {
        "title": "Regular realizability problems and regular languages",
        "authors": [
            "Alexander A. Rubtsov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate regular realizability (RR) problems, which are the problems of\nverifying whether intersection of a regular language -- the input of the\nproblem -- and fixed language called filter is non-empty. We consider two kind\nof problems depending on representation of regular language. If a regular\nlanguage on input is represented by a DFA, then we obtain (deterministic)\nregular realizability problem and we show that in this case the complexity of\nregular realizability problem for an arbitrary regular filter is either\nL-complete or NL-complete. We also show that in case of representation regular\nlanguage on input by NFA the problem is always NL-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.05879v1"
    },
    {
        "title": "Fully bordered words",
        "authors": [
            "Štěpán Holub",
            "Mike Müller"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We characterize binary words that have exactly two unbordered conjugates and\nshow that they can be expressed as a product of two palindromes.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.02222v2"
    },
    {
        "title": "Adaptive Homing is in P",
        "authors": [
            "Natalia Kushik",
            "Nina Yevtushenko"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Homing preset and adaptive experiments with Finite State Machines (FSMs) are\nwidely used when a non-initialized discrete event system is given for testing\nand thus, has to be set to the known state at the first step. The length of a\nshortest homing sequence is known to be exponential with respect to the number\nof states for a complete observable nondeterministic FSM while the problem of\nchecking the existence of such sequence (Homing problem) is PSPACE-complete. In\norder to decrease the complexity of related problems, one can consider adaptive\nexperiments when a next input to be applied to a system under experiment\ndepends on the output responses to the previous inputs. In this paper, we study\nthe problem of the existence of an adaptive homing experiment for complete\nobservable nondeterministic machines. We show that if such experiment exists\nthen it can be constructed with the use of a polynomial-time algorithm with\nrespect to the number of FSM states.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.02444v1"
    },
    {
        "title": "Reachability analysis of first-order definable pushdown systems",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study pushdown systems where control states, stack alphabet, and\ntransition relation, instead of being finite, are first-order definable in a\nfixed countably-infinite structure. We show that the reachability analysis can\nbe addressed with the well-known saturation technique for the wide class of\noligomorphic structures. Moreover, for the more restrictive homogeneous\nstructures, we are able to give concrete complexity upper bounds. We show ample\napplicability of our technique by presenting several concrete examples of\nhomogeneous structures, subsuming, with optimal complexity, known results from\nthe literature. We show that infinitely many such examples of homogeneous\nstructures can be obtained with the classical wreath product construction.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.02651v2"
    },
    {
        "title": "A Fibrational Approach to Automata Theory",
        "authors": [
            "Liang-Ting Chen",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  For predual categories C and D we establish isomorphisms between opfibrations\nrepresenting local varieties of languages in C, local pseudovarieties of\nD-monoids, and finitely generated profinite D-monoids. The global sections of\nthese opfibrations are shown to correspond to varieties of languages in C,\npseudovarieties of D-monoids, and profinite equational theories of D-monoids,\nrespectively. As an application, we obtain a new proof of Eilenberg's variety\ntheorem along with several related results, covering varieties of languages and\ntheir coalgebraic modifications, Straubing's C-varieties, fully invariant local\nvarieties, etc., within a single framework.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.02692v1"
    },
    {
        "title": "Context-Free Language Theory Formalization",
        "authors": [
            "Marcus Vinícius Midena Ramos",
            "Ruy J. G. B. de Queiroz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Proof assistants are software-based tools that are used in the mechanization\nof proof construction and validation in mathematics and computer science, and\nalso in certified program development. Different tools are being increasingly\nused in order to accelerate and simplify proof checking. Context-free language\ntheory is a well-established area of mathematics, relevant to computer science\nfoundations and technology. This proposal aims at formalizing parts of\ncontext-free language theory in the Coq proof assistant. This report presents\nthe underlying theory and general characteristics of proof assistants,\nincluding Coq itself, discusses its use in relevant formalization projects,\npresents the current status of the implementation, addresses related projects\nand the contributions of this work. The results obtained so far include the\nformalization of closure properties for context-free grammars (under union,\nconcatenation and closure) and the formalization of grammar simplification.\nGrammar simplification is a subject of high importance in computer language\nprocessing technology as well as in formal language theory, and the\nformalization refers to the fact that general context-free grammars generate\nlanguages that can be also generated by simpler and equivalent context-free\ngrammars. Namely, useless symbol elimination, inaccessible symbol elimination,\nunit rules elimination and empty rules elimination operations were described\nand proven correct with respect to the preservation of the language generated\nby the original grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.00061v1"
    },
    {
        "title": "A Formalisation of Finite Automata using Hereditarily Finite Sets",
        "authors": [
            "Lawrence C. Paulson"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Hereditarily finite (HF) set theory provides a standard universe of sets, but\nwith no infinite sets. Its utility is demonstrated through a formalisation of\nthe theory of regular languages and finite automata, including the\nMyhill-Nerode theorem and Brzozowski's minimisation algorithm. The states of an\nautomaton are HF sets, possibly constructed by product, sum, powerset and\nsimilar operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.01662v1"
    },
    {
        "title": "State complexity of catenation combined with a boolean operation: a\n  unified approach",
        "authors": [
            "Pascal Caron",
            "Jean-Gabriel Luque",
            "Ludovic Mignot",
            "Bruno Patrou"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we study the state complexity of catenation combined with\nsymmetric difference. First, an upper bound is computed using some combinatoric\ntools. Then, this bound is shown to be tight by giving a witness for it.\nMoreover, we relate this work with the study of state complexity for two other\ncombinations: catenation with union and catenation with intersection. And we\nextract a unified approach which allows to obtain the state complexity of any\ncombination involving catenation and a binary boolean operation.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.03474v1"
    },
    {
        "title": "Automatic Completion of Distributed Protocols with Symmetry",
        "authors": [
            "Rajeev Alur",
            "Mukund Raghothaman",
            "Christos Stergiou",
            "Stavros Tripakis",
            "Abhishek Udupa"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A distributed protocol is typically modeled as a set of communicating\nprocesses, where each process is described as an extended state machine along\nwith fairness assumptions, and its correctness is specified using safety and\nliveness requirements. Designing correct distributed protocols is a challenging\ntask. Aimed at simplifying this task, we allow the designer to leave some of\nthe guards and updates to state variables in the description of extended state\nmachines as unknown functions. The protocol completion problem then is to find\ninterpretations for these unknown functions while guaranteeing correctness. In\nmany distributed protocols, process behaviors are naturally symmetric, and\nthus, synthesized expressions are further required to obey symmetry\nconstraints. Our counterexample-guided synthesis algorithm consists of\nrepeatedly invoking two phases. In the first phase, candidates for unknown\nexpressions are generated using the SMT solver Z3. This phase requires\ncarefully orchestrating constraints to enforce the desired symmetry in\nread/write accesses. In the second phase, the resulting completed protocol is\nchecked for correctness using a custom-built model checker that handles\nfairness assumptions, safety and liveness requirements, and exploits symmetry.\nWhen model checking fails, our tool examines a set of counterexamples to\nsafety/liveness properties to generate constraints on unknown functions that\nmust be satisfied by subsequent completions. For evaluation, we show that our\nprototype is able to automatically discover interesting missing details in\ndistributed protocols for mutual exclusion, self stabilization, and cache\ncoherence.\n",
        "pdf_link": "http://arxiv.org/pdf/1505.04409v1"
    },
    {
        "title": "Logic and Branching Automata",
        "authors": [
            "Bedon Nicolas"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we study the logical aspects of branching automata, as defined\nby Lodaya and Weil. We first prove that the class of languages of finite N-free\nposets recognized by branching automata is closed under complementation. Then\nwe define a logic, named P-MSO as it is a extension of monadic second-order\nlogic with Presburger arithmetic, and show that it is precisely as expressive\nas branching automata. As a consequence of the effectiveness of the\nconstruction of one formalism from the other, the P-MSO theory of the class of\nall finite N-free posets is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.02890v2"
    },
    {
        "title": "One-Tape Turing Machine Variants and Language Recognition",
        "authors": [
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We present two restricted versions of one-tape Turing machines. Both\ncharacterize the class of context-free languages. In the first version,\nproposed by Hibbard in 1967 and called limited automata, each tape cell can be\nrewritten only in the first $d$ visits, for a fixed constant $d\\geq 2$.\nFurthermore, for $d=2$ deterministic limited automata are equivalent to\ndeterministic pushdown automata, namely they characterize deterministic\ncontext-free languages. Further restricting the possible operations, we\nconsider strongly limited automata. These models still characterize\ncontext-free languages. However, the deterministic version is less powerful\nthan the deterministic version of limited automata. In fact, there exist\ndeterministic context-free languages that are not accepted by any deterministic\nstrongly limited automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1507.08582v1"
    },
    {
        "title": "Structural Complexity of Multi-Valued Partial Functions Computed by\n  Nondeterministic Pushdown Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  This paper continues a systematic and comprehensive study on the structural\nproperties of CFL functions, which are in general multi-valued partial\nfunctions computed by one-way one-head nondeterministic pushdown automata\nequipped with write-only output tapes (or pushdown transducers), where CFL\nrefers to a relevance to context-free languages. The CFL functions tend to\nbehave quite differently from their corresponding context-free languages. We\nextensively discuss containments, separations, and refinements among various\nclasses of functions obtained from the CFL functions by applying Boolean\noperations, functional composition, many-one relativization, and Turing\nrelativization. In particular, Turing relativization helps construct a\nhierarchy over the class of CFL functions. We also analyze the computational\ncomplexity of optimization functions, which are to find optimal values of CFL\nfunctions, and discuss their relationships to the associated languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.05814v1"
    },
    {
        "title": "Weight Assignment Logic",
        "authors": [
            "Vitaly Perevoshchikov"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We introduce a weight assignment logic for reasoning about quantitative\nlanguages of infinite words. This logic is an extension of the classical MSO\nlogic and permits to describe quantitative properties of systems with multiple\nweight parameters, e.g., the ratio between rewards and costs. We show that this\nlogic is expressively equivalent to unambiguous weighted B\\\"uchi automata. We\nalso consider an extension of weight assignment logic which is expressively\nequivalent to nondeterministic weighted B\\\"uchi automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.06121v1"
    },
    {
        "title": "Inkdots as advice for finite automata",
        "authors": [
            "Uğur Küçük",
            "A. C. Cem Say",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We examine inkdots placed on the input string as a way of providing advice to\nfinite automata, and establish the relations between this model and the\npreviously studied models of advised finite automata. The existence of an\ninfinite hierarchy of classes of languages that can be recognized with the help\nof increasing numbers of inkdots as advice is shown. The effects of different\nforms of advice on the succinctness of the advised machines are examined. We\nalso study randomly placed inkdots as advice to probabilistic finite automata,\nand demonstrate the superiority of this model over its deterministic version.\nEven very slowly growing amounts of space can become a resource of meaningful\nuse if the underlying advised model is extended with access to secondary\nmemory, while it is famously known that such small amounts of space are not\nuseful for unadvised one-way Turing machines.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.03712v3"
    },
    {
        "title": "Periods and borders of random words",
        "authors": [
            "Štěpán Holub",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate the behavior of the periods and border lengths of random words\nover a fixed alphabet. We show that the asymptotic probability that a random\nword has a given maximal border length $k$ is a constant, depending only on $k$\nand the alphabet size $\\ell$. We give a recurrence that allows us to determine\nthese constants with any required precision. This also allows us to evaluate\nthe expected period of a random word. For the binary case, the expected period\nis asymptotically about $n-1.641$. We also give explicit formulas for the\nprobability that a random word is unbordered or has maximum border length one.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.05240v1"
    },
    {
        "title": "The Word Problem for Omega-Terms over the Trotter-Weil Hierarchy",
        "authors": [
            "Manfred Kufleitner",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  For two given $\\omega$-terms $\\alpha$ and $\\beta$, the word problem for\n$\\omega$-terms over a variety $\\boldsymbol{\\mathrm{V}}$ asks whether\n$\\alpha=\\beta$ in all monoids in $\\boldsymbol{\\mathrm{V}}$. We show that the\nword problem for $\\omega$-terms over each level of the Trotter-Weil Hierarchy\nis decidable. More precisely, for every fixed variety in the Trotter-Weil\nHierarchy, our approach yields an algorithm in nondeterministic logarithmic\nspace (NL). In addition, we provide deterministic polynomial time algorithms\nwhich are more efficient than straightforward translations of the\nNL-algorithms. As an application of our results, we show that separability by\nthe so-called corners of the Trotter-Weil Hierarchy is witnessed by\n$\\omega$-terms (this property is also known as $\\omega$-reducibility). In\nparticular, the separation problem for the corners of the Trotter-Weil\nHierarchy is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.05364v2"
    },
    {
        "title": "Level Two of the Quantifier Alternation Hierarchy over Infinite Words",
        "authors": [
            "Manfred Kufleitner",
            "Tobias Walter"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The study of various decision problems for logic fragments has a long history\nin computer science. This paper is on the membership problem for a fragment of\nfirst-order logic over infinite words; the membership problem asks for a given\nlanguage whether it is definable in some fixed fragment. The alphabetic\ntopology was introduced as part of an effective characterization of the\nfragment $\\Sigma_2$ over infinite words. Here, $\\Sigma_2$ consists of the\nfirst-order formulas with two blocks of quantifiers, starting with an\nexistential quantifier. Its Boolean closure is $\\mathbb{B}\\Sigma_2$. Our first\nmain result is an effective characterization of the Boolean closure of the\nalphabetic topology, that is, given an $\\omega$-regular language $L$, it is\ndecidable whether $L$ is a Boolean combination of open sets in the alphabetic\ntopology. This is then used for transferring Place and Zeitoun's recent\ndecidability result for $\\mathbb{B}\\Sigma_2$ from finite to infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.06207v1"
    },
    {
        "title": "Synchronous Subsequentiality and Approximations to Undecidable Problems",
        "authors": [
            "Christian Wurm"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We introduce the class of synchronous subsequential relations, a subclass of\nthe synchronous relations which embodies some properties of subsequential\nrelations. If we take relations of this class as forming the possible\ntransitions of an infinite automaton, then most decision problems (apart from\nmembership) still remain undecidable (as they are for synchronous and\nsubsequential rational relations), but on the positive side, they can be\napproximated in a meaningful way we make precise in this paper. This might make\nthe class useful for some applications, and might serve to establish an\nintermediate position in the trade-off between issues of expressivity and\n(un)decidability.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.07200v1"
    },
    {
        "title": "An Automata Theoretic Approach to the Zero-One Law for Regular\n  Languages: Algorithmic and Logical Aspects",
        "authors": [
            "Ryoma Sin'ya"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  A zero-one language L is a regular language whose asymptotic probability\nconverges to either zero or one. In this case, we say that L obeys the zero-one\nlaw. We prove that a regular language obeys the zero-one law if and only if its\nsyntactic monoid has a zero element, by means of Eilenberg's variety theoretic\napproach. Our proof gives an effective automata characterisation of the\nzero-one law for regular languages, and it leads to a linear time algorithm for\ntesting whether a given regular language is zero-one. In addition, we discuss\nthe logical aspects of the zero-one law for regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1509.07209v1"
    },
    {
        "title": "Vector Reachability Problem in $\\mathrm{SL}(2,\\mathbb{Z})$",
        "authors": [
            "Igor Potapov",
            "Pavel Semukhin"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The decision problems on matrices were intensively studied for many decades\nas matrix products play an essential role in the representation of various\ncomputational processes. However, many computational problems for matrix\nsemigroups are inherently difficult to solve even for problems in low\ndimensions and most matrix semigroup problems become undecidable in general\nstarting from dimension three or four.\n  This paper solves two open problems about the decidability of the vector\nreachability problem over a finitely generated semigroup of matrices from\n$\\mathrm{SL}(2,\\mathbb{Z})$ and the point to point reachability (over rational\nnumbers) for fractional linear transformations, where associated matrices are\nfrom $\\mathrm{SL}(2,\\mathbb{Z})$. The approach to solving reachability problems\nis based on the characterization of reachability paths between points which is\nfollowed by the translation of numerical problems on matrices into\ncomputational and combinatorial problems on words and formal languages. We also\ngive a geometric interpretation of reachability paths and extend the\ndecidability results to matrix products represented by arbitrary labelled\ndirected graphs. Finally, we will use this technique to prove that a special\ncase of the scalar reachability problem is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.03227v2"
    },
    {
        "title": "A synchronous rendering of hybrid systems for designing Plant-on-a-Chip\n  (PoC)",
        "authors": [
            "Avinash Malik",
            "Partha S Roop",
            "Sidharta Andalam",
            "Eugene Yip",
            "Mark Trew"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Hybrid systems are discrete controllers that are used for controlling a\nphysical process (plant) exhibiting continuous dynamics. A hybrid automata (HA)\nis a well known and widely used formal model for the specification of such\nsystems. While many methods exist for simulating hybrid automata, there are no\nknown approaches for the automatic code generation from HA that are semantic\npreserving. If this were feasible, it would enable the design of a\nplant-on-a-chip (PoC) system that could be used for the emulation of the plant\nto validate discrete controllers. Such an approach would need to be\nmathematically sound and should not rely on numerical solvers. We propose a\nmethod of PoC design for plant emulation, not possible before. The approach\nrestricts input/output (I/O) HA models using a set of criteria for\nwell-formedness which are statically verified. Following verification, we use\nan abstraction based on a synchronous approach to facilitate code generation.\nThis is feasible through a sound transformation to synchronous HA. We compare\nour method (the developed tool called Piha) to the widely used Simulink R\nsimulation framework and show that our method is superior in both execution\ntime and code size. Our approach to the PoC problem paves the way for the\nemulation of physical plants in diverse domains such as robotics, automation,\nmedical devices, and intelligent transportation systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.04336v1"
    },
    {
        "title": "Shortest paths in one-counter systems",
        "authors": [
            "Dmitry Chistikov",
            "Wojciech Czerwiński",
            "Piotr Hofman",
            "Michał Pilipczuk",
            "Michael Wehar"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We show that any one-counter automaton with $n$ states, if its language is\nnon-empty, accepts some word of length at most $O(n^2)$. This closes the gap\nbetween the previously known upper bound of $O(n^3)$ and lower bound of\n$\\Omega(n^2)$. More generally, we prove a tight upper bound on the length of\nshortest paths between arbitrary configurations in one-counter transition\nsystems (weaker bounds have previously appeared in the literature).\n",
        "pdf_link": "http://arxiv.org/pdf/1510.05460v5"
    },
    {
        "title": "Relations on words",
        "authors": [
            "Michel Rigo"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In the first part of this survey, we present classical notions arising in\ncombinatorics on words: growth function of a language, complexity function of\nan infinite word, pattern avoidance, periodicity and uniform recurrence. Our\npresentation tries to set up a unified framework with respect to a given binary\nrelation.\n  In the second part, we mainly focus on abelian equivalence, $k$-abelian\nequivalence, combinatorial coefficients and associated relations, Parikh\nmatrices and $M$-equivalence. In particular, some new refinements of abelian\nequivalence are introduced.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.03364v1"
    },
    {
        "title": "Complexity of regular abstractions of one-counter languages",
        "authors": [
            "Mohamed Faouzi Atig",
            "Dmitry Chistikov",
            "Piotr Hofman",
            "K Narayan Kumar",
            "Prakash Saivasan",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study the computational and descriptional complexity of the following\ntransformation: Given a one-counter automaton (OCA) A, construct a\nnondeterministic finite automaton (NFA) B that recognizes an abstraction of the\nlanguage L(A): its (1) downward closure, (2) upward closure, or (3) Parikh\nimage.\n  For the Parikh image over a fixed alphabet and for the upward and downward\nclosures, we find polynomial-time algorithms that compute such an NFA. For the\nParikh image with the alphabet as part of the input, we find a quasi-polynomial\ntime algorithm and prove a completeness result: we construct a sequence of OCA\nthat admits a polynomial-time algorithm iff there is one for all OCA.\n  For all three abstractions, it was previously unknown if appropriate NFA of\nsub-exponential size exist.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.03419v1"
    },
    {
        "title": "Time Window Temporal Logic",
        "authors": [
            "Cristian-Ioan Vasile",
            "Derya Aksaray",
            "Calin Belta"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper introduces time window temporal logic (TWTL), a rich expressivity\nlanguage for describing various time bounded specifications. In particular, the\nsyntax and semantics of TWTL enable the compact representation of serial tasks,\nwhich are typically seen in robotics and control applications. This paper also\ndiscusses the relaxation of TWTL formulae with respect to deadlines of tasks.\nEfficient automata-based frameworks to solve synthesis, verification and\nlearning problems are also presented. The key ingredient to the presented\nsolution is an algorithm to translate a TWTL formula to an annotated finite\nstate automaton that encodes all possible temporal relaxations of the\nspecification. Case studies illustrating the expressivity of the logic and the\nproposed algorithms are included.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.04294v1"
    },
    {
        "title": "A Polynomial-Time Algorithm for Reachability in Branching VASS in\n  Dimension One",
        "authors": [
            "Stefan Göller",
            "Christoph Haase",
            "Ranko Lazić",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Branching VASS (BVASS) generalise vector addition systems with states by\nallowing for special branching transitions that can non-deterministically\ndistribute a counter value between two control states. A run of a BVASS\nconsequently becomes a tree, and reachability is to decide whether a given\nconfiguration is the root of a reachability tree. This paper shows\nP-completeness of reachability in BVASS in dimension one, the first\ndecidability result for reachability in a subclass of BVASS known so far.\nMoreover, we show that coverability and boundedness in BVASS in dimension one\nare P-complete as well.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05547v2"
    },
    {
        "title": "Repetition-Free Derivability from a Regular Grammar is NP-Hard",
        "authors": [
            "Jochen Burghardt"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We prove the NP-hardness of the problem whether a given word can be derived\nfrom a given regular grammar without repeated occurrence of any nonterminal.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05555v2"
    },
    {
        "title": "Eilenberg Theorems for Free",
        "authors": [
            "Henning Urbat",
            "Jiří Adámek",
            "Liang-Ting Chen",
            "Stefan Milius"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Eilenberg-type correspondences, relating varieties of languages (e.g. of\nfinite words, infinite words, or trees) to pseudovarieties of finite algebras,\nform the backbone of algebraic language theory. Numerous such correspondences\nare known in the literature. We demonstrate that they all arise from the same\nrecipe: one models languages and the algebras recognizing them by monads on an\nalgebraic category, and applies a Stone-type duality. Our main contribution is\na variety theorem that covers e.g. Wilke's and Pin's work on\n$\\infty$-languages, the variety theorem for cost functions of Daviaud,\nKuperberg, and Pin, and unifies the two previous categorical approaches of\nBoja\\'nczyk and of Ad\\'amek et al. In addition we derive a number of new\nresults, including an extension of the local variety theorem of Gehrke,\nGrigorieff, and Pin from finite to infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05831v3"
    },
    {
        "title": "One-Counter Automata with Counter Observability",
        "authors": [
            "Benedikt Bollig"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In a one-counter automaton (OCA), one can produce a letter from some finite\nalphabet, increment and decrement the counter by one, or compare it with\nconstants up to some threshold. It is well-known that universality and language\ninclusion for OCAs are undecidable. In this paper, we consider OCAs with\ncounter observability: Whenever the automaton produces a letter, it outputs the\ncurrent counter value along with it. Hence, its language is now a set of words\nover an infinite alphabet. We show that universality and inclusion for that\nmodel are PSPACE-complete, thus no harder than the corresponding problems for\nfinite automata. In fact, by establishing a link with visibly one-counter\nautomata, we show that OCAs with counter observability are effectively\ndeterminizable and closed under all boolean operations.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05940v2"
    },
    {
        "title": "Regular Language Distance and Entropy",
        "authors": [
            "Austin J. Parker",
            "Kelly B. Yancey",
            "Matthew P. Yancey"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper addresses the problem of determining the distance between two\nregular languages. It will show how to expand Jaccard distance, which works on\nfinite sets, to potentially-infinite regular languages. The entropy of a\nregular language plays a large role in the extension. Much of the paper is\nspent investigating the entropy of a regular language. This includes addressing\nissues that have required previous authors to rely on the upper limit of\nShannon's traditional formulation of entropy, because its limit does not always\nexist. The paper also includes proposing a new limit based formulation for the\nentropy of a regular language and proves that formulation to both exist and be\nequivalent to Shannon's original formulation (when it exists). Additionally,\nthe proposed formulation is shown to equal an analogous but formally quite\ndifferent notion of topological entropy from Symbolic Dynamics -- consequently\nalso showing Shannon's original formulation to be equivalent to topological\nentropy. Surprisingly, the natural Jaccard-like entropy distance is trivial in\nmost cases. Instead, the {\\it entropy sum} distance metric is suggested, and\nshown to be granular in certain situations.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.07715v1"
    },
    {
        "title": "The Complexity of Synchronizing Markov Decision Processes",
        "authors": [
            "Laurent Doyen",
            "Thierry Massart",
            "Mahsa Shirmohammadi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider Markov decision processes (MDP) as generators of sequences of\nprobability distributions over states. A probability distribution is\np-synchronizing if the probability mass is at least p in a single state, or in\na given set of states. We consider four temporal synchronizing modes: a\nsequence of probability distributions is always p-synchronizing, eventually\np-synchronizing, weakly p-synchronizing, or strongly p-synchronizing if,\nrespectively, all, some, infinitely many, or all but finitely many\ndistributions in the sequence are p-synchronizing.\n  For each synchronizing mode, an MDP can be (i) sure winning if there is a\nstrategy that produces a 1-synchronizing sequence; (ii) almost-sure winning if\nthere is a strategy that produces a sequence that is, for all epsilon > 0, a\n(1-epsilon)-synchronizing sequence; (iii) limit-sure winning if for all epsilon\n> 0, there is a strategy that produces a (1-epsilon)-synchronizing sequence.\n  We provide fundamental results on the expressiveness, decidability, and\ncomplexity of synchronizing properties for MDPs. For each synchronizing mode,\nwe consider the problem of deciding whether an MDP is sure, almost-sure, or\nlimit-sure winning, and we establish matching upper and lower complexity bounds\nof the problems: for all winning modes, we show that the problems are\nPSPACE-complete for eventually and weakly synchronizing, and PTIME-complete for\nalways and strongly synchronizing. We establish the memory requirement for\nwinning strategies, and we show that all winning modes coincide for always\nsynchronizing, and that the almost-sure and limit-sure winning modes coincide\nfor weakly and strongly synchronizing.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.01942v2"
    },
    {
        "title": "Connected reversible Mealy automata of prime size cannot generate\n  infinite Burnside groups",
        "authors": [
            "Thibault Godin",
            "Ines Klimann"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The simplest example of an infinite Burnside group arises in the class of\nautomaton groups. However there is no known example of such a group generated\nby a reversible Mealy automaton. It has been proved that, for a connected\nautomaton of size at most~3, or when the automaton is not bireversible, the\ngenerated group cannot be Burnside infinite. In this paper, we extend these\nresults to automata with bigger stateset, proving that, if a connected\nreversible automaton has a prime number of states, it cannot generate an\ninfinite Burnside group.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.03270v1"
    },
    {
        "title": "Minimizing Expected Cost Under Hard Boolean Constraints, with\n  Applications to Quantitative Synthesis",
        "authors": [
            "Shaull Almagor",
            "Orna Kupferman",
            "Yaron Velner"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In Boolean synthesis, we are given an LTL specification, and the goal is to\nconstruct a transducer that realizes it against an adversarial environment.\nOften, a specification contains both Boolean requirements that should be\nsatisfied against an adversarial environment, and multi-valued components that\nrefer to the quality of the satisfaction and whose expected cost we would like\nto minimize with respect to a probabilistic environment.\n  In this work we study, for the first time, mean-payoff games in which the\nsystem aims at minimizing the expected cost against a probabilistic\nenvironment, while surely satisfying an $\\omega$-regular condition against an\nadversarial environment. We consider the case the $\\omega$-regular condition is\ngiven as a parity objective or by an LTL formula. We show that in general,\noptimal strategies need not exist, and moreover, the limit value cannot be\napproximated by finite-memory strategies. We thus focus on computing the\nlimit-value, and give tight complexity bounds for synthesizing\n$\\epsilon$-optimal strategies for both finite-memory and infinite-memory\nstrategies.\n  We show that our game naturally arises in various contexts of synthesis with\nBoolean and multi-valued objectives. Beyond direct applications, in synthesis\nwith costs and rewards to certain behaviors, it allows us to compute the\nminimal sensing cost of $\\omega$-regular specifications -- a measure of quality\nin which we look for a transducer that minimizes the expected number of signals\nthat are read from the input.\n",
        "pdf_link": "http://arxiv.org/pdf/1604.07064v1"
    },
    {
        "title": "Analyzing Timed Systems Using Tree Automata",
        "authors": [
            "S. Akshay",
            "Paul Gastin",
            "Shankara Narayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Timed systems, such as timed automata, are usually analyzed using their\noperational semantics on timed words. The classical region abstraction for\ntimed automata reduces them to (untimed) finite state automata with the same\ntime-abstract properties, such as state reachability. We propose a new\ntechnique to analyze such timed systems using finite tree automata instead of\nfinite word automata. The main idea is to consider timed behaviors as graphs\nwith matching edges capturing timing constraints. When a family of graphs has\nbounded tree-width, they can be interpreted in trees and MSO-definable\nproperties of such graphs can be checked using tree automata. The technique is\nquite general and applies to many timed systems. In this paper, as an example,\nwe develop the technique on timed pushdown systems, which have recently\nreceived considerable attention. Further, we also demonstrate how we can use it\non timed automata and timed multi-stack pushdown systems (with boundedness\nrestrictions).\n",
        "pdf_link": "http://arxiv.org/pdf/1604.08443v4"
    },
    {
        "title": "Nested Weighted Limit-Average Automata of Bounded Width",
        "authors": [
            "Krishnendu Chatterjee",
            "Thomas A. Henzinger",
            "Jan Otop"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  While weighted automata provide a natural framework to express quantitative\nproperties, many basic properties like average response time cannot be\nexpressed with weighted automata. Nested weighted automata extend weighted\nautomata and consist of a master automaton and a set of slave automata that are\ninvoked by the master automaton. Nested weighted automata are strictly more\nexpressive than weighted automata (e.g., average response time can be expressed\nwith nested weighted automata), but the basic decision questions have higher\ncomplexity (e.g., for deterministic automata, the emptiness question for nested\nweighted automata is PSPACE-hard, whereas the corresponding complexity for\nweighted automata is PTIME). We consider a natural subclass of nested weighted\nautomata where at any point at most a bounded number k of slave automata can be\nactive. We focus on automata whose master value function is the limit average.\nWe show that these nested weighted automata with bounded width are strictly\nmore expressive than weighted automata (e.g., average response time with no\noverlapping requests can be expressed with bound k=1, but not with non-nested\nweighted automata). We show that the complexity of the basic decision problems\n(i.e., emptiness and universality) for the subclass with k constant matches the\ncomplexity for weighted automata. Moreover, when k is part of the input given\nin unary we establish PSPACE-completeness.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.03598v1"
    },
    {
        "title": "On parametrized verification of asynchronous, shared-memory pushdown\n  systems",
        "authors": [
            "Marie Fortin",
            "Anca Muscholl",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider the model of parametrized asynchronous shared-memory pushdown\nsystems, as introduced in [Hague'11]. In a series of recent papers it has been\nshown that reachability in this model is PSPACE-complete [Esparza, Ganty,\nMajumdar'13] and that liveness is decidable in NEXPTIME [Durand-Gasselin,\nEsparza, Ganty, Majumdar'15]. We show here that the liveness problem is\nPSPACE-complete. We also introduce the universal reachability problem. We show\nthat it is decidable, and coNEXPTIME-complete. Finally, using these results, we\nprove that the verifying regular properties of traces of executions, satisfying\nsome stuttering condition, is also decidable in NEXPTIME for this model.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.08707v2"
    },
    {
        "title": "A Survey of Cellular Automata: Types, Dynamics, Non-uniformity and\n  Applications",
        "authors": [
            "Kamalika Bhattacharjee",
            "Nazma Naskar",
            "Souvik Roy",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Cellular automata (CAs) are dynamical systems which exhibit complex global\nbehavior from simple local interaction and computation. Since the inception of\ncellular automaton (CA) by von Neumann in 1950s, it has attracted the attention\nof several researchers over various backgrounds and fields for modelling\ndifferent physical, natural as well as real-life phenomena. Classically, CAs\nare uniform. However, non-uniformity has also been introduced in update\npattern, lattice structure, neighborhood dependency and local rule. In this\nsurvey, we tour to the various types of CAs introduced till date, the different\ncharacterization tools, the global behaviors of CAs, like universality,\nreversibility, dynamics etc. Special attention is given to non-uniformity in\nCAs and especially to non-uniform elementary CAs, which have been very useful\nin solving several real-life problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.02291v3"
    },
    {
        "title": "FO-definable transformations of infinite strings",
        "authors": [
            "Vrunda Dave",
            "Shankara Narayanan Krishna",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The theory of regular and aperiodic transformations of finite strings has\nrecently received a lot of interest. These classes can be equivalently defined\nusing logic (Monadic second-order logic and first-order logic), two-way\nmachines (regular two-way and aperiodic two-way transducers), and one-way\nregister machines (regular streaming string and aperiodic streaming string\ntransducers). These classes are known to be closed under operations such as\nsequential composition and regular (star-free) choice; and problems such as\nfunctional equivalence and type checking, are decidable for these classes. On\nthe other hand, for infinite strings these results are only known for\n$\\omega$-regular transformations: Alur, Filiot, and Trivedi studied\ntransformations of infinite strings and introduced an extension of streaming\nstring transducers over $\\omega$-strings and showed that they capture monadic\nsecond-order definable transformations for infinite strings. In this paper we\nextend their work to recover connection for infinite strings among first-order\nlogic definable transformations, aperiodic two-way transducers, and aperiodic\nstreaming string transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.04910v1"
    },
    {
        "title": "On the complexity of automatic complexity",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Generalizing the notion of automatic complexity of individual strings due to\nShallit and Wang, we define the automatic complexity $A(E)$ of an equivalence\nrelation $E$ on a finite set $S$ of strings.\n  We prove that the problem of determining whether $A(E)$ equals the number\n$|E|$ of equivalence classes of $E$ is $\\mathsf{NP}$-complete. The problem of\ndetermining whether $A(E) = |E| + k$ for a fixed $k\\ge 1$ is complete for the\nsecond level of the Boolean hierarchy for $\\mathsf{NP}$, i.e.,\n$\\mathsf{BH}_2$-complete.\n  Let $L$ be the language consisting of all strings of maximal nondeterministic\nautomatic complexity. We characterize the complexity of infinite subsets of $L$\nby showing that they can be co-context-free but not context-free, i.e., $L$ is\n$\\mathsf{CFL}$-immune, but not $\\mathsf{coCFL}$-immune.\n  We show that for each $\\epsilon>0$, $L_\\epsilon\\not\\in\\mathsf{coCFL}$, where\n$L_\\epsilon$ is the set of all strings whose deterministic automatic complexity\n$A(x)$ satisfies $A(x)\\ge |x|^{1/2-\\epsilon}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.06106v2"
    },
    {
        "title": "Automatic complexity of shift register sequences",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Let $x$ be an $m$-sequence, a maximal length sequence produced by a linear\nfeedback shift register. We show that $x$ has maximal subword complexity\nfunction in the sense of Allouche and Shallit. We show that this implies that\nthe nondeterministic automatic complexity $A_N(x)$ is close to maximal:\n$n/2-A_N(x)=O(\\log^2n)$, where $n$ is the length of $x$. In contrast, Hyde has\nshown $A_N(y)\\le n/2+1$ for all sequences $y$ of length $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1607.08226v2"
    },
    {
        "title": "Two-Buffer Simulation Games",
        "authors": [
            "Milka Hutagalung",
            "Norbert Hundeshagen",
            "Dietrich Kuske",
            "Martin Lange",
            "Etienne Lozes"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider simulation games played between Spoiler and Duplicator on two\nBuchi automata in which the choices made by Spoiler can be buffered by\nDuplicator in two different buffers before she executes them on her structure.\nPrevious work on such games using a single buffer has shown that they are\nuseful to approximate language inclusion problems. We study the decidability\nand complexity and show that games with two buffers can be used to approximate\ncorresponding problems on finite transducers, i.e. the inclusion problem for\nrational relations over infinite words.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.00654v1"
    },
    {
        "title": "Approximating the Maximum Number of Synchronizing States in Automata",
        "authors": [
            "Andrew Ryzhikov"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider the problem {\\sc Max Sync Set} of finding a maximum synchronizing\nset of states in a given automaton. We show that the decision version of this\nproblem is PSPACE-complete and investigate the approximability of {\\sc Max Sync\nSet} for binary and weakly acyclic automata (an automaton is called weakly\nacyclic if it contains no cycles other than self-loops). We prove that,\nassuming $P \\ne NP$, for any $\\varepsilon > 0$, the {\\sc Max Sync Set} problem\ncannot be approximated in polynomial time within a factor of $O(n^{1 -\n\\varepsilon})$ for weakly acyclic $n$-state automata with alphabet of linear\nsize, within a factor of $O(n^{\\frac{1}{2} - \\varepsilon})$ for binary\n$n$-state automata, and within a factor of $O(n^{\\frac{1}{3} - \\varepsilon})$\nfor binary weakly acyclic $n$-state automata. Finally, we prove that for unary\nautomata the problem becomes solvable in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.00889v2"
    },
    {
        "title": "State machines for large scale computer software and systems",
        "authors": [
            "Victor Yodaiken"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The behavior and architecture of large scale discrete state systems found in\ncomputer software and hardware can be specified and analyzed using a particular\nclass of primitive recursive functions. This paper begins with an illustration\nof the utility of the method via a number of small examples and then via longer\nspecification and verification of the Paxos distributed consensus algorithm.\nThe sequence maps are then shown to provide an alternative representation of\ndeterministic state machines and algebraic products of state machines.\nDistributed and composite systems, parallel and concurrent computation, and\nreal-time behavior can all be specified naturally with these methods - which\nrequire neither extensions to the classical state machine model nor any\naxiomatic methods or other techniques from formal methods. Compared to state\ndiagrams or tables or the standard set-tuple-transition-maps, sequence maps are\nmore concise and better suited to describing the behavior and compositional\narchitecture of computer systems. Staying strictly within the boundaries of\nclassical deterministic state machines anchors the methods to the algebraic\nstructures of automata and makes the specifications faithful to engineering\npractice.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.01712v11"
    },
    {
        "title": "On the Regular Emptiness Problem of Subzero Automata",
        "authors": [
            "Henryk Michalewski",
            "Matteo Mio",
            "Mikołaj Bojańczyk"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Subzero automata is a class of tree automata whose acceptance condition can\nexpress probabilistic constraints. Our main result is that the problem of\ndetermining if a subzero automaton accepts some regular tree is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.03319v1"
    },
    {
        "title": "Supervisor Synthesis to Thwart Cyber Attack with Bounded Sensor Reading\n  Alterations",
        "authors": [
            "Rong Su"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  One of the major challenges about cyber physical systems is how to prevent\ncyber attacks to ensure system integrity. There has been a large number of\ndifferent types of attacks discussed in the modern control and computer science\ncommunities. In this paper we aim to investigate one special type of attacks in\nthe discrete-event system framework, where an attacker can arbitrarily alter\nsensor readings after intercepting them from a target system in order to trick\na given supervisor to issue control commands improperly, driving the system to\nan undesirable state. We first consider the cyber attack problem from an\nattacker point of view, and formulate an attack with bounded sensor reading\nalterations (ABSRA) problem. We then show that the supremal (or least\nrestrictive) ABSRA exists and can be synthesized, as long as the plant model\nand the supervisor model are regular, i.e., representable by finite-state\nautomata. Upon the synthesis of the supremal ABSRA, we present a synthesis\nalgorithm, which ensures that a computed supervisor will be ABSRA-robust ,\ni.e., either an ABSRA will be detectable or will not lead the system to an\nundesirable state.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.04103v2"
    },
    {
        "title": "Bounded-oscillation Pushdown Automata",
        "authors": [
            "Pierre Ganty",
            "Damir Valput"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present an underapproximation for context-free languages by filtering out\nruns of the underlying pushdown automaton depending on how the stack height\nevolves over time. In particular, we assign to each run a number quantifying\nthe oscillating behavior of the stack along the run. We study languages\naccepted by pushdown automata restricted to k-oscillating runs. We relate\noscillation on pushdown automata with a counterpart restriction on context-free\ngrammars. We also provide a way to filter all but the k-oscillating runs from a\ngiven PDA by annotating stack symbols with information about the oscillation.\nFinally, we study closure properties of the defined class of languages and the\ncomplexity of the k-emptiness problem asking, given a pushdown automaton P and\nk >= 0, whether P has a k-oscillating run. We show that, when k is not part of\nthe input, the k-emptiness problem is NLOGSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.04096v1"
    },
    {
        "title": "Multi-Buffer Simulations for Trace Language Inclusion",
        "authors": [
            "Milka Hutagalung",
            "Norbert Hundeshagen",
            "Dietrich Kuske",
            "Martin Lange",
            "Etienne Lozes"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider simulation games played between Spoiler and Duplicator on two\nB\\\"uchi automata in which the choices made by Spoiler can be buffered by\nDuplicator in several buffers before she executes them on her structure. We\nshow that the simulation games are useful to approximate the inclusion of trace\nclosures of languages accepted by finite-state automata, which is known to be\nundecidable. We study the decidability and complexity and show that the game\nwith bounded buffers can be decided in polynomial time, whereas the game with\none unbounded and one bounded buffer is highly undecidable. We also show some\nsufficient conditions on the automata for Duplicator to win the game (with\nunbounded buffers).\n",
        "pdf_link": "http://arxiv.org/pdf/1609.04098v1"
    },
    {
        "title": "The Almost Equivalence by Asymptotic Probabilities for Regular Languages\n  and Its Computational Complexities",
        "authors": [
            "Yoshiki Nakamura"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce p-equivalence by asymptotic probabilities, which is a weak\nalmost-equivalence based on zero-one laws in finite model theory. In this\npaper, we consider the computational complexities of p-equivalence problems for\nregular languages and provide the following details. First, we give an\nrobustness of p-equivalence and a logical characterization for p-equivalence.\nThe characterization is useful to generate some algorithms for p-equivalence\nproblems by coupling with standard results from descriptive complexity. Second,\nwe give the computational complexities for the p-equivalence problems by the\nlogical characterization. The computational complexities are the same as for\nthe (fully) equivalence problems. Finally, we apply the proofs for\np-equivalence to some generalized equivalences.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.04101v1"
    },
    {
        "title": "The Complexity of Flat Freeze LTL",
        "authors": [
            "Benedikt Bollig",
            "Karin Quaas",
            "Arnaud Sangnier"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We consider the model-checking problem for freeze LTL on one-counter automata\n(OCA). Freeze LTL extends LTL with the freeze quantifier, which allows one to\nstore different counter values of a run in registers so that they can be\ncompared with one another. As the model-checking problem is undecidable in\ngeneral, we focus on the flat fragment of freeze LTL, in which the usage of the\nfreeze quantifier is restricted. In a previous work, Lechner et al. showed that\nmodel checking for flat freeze LTL on OCA with binary encoding of counter\nupdates is decidable and in 2NEXPTIME. In this paper, we prove that the problem\nis, in fact, NEXPTIME-complete no matter whether counter updates are encoded in\nunary or binary. Like Lechner et al., we rely on a reduction to the\nreachability problem in OCA with parameterized tests (OCA(P)). The new aspect\nis that we simulate OCA(P) by alternating two-way automata over words. This\nimplies an exponential upper bound on the parameter values that we exploit\ntowards an NP algorithm for reachability in OCA(P) with unary updates. We\nobtain our main result as a corollary. As another application, relying on a\nreduction by Bundala and Ouaknine, one obtains an alternative proof of the\nknown fact that reachability in closed parametric timed automata with one\nparametric clock is in NEXPTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.06124v8"
    },
    {
        "title": "Nested Words for Order-2 Pushdown Systems",
        "authors": [
            "C. Aiswarya",
            "Paul Gastin",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study linear time model checking of collapsible higher-order pushdown\nsystems (CPDS) of order 2 (manipulating stack of stacks) against MSO and PDL\n(propositional dynamic logic with converse and loop) enhanced with push/pop\nmatching relations. To capture these linear time behaviours with matchings, we\npropose order-2 nested words. These graphs consist of a word structure\naugmented with two binary matching relations, one for each order of stack,\nwhich relate a push with matching pops (or collapse) on the respective stack.\nDue to the matching relations, satisfiability and model checking are\nundecidable. Hence we propose an under-approximation, bounding the number of\ntimes an order-1 push can be popped. With this under-approximation, which still\nallows unbounded stack height, we get decidability for satisfiability and model\nchecking of both MSO and PDL. The problems are ExpTime-Complete for PDL.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.06290v1"
    },
    {
        "title": "Slowly synchronizing automata with fixed alphabet size",
        "authors": [
            "Michiel de Bondt",
            "Henk Don",
            "Hans Zantema"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  It was conjectured by \\v{C}ern\\'y in 1964 that a synchronizing DFA on $n$\nstates always has a shortest synchronizing word of length at most $(n-1)^2$,\nand he gave a sequence of DFAs for which this bound is reached.\n  In this paper, we investigate the role of the alphabet size. For each\npossible alphabet size, we count DFAs on $n \\le 6$ states which synchronize in\n$(n-1)^2 - e$ steps, for all $e < 2\\lceil n/2 \\rceil$. Furthermore, we give\nconstructions of automata with any number of states, and $3$, $4$, or $5$\nsymbols, which synchronize slowly, namely in $n^2 - 3n + O(1)$ steps.\n  In addition, our results prove \\v{C}ern\\'y's conjecture for $n \\le 6$. Our\ncomputation has led to $27$ DFAs on $3$, $4$, $5$ or $6$ states, which\nsynchronize in $(n-1)^2$ steps, but do not belong to \\v{C}ern\\'y's sequence. Of\nthese $27$ DFA's, $19$ are new, and the remaining $8$ which were already known\nare exactly the \\emph{minimal} ones: they will not synchronize any more after\nremoving a symbol.\n  So the $19$ new DFAs are extensions of automata which were already known,\nincluding the \\v{C}ern\\'y automaton on $3$ states. But for $n > 3$, we prove\nthat the \\v{C}ern\\'y automaton on $n$ states does not admit non-trivial\nextensions with the same smallest synchronizing word length $(n-1)^2$.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.06853v5"
    },
    {
        "title": "Study of Parameterized-Chain networks",
        "authors": [
            "M. H. Zibaeenejad",
            "J. G. Thistle"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In areas such as computer software and hardware, manufacturing systems, and\ntransportation, engineers encounter networks with arbitrarily large numbers of\nisomorphic subprocesses. Parameterized systems provide a framework for modeling\nsuch networks. The analysis of parameterized systems is a challenge as some key\nproperties such as nonblocking and deadlock-freedom are undecidable even for\nthe case of a parameterized system with ring topology. In this paper, we\nintroduce \\textit{Parameterized-Chain Networks} (PCN) for modeling of networks\ncontaining several linear parameterized segments. Since deadlock analysis is\nundecidable, to achieve a tractable subproblem we limit the behavior of\nsubprocesses of the network using our previously developed mathematical notion\n`weak invariant simulation.' We develop a dependency graph for analysis of PCN\nand show that partial and total deadlocks of the proposed PCN are characterized\nby full, consistent subgraphs of the dependency graph. We investigate deadlock\nin a traffic network as an illustrative example. This document contains all the\ndetails and proofs of the study.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.09555v1"
    },
    {
        "title": "On the Complexity of Bounded Context Switching",
        "authors": [
            "Peter Chini",
            "Jonathan Kolberg",
            "Andreas Krebs",
            "Roland Meyer",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Bounded context switching (BCS) is an under-approximate method for finding\nviolations to safety properties in shared memory concurrent programs.\nTechnically, BCS is a reachability problem that is known to be NP-complete. Our\ncontribution is a parameterized analysis of BCS.\n  The first result is an algorithm that solves BCS when parameterized by the\nnumber of context switches (cs) and the size of the memory (m) in\nO*(m^(cs)2^(cs)). This is achieved by creating instances of the easier problem\nShuff which we solve via fast subset convolution. We also present a lower bound\nfor BCS of the form m^o(cs / log(cs)), based on the exponential time\nhypothesis. Interestingly, closing the gap means settling a conjecture that has\nbeen open since FOCS'07. Further, we prove that BCS admits no polynomial\nkernel.\n  Next, we introduce a measure, called scheduling dimension, that captures the\ncomplexity of schedules. We study BCS parameterized by the scheduling dimension\n(sdim) and show that it can be solved in O*((2m)^(4sdim)4^t)$, where t is the\nnumber of threads. We consider variants of the problem for which we obtain\n(matching) upper and lower bounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.09728v2"
    },
    {
        "title": "5-State Rotation-Symmetric Number-Conserving Cellular Automata are not\n  Strongly Universal",
        "authors": [
            "Katsunobu Imai",
            "Hisamichi Ishizaka",
            "Victor Poupet"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We study two-dimensional rotation-symmetric number-conserving cellular\nautomata working on the von Neumann neighborhood (RNCA). It is known that such\nautomata with 4 states or less are trivial, so we investigate the possible\nrules with 5 states. We give a full characterization of these automata and show\nthat they cannot be strongly Turing universal. However, we give example of\nconstructions that allow to embed some boolean circuit elements in a 5-states\nRNCA.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.00333v1"
    },
    {
        "title": "A Linear Acceleration Theorem for 2D Cellular Automata on all Complete\n  Neighborhoods",
        "authors": [
            "Anaël Grandjean",
            "Victor Poupet"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Linear acceleration theorems are known for most computational models.\nAlthough such results have been proved for two-dimensional cellular automata\nworking on specific neighborhoods, no general construction was known. We\npresent here a technique of linear acceleration for all two-dimensional\nlanguages recognized by cellular automata working on complete neighborhoods.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.00338v1"
    },
    {
        "title": "An Alternating Automaton for First-Order Linear Temporal Logic--Tech\n  Report",
        "authors": [
            "Yannick Lebrun",
            "Raphaël Khoury",
            "Sylvain Hallé"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper we give automata-based representation of LTL-FO$^+$ properties.\nLTL-FO$^+$ is an extension of LTL that includes first-order quantification over\nbounded variable, thus greatly increasing the expressivity of the language. An\nautomata representation of this formalism allows greater ease in writing and\nunderstanding properties, as well as in performing manipulations, such as\nnegation or emptiness checking. The automata representation of an LTL-FO$^+$\nformula has finite size regardless of the domain of quantified variables, and\nthe number of states that is linear in the size of the property.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07080v1"
    },
    {
        "title": "Not All Multi-Valued Partial CFL Functions Are Refined by Single-Valued\n  Functions",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Multi-valued partial CFL functions are functions computed along accepting\ncomputation paths by one-way nondeterministic pushdown automata, equipped with\nwrite-only output tapes, which are allowed to reject an input, in comparison\nwith single-valued partial CFL functions. We give an answer to a fundamental\nquestion, raised by Konstantinidis, Santean, and Yu [Act. Inform. 43 (2007)\n395-417], of whether all such multi-valued partial CFL functions can be refined\nby single-valued partial CFL functions. We negatively solve this open question\nby presenting a special multi-valued partial CFL function as an example\nfunction and by proving that no refinement of this particular function becomes\na single-valued partial CFL function. This contrasts an early result of\nKobayashi [Inform. Control 15 (1969) 95-109] that multi-valued partial NFA\nfunctions are always refined by single-valued NFA functions, where NFA\nfunctions are computed by one-way nondeterministic finite automata with output\ntapes. Our example function turns out to be unambiguously 2-valued, and thus we\nobtain a stronger separation result, in which no refinement of unambiguously\n2-valued partial CFL functions can be single-valued. For the proof of this\nfact, we first introduce a new concept of colored automata having no output\ntapes but having \"colors,\" which can simulate pushdown automata equipped with\nconstant-space output tapes. We then conduct an extensive combinatorial\nanalysis on the behaviors of transition records of stack contents (called stack\nhistories) of these colored automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07175v2"
    },
    {
        "title": "A Language-theoretic View on Network Protocols",
        "authors": [
            "Pierre Ganty",
            "Boris Köpf",
            "Pedro Valero"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Input validation is the first line of defense against malformed or malicious\ninputs. It is therefore critical that the validator (which is often part of the\nparser) is free of bugs.\n  To build dependable input validators, we propose using parser generators for\ncontext-free languages. In the context of network protocols, various works have\npointed at context-free languages as falling short to specify precisely or\nconcisely common idioms found in protocols. We review those assessments and\nperform a rigorous, language-theoretic analysis of several common protocol\nidioms. We then demonstrate the practical value of our findings by developing a\nmodular, robust, and efficient input validator for HTTP relying on context-free\ngrammars and regular expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07198v2"
    },
    {
        "title": "Generating the Functions with Regular Graphs under Composition",
        "authors": [
            "Thomas Kern"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  While automata theory often concerns itself with regular predicates,\nrelations corresponding to acceptance by a finite state automaton, in this\narticle we study the regular functions, such relations which are also functions\nin the set-theoretic sense. Here we present a small (but necessarily infinite)\ncollection of (multi-ary) functions which generate the regular functions under\ncomposition. To this end, this paper presents an interpretation of the powerset\ndeterminization construction in terms of compositions of input-to-run maps.\nFurthermore, known results using the Krohn-Rhodes theorem to further decompose\nour generating set are spelled out in detail, alongside some coding tricks for\ndealing with variable length words. This will include two clear proofs of the\nKrohn-Rhodes Theorem in modern notation.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07535v1"
    },
    {
        "title": "Finding Minimum and Maximum Termination Time of Timed Automata Models\n  with Cyclic Behaviour",
        "authors": [
            "Omar Al-Bataineh",
            "Mark Reynolds",
            "Tim French"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The paper presents a novel algorithm for computing best and worst case\nexecution times (BCET/WCET) of timed automata models with cyclic behaviour. The\nalgorithms can work on any arbitrary diagonal-free TA and can handle more cases\nthan previously existing algorithms for BCET/WCET computations, as it can\nhandle cycles in TA and decide whether they lead to an infinite WCET. We show\nsoundness of the proposed algorithm and study its complexity. To our knowledge,\nthis is the first model checking algorithm that addresses comprehensively the\nBCET/WCET problem of systems with cyclic behaviour. Behrmann et al. provide an\nalgorithm for computing the minimum cost/time of reaching a goal state in\npriced timed automata (PTA). The algorithm has been implemented in the\nwell-known model checking tool UPPAAL to compute the minimum time for\ntermination of an automaton. However, we show that in certain circumstances,\nwhen infinite cycles exist, the algorithm implemented in UPPAAL may not\nterminate, and we provide examples which UPPAAL fails to verify.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.09795v1"
    },
    {
        "title": "Commutative positive varieties of languages",
        "authors": [
            "Jorge Almeida",
            "Zoltán Ésik",
            "Jean-Éric Pin"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the commutative positive varieties of languages closed under various\noperations: shuffle, renaming and product over one-letter alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.02154v1"
    },
    {
        "title": "Soundness in negotiations",
        "authors": [
            "Javier Esparza",
            "Denis Kuperberg",
            "Anca Muscholl",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Negotiations are a formalism for describing multiparty distributed\ncooperation. Alternatively, they can be seen as a model of concurrency with\nsynchronized choice as communication primitive. Well-designed negotiations must\nbe sound, meaning that, whatever its current state, the negotiation can still\nbe completed. In earlier work, Esparza and Desel have shown that deciding\nsoundness of a negotiation is Pspace-complete, and in Ptime if the negotiation\nis deterministic. They have also extended their polynomial soundness algorithm\nto an intermediate class of acyclic, non-deterministic negotiations. However,\nthey did not analyze the runtime of the extended algorithm, and also left open\nthe complexity of the soundness problem for the intermediate class. In the\nfirst part of this paper we revisit the soundness problem for deterministic\nnegotiations, and show that it is Nlogspace-complete, improving on the earlier\nalgorithm, which requires linear space. In the second part we answer the\nquestion left open by Esparza and Desel. We prove that the soundness problem\ncan be solved in polynomial time for acyclic, weakly non- deterministic\nnegotiations, a more general class than the one considered by them. In the\nthird and final part, we show that the techniques developed in the first two\nparts of the paper can be applied to analysis problems other than soundness,\nincluding the problem of detecting race conditions, and several classical\nstatic analysis problems. More specifically, we show that, while these problems\nare intractable for arbitrary acyclic deterministic negotiations, they become\ntractable in the sound case. So soundness is not only a desirable behavioral\nproperty in itself, but also helps to analyze other properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.05137v4"
    },
    {
        "title": "Birecurrent sets",
        "authors": [
            "Francesco Dolce",
            "Dominique Perrin",
            "Antonio Restivo",
            "Christophe Reutenauer",
            "Giuseppina Rindone"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A set is called recurrent if its minimal automaton is strongly connected and\nbirecurrent if it is recurrent as well as its reversal. We prove a series of\nresults concerning birecurrent sets. It is already known that any birecurrent\nset is completely reducible (that is, such that the minimal representation of\nits characteristic series is completely reducible). The main result of this\npaper characterizes completely reducible sets as linear combinations of\nbirecurrent sets\n",
        "pdf_link": "http://arxiv.org/pdf/1703.10081v3"
    },
    {
        "title": "On computational complexity of Set Automata",
        "authors": [
            "Alexander A. Rubtsov",
            "Mikhail N. Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider a computational model which is known as set automata.\n  The set automata are one-way finite automata with an additional storage---the\nset. There are two kinds of set automata---the deterministic and the\nnondeterministic ones. We denote them as DSA and NSA respectively. The model\nwas introduced by M. Kutrib, A. Malcher, M. Wendlandt in 2014. It was shown\nthat DSA-languages look similar to DCFL due to their closure properties and\nNSA-languages look similar to CFL due to their undecidability properties.\n  In this paper we show that this similarity is natural: we prove that\nlanguages recognizable by NSA form a rational cone, so as CFL.\n  The main topic of this paper is computational complexity: we prove that\n  - languages recognizable by DSA belong to P and there are P-complete\nlanguages among them;\n  - languages recognizable by NSA are in NP and there are NP-complete languages\namong them;\n  - the word membership problem is P-complete for DSA without epsilon-loops and\nPSPACE-complete for general DSA;\n  - the emptiness problem is in PSPACE for NSA and, moreover, it is\nPSPACE-complete for DSA.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.03730v2"
    },
    {
        "title": "Register automata with linear arithmetic",
        "authors": [
            "Yu-Fang Chen",
            "Ondrej Lengal",
            "Tony Tan",
            "Zhilin Wu"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We propose a novel automata model over the alphabet of rational numbers,\nwhich we call register automata over the rationals (RA-Q). It reads a sequence\nof rational numbers and outputs another rational number. RA-Q is an extension\nof the well-known register automata (RA) over infinite alphabets, which are\nfinite automata equipped with a finite number of registers/variables for\nstoring values. Like in the standard RA, the RA-Q model allows both equality\nand ordering tests between values. It, moreover, allows to perform linear\narithmetic between certain variables. The model is quite expressive: in\naddition to the standard RA, it also generalizes other well-known models such\nas affine programs and arithmetic circuits.\n  The main feature of RA-Q is that despite the use of linear arithmetic, the\nso-called invariant problem---a generalization of the standard non-emptiness\nproblem---is decidable. We also investigate other natural decision problems,\nnamely, commutativity, equivalence, and reachability. For deterministic RA-Q,\ncommutativity and equivalence are polynomial-time inter-reducible with the\ninvariant problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.03972v2"
    },
    {
        "title": "On the interplay between Babai and Cerny's conjectures",
        "authors": [
            "François Gonze",
            "Vladimir Gusev",
            "Balázs Gerencsér",
            "Raphaël M. Jungers",
            "Mikhail V. Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Motivated by the Babai conjecture and the Cerny conjecture, we study the\nreset thresholds of automata with the transition monoid equal to the full\nmonoid of transformations of the state set. For automata with $n$ states in\nthis class, we prove that the reset thresholds are upper-bounded by $2n^2-6n+5$\nand can attain the value $\\tfrac{n(n-1)}{2}$. In addition, we study diameters\nof the pair digraphs of permutation automata and construct $n$-state\npermutation automata with diameter $\\tfrac{n^2}{4} + o(n^2)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.04047v2"
    },
    {
        "title": "Specifying Graph Languages with Type Graphs",
        "authors": [
            "Andrea Corradini",
            "Barbara König",
            "Dennis Nolte"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate three formalisms to specify graph languages, i.e. sets of\ngraphs, based on type graphs. First, we are interested in (pure) type graphs,\nwhere the corresponding language consists of all graphs that can be mapped\nhomomorphically to a given type graph. In this context, we also study languages\nspecified by restriction graphs and their relation to type graphs. Second, we\nextend this basic approach to a type graph logic and, third, to type graphs\nwith annotations. We present decidability results and closure properties for\neach of the formalisms.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.05263v2"
    },
    {
        "title": "Brzozowski Goes Concurrent - A Kleene Theorem for Pomset Languages",
        "authors": [
            "Tobias Kappé",
            "Paul Brunet",
            "Bas Luttik",
            "Alexandra Silva",
            "Fabio Zanasi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Concurrent Kleene Algebra (CKA) is a mathematical formalism to study programs\nthat exhibit concurrent behaviour. As with previous extensions of Kleene\nAlgebra, characterizing the free model is crucial in order to develop the\nfoundations of the theory and potential applications. For CKA, this has been an\nopen question for a few years and this paper makes an important step towards an\nanswer. We present a new automaton model and a Kleene-like theorem that relates\na relaxed version of CKA to series-parallel pomset languages, which are a\nnatural candidate for the free model. There are two substantial differences\nwith previous work: from expressions to automata, we use Brzozowski\nderivatives, which enable a direct construction of the automaton; from automata\nto expressions, we provide a syntactic characterization of the automata that\ndenote valid CKA behaviours.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.07199v3"
    },
    {
        "title": "Optimizing Automata Learning via Monads",
        "authors": [
            "Gerco van Heerdt",
            "Matteo Sammartino",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Automata learning has been successfully applied in the verification of\nhardware and software. The size of the automaton model learned is a bottleneck\nfor scalability, and hence optimizations that enable learning of compact\nrepresentations are important. This paper exploits monads, both as a\nmathematical structure and a programming construct, to design, prove correct,\nand implement a wide class of such optimizations. The former perspective on\nmonads allows us to develop a new algorithm and accompanying correctness\nproofs, building upon a general framework for automata learning based on\ncategory theory. The new algorithm is parametric on a monad, which provides a\nrich algebraic structure to capture non-determinism and other side-effects. We\nshow that our approach allows us to uniformly capture existing algorithms,\ndevelop new ones, and add optimizations. The latter perspective allows us to\neffortlessly translate the theory into practice: we provide a Haskell library\nimplementing our general framework, and we show experimental results for two\nspecific instances: non-deterministic and weighted automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1704.08055v4"
    },
    {
        "title": "Emptiness Problems for Distributed Automata",
        "authors": [
            "Antti Kuusisto",
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the decidability of the emptiness problem for three classes of\ndistributed automata. These devices operate on finite directed graphs, acting\nas networks of identical finite-state machines that communicate in an infinite\nsequence of synchronous rounds. The problem is shown to be decidable in\nLogSpace for a class of forgetful automata, where the nodes see the messages\nreceived from their neighbors but cannot remember their own state. When\nrestricted to the appropriate families of graphs, these forgetful automata are\nequivalent to classical finite word automata, but strictly more expressive than\nfinite tree automata. On the other hand, we also show that the emptiness\nproblem is undecidable in general. This already holds for two heavily\nrestricted classes of distributed automata: those that reject immediately if\nthey receive more than one message per round, and those whose state diagram\nmust be acyclic except for self-loops.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.02609v2"
    },
    {
        "title": "Ten Conferences WORDS: Open Problems and Conjectures",
        "authors": [
            "Jean Néraud"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In connection to the development of the field of Combinatorics on Words, we\npresent a list of open problems and conjectures that were stated during the ten\nlast meetings WORDS. We wish to continually update the present document by\nadding informations concerning advances in problems solving.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.04055v1"
    },
    {
        "title": "New Directions In Cellular Automata",
        "authors": [
            "Abdulrhman Elnekiti"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We Propose A Novel Automaton Model which uses Arithmetic Operations as the\nEvolving Rules, each cell has the states of the Natural Numbers k = (N), a\nradius of r = 1/2 and operates on an arbitrary input size. The Automaton reads\nan Arithmetic Expression as an input and outputs another Arithmetic Expression.\nIn Addition, we simulate a variety of One Dimensional Cellular Automata\nStructures with different Dynamics including Elementary Cellular Automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.05832v1"
    },
    {
        "title": "Synchronizing automata and the language of minimal reset words",
        "authors": [
            "Emanuele Rodaro"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study a connection between synchronizing automata and its set $M$ of\nminimal reset words, i.e., such that no proper factor is a reset word. We first\nshow that any synchronizing automaton having the set of minimal reset words\nwhose set of factors does not contain a word of length at most\n$\\frac{1}{4}\\min\\{|u|: u\\in I\\}+\\frac{1}{16}$ has a reset word of length at\nmost $(n-\\frac{1}{2})^{2}$ In the last part of the paper we focus on the\nexistence of synchronizing automata with a given ideal $I$ that serves as the\nset of reset words. To this end, we introduce the notion of the tail structure\nof the (not necessarily regular) ideal $I=\\Sigma^{*}M\\Sigma^{*}$. With this\ntool, we first show the existence of an infinite strongly connected\nsynchronizing automaton $\\mathcal{A}$ having $I$ as the set of reset words and\nsuch that every other strongly connected synchronizing automaton having $I$ as\nthe set of reset words is an homomorphic image of $\\mathcal{A}$. Finally, we\nshow that for any non-unary regular ideal $I$ there is a strongly connected\nsynchronizing automaton having $I$ as the set of reset words with at most\n$(km^{k})2^{km^{k}n}$ states, where $k=|\\Sigma|$, $m$ is the length of a\nshortest word in $M$, and $n$ is the dimension of the smallest automaton\nrecognizing $M$ (state complexity of $M$). This automaton is computable and we\nshow an algorithm to compute it in time $\\mathcal{O}((k^{2}m^{k})2^{km^{k}n})$.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.04864v1"
    },
    {
        "title": "To Infinity and Beyond",
        "authors": [
            "Ines Klimann"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We prove that if a group generated by a bireversible Mealy automaton contains\nan element of infinite order, its growth blows up and is necessarily\nexponential. As a direct consequence, no infinite virtually nilpotent group can\nbe generated by a bireversible Mealy automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06173v2"
    },
    {
        "title": "An efficient algorithm to decide periodicity of $b$-recognisable sets\n  using LSDF convention",
        "authors": [
            "Victor Marsault"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Let $b$ be an integer strictly greater than $1$. Each set of nonnegative\nintegers is represented in base $b$ by a language over $\\{0, 1, \\dots, b -\n1\\}$. The set is said to be $b$-recognisable if it is represented by a regular\nlanguage. It is known that ultimately periodic sets are $b$-recognisable, for\nevery base $b$, and Cobham's theorem implies the converse: no other set is\n$b$-recognisable in every base $b$.\n  We consider the following decision problem: let $S$ be a set of nonnegative\nintegers that is $b$-recognisable, given as a finite automaton over $\\{0,1,\n\\dots, b - 1\\}$, is $S$ periodic? Honkala showed in 1986 that this problem is\ndecidable. Later on, Leroux used in 2005 the convention to write number\nrepresentations with the least significant digit first (LSDF), and designed a\nquadratic algorithm to solve a more general problem.\n  We use here LSDF convention as well and give a structural description of the\nminimal automata that accept periodic sets. Then, we show that it can be\nverified in linear time if a minimal automaton meets this description. In\ngeneral, this yields a $O(b \\log(n))$ procedure to decide whether an automaton\nwith $n$ states accepts an ultimately periodic set of nonnegative integers.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06228v6"
    },
    {
        "title": "Constructing Words with High Distinct Square Densities",
        "authors": [
            "F. Blanchet-Sadri",
            "S. Osborne"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Fraenkel and Simpson showed that the number of distinct squares in a word of\nlength n is bounded from above by 2n, since at most two distinct squares have\ntheir rightmost, or last, occurrence begin at each position. Improvements by\nIlie to $2n-\\Theta(\\log n)$ and by Deza et al. to 11n/6 rely on the study of\ncombinatorics of FS-double-squares, when the maximum number of two last\noccurrences of squares begin. In this paper, we first study how to maximize\nruns of FS-double-squares in the prefix of a word. We show that for a given\npositive integer m, the minimum length of a word beginning with m\nFS-double-squares, whose lengths are equal, is 7m+3. We construct such a word\nand analyze its distinct-square-sequence as well as its\ndistinct-square-density. We then generalize our construction. We also construct\nwords with high distinct-square-densities that approach 5/6.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.06462v1"
    },
    {
        "title": "MK-fuzzy Automata and MSO Logics",
        "authors": [
            "Manfred Droste",
            "Temur Kutsia",
            "George Rahonis",
            "Wolfgang Schreiner"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce MK-fuzzy automata over a bimonoid K which is related to the\nfuzzification of the McCarthy-Kleene logic. Our automata are inspired by, and\nintend to contribute to, practical applications being in development in a\nproject on runtime network monitoring based on predicate logic. We investigate\nclosure properties of the class of recognizable MK-fuzzy languages accepted by\nMK-fuzzy automata as well as of deterministically recognizable MK-fuzzy\nlanguages accepted by their deterministic counterparts. Moreover, we establish\na Nivat-like result for recognizable MK-fuzzy languages. We introduce an\nMK-fuzzy MSO logic and show the expressive equivalence of a fragment of this\nlogic with MK-fuzzy automata, i.e., a B\\\"uchi type theorem.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.02098v1"
    },
    {
        "title": "A new indexed approach to render the attractors of Kleinian groups",
        "authors": [
            "Alessandro Rosa"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  One widespread procedure to render the attractor of Kleinian groups,\npublished in the renown book \"Indra's Pearls\" and based upon a combinatorial\ntree model, wants huge memory resources to compute and store all the words\nrequired. We will present here a new faster and lighter version which drops the\noriginal words array and pulls out words from integer numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.08018v1"
    },
    {
        "title": "On Automata Recognizing Birecurrent Sets",
        "authors": [
            "Andrew Ryzhikov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this note we study automata recognizing birecurrent sets. A set of words\nis birecurrent if the minimal partial DFA recognizing this set and the minimal\npartial DFA recognizing the reversal of this set are both strongly connected.\nThis notion was introduced by Perrin, and Dolce et al. provided a\ncharacterization of such sets. We prove that deciding whether a partial DFA\nrecognizes a birecurrent set is a PSPACE-complete problem. We show that this\nproblem is PSPACE-complete even in the case of binary partial DFAs with all\nstates accepting and in the case of binary complete DFAs. We also consider a\nrelated problem of computing the rank of a partial DFA.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.01061v2"
    },
    {
        "title": "Efficient reduction of nondeterministic automata with application to\n  language inclusion testing",
        "authors": [
            "Lorenzo Clemente",
            "Richard Mayr"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We present efficient algorithms to reduce the size of nondeterministic\nB\\\"uchi word automata (NBA) and nondeterministic finite word automata (NFA),\nwhile retaining their languages. Additionally, we describe methods to solve\nPSPACE-complete automata problems like language universality, equivalence, and\ninclusion for much larger instances than was previously possible ($\\ge 1000$\nstates instead of 10-100). This can be used to scale up applications of\nautomata in formal verification tools and decision procedures for logical\ntheories. The algorithms are based on new techniques for removing transitions\n(pruning) and adding transitions (saturation), as well as extensions of classic\nquotienting of the state space. These techniques use criteria based on\ncombinations of backward and forward trace inclusions and simulation relations.\nSince trace inclusion relations are themselves PSPACE-complete, we introduce\nlookahead simulations as good polynomial time computable approximations\nthereof. Extensive experiments show that the average-case time complexity of\nour algorithms scales slightly above quadratically. (The space complexity is\nworst-case quadratic.) The size reduction of the automata depends very much on\nthe class of instances, but our algorithm consistently reduces the size far\nmore than all previous techniques. We tested our algorithms on NBA derived from\nLTL-formulae, NBA derived from mutual exclusion protocols and many classes of\nrandom NBA and NFA, and compared their performance to the well-known automata\ntool GOAL.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.09946v4"
    },
    {
        "title": "CTL* synthesis via LTL synthesis",
        "authors": [
            "Roderick Bloem",
            "Sven Schewe",
            "Ayrat Khalimov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We reduce synthesis for CTL* properties to synthesis for LTL. In the context\nof model checking this is impossible - CTL* is more expressive than LTL. Yet,\nin synthesis we have knowledge of the system structure and we can add new\noutputs. These outputs can be used to encode witnesses of the satisfaction of\nCTL* subformulas directly into the system. This way, we construct an LTL\nformula, over old and new outputs and original inputs, which is realisable if,\nand only if, the original CTL* formula is realisable. The CTL*-via-LTL\nsynthesis approach preserves the problem complexity, although it might increase\nthe minimal system size. We implemented the reduction, and evaluated the\nCTL*-via-LTL synthesiser on several examples.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.10636v1"
    },
    {
        "title": "Verifying Probabilistic Timed Automata Against Omega-Regular Dense-Time\n  Properties",
        "authors": [
            "Hongfei Fu",
            "Yi Li",
            "Jianlin Li",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Probabilistic timed automata (PTAs) are timed automata (TAs) extended with\ndiscrete probability distributions.They serve as a mathematical model for a\nwide range of applications that involve both stochastic and timed behaviours.\nIn this work, we consider the problem of model-checking linear\n\\emph{dense-time} properties over {PTAs}. In particular, we study linear\ndense-time properties that can be encoded by TAs with infinite acceptance\ncriterion.First, we show that the problem of model-checking PTAs against\ndeterministic-TA specifications can be solved through a product construction.\nBased on the product construction, we prove that the computational complexity\nof the problem with deterministic-TA specifications is EXPTIME-complete. Then\nwe show that when relaxed to general (nondeterministic) TAs, the model-checking\nproblem becomes undecidable.Our results substantially extend state of the art\nwith both the dense-time feature and the nondeterminism in TAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.00275v2"
    },
    {
        "title": "Self-organization and the Maximum Empower Principle in the Framework of\n  max-plus Algebra",
        "authors": [
            "Chams Lahlou",
            "Laurent Truffet"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Self-organization is a process where order of a whole system arises out of\nlocal interactions between small components of a system.\n  Emergy, spelled with an 'm', defined as the amount of (solar) energy used to\nmake a product or service, is becoming an important ecological indicator. The\nMaximum Empower Principle (MEP) was proposed as the fourth law of\nthermodynamics by the ecologist Odum in the 90's to explain observed\nself-organization of energy driven systems. But this principle suffers a lack\nof mathematical formulation due to an insufficiency of details about the\nunderlying computation of empower (i.e. emergy per time).\n  For empower computation in steady-state an axiomatic basis has been developed\nrecently by Le Corre and the second author of this paper. In this axiomatic\nbasis emergy is defined as a recursive max-plus linear function.\n  Using this axiomatic basis and a correspondance between ecological theory and\ndynamic systems theory, we prove the MEP. In particular, we show that the\nempower computation in steady-state is equivalent to a combinatorial\noptimization problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.05798v2"
    },
    {
        "title": "Automaton Semigroups and Groups: On the Undecidability of Problems\n  Related to Freeness and Finiteness",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper, we study algorithmic problems for automaton semigroups and\nautomaton groups related to freeness and finiteness. In the course of this\nstudy, we also exhibit some connections between the algebraic structure of\nautomaton (semi)groups and their dynamics on the boundary. First, we show that\nit is undecidable to check whether the group generated by a given invertible\nautomaton has a positive relation, i.e. a relation p = 1 such that p only\ncontains positive generators. Besides its obvious relation to the freeness of\nthe group, the absence of positive relations has previously been studied and is\nconnected to the triviality of some stabilizers of the boundary. We show that\nthe emptiness of the set of positive relations is equivalent to the dynamical\nproperty that all (directed positive) orbital graphs centered at non-singular\npoints are acyclic.\n  Gillibert showed that the finiteness problem for automaton semigroups is\nundecidable. In the second part of the paper, we show that this undecidability\nresult also holds if the input is restricted to be bi-reversible and invertible\n(but, in general, not complete). As an immediate consequence, we obtain that\nthe finiteness problem for automaton subsemigroups of semigroups generated by\ninvertible, yet partial automata, so called automaton-inverse semigroups, is\nalso undecidable.\n  Erratum: Contrary to a statement in a previous version of the paper, our\napproach does not show that that the freeness problem for automaton semigroups\nis undecidable. We discuss this in an erratum at the end of the paper.\n",
        "pdf_link": "http://arxiv.org/pdf/1712.07408v3"
    },
    {
        "title": "More on the dynamics of the symbolic square root map",
        "authors": [
            "Jarkko Peltomäki",
            "Markus Whiteland"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In our earlier paper [A square root map on Sturmian words, Electron. J.\nCombin. 24.1 (2017)], we introduced a symbolic square root map. Every optimal\nsquareful infinite word $s$ contains exactly six minimal squares and can be\nwritten as a product of these squares: $s = X_1^2 X_2^2 \\cdots$. The square\nroot $\\sqrt{s}$ of $s$ is the infinite word $X_1 X_2 \\cdots$ obtained by\ndeleting half of each square. We proved that the square root map preserves the\nlanguages of Sturmian words (which are optimal squareful words). The dynamics\nof the square root map on a Sturmian subshift are well understood. In our\nearlier work, we introduced another type of subshift of optimal squareful words\nwhich together with the square root map form a dynamical system. In this paper,\nwe study these dynamical systems in more detail and compare their properties to\nthe Sturmian case. The main results are characterizations of periodic points\nand the limit set. The results show that while there is some similarity it is\npossible for the square root map to exhibit quite different behavior compared\nto the Sturmian case.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.00920v1"
    },
    {
        "title": "Exploring the Topological Entropy of Formal Languages",
        "authors": [
            "Florian Starke"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce the notions of topological entropy of a formal language and of a\ntopological automaton. We show that the entropy function is surjective and\nbound the entropy of languages accepted by deterministic {\\epsilon}-free\npush-down automata with an arbitrary amount of stacks.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.07321v2"
    },
    {
        "title": "New Size Hierarchies for Two Way Automata",
        "authors": [
            "Kamil Khadiev",
            "Rishat Ibrahimov",
            "Abuzer Yakary"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a new type of nonuniform two--way automaton that can use a\ndifferent transition function for each tape square. We also enhance this model\nby allowing to shuffle the given input at the beginning of the computation.\nThen we present some hierarchy and incomparability results on the number of\nstates for the types of deterministic, nondeterministic, and bounded-error\nprobabilistic models. For this purpose, we provide some lower bounds for all\nthree models based on the numbers of subfunctions and we define two witness\nfunctions.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.10483v1"
    },
    {
        "title": "Learning from Informants: Relations between Learning Success Criteria",
        "authors": [
            "Martin Aschenbach",
            "Timo Kötzing",
            "Karen Seidel"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Learning from positive and negative information, so-called \\emph{informants},\nbeing one of the models for human and machine learning introduced by\nE.~M.~Gold, is investigated. Particularly, naturally arising questions about\nthis learning setting, originating in results on learning from solely positive\ninformation, are answered. By a carefully arranged argument learners can be\nassumed to only change their hypothesis in case it is inconsistent with the\ndata (such a learning behavior is called \\emph{conservative}). The deduced main\ntheorem states the relations between the most important delayable learning\nsuccess criteria, being the ones not ruined by a delayed in time hypothesis\noutput. Additionally, our investigations concerning the non-delayable\nrequirement of consistent learning underpin the claim for \\emph{delayability}\nbeing the right structural property to gain a deeper understanding concerning\nthe nature of learning success criteria. Moreover, we obtain an anomalous\n\\emph{hierarchy} when allowing for an increasing finite number of\n\\emph{anomalies} of the hypothesized language by the learner compared with the\nlanguage to be learned. In contrast to the vacillatory hierarchy for learning\nfrom solely positive information, we observe a \\emph{duality} depending on\nwhether infinitely many \\emph{vacillations} between different (almost) correct\nhypotheses are still considered a successful learning behavior.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.10502v5"
    },
    {
        "title": "Deterministic Regular Expressions With Back-References",
        "authors": [
            "Dominik D. Freydenberger",
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Most modern libraries for regular expression matching allow back-references\n(i.e., repetition operators) that substantially increase expressive power, but\nalso lead to intractability. In order to find a better balance between\nexpressiveness and tractability, we combine these with the notion of\ndeterminism for regular expressions used in XML DTDs and XML Schema. This\nincludes the definition of a suitable automaton model, and a generalization of\nthe Glushkov construction. We demonstrate that, compared to their\nnon-deterministic superclass, these deterministic regular expressions with\nback-references have desirable algorithmic properties (i.e., efficiently\nsolvable membership problem and some decidable problems in static analysis),\nwhile, at the same time, their expressive power exceeds that of deterministic\nregular expressions without back-references.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.01508v1"
    },
    {
        "title": "Lengths of Words Accepted by Nondeterministic Finite Automata",
        "authors": [
            "Aaron Potechin",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider two natural problems about nondeterministic finite automata.\nFirst, given such an automaton M of n states, and a length l, does M accept a\nword of length l? We show that the classic problem of triangle-free graph\nrecognition reduces to this problem, and give an O(n^{\\omega} (log\nn)^{1+{\\epsilon}} log l)-time algorithm to solve it, where {\\omega} is the\noptimal exponent for matrix multiplication. Second, provided L(M) is finite, we\nconsider the problem of listing the lengths of all words accepted by M.\nAlthough this problem seems like it might be significantly harder, we show that\nthis problem can be solved in O(n^{\\omega}(log n)^{2+{\\epsilon}}) time.\nFinally, we give a connection between NFA acceptance and the strong\nexponential-time hypothesis.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.04708v1"
    },
    {
        "title": "Gossiping in Message-Passing Systems",
        "authors": [
            "Benedikt Bollig",
            "Marie Fortin",
            "Paul Gastin"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study the gossip problem in a message-passing environment: When a process\nreceives a message, it has to decide whether the sender has more recent\ninformation on other processes than itself. This problem is at the heart of\nmany distributed algorithms, and it is tightly related to questions from formal\nmethods concerning the expressive power of distributed automata. We provide a\nnon-deterministic gossip protocol for message-passing systems with unbounded\nFIFO channels, using only finitely many local states and a finite message\nalphabet. We show that this is optimal in the sense that there is no\ndeterministic counterpart. As an application, the gossip protocol allows us to\nshow that message-passing systems capture well-known extensions of linear-time\ntemporal logics to a concurrent setting.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.08641v2"
    },
    {
        "title": "Continuity of Functional Transducers: A Profinite Study of Rational\n  Functions",
        "authors": [
            "Michaël Cadilhac",
            "Olivier Carton",
            "Charles Paperman"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A word-to-word function is continuous for a class of languages~$\\mathcal{V}$\nif its inverse maps $\\mathcal{V}$_languages to~$\\mathcal{V}$. This notion\nprovides a basis for an algebraic study of transducers, and was integral to the\ncharacterization of the sequential transducers computable in some circuit\ncomplexity classes.\n  Here, we report on the decidability of continuity for functional transducers\nand some standard classes of regular languages. To this end, we develop a\nrobust theory rooted in the standard profinite analysis of regular languages.\n  Since previous algebraic studies of transducers have focused on the sole\nstructure of the underlying input automaton, we also compare the two algebraic\napproaches. We focus on two questions: When are the automaton structure and the\ncontinuity properties related, and when does continuity propagate to\nsuperclasses?\n",
        "pdf_link": "http://arxiv.org/pdf/1802.10555v3"
    },
    {
        "title": "Abelian networks IV. Dynamics of nonhalting networks",
        "authors": [
            "Swee Hong Chan",
            "Lionel Levine"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  An abelian network is a collection of communicating automata whose state\ntransitions and message passing each satisfy a local commutativity condition.\nThis paper is a continuation of the abelian networks series of Bond and Levine\n(2016), for which we extend the theory of abelian networks that halt on all\ninputs to networks that can run forever. A nonhalting abelian network can be\nrealized as a discrete dynamical system in many different ways, depending on\nthe update order. We show that certain features of the dynamics, such as\nminimal period length, have intrinsic definitions that do not require\nspecifying an update order.\n  We give an intrinsic definition of the \\emph{torsion group} of a finite\nirreducible (halting or nonhalting) abelian network, and show that it coincides\nwith the critical group of Bond and Levine (2016) if the network is halting. We\nshow that the torsion group acts freely on the set of invertible recurrent\ncomponents of the trajectory digraph, and identify when this action is\ntransitive.\n  This perspective leads to new results even in the classical case of sinkless\nrotor networks (deterministic analogues of random walks). In Holroyd et. al\n(2008) it was shown that the recurrent configurations of a sinkless rotor\nnetwork with just one chip are precisely the unicycles (spanning subgraphs with\na unique oriented cycle, with the chip on the cycle). We generalize this result\nto abelian mobile agent networks with any number of chips. We give formulas for\ngenerating series such as \\[ \\sum_{n \\geq 1} r_n z^n = \\det (\\frac{1}{1-z}D - A\n) \\] where $r_n$ is the number of recurrent chip-and-rotor configurations with\n$n$ chips; $D$ is the diagonal matrix of outdegrees, and $A$ is the adjacency\nmatrix. A consequence is that the sequence $(r_n)_{n \\geq 1}$ completely\ndetermines the spectrum of the simple random walk on the network.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.03322v2"
    },
    {
        "title": "Counter Machines and Distributed Automata: A Story about Exchanging\n  Space and Time",
        "authors": [
            "Olivier Carton",
            "Bruno Guillon",
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We prove the equivalence of two classes of counter machines and one class of\ndistributed automata. Our counter machines operate on finite words, which they\nread from left to right while incrementing or decrementing a fixed number of\ncounters. The two classes differ in the extra features they offer: one allows\nto copy counter values, whereas the other allows to compute copyless sums of\ncounters. Our distributed automata, on the other hand, operate on directed path\ngraphs that represent words. All nodes of a path synchronously execute the same\nfinite-state machine, whose state diagram must be acyclic except for\nself-loops, and each node receives as input the state of its direct\npredecessor. These devices form a subclass of linear-time one-way cellular\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.03582v1"
    },
    {
        "title": "On Computing the Total Variation Distance of Hidden Markov Models",
        "authors": [
            "Stefan Kiefer"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We prove results on the decidability and complexity of computing the total\nvariation distance (equivalently, the $L_1$-distance) of hidden Markov models\n(equivalently, labelled Markov chains). This distance measures the difference\nbetween the distributions on words that two hidden Markov models induce. The\nmain results are: (1) it is undecidable whether the distance is greater than a\ngiven threshold; (2) approximation is #P-hard and in PSPACE.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.06170v1"
    },
    {
        "title": "Additive Number Theory via Approximation by Regular Languages",
        "authors": [
            "Jason Bell",
            "Thomas Finn Lidbetter",
            "Jeffrey Shallit"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We prove some new theorems in additive number theory, using novel techniques\nfrom automata theory and formal languages. As an example of our method, we\nprove that every natural number > 25 is the sum of at most three natural\nnumbers whose base-2 representation has an equal number of 0's and 1's.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.07996v1"
    },
    {
        "title": "Abstract Geometrical Computation 10: An Intrinsically Universal Family\n  of Signal Machines",
        "authors": [
            "Florent Becker",
            "Tom Besson",
            "Jérôme Durand-Lose",
            "Aurélien Emmanuel",
            "Mohammad-Hadi Foroughmand-Araabi",
            "Sama Goliaei",
            "Shahrzad Heydarshahi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Signal machines form an abstract and idealised model of collision computing.\nBased on dimensionless signals moving on the real line, they model\nparticle/signal dynamics in Cellular Automata. Each particle, or signal, moves\nat constant speed in continuous time and space. When signals meet, they get\nreplaced by other signals. A signal machine defines the types of available\nsignals, their speeds and the rules for replacement in collision. A signal\nmachine A simulates another one B if all the space-time diagrams of B can be\ngenerated from space-time diagrams of A by removing some signals and renaming\nother signals according to local information. Given any finite set of speeds S,\nwe construct a signal machine that is able to simulate any signal machine whose\nspeeds belong to S. Each signal is simulated by a macro-signal, a ray of\nparallel signals. Each macro-signal has a main signal located exactly where the\nsimulated signal would be, as well as auxiliary signals which encode its id and\nthe collision rules of the simulated machine. The simulation of a collision, a\nmacro-collision, consists of two phases. In the first phase, macro-signals are\nshrunk, then the macro-signals involved in the collision are identified and it\nis ensured that no other macro-signal comes too close. If some do, the process\nis aborted and the macro-signals are shrunk, so that the correct\nmacro-collision will eventually be restarted and successfully initiated.\nOtherwise, the second phase starts: the appropriate collision rule is found and\nnew macro-signals are generated accordingly. Considering all finite set of\nspeeds S and their corresponding simulators provides an intrinsically universal\nfamily of signal machines.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.09018v2"
    },
    {
        "title": "Symbolic Automata with Memory: a Computational Model for Complex Event\n  Processing",
        "authors": [
            "Elias Alevizos",
            "Alexander Artikis",
            "Georgios Paliouras"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We propose an automaton model which is a combination of symbolic and register\nautomata, i.e., we enrich symbolic automata with memory. We call such automata\nRegister Match Automata (RMA). RMA extend the expressive power of symbolic\nautomata, by allowing formulas to be applied not only to the last element read\nfrom the input string, but to multiple elements, stored in their registers. RMA\nalso extend register automata, by allowing arbitrary formulas, besides equality\npredicates. We study the closure properties of RMA under union, concatenation,\nKleene+, complement and determinization and show that RMA, contrary to symbolic\nautomata, are not determinizable when viewed as recognizers, without taking the\noutput of transitions into account. However, when a window operator, a\nquintessential feature in Complex Event Processing, is used, RMA are indeed\ndeterminizable even when viewed as recognizers. We present detailed algorithms\nfor constructing deterministic RMA from regular expressions extended with\n$n$-ary constraints. We show how RMA can be used in Complex Event Processing in\norder to detect patterns upon streams of events, using a framework that\nprovides denotational and compositional semantics, and that allows for a\nsystematic treatment of such automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.09999v2"
    },
    {
        "title": "Binary reachability of timed pushdown automata via quantifier\n  elimination and cyclic order atoms",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study an expressive model of timed pushdown automata extended with modular\nand fractional clock constraints. We show that the binary reachability relation\nis effectively expressible in hybrid linear arithmetic with a rational and an\ninteger sort. This subsumes analogous expressibility results previously known\nfor finite and pushdown timed automata with untimed stack. As key technical\ntools, we use quantifier elimination for a fragment of hybrid linear arithmetic\nand for cyclic order atoms, and a reduction to register pushdown automata over\ncyclic order atoms.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.10772v1"
    },
    {
        "title": "Optimal and Robust Controller Synthesis: using Energy Timed Automata\n  with Uncertainty",
        "authors": [
            "Giovanni Bacci",
            "Patricia Bouyer",
            "Uli Fahrenberg",
            "Kim G. Larsen",
            "Nicolas Markey",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we propose a novel framework for the synthesis of robust and\noptimal energy-aware controllers. The framework is based on energy timed\nautomata, allowing for easy expression of timing constraints and variable\nenergy rates. We prove decidability of the energy-constrained infinite-run\nproblem in settings with both certainty and uncertainty of the energy rates. We\nalso consider the optimization problem of identifying the minimal upper bound\nthat will permit the existence of energy-constrained infinite runs. Our\nalgorithms are based on quantifier elimination for linear real arithmetic.\nUsing Mathematica and Mjollnir, we illustrate our framework through a real\nindustrial example of a hydraulic oil pump. Compared with previous approaches\nour method is completely automated and provides improved results.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.00847v2"
    },
    {
        "title": "A Language Hierarchy of Binary Relations",
        "authors": [
            "Tara Brough",
            "Alan J. Cain"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Motivated by the study of word problems of monoids, we explore two ways of\nviewing binary relations on $A^*$ as languages. We exhibit a hierarchy of\nclasses of binary relations on $A^*$, according to the class of languages the\nrelation belongs to and the chosen viewpoint. We give examples of word problems\nof monoids distinguishing the various classes.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.03125v2"
    },
    {
        "title": "DReAM: Dynamic Reconfigurable Architecture Modeling (full paper)",
        "authors": [
            "Rocco De Nicola",
            "Alessandro Maggi",
            "Joseph Sifakis"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Modern systems evolve in unpredictable environments and have to continuously\nadapt their behavior to changing conditions. The \"DReAM\" (Dynamic\nReconfigurable Architecture Modeling) framework, has been designed for modeling\nreconfigurable dynamic systems. It provides a rule-based language, inspired\nfrom Interaction Logic, which is expressive and easy to use encompassing all\naspects of dynamicity including parametric multi-modal coordination with\ncreation/deletion of components as well as mobility. Additionally, it allows\nthe description of both endogenous/modular and exogenous/centralized\ncoordination styles and sound transformations from one style to the other. The\nDReAM framework is implemented in the form of a Java API bundled with an\nexecution engine. It allows to develop runnable systems combining the\nexpressiveness of the rule-based notation together with the flexibility of this\nwidespread programming language.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.03724v2"
    },
    {
        "title": "Estimating probabilistic context-free grammars for proteins using\n  contact map constraints",
        "authors": [
            "Witold Dyrka",
            "François Coste",
            "Juliette Talibart"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Learning language of protein sequences, which captures non-local interactions\nbetween amino acids close in the spatial structure, is a long-standing\nbioinformatics challenge, which requires at least context-free grammars.\nHowever, complex character of protein interactions impedes unsupervised\nlearning of context-free grammars. Using structural information to constrain\nthe syntactic trees proved effective in learning probabilistic natural and RNA\nlanguages. In this work, we establish a framework for learning probabilistic\ncontext-free grammars for protein sequences from syntactic trees partially\nconstrained using amino acid contacts obtained from wet experiments or\ncomputational predictions, whose reliability has substantially increased\nrecently. Within the framework, we implement the maximum-likelihood and\ncontrastive estimators of parameters for simple yet practical grammars. Tested\non samples of protein motifs, grammars developed within the framework showed\nimproved precision in recognition and higher fidelity to protein structures.\nThe framework is applicable to other biomolecular languages and beyond wherever\nknowledge of non-local dependencies is available.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.08630v1"
    },
    {
        "title": "Convex Language Semantics for Nondeterministic Probabilistic Automata",
        "authors": [
            "Gerco van Heerdt",
            "Justin Hsu",
            "Joël Ouaknine",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We explore language semantics for automata combining probabilistic and\nnondeterministic behavior. We first show that there are precisely two natural\nsemantics for probabilistic automata with nondeterminism. For both choices, we\nshow that these automata are strictly more expressive than deterministic\nprobabilistic automata, and we prove that the problem of checking language\nequivalence is undecidable by reduction from the threshold problem. However, we\nprovide a discounted metric that can be computed to arbitrarily high precision.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.11550v1"
    },
    {
        "title": "Unfolding of Finite Concurrent Automata",
        "authors": [
            "Alexandre Mansard"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We consider recognizable trace rewriting systems with level-regular contexts\n(RTL). A trace language is level-regular if the set of Foata normal forms of\nits elements is regular. We prove that the rewriting graph of a RTL is\nword-automatic. Thus its first-order theory is decidable. Then, we prove that\nthe concurrent unfolding of a finite concurrent automaton with the reachability\nrelation is a RTL graph. It follows that the first-order theory with the\nreachability predicate (FO[Reach] theory) of such an unfolding is decidable. It\nis known that this property holds also for the ground term rewriting graphs. We\nprovide examples of finite concurrent automata of which the concurrent\nunfoldings fail to be ground term rewriting graphs. The infinite grid tree (for\neach vertex of an infinite grid, there is an edge from this vertex to the\norigin of a copy of the infinite grid) is such an unfolding. We prove that the\ninfinite grid tree is not a ground term rewriting graph. We have thus obtained\na new class of graphs for with a decidable FO[Reach] theory.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.02471v1"
    },
    {
        "title": "Automatic sequences based on Parry or Bertrand numeration systems",
        "authors": [
            "Adeline Massuir",
            "Jarkko Peltomäki",
            "Michel Rigo"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study the factor complexity and closure properties of automatic sequences\nbased on Parry or Bertrand numeration systems. These automatic sequences can be\nviewed as generalizations of the more typical $k$-automatic sequences and\nPisot-automatic sequences. We show that, like $k$-automatic sequences,\nParry-automatic sequences have sublinear factor complexity while there exist\nBertrand-automatic sequences with superlinear factor complexity. We prove that\nthe set of Parry-automatic sequences with respect to a fixed Parry numeration\nsystem is not closed under taking images by uniform substitutions or periodic\ndeletion of letters. These closure properties hold for $k$-automatic sequences\nand Pisot-automatic sequences, so our result shows that these properties are\nlost when generalizing to Parry numeration systems and beyond. Moreover, we\nshow that a multidimensional sequence is $U$-automatic with respect to a\npositional numeration system $U$ with regular language of numeration if and\nonly if its $U$-kernel is finite.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.11081v1"
    },
    {
        "title": "The problem with probabilistic DAG automata for semantic graphs",
        "authors": [
            "Ieva Vasiljeva",
            "Sorcha Gilroy",
            "Adam Lopez"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Semantic representations in the form of directed acyclic graphs (DAGs) have\nbeen introduced in recent years, and to model them, we need probabilistic\nmodels of DAGs. One model that has attracted some attention is the DAG\nautomaton, but it has not been studied as a probabilistic model. We show that\nsome DAG automata cannot be made into useful probabilistic models by the nearly\nuniversal strategy of assigning weights to transitions. The problem affects\nsingle-rooted, multi-rooted, and unbounded-degree variants of DAG automata, and\nappears to be pervasive. It does not affect planar variants, but these are\nproblematic for other reasons.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.12266v2"
    },
    {
        "title": "The isomorphism problem for tree-automatic ordinals with addition",
        "authors": [
            "Sanjay Jain",
            "Bakhadyr Khoussainov",
            "Philipp Schlicht",
            "Frank Stephan"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper studies tree-automatic ordinals (or equivalently, well-founded\nlinearly ordered sets) together with the ordinal addition operation +.\nInformally, these are ordinals such that their elements are coded by finite\ntrees for which the linear order relation of the ordinal and the ordinal\naddition operation can be determined by tree automata. We describe an algorithm\nthat, given two tree-automatic ordinals with the ordinal addition operation,\ndecides if the ordinals are isomorphic.\n",
        "pdf_link": "http://arxiv.org/pdf/1810.13153v2"
    },
    {
        "title": "Proving that a Tree Language is not First-Order Definable",
        "authors": [
            "Martin Beaudry"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We explore from an algebraic viewpoint the properties of the tree languages\ndefinable with a first-order formula involving the ancestor predicate, using\nthe description of these languages as those recognized by iterated block\nproducts of forest algebras defined from finite counter monoids. Proofs of\nnondefinability are infinite sequences of sets of forests, one for each level\nof the hierarchy of quantification levels that defines the corresponding\nvariety of languages. The forests at a given level are built recursively by\ninserting forests from previous level at the ports of a suitable set of\nmulticontexts. We show that a recursive proof exists for the syntactic algebra\nof every non-definable language. We also investigate certain types of uniform\nrecursive proofs. For this purpose, we define from a forest algebra an algebra\nof mappings and an extended algebra, which we also use to redefine the notion\nof aperiodicity in a way that generalizes the existing ones.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.01674v1"
    },
    {
        "title": "A decidability result for the halting problem of cellular automata in\n  the pentagrid",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we investigate the halting problem for deterministic cellula\nautomata in the pentagrid. We prove that the problem is decidable when the\ncellular automaton starts its computation from a finite configuration and when\nit has at most two states, one of them being a quiescent state.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.03882v1"
    },
    {
        "title": "Comparator automata in quantitative verification",
        "authors": [
            "Suguman Bansal",
            "Swarat Chaudhuri",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The notion of comparison between system runs is fundamental in formal\nverification. This concept is implicitly present in the verification of\nqualitative systems, and is more pronounced in the verification of quantitative\nsystems. In this work, we identify a novel mode of comparison in quantitative\nsystems: the online comparison of the aggregate values of two sequences of\nquantitative weights. This notion is embodied by comparator automata\n(comparators, in short), a new class of automata that read two infinite\nsequences of weights synchronously and relate their aggregate values.\n  We show that aggregate functions that can be represented with B\\\"uchi\nautomaton result in comparators that are finite-state and accept by the B\\\"uchi\ncondition as well. Such $\\omega$-regular comparators further lead to generic\nalgorithms for a number of well-studied problems, including the quantitative\ninclusion and winning strategies in quantitative graph games with incomplete\ninformation, as well as related non-decision problems, such as obtaining a\nfinite representation of all counterexamples in the quantitative inclusion\nproblem.\n  We study comparators for two aggregate functions: discounted-sum and\nlimit-average. We prove that the discounted-sum comparator is $\\omega$-regular\niff the discount-factor is an integer. Not every aggregate function, however,\nhas an $\\omega$-regular comparator. Specifically, we show that the language of\nsequence-pairs for which limit-average aggregates exist is neither\n$\\omega$-regular nor $\\omega$-context-free. Given this result, we introduce the\nnotion of prefix-average as a relaxation of limit-average aggregation, and show\nthat it admits $\\omega$-context-free comparators i.e. comparator automata\nexpressed by B\\\"uchi pushdown automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.06569v5"
    },
    {
        "title": "Orbit Expandability of Automaton Semigroups and Groups",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce the notion of expandability in the context of automaton\nsemigroups and groups: a word is k-expandable if one can append a suffix to it\nsuch that the size of the orbit under the action of the automaton increases by\nat least k. This definition is motivated by the question which {\\omega}-words\nadmit infinite orbits: for such a word, every prefix is expandable.\n  In this paper, we show that, on input of a word u, an automaton T and a\nnumber k, it is decidable to check whether u is k-expandable with respect to\nthe action of T. In fact, this can be done in exponential nondeterministic\nspace. From this nondeterministic algorithm, we obtain a bound on the length of\na potential orbit-increasing suffix x. Moreover, we investigate the situation\nif the automaton is invertible and generates a group. In this case, we give an\nalgebraic characterization for the expandability of a word based on its shifted\nstabilizer. We also give a more efficient algorithm to decide expandability of\na word in the case of automaton groups, which allows us to improve the upper\nbound on the maximal orbit-increasing suffix length. Then, we investigate the\nsituation for reversible (and complete) automata and obtain that every word is\nexpandable with respect to these automata. Finally, we give a lower bound\nexample for the length of an orbit-increasing suffix.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.07359v2"
    },
    {
        "title": "Transition Property For Cube-Free Words",
        "authors": [
            "Elena A. Petrova",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study cube-free words over arbitrary non-unary finite alphabets and prove\nthe following structural property: for every pair $(u,v)$ of $d$-ary cube-free\nwords, if $u$ can be infinitely extended to the right and $v$ can be infinitely\nextended to the left respecting the cube-freeness property, then there exists a\n\"transition\" word $w$ over the same alphabet such that $uwv$ is cube free. The\ncrucial case is the case of the binary alphabet, analyzed in the central part\nof the paper.\n  The obtained \"transition property\", together with the developed technique,\nallowed us to solve cube-free versions of three old open problems by Restivo\nand Salemi. Besides, it has some further implications for combinatorics on\nwords; e.g., it implies the existence of infinite cube-free words of very big\nsubword (factor) complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1812.11119v1"
    },
    {
        "title": "Infinite Automaton Semigroups and Groups Have Infinite Orbits",
        "authors": [
            "Daniele D'Angeli",
            "Dominik Francoeur",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that an automaton group or semigroup is infinite if and only if it\nadmits an $\\omega$-word (i. e. a right-infinite word) with an infinite orbit,\nwhich solves an open problem communicated to us by Ievgen V. Bondarenko. In\nfact, we prove a generalization of this result, which can be applied to show\nthat finitely generated subgroups and subsemigroups as well as principal left\nideals of automaton semigroups are infinite if and only if there is an $\\omega$\n-word with an infinite orbit under their action. The proof also shows some\ninteresting connections between the automaton semigroup and its dual. Finally,\nour result is interesting from an algorithmic perspective as it allows for a\nreformulation of the finiteness problem for automaton groups and semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.00222v3"
    },
    {
        "title": "Regular Expressions with Backreferences: Polynomial-Time Matching\n  Techniques",
        "authors": [
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Regular expressions with backreferences (regex, for short), as supported by\nmost modern libraries for regular expression matching, have an NP-complete\nmatching problem. We define a complexity parameter of regex, called active\nvariable degree, such that regex with this parameter bounded by a constant can\nbe matched in polynomial-time. Moreover, we formulate a novel type of\ndeterminism for regex (on an automaton-theoretic level), which yields the class\nof memory-deterministic regex that can be matched in time O(|w|p(|r|)) for a\npolynomial p (where r is the regex and w the word). Natural extensions of these\nconcepts lead to properties of regex that are intractable to check.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.05896v2"
    },
    {
        "title": "One-Way Topological Automata and the Tantalizing Effects of Their\n  Topological Features",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We cast new light on the existing models of one-way deterministic topological\nautomata by introducing a fresh but general, convenient model, in which, as\neach input symbol is read, an interior system of an automaton, known as a\nconfiguration, continues to evolve in a topological space by applying\ncontinuous transition operators one by one. The acceptance and rejection of a\ngiven input are determined by observing the interior system after the input is\ncompletely processed. Such automata naturally generalize one-way finite\nautomata of various types, including deterministic, probabilistic, quantum, and\npushdown automata. We examine the strengths and weaknesses of the power of this\nnew automata model when recognizing formal languages. We investigate\ntantalizing effects of various topological features of our topological automata\nby analyzing their behaviors when different kinds of topological spaces and\ncontinuous maps, which are used respectively as configuration spaces and\ntransition operators, are provided to the automata. Finally, we present goals\nand directions of future studies on the topological features of topological\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.07477v3"
    },
    {
        "title": "The Intersection of $3$-Maximal Submonids",
        "authors": [
            "Giuseppa Castiglione",
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Very little is known about the structure of the intersection of two\n$k$-generated monoids of words, even for $k=3$. Here we investigate the case of\n$k$-maximal monoids, that is, monoids whose basis of cardinality $k$ cannot be\nnon-trivially decomposed into at most $k$ words. We characterize the\nintersection in the case of two $3$-maximal monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.01824v1"
    },
    {
        "title": "Glushkov's construction for functional subsequential transducers",
        "authors": [
            "Aleksander Mendoza-Drosik"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Glushkov's construction has many interesting properties and they become even\nmore evident when applied to transducers. This article strives to show the wast\nrange of possible extensions and optimisations for this algorithm. Special\nflavour of regular expressions is introduced, which can be efficiently\nconverted to $\\epsilon$-free functional subsequential weighted finite state\ntransducers. Produced automata are very compact, as they contain only one state\nfor each symbol (from input alphabet) of original expression and only one\ntransition for each range of symbols, no matter how large. Such compactified\nranges of transitions allow for efficient binary search lookup during automaton\nevaluation. All the methods and algorithms presented here were used to\nimplement open-source compiler of regular expressions for multitape\ntransducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.02239v4"
    },
    {
        "title": "An Efficient Model Inference Algorithm for Learning-based Testing of\n  Reactive Systems",
        "authors": [
            "Muddassar A. Sindhu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Learning-based testing (LBT) is an emerging methodology to automate iterative\nblack-box requirements testing of software systems. The methodology involves\ncombining model inference with model checking techniques. However, a variety of\noptimisations on model inference are necessary in order to achieve scalable\ntesting for large systems. In this paper we describe the IKL learning algorithm\nwhich is an active incremental learning algorithm for deterministic Kripke\nstructures. We formally prove the correctness of IKL. We discuss the\noptimisations it incorporates to achieve scalability of testing. We also\nevaluate a black box heuristic for test termination based on convergence of IKL\nlearning.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.06268v1"
    },
    {
        "title": "Kolmogorov structure functions for automatic complexity",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  For a finite word $w$ we define and study the Kolmogorov structure function\n$h_w$ for nondeterministic automatic complexity. We prove upper bounds on $h_w$\nthat appear to be quite sharp, based on numerical evidence.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.0584v2"
    },
    {
        "title": "LTL Parameter Synthesis of Parametric Timed Automata",
        "authors": [
            "Peter Bezděk",
            "Nikola Beneš",
            "Jiří Barnat",
            "Ivana Černá"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The parameter synthesis problem for parametric timed automata is undecidable\nin general even for very simple reachability properties. In this paper we\nintroduce restrictions on parameter valuations under which the parameter\nsynthesis problem is decidable for LTL properties. The investigated bounded\ninteger parameter synthesis problem could be solved using an explicit\nenumeration of all possible parameter valuations. We propose an alternative\nsymbolic zone-based method for this problem which results in a faster\ncomputation. Our technique extends the ideas of the automata-based approach to\nLTL model checking of timed automata. To justify the usefulness of our\napproach, we provide experimental evaluation and compare our method with\nexplicit enumeration technique.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.3696v2"
    },
    {
        "title": "A connected 3-state reversible Mealy automaton cannot generate an\n  infinite Burnside group",
        "authors": [
            "Ines Klimann",
            "Matthieu Picantin",
            "Dmytro Savchuk"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The class of automaton groups is a rich source of the simplest examples of\ninfinite Burnside groups. However, there are some classes of automata that do\nnot contain such examples. For instance, all infinite Burnside automaton groups\nin the literature are generated by non reversible Mealy automata and it was\nrecently shown that 2-state invertible-reversible Mealy automata cannot\ngenerate infinite Burnside groups. Here we extend this result to connected\n3-state invertible-reversible Mealy automata, using new original techniques.\nThe results provide the first uniform method to construct elements of infinite\norder in each infinite group in this class.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.6142v1"
    },
    {
        "title": "Computing downward closures for stacked counter automata",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The downward closure of a language $L$ of words is the set of all (not\nnecessarily contiguous) subwords of members of $L$. It is well known that the\ndownward closure of any language is regular. Although the downward closure\nseems to be a promising abstraction, there are only few language classes for\nwhich an automaton for the downward closure is known to be computable.\n  It is shown here that for stacked counter automata, the downward closure is\ncomputable. Stacked counter automata are finite automata with a storage\nmechanism obtained by \\emph{adding blind counters} and \\emph{building stacks}.\nHence, they generalize pushdown and blind counter automata.\n  The class of languages accepted by these automata are precisely those in the\nhierarchy obtained from the context-free languages by alternating two closure\noperators: imposing semilinear constraints and taking the algebraic extension.\nThe main tool for computing downward closures is the new concept of Parikh\nannotations. As a second application of Parikh annotations, it is shown that\nthe hierarchy above is strict at every level.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.7922v1"
    },
    {
        "title": "Converting Reconfigurable Petri Nets to Maude",
        "authors": [
            "Alexander Schulz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Model checking is an important aim of the theoretical computer science. It\nenables the verification of a model with a set of properties such as liveness,\ndeadlock or safety. One of the typical modelling techniques are Petri nets they\nare well understood and can be used for a model checking. Reconfigurable Petri\nnets are based on a Petri nets with a set of rules. These rules can be used\ndynamically to change the net. Missing is the possibility to verify a\nreconfigurable net and properties such as deadlocks or liveness. This paper\nintroduces a conversion from reconfigurable Petri net to Maude, that allows us\nto fill the gap. It presents a net transformation approach which is based on\nMaude's equation- and rewrite logic as well as the LTLR model checker.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.8404v5"
    },
    {
        "title": "Towards an Efficient Tree Automata based technique for Timed Systems",
        "authors": [
            "S. Akshay",
            "Paul Gastin",
            "Shankara Narayanan Krishna",
            "Ilias Sarkar"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The focus of this paper is the analysis of real-time systems with recursion,\nthrough the development of good theoretical techniques which are implementable.\nTime is modeled using clock variables, and recursion using stacks. Our\ntechnique consists of modeling the behaviours of the timed system as graphs,\nand interpreting these graphs on tree terms by showing a bound on their\ntree-width. We then build a tree automaton that accepts exactly those tree\nterms that describe realizable runs of the timed system. The emptiness of the\ntimed system thus boils down to emptiness of a finite tree automaton that\naccepts these tree terms. This approach helps us in obtaining an optimal\ncomplexity, not just in theory (as done in earlier work), but also in going\ntowards an efficient implementation of our technique. To do this, we make\nseveral improvements in the theory and exploit these to build a first prototype\ntool that can analyze timed systems with recursion.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.02297v1"
    },
    {
        "title": "Multiple Context-Free Tree Grammars: Lexicalization and Characterization",
        "authors": [
            "Joost Engelfriet",
            "Andreas Maletti",
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Multiple (simple) context-free tree grammars are investigated, where \"simple\"\nmeans \"linear and nondeleting\". Every multiple context-free tree grammar that\nis finitely ambiguous can be lexicalized; i.e., it can be transformed into an\nequivalent one (generating the same tree language) in which each rule of the\ngrammar contains a lexical symbol. Due to this transformation, the rank of the\nnonterminals increases at most by 1, and the multiplicity (or fan-out) of the\ngrammar increases at most by the maximal rank of the lexical symbols; in\nparticular, the multiplicity does not increase when all lexical symbols have\nrank 0. Multiple context-free tree grammars have the same tree generating power\nas multi-component tree adjoining grammars (provided the latter can use a\nroot-marker). Moreover, every multi-component tree adjoining grammar that is\nfinitely ambiguous can be lexicalized. Multiple context-free tree grammars have\nthe same string generating power as multiple context-free (string) grammars and\npolynomial time parsing algorithms. A tree language can be generated by a\nmultiple context-free tree grammar if and only if it is the image of a regular\ntree language under a deterministic finite-copying macro tree transducer.\nMultiple context-free tree grammars can be used as a synchronous translation\ndevice.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.03457v1"
    },
    {
        "title": "Non-locality of the meet levels of the Trotter-Weil Hierarchy",
        "authors": [
            "João Daniel Moreira"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We prove that the meet level $m$ of the Trotter-Weil, $\\mathsf{V}_m$ is not\nlocal for all $m \\geq 1$, as conjectured in a paper by Kufleitner and Lauser.\nIn order to show this, we explicitly provide a language whose syntactic\nsemigroup is in $L \\mathsf{V}_m$ and not in $\\mathsf{V}_m*\\mathsf{D}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.04441v1"
    },
    {
        "title": "On Stochastic Automata over Monoids",
        "authors": [
            "Karl-Heinz Zimmermann",
            "Merve Nur Cakir"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Stochastic automata over monoids as input sets are studied. The\nwell-definedness of these automata requires an extension postulate that\nreplaces the inherent universal property of free monoids. As a generalization\nof Turakainen's result, it will be shown that the generalized automata over\nmonoids have the same acceptance power as their stochastic counterparts. The\nkey to homomorphisms is a commuting property between the monoid homomorphism of\ninput states and the monoid homomorphism of transition matrices. Closure\nproperties of the languages accepted by stochastic automata over monoids are\ninvestigated. matrices. Closure properties of the languages accepted by\nstochastic automata over monoids are investigated.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.01214v1"
    },
    {
        "title": "Alternating Tree Automata with Qualitative Semantics",
        "authors": [
            "Raphaël Berthon",
            "Nathanaël Fijalkow",
            "Emmanuel Filiot",
            "Shibashis Guha",
            "Bastien Maubert",
            "Aniello Murano",
            "Laureline Pinault",
            "Sophie Pinchinat",
            "Sasha Rubin",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study alternating automata with qualitative semantics over infinite binary\ntrees: alternation means that two opposing players construct a decoration of\nthe input tree called a run, and the qualitative semantics says that a run of\nthe automaton is accepting if almost all branches of the run are accepting. In\nthis paper we prove a positive and a negative result for the emptiness problem\nof alternating automata with qualitative semantics.\n  The positive result is the decidability of the emptiness problem for the case\nof B\\\"uchi acceptance condition. An interesting aspect of our approach is that\nwe do not extend the classical solution for solving the emptiness problem of\nalternating automata, which first constructs an equivalent non-deterministic\nautomaton. Instead, we directly construct an emptiness game making use of\nimperfect information.\n  The negative result is the undecidability of the emptiness problem for the\ncase of co-B\\\"uchi acceptance condition. This result has two direct\nconsequences: the undecidability of monadic second-order logic extended with\nthe qualitative path-measure quantifier, and the undecidability of the\nemptiness problem for alternating tree automata with non-zero semantics, a\nrecently introduced probabilistic model of alternating tree automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.03664v2"
    },
    {
        "title": "Information-Flow Interfaces",
        "authors": [
            "Ezio Bartocci",
            "Thomas Ferrère",
            "Thomas A. Henzinger",
            "Dejan Nickovic",
            "Ana Oliveira da Costa"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Contract-based design is a promising methodology for taming the complexity of\ndeveloping sophisticated systems. A formal contract distinguishes between\nassumptions, which are constraints that the designer of a component puts on the\nenvironments in which the component can be used safely, and guarantees, which\nare promises that the designer asks from the team that implements the\ncomponent. A theory of formal contracts can be formalized as an interface\ntheory, which supports the composition and refinement of both assumptions and\nguarantees. Although there is a rich landscape of contract-based design methods\nthat address functional and extra-functional properties, we present the first\ninterface theory that is designed for ensuring system-wide security properties,\nthus paving the way for a science of safety and security co-engineering. Our\nframework provides a refinement relation and a composition operation that\nsupport both incremental design and independent implementability. We develop\nour theory for both stateless and stateful interfaces. We illustrate the\napplicability of our framework with an example inspired from the automotive\ndomain. Finally, we provide three plausible trace semantics to stateful\ninformation-flow interfaces and we show that only two correspond to temporal\nlogics for specifying hyperproperties, while the third defines a new class of\nhyperproperties that lies between the other two classes.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.06465v3"
    },
    {
        "title": "Decidability of cutpoint isolation for probabilistic finite automata on\n  letter-bounded inputs",
        "authors": [
            "Paul C. Bell",
            "Pavel Semukhin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show the surprising result that the cutpoint isolation problem is\ndecidable for Probabilistic Finite Automata (PFA) where input words are taken\nfrom a letter-bounded context-free language. A context-free language\n$\\mathcal{L}$ is letter-bounded when $\\mathcal{L} \\subseteq a_1^*a_2^* \\cdots\na_\\ell^*$ for some finite $\\ell > 0$ where each letter is distinct. A cutpoint\nis isolated when it cannot be approached arbitrarily closely. The decidability\nof this problem is in marked contrast to the situation for the (strict)\nemptiness problem for PFA which is undecidable under the even more severe\nrestrictions of PFA with polynomial ambiguity, commutative matrices and input\nover a letter-bounded language as well as to the injectivity problem which is\nundecidable for PFA over letter-bounded languages. We provide a constructive\nnondeterministic algorithm to solve the cutpoint isolation problem, which holds\neven when the PFA is exponentially ambiguous. We also show that the problem is\nat least NP-hard and use our decision procedure to solve several related\nproblems.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07660v2"
    },
    {
        "title": "Comparing consecutive letter counts in multiple context-free languages",
        "authors": [
            "Florian Lehner",
            "Christian Lindorfer"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Context-free grammars are not able to model cross-serial dependencies in\nnatural languages. To overcome this issue, Seki et al. introduced a\ngeneralization called $m$-multiple context-free grammars ($m$-MCFGs), which\ndeal with $m$-tuples of strings. We show that $m$-MCFGs are capable of\ncomparing the number of consecutive occurrences of at most $2m$ different\nletters. In particular, the language $\\{a_1^{n_1} a_2^{n_2} \\dots\na_{k}^{n_{2m+1}} \\mid n_1 \\geq n_2 \\geq \\dots \\geq n_{2m+1} \\geq 0\\}$ is\n$(m+1)$-multiple context-free, but not $m$-multiple context-free.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.08236v3"
    },
    {
        "title": "Extensions of $ω$-Regular Languages",
        "authors": [
            "Mikołaj Bojańczyk",
            "Edon Kelmendi",
            "Rafał Stefański",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider extensions of monadic second order logic over $\\omega$-words,\nwhich are obtained by adding one language that is not $\\omega$-regular. We show\nthat if the added language $L$ has a neutral letter, then the resulting logic\nis necessarily undecidable. A corollary is that the $\\omega$-regular languages\nare the only decidable Boolean-closed full trio over $\\omega$-words.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.09393v1"
    },
    {
        "title": "Automata for Hyperlanguages",
        "authors": [
            "Borzoo Bonakdarpour",
            "Sarai Sheinvald"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Hyperproperties lift conventional trace properties from a set of execution\ntraces to a set of sets of execution traces. Hyperproperties have been shown to\nbe a powerful formalism for expressing and reasoning about information-flow\nsecurity policies and important properties of cyber-physical systems such as\nsensitivity and robustness, as well as consistency conditions in distributed\ncomputing such as linearizability. Although there is an extensive body of work\non automata-based representation of trace properties, we currently lack such\ncharacterization for hyperproperties. We introduce hyperautomata for em\nhyperlanguages, which are languages over sets of words. Essentially,\nhyperautomata allow running multiple quantified words over an automaton. We\npropose a specific type of hyperautomata called nondeterministic finite\nhyperautomata (NFH), which accept regular hyperlanguages. We demonstrate the\nability of regular hyperlanguages to express hyperproperties for finite traces.\nWe then explore the fundamental properties of NFH and show their closure under\nthe Boolean operations. We show that while nonemptiness is undecidable in\ngeneral, it is decidable for several fragments of NFH. We further show the\ndecidability of the membership problem for finite sets and regular languages\nfor NFH, as well as the containment problem for several fragments of NFH.\nFinally, we introduce learning algorithms based on Angluin's L-star algorithm\nfor the fragments NFH in which the quantification is either strictly universal\nor strictly existential.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.09877v1"
    },
    {
        "title": "Buchi automata augmented with spatial constraints: simulating an\n  alternating with a nondeterministic and deciding the emptiness problem for\n  the latter",
        "authors": [
            "Amar Isli"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The aim of this work is to thoroughly investigate Buchi automata augmented\nwith spatial constraints. The input trees of such an automaton are infinite\nk-ary Sigma-trees, with the nodes standing for time points, and Sigma\nincluding, additionally to its uses in classical k-ary Sigma-trees, the\ndescription of the snapshot of an n-object spatial scene of interest. The\nconstraints, from an RCC8-like spatial Relation Algebra (RA) x, are used to\nimpose spatial constraints on objects of the spatial scene, eventually at\ndifferent nodes of the input trees. We show that a Buchi alternating automaton\naugmented with spatial constraints can be simulated with a classical Buchi\nnondeterministic automaton of the same type, augmented with spatial\nconstraints. We then provide a nondeterministic doubly depth-first polynomial\nspace algorithm for the emptiness problem of the latter automaton. Our main\nmotivation came from another work, also submitted to this conference, which\ndefines a spatio-temporalisation of the well-known family ALC(D) of description\nlogics with a concrete domain: together, the two works provide an effective\nsolution to the satisfiability problem of a concept of the\nspatio-temporalisation with respect to a weakly cyclic TBox.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.11510v1"
    },
    {
        "title": "Kleene Algebras and Semimodules for Energy Problems",
        "authors": [
            "Zoltán Ésik",
            "Uli Fahrenberg",
            "Axel Legay",
            "Karin Quaas"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  With the purpose of unifying a number of approaches to energy problems found\nin the literature, we introduce generalized energy automata. These are finite\nautomata whose edges are labeled with energy functions that define how energy\nlevels evolve during transitions. Uncovering a close connection between energy\nproblems and reachability and B\\\"uchi acceptance for semiring-weighted\nautomata, we show that these generalized energy problems are decidable. We also\nprovide complexity results for important special cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.0635v1"
    },
    {
        "title": "On the state complexity of semi-quantum finite automata",
        "authors": [
            "Shenggen Zheng",
            "Jozef Gruska",
            "Daowen Qiu"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Some of the most interesting and important results concerning quantum finite\nautomata are those showing that they can recognize certain languages with\n(much) less resources than corresponding classical finite automata\n\\cite{Amb98,Amb09,AmYa11,Ber05,Fre09,Mer00,Mer01,Mer02,Yak10,ZhgQiu112,Zhg12}.\nThis paper shows three results of such a type that are stronger in some sense\nthan other ones because (a) they deal with models of quantum automata with very\nlittle quantumness (so-called semi-quantum one- and two-way automata with one\nqubit memory only); (b) differences, even comparing with probabilistic\nclassical automata, are bigger than expected; (c) a trade-off between the\nnumber of classical and quantum basis states needed is demonstrated in one case\nand (d) languages (or the promise problem) used to show main results are very\nsimple and often explored ones in automata theory or in communication\ncomplexity, with seemingly little structure that could be utilized.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.2499v2"
    },
    {
        "title": "A Unifying Approach to Decide Relations for Timed Automata and their\n  Game Characterization",
        "authors": [
            "Shibashis Guha",
            "Shankara Narayanan Krishna",
            "Chinmay Narayan",
            "S. Arun-Kumar"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In this paper we present a unifying approach for deciding various\nbisimulations, simulation equivalences and preorders between two timed automata\nstates. We propose a zone based method for deciding these relations in which we\neliminate an explicit product construction of the region graphs or the zone\ngraphs as in the classical methods. Our method is also generic and can be used\nto decide several timed relations. We also present a game characterization for\nthese timed relations and show that the game hierarchy reflects the hierarchy\nof the timed relations. One can obtain an infinite game hierarchy and thus the\ngame characterization further indicates the possibility of defining new timed\nrelations which have not been studied yet. The game characterization also helps\nus to come up with a formula which encodes the separation between two states\nthat are not timed bisimilar. Such distinguishing formulae can also be\ngenerated for many relations other than timed bisimilarity.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.7443v1"
    },
    {
        "title": "Regular Substitution Sets: A Means of Controlling E-Unification",
        "authors": [
            "Jochen Burghardt"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A method for selecting solution constructors in narrowing is presented. The\nmethod is based on a sort discipline that describes regular sets of ground\nconstructor terms as sorts. It is extended to cope with regular sets of ground\nsubstitutions, thus allowing different sorts to be computed for terms with\ndifferent variable bindings. An algorithm for computing signatures of\nequationally defined functions is given that allows potentially infinite\noverloading. Applications to formal program development are sketched.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.1201v2"
    },
    {
        "title": "The Kinetic Basis of Self-Organized Pattern Formation",
        "authors": [
            "Yuri Shalygo"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  In his seminal paper on morphogenesis (1952), Alan Turing demonstrated that\ndifferent spatio-temporal patterns can arise due to instability of the\nhomogeneous state in reaction-diffusion systems, but at least two species are\nnecessary to produce even the simplest stationary patterns. This paper is aimed\nto propose a novel model of the analog (continuous state) kinetic automaton and\nto show that stationary and dynamic patterns can arise in one-component\nnetworks of kinetic automata. Possible applicability of kinetic networks to\nmodeling of real-world phenomena is also discussed.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.1283v2"
    },
    {
        "title": "The monoid of queue actions",
        "authors": [
            "Martin Huschenbett",
            "Dietrich Kuske",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We investigate the monoid of transformations that are induced by sequences of\nwriting to and reading from a queue storage. We describe this monoid by means\nof a confluent and terminating semi-Thue system and study some of its basic\nalgebraic properties, e.g., conjugacy. Moreover, we show that while several\nproperties concerning its rational subsets are undecidable, their uniform\nmembership problem is NL-complete. Furthermore, we present an algebraic\ncharacterization of this monoid's recognizable subsets. Finally, we prove that\nit is not Thurston-automatic.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.5479v1"
    },
    {
        "title": "Distributed Graph Automata",
        "authors": [
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Inspired by distributed algorithms, we introduce a new class of finite graph\nautomata that recognize precisely the graph languages definable in monadic\nsecond-order logic. For the cases of words and trees, it has been long known\nthat the regular languages are precisely those definable in monadic\nsecond-order logic. In this regard, the automata proposed in the present work\ncan be seen, to some extent, as a generalization of finite automata to graphs.\n  Furthermore, we show that, unlike for finite automata on words and trees, the\ndeterministic, nondeterministic and alternating variants of our automata form a\nstrict hierarchy with respect to their expressive power. For the weaker\nvariants, the emptiness problem is decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6503v1"
    },
    {
        "title": "Reducing Clocks in Timed Automata while Preserving Bisimulation",
        "authors": [
            "Shibashis Guha",
            "Chinmay Narayan",
            "S. Arun-Kumar"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Model checking timed automata becomes increasingly complex with the increase\nin the number of clocks. Hence it is desirable that one constructs an automaton\nwith the minimum number of clocks possible. The problem of checking whether\nthere exists a timed automaton with a smaller number of clocks such that the\ntimed language accepted by the original automaton is preserved is known to be\nundecidable. In this paper, we give a construction, which for any given timed\nautomaton produces a timed bisimilar automaton with the least number of clocks.\nFurther, we show that such an automaton with the minimum possible number of\nclocks can be constructed in time that is doubly exponential in the number of\nclocks of the original automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6613v2"
    },
    {
        "title": "Going higher in the First-order Quantifier Alternation Hierarchy on\n  Words",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We investigate the quantifier alternation hierarchy in first-order logic on\nfinite words. Levels in this hierarchy are defined by counting the number of\nquantifier alternations in formulas. We prove that one can decide membership of\na regular language to the levels $\\mathcal{B}\\Sigma_2$ (boolean combination of\nformulas having only 1 alternation) and $\\Sigma_3$ (formulas having only 2\nalternations beginning with an existential block). Our proof works by\nconsidering a deeper problem, called separation, which, once solved for lower\nlevels, allows us to solve membership for higher levels.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.6832v1"
    },
    {
        "title": "Automata in SageMath---Combinatorics meet Theoretical Computer Science",
        "authors": [
            "Clemens Heuberger",
            "Daniel Krenn",
            "Sara Kropf"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The new finite state machine package in the mathematics software system\nSageMath is presented and illustrated by many examples. Several combinatorial\nproblems, in particular digit problems, are introduced, modeled by automata and\ntransducers and solved using SageMath. In particular, we compute the asymptotic\nHamming weight of a non-adjacent-form-like digit expansion, which was not known\nbefore.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.7458v4"
    },
    {
        "title": "Recognizable Series on Hypergraphs",
        "authors": [
            "Raphaël Bailly",
            "François Denis",
            "Guillaume Rabusseau"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We introduce the notion of Hypergraph Weighted Model (HWM) that generically\nassociates a tensor network to a hypergraph and then computes a value by tensor\ncontractions directed by its hyperedges. A series r defined on a hypergraph\nfamily is said to be recognizable if there exists a HWM that computes it. This\nmodel generalizes the notion of rational series on strings and trees. We prove\nsome properties of the model and study at which conditions finite support\nseries are recognizable.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.7533v2"
    },
    {
        "title": "Topological abstraction of higher-dimensional automata",
        "authors": [
            "Thomas Kahl"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Higher-dimensional automata constitute a very expressive model for concurrent\nsystems. In this paper, we discuss \"topological abstraction\" of\nhigher-dimensional automata, i.e., the replacement of HDAs by smaller ones that\ncan be considered equivalent from both a computer scientific and a topological\npoint of view. By definition, topological abstraction preserves the homotopy\ntype, the trace category, and the homology graph of an HDA. We establish\nconditions under which cube collapses yield topological abstractions of HDAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02270v1"
    },
    {
        "title": "Processing XML for Domain Specific Languages",
        "authors": [
            "Tony Clark"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  XML is a standard and universal language for representing information. XML\nprocessing is supported by two key frameworks: DOM and SAX. SAX is efficient,\nbut leaves the developer to encode much of the processing. This paper\nintroduces a language for expressing XML-based languages via grammars that can\nbe used to process XML documents and synthesize arbitrary values. The language\nis declarative and shields the developer from SAX implementation details. The\nlanguage is specified and an efficient implementation is defined as an abstract\nmachine.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.03366v1"
    },
    {
        "title": "Automata and automata mappings of semigroups",
        "authors": [
            "Boris Plotkin",
            "Tatjana Plotkin"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The paper is devoted to two types of algebraic models of automata. The usual\n(first type) model leads to the developed decomposition theory (Krohn-Rhodes\ntheory). We introduce another type of automata model and study how these\nautomata are related to cascade connections of automata of the first type. The\nintroduced automata play a significant role in group theory and, hopefully, in\nthe theory of formal languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.06004v1"
    },
    {
        "title": "Parikh matrices and Parikh Rewriting Systems",
        "authors": [
            "Wen Chean Teh"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Since the introduction of the Parikh matrix mapping, its injectivity problem\nis on top of the list of open problems in this topic. In 2010 Salomaa provided\na solution for the ternary alphabet in terms of a Thue system with an\nadditional feature called counter. This paper proposes the notion of a Parikh\nrewriting system as a generalization and systematization of Salomaa's result.\nIt will be shown that every Parikh rewriting system induces a Thue system\nwithout counters that serves as a feasible solution to the injectivity problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.06476v1"
    },
    {
        "title": "Synchronization of Bernoulli sequences on shared letters",
        "authors": [
            "Samy Abbes"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The topic of this paper is the distributed and incremental generation of long\nexecutions of concurrent systems, uniformly or more generally with weights\nassociated to elementary actions. Synchronizing sequences of letters on\nalphabets sharing letters are known to produce a trace in the concurrency\ntheoretic sense, i.e., a labeled partially ordered set. We study the\nprobabilistic aspects by considering the synchronization of Bernoulli sequences\nof letters, under the light of Bernoulli and uniform measures recently\nintroduced for trace monoids. We introduce two algorithms that produce random\ntraces, using only local random primitives. We thoroughly study some specific\nexamples, the path model and the ring model, both of arbitrary size. For these\nmodels, we show how to generate any Bernoulli distributed random traces, which\nincludes the case of uniform generation.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.06537v2"
    },
    {
        "title": "Weighted Automata and Logics for Infinite Nested Words",
        "authors": [
            "Manfred Droste",
            "Stefan Dück"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Nested words introduced by Alur and Madhusudan are used to capture structures\nwith both linear and hierarchical order, e.g. XML documents, without losing\nvaluable closure properties. Furthermore, Alur and Madhusudan introduced\nautomata and equivalent logics for both finite and infinite nested words, thus\nextending B\\\"uchi's theorem to nested words. Recently, average and discounted\ncomputations of weights in quantitative systems found much interest. Here, we\nwill introduce and investigate weighted automata models and weighted MSO logics\nfor infinite nested words. As weight structures we consider valuation monoids\nwhich incorporate average and discounted computations of weights as well as the\nclassical semirings. We show that under suitable assumptions, two resp. three\nfragments of our weighted logics can be transformed into each other. Moreover,\nwe show that the logic fragments have the same expressive power as weighted\nnested word automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.07031v1"
    },
    {
        "title": "Tightening the Complexity of Equivalence Problems for Commutative\n  Grammars",
        "authors": [
            "Christoph Haase",
            "Piotr Hofman"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We show that the language equivalence problem for regular and context-free\ncommutative grammars is coNEXP-complete. In addition, our lower bound\nimmediately yields further coNEXP-completeness results for equivalence problems\nfor communication-free Petri nets and reversal-bounded counter automata.\nMoreover, we improve both lower and upper bounds for language equivalence for\nexponent-sensitive commutative grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.07774v1"
    },
    {
        "title": "Pure Strategies in Imperfect Information Stochastic Games",
        "authors": [
            "Arnaud Carayol",
            "Christof Löding",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider imperfect information stochastic games where we require the\nplayers to use pure (i.e. non randomised) strategies. We consider reachability,\nsafety, B\\\"uchi and co-B\\\"uchi objectives, and investigate the existence of\nalmost-sure/positively winning strategies for the first player when the second\nplayer is perfectly informed or more informed than the first player. We obtain\ndecidability results for positive reachability and almost-sure B\\\"uchi with\noptimal algorithms to decide existence of a pure winning strategy and to\ncompute one if exists. We complete the picture by showing that positive safety\nis undecidable when restricting to pure strategies even if the second player is\nperfectly informed.\n",
        "pdf_link": "http://arxiv.org/pdf/1506.09140v2"
    },
    {
        "title": "Characterization and Complexity Results on Jumping Finite Automata",
        "authors": [
            "Henning Fernau",
            "Meenakshi Paramasivan",
            "Markus L. Schmid",
            "Vojtěch Vorel"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In a jumping finite automaton, the input head can jump to an arbitrary\nposition within the remaining input after reading and consuming a symbol.\n  We characterize the corresponding class of languages in terms of special\nshuffle expressions and survey other equivalent notions from the existing\nliterature.\n  Moreover, we present several results concerning computational hardness and\nalgorithms for parsing and other basic tasks concerning jumping finite\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.00482v1"
    },
    {
        "title": "Algorithmic decidability of Engel's property for automaton groups",
        "authors": [
            "Laurent Bartholdi"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider decidability problems associated with Engel's identity\n($[\\cdots[[x,y],y],\\dots,y]=1$ for a long enough commutator sequence) in groups\ngenerated by an automaton. We give a partial algorithm that decides, given\n$x,y$, whether an Engel identity is satisfied. It succeeds, importantly, in\nproving that Grigorchuk's $2$-group is not Engel. We consider next the problem\nof recognizing Engel elements, namely elements $y$ such that the map\n$x\\mapsto[x,y]$ attracts to $\\{1\\}$. Although this problem seems intractable in\ngeneral, we prove that it is decidable for Grigorchuk's group: Engel elements\nare precisely those of order at most $2$. Our computations were implemented\nusing the package FR within the computer algebra system GAP.\n",
        "pdf_link": "http://arxiv.org/pdf/1512.01717v1"
    },
    {
        "title": "Sound Structure-Preserving Transformation for Weakly-Left-Linear\n  Deterministic Conditional Term Rewriting Systems",
        "authors": [
            "Ryota Nakayama",
            "Naoki Nishida",
            "Masahiko Sakai"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this paper, we show that the SR transformation, a computationally\nequivalent transformation proposed by Serbanuta and Rosu, is a sound\nstructure-preserving transformation for weakly-left-linear deterministic\nconditional term rewriting systems. More precisely, we show that every\nweakly-left-linear deterministic conditional term rewriting system can be\nconverted to an equivalent weakly-left-linear and ultra-weakly-left-linear\ndeterministic conditional term rewriting system and prove that the SR\ntransformation is sound for weakly-left-linear and ultra-weakly-left-linear\ndeterministic conditional term rewriting systems. Here, soundness for a\nconditional term rewriting system means that reduction of the transformed\nunconditional term rewriting system creates no undesired reduction sequence for\nthe conditional system.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.00650v1"
    },
    {
        "title": "An Overview of Recent Solutions to and Lower Bounds for the Firing\n  Synchronization Problem",
        "authors": [
            "Thiago Correa",
            "Breno Gustavo",
            "Lucas Lemos",
            "Amber Settle"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Complex systems in a wide variety of areas such as biological modeling, image\nprocessing, and language recognition can be modeled using networks of very\nsimple machines called finite automata. Connecting subsystems modeled using\nfinite automata into a network allows for more computational power. One such\nnetwork, called a cellular automaton, consists of an n-dimensional array for n\n> 1 with a single finite automaton located at each point of the array. One of\nthe oldest problems associated with cellular automata is the firing\nsynchronization problem, originally proposed by John Myhill in 1957. As with\nany long-standing problem, there are a large number of solutions to the firing\nsynchronization problem. Our goal, and the contribution of this work, is to\nsummarize recent solutions to the problem. We focus primarily on solutions to\nthe original problem, that is, the problem where the network is a\none-dimensional array and there is a single initiator located at one of the\nends. We summarize both minimal-time and non-minimal-time solutions, with an\nemphasis on solutions that were published after 1998. We also focus on\nsolutions that minimize the number of states required by the finite automata.\nIn the process we also identify open problems that remain in terms of finding\nminimal-state solutions to the firing synchronization problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.01045v1"
    },
    {
        "title": "On the Upward/Downward Closures of Petri Nets",
        "authors": [
            "Mohamed Faouzi Atig",
            "Roland Meyer",
            "Sebastian Muskalla",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the size and the complexity of computing finite state automata (FSA)\nrepresenting and approximating the downward and the upward closure of Petri net\nlanguages with coverability as the acceptance condition. We show how to\nconstruct an FSA recognizing the upward closure of a Petri net language in\ndoubly-exponential time, and therefore the size is at most doubly exponential.\nFor downward closures, we prove that the size of the minimal automata can be\nnon-primitive recursive. In the case of BPP nets, a well-known subclass of\nPetri nets, we show that an FSA accepting the downward/upward closure can be\nconstructed in exponential time. Furthermore, we consider the problem of\nchecking whether a simple regular language is included in the downward/upward\nclosure of a Petri net/BPP net language. We show that this problem is\nEXPSPACE-complete (resp. NP-complete) in the case of Petri nets (resp. BPP\nnets). Finally, we show that it is decidable whether a Petri net language is\nupward/downward closed. To this end, we prove that one can decide whether a\ngiven regular language is a subset of a Petri net coverability language.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.02927v2"
    },
    {
        "title": "Liveness Verification and Synthesis: New Algorithms for Recursive\n  Programs",
        "authors": [
            "Roland Meyer",
            "Sebastian Muskalla",
            "Elisabeth Neumann"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider the problems of liveness verification and liveness synthesis for\nrecursive programs. The liveness verification problem (LVP) is to decide\nwhether a given omega-context-free language is contained in a given\nomega-regular language. The liveness synthesis problem (LSP) is to compute a\nstrategy so that a given omega-context-free game, when played along the\nstrategy, is guaranteed to derive a word in a given omega-regular language. The\nproblems are known to be EXPTIME-complete and EXPTIME-complete, respectively.\nOur contributions are new algorithms with optimal time complexity. For LVP, we\ngeneralize recent lasso-finding algorithms (also known as Ramsey-based\nalgorithms) from finite to recursive programs. For LSP, we generalize a recent\nsummary-based algorithm from finite to infinite words. Lasso finding and\nsummaries have proven to be efficient in a number of implementations for the\nfinite state and finite word setting.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.02947v1"
    },
    {
        "title": "Logics for Word Transductions with Synthesis",
        "authors": [
            "Luc Dartois",
            "Emmanuel Filiot",
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce a logic, called LT, to express properties of transductions, i.e.\nbinary relations from input to output (finite) words. In LT, the input/output\ndependencies are modelled via an origin function which associates to any\nposition of the output word, the input position from which it originates. LT is\nwell-suited to express relations (which are not necessarily functional), and\ncan express all regular functional transductions, i.e. transductions definable\nfor instance by deterministic two-way transducers. Despite its high expressive\npower, LT has decidable satisfiability and equivalence problems, with tight\nnon-elementary and elementary complexities, depending on specific\nrepresentation of LT-formulas. Our main contribution is a synthesis result:\nfrom any transduction R defined in LT , it is possible to synthesise a regular\nfunctional transduction f such that for all input words u in the domain of R, f\nis defined and (u,f(u)) belongs to R. As a consequence, we obtain that any\nfunctional transduction is regular iff it is LT-definable. We also investigate\nthe algorithmic and expressiveness properties of several extensions of LT, and\nexplicit a correspondence between transductions and data words. As a\nside-result, we obtain a new decidable logic for data words.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.03670v4"
    },
    {
        "title": "Parallel Graph Rewriting with Overlapping Rules",
        "authors": [
            "Rachid Echahed",
            "Aude Maignan"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We tackle the problem of simultaneous transformations of networks represented\nas graphs. Roughly speaking, one may distinguish two kinds of simultaneous or\nparallel rewrite relations over complex structures such as graphs: (i) those\nwhich transform disjoint subgraphs in parallel and hence can be simulated by\nsuccessive mere sequential and local transformations and (ii) those which\ntransform overlapping subgraphs simultaneously. In the latter situations,\nparallel transformations cannot be simulated in general by means of successive\nlocal rewrite steps. We investigate this last problem in the framework of\noverlapping graph transformation systems. As parallel transformation of a graph\ndoes not produce a graph in general, we propose first some sufficient\nconditions that ensure the closure of graphs by parallel rewrite relations.\nThen we mainly introduce and discuss two parallel rewrite relations over\ngraphs. One relation is functional and thus deterministic, the other one is not\nfunctional for which we propose sufficient conditions which ensure its\nconfluence.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.06790v1"
    },
    {
        "title": "Word equations in linear space",
        "authors": [
            "Artur Jeż"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Satisfiability of word equations is an important problem in the intersection\nof formal languages and algebra: Given two sequences consisting of letters and\nvariables we are to decide whether there is a substitution for the variables\nthat turns this equation into true equality of strings. The exact computational\ncomplexity of this problem remains unknown, with the best lower and upper\nbounds being, respectively, NP and PSPACE. Recently, the novel technique of\nrecompression was applied to this problem, simplifying the known proofs and\nlowering the space complexity to (nondeterministic) O(n log n). In this paper\nwe show that satisfiability of word equations is in nondeterministic linear\nspace, thus the language of satisfiable word equations is context-sensitive,\nand by the famous Immerman-Szelepcsenyi theorem: the language of unsatisfiable\nword equations is also context-sensitive. We use the known recompression-based\nalgorithm and additionally employ Huffman coding for letters. The proof,\nhowever, uses analysis of how the fragments of the equation depend on each\nother as well as a new strategy for nondeterministic choices of the algorithm,\nwhich uses several new ideas to limit the space occupied by the letters.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.00736v2"
    },
    {
        "title": "Primitivity, Uniform Minimality and State Complexity of Boolean\n  Operations",
        "authors": [
            "Sylvie Davies"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A minimal deterministic finite automaton (DFA) is uniformly minimal if it\nalways remains minimal when the final state set is replaced by a non-empty\nproper subset of the state set. We prove that a permutation DFA is uniformly\nminimal if and only if its transition monoid is a primitive group. We use this\nto study boolean operations on group languages, which are recognized by direct\nproducts of permutation DFAs. A direct product cannot be uniformly minimal,\nexcept in the trivial case where one of the DFAs in the product is a one-state\nDFA. However, non-trivial direct products can satisfy a weaker condition we\ncall uniform boolean minimality, where only final state sets used to recognize\nboolean operations are considered. We give sufficient conditions for a direct\nproduct of two DFAs to be uniformly boolean minimal, which in turn gives\nsufficient conditions for pairs of group languages to have maximal state\ncomplexity under all binary boolean operations (\"maximal boolean complexity\").\nIn the case of permutation DFAs with one final state, we give necessary and\nsufficient conditions for pairs of group languages to have maximal boolean\ncomplexity. Our results demonstrate a connection between primitive groups and\nautomata with strong minimality properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.00877v3"
    },
    {
        "title": "A short proof of correctness of the quasi-polynomial time algorithm for\n  parity games",
        "authors": [
            "Hugo Gimbert",
            "Rasmus Ibsen-Jensen"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Recently Cristian S. Calude, Sanjay Jain, Bakhadyr Khoussainov, Wei Li and\nFrank Stephan proposed a quasi-polynomial time algorithm for parity games. This\npaper proposes a short proof of correctness of their algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.01953v4"
    },
    {
        "title": "Unveiling Eilenberg-type Correspondences: Birkhoff's Theorem for\n  (finite) Algebras + Duality",
        "authors": [
            "Julian Salamanca"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The purpose of the present paper is to show that: Eilenberg-type\ncorrespondences = Birkhoff's theorem for (finite) algebras + duality. We\nconsider algebras for a monad T on a category D and we study (pseudo)varieties\nof T-algebras. Pseudovarieties of algebras are also known in the literature as\nvarieties of finite algebras. Two well-known theorems that characterize\nvarieties and pseudovarieties of algebras play an important role here:\nBirkhoff's theorem and Birkhoff's theorem for finite algebras, the latter also\nknown as Reiterman's theorem. We prove, under mild assumptions, a categorical\nversion of Birkhoff's theorem for (finite) algebras to establish a one-to-one\ncorrespondence between (pseudo)varieties of T-algebras and (pseudo)equational\nT-theories. Now, if C is a category that is dual to D and B is the comonad on C\nthat is the dual of T, we get a one-to-one correspondence between\n(pseudo)equational T-theories and their dual, (pseudo)coequational B-theories.\nParticular instances of (pseudo)coequational B-theories have been already\nstudied in language theory under the name of \"varieties of languages\" to\nestablish Eilenberg-type correspondences. All in all, we get a one-to-one\ncorrespondence between (pseudo)varieties of T-algebras and (pseudo)coequational\nB-theories, which will be shown to be exactly the nature of Eilenberg-type\ncorrespondences.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.02822v1"
    },
    {
        "title": "The Word Problem of $\\mathbb{Z}^n$ Is a Multiple Context-Free Language",
        "authors": [
            "Meng-Che \"Turbo\" Ho"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The \\emph{word problem} of a group $G = \\langle \\Sigma \\rangle$ can be\ndefined as the set of formal words in $\\Sigma^*$ that represent the identity in\n$G$. When viewed as formal languages, this gives a strong connection between\nclasses of groups and classes of formal languages. For example, Anisimov showed\nthat a group is finite if and only if its word problem is a regular language,\nand Muller and Schupp showed that a group is virtually-free if and only if its\nword problem is a context-free language. Above this, not much was known, until\nSalvati showed recently that the word problem of $\\mathbb{Z}^2$ is a multiple\ncontext-free language, giving first such example. We generalize Salvati's\nresult to show that the word problem of $\\mathbb{Z}^n$ is a multiple\ncontext-free language for any $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.02926v2"
    },
    {
        "title": "Emptiness of zero automata is decidable",
        "authors": [
            "Mikolaj Bojańczyk",
            "Hugo Gimbert",
            "Edon Kelmendi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Zero automata are a probabilistic extension of parity automata on infinite\ntrees. The satisfiability of a certain probabilistic variant of mso, called\ntmso + zero, reduces to the emptiness problem for zero automata. We introduce a\nvariant of zero automata called nonzero automata. We prove that for every zero\nautomaton there is an equivalent nonzero automaton of quadratic size and the\nemptiness problem of nonzero automata is decidable and both in NP and in coNP.\nThese results imply that tmso + zero has decidable satisfiability.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.06858v2"
    },
    {
        "title": "The linear nature of pseudowords",
        "authors": [
            "Jorge Almeida",
            "Alfredo Costa",
            "José Carlos Costa",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Given a pseudoword over suitable pseudovarieties, we associate to it a\nlabeled linear order determined by the factorizations of the pseudoword. We\nshow that, in the case of the pseudovariety of aperiodic finite semigroups, the\npseudoword can be recovered from the labeled linear order.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.08083v2"
    },
    {
        "title": "Synchronization Problems in Automata without Non-trivial Cycles",
        "authors": [
            "Andrew Ryzhikov"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the computational complexity of various problems related to\nsynchronization of weakly acyclic automata, a subclass of widely studied\naperiodic automata. We provide upper and lower bounds on the length of a\nshortest word synchronizing a weakly acyclic automaton or, more generally, a\nsubset of its states, and show that the problem of approximating this length is\nhard. We investigate the complexity of finding a synchronizing set of states of\nmaximum size. We also show inapproximability of the problem of computing the\nrank of a subset of states in a binary weakly acyclic automaton and prove that\nseveral problems related to recognizing a synchronizing subset of states in\nsuch automata are NP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.08144v2"
    },
    {
        "title": "A Topological proof that $O_2$ is $2$-MCFL",
        "authors": [
            "Subhadip Chowdhury"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We give a new proof of Salvati's theorem that the group language $O_2$ is $2$\nmultiple context free. Unlike Salvati's proof, our arguments do not use any\nidea specific to two-dimensions. This raises the possibility that the argument\nmight generalize to $O_n$.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.04597v2"
    },
    {
        "title": "Deciding Confluence and Normal Form Properties of Ground Term Rewrite\n  Systems Efficiently",
        "authors": [
            "Bertram Felgenhauer"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  It is known that the first-order theory of rewriting is decidable for ground\nterm rewrite systems, but the general technique uses tree automata and often\ntakes exponential time. For many properties, including confluence (CR),\nuniqueness of normal forms with respect to reductions (UNR) and with respect to\nconversions (UNC), polynomial time decision procedures are known for ground\nterm rewrite systems. However, this is not the case for the normal form\nproperty (NFP). In this work, we present a cubic time algorithm for NFP, an\nalmost cubic time algorithm for UNR, and an almost linear time algorithm for\nUNC, improving previous bounds. We also present a cubic time algorithm for CR.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.10991v3"
    },
    {
        "title": "Every nonnegative real number is an abelian critical exponent",
        "authors": [
            "Jarkko Peltomäki",
            "Markus A. Whiteland"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The abelian critical exponent of an infinite word $w$ is defined as the\nmaximum ratio between the exponent and the period of an abelian power occurring\nin $w$. It was shown by Fici et al. that the set of finite abelian critical\nexponents of Sturmian words coincides with the Lagrange spectrum. This spectrum\ncontains every large enough positive real number. We construct words whose\nabelian critical exponents fill the remaining gaps, that is, we prove that for\neach nonnegative real number $\\theta$ there exists an infinite word having\nabelian critical exponent $\\theta$. We also extend this result to the\n$k$-abelian setting.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.00665v1"
    },
    {
        "title": "An Automaton Group with PSPACE-Complete Word Problem",
        "authors": [
            "Jan Philipp Wächter",
            "Armin Weiß"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We construct an automaton group with a PSPACE-complete word problem, proving\na conjecture due to Steinberg. Additionally, the constructed group has a\nprovably more difficult, namely EXPSPACE-complete, compressed word problem and\nacts over a binary alphabet. Thus, it is optimal in terms of the alphabet size.\nOur construction directly simulates the computation of a Turing machine in an\nautomaton group and, therefore, seems to be quite versatile. It combines two\nideas: the first one is a construction used by D'Angeli, Rodaro and the first\nauthor to obtain an inverse automaton semigroup with a PSPACE-complete word\nproblem and the second one is to utilize a construction used by Barrington to\nsimulate Boolean circuits of bounded degree and logarithmic depth in the group\nof even permutations over five elements.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.03424v3"
    },
    {
        "title": "Synthesis of Computable Regular Functions of Infinite Words",
        "authors": [
            "V. Dave",
            "E. Filiot",
            "S. Krishna",
            "N. Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Regular functions from infinite words to infinite words can be equivalently\nspecified by MSO-transducers, streaming $\\omega$-string transducers as well as\ndeterministic two-way transducers with look-ahead. In their one-way\nrestriction, the latter transducers define the class of rational functions.\nEven though regular functions are robustly characterised by several\nfinite-state devices, even the subclass of rational functions may contain\nfunctions which are not computable (by a Turing machine with infinite input).\nThis paper proposes a decision procedure for the following synthesis problem:\ngiven a regular function $f$ (equivalently specified by one of the\naforementioned transducer model), is $f$ computable and if it is, synthesize a\nTuring machine computing it.\n  For regular functions, we show that computability is equivalent to\ncontinuity, and therefore the problem boils down to deciding continuity. We\nestablish a generic characterisation of continuity for functions preserving\nregular languages under inverse image (such as regular functions). We exploit\nthis characterisation to show the decidability of continuity (and hence\ncomputability) of rational and regular functions. For rational functions, we\nshow that this can be done in $\\mathsf{NLogSpace}$ (it was already known to be\nin $\\mathsf{PTime}$ by Prieur). In a similar fashion, we also effectively\ncharacterise uniform continuity of regular functions, and relate it to the\nnotion of uniform computability, which offers stronger efficiency guarantees.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.04199v6"
    },
    {
        "title": "Opportunistic Synthesis in Reactive Games under Information Asymmetry",
        "authors": [
            "Abhishek N. Kulkarni",
            "Jie Fu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Reactive synthesis is a class of methods to construct a provably-correct\ncontrol system, referred to as a robot, with respect to a temporal logic\nspecification in the presence of a dynamic and uncontrollable environment. This\nis achieved by modeling the interaction between the robot and its environment\nas a two-player zero-sum game. However, existing reactive synthesis methods\nassume both players to have complete information, which is not the case in many\nstrategic interactions. In this paper, we use a variant of hypergames to model\nthe interaction between the robot and its environment; which has incomplete\ninformation about the specification of the robot. This model allows us to\nidentify a subset of game states from where the robot can leverage the\nasymmetrical information to achieve a better outcome, which is not possible if\nboth players have symmetrical and complete information. We then introduce a\nnovel method of opportunistic synthesis by defining a Markov Decision Process\n(MDP) using the hypergame under temporal logic specifications. When the\nenvironment plays some stochastic strategy in its perceived sure-winning and\nsure-losing regions of the game, we show that by following the opportunistic\nstrategy, the robot is ensured to only improve the outcome of the game -\nmeasured by satisfaction of sub-specifications - whenever an opportunity\nbecomes available. We demonstrate the correctness and optimality of this method\nusing a robot motion planning example in the presence of an adversary.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.05847v1"
    },
    {
        "title": "Pseudo-solutions of word equations",
        "authors": [
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present a framework which allows a uniform approach to the recently\nintroduced concept of pseudo-repetitions on words in the morphic case. This\nframework is at the same time more general and simpler. We introduce the\nconcept of a pseudo-solution and a pseudo-rank of an equation. In particular,\nthis allows to prove that if a classical equation forces periodicity then it\nalso forces pseudo-periodicity. Consequently, there is no need to investigate\ngeneralizations of important equations one by one.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.10535v2"
    },
    {
        "title": "FSM Error Messages",
        "authors": [
            "Marco T. Morazán",
            "Josephine A. Des Rosiers"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Computer Science students, in general, find Automata Theory difficult and\nmostly unrelated to their area of study. To mitigate these perceptions, FSM, a\nlibrary to program state machines and grammars, was developed to bring\nprogramming to the Automata Theory classroom. The results of the library's\nmaiden voyage at Seton Hall University had a positive impact on students, but\nthe students found the library difficult to use due to the error messages\ngenerated. These messages were generated by the host language meaning that\nstudents needed to be familiar with the library's implementation to make sense\nof them. This article presents the design of and results obtained from using an\nerror-messaging system tailor-made for FSM. The effectiveness of the library\nwas measured by both a control group study and a survey. The results strongly\nsuggest that the error-messaging system has had a positive impact on students'\nattitude towards automata theory, towards programming in FSM, and towards FSM\nerror messages. The consequence has been a marked improvement on students'\nability to implement algorithms developed as part of constructive proofs by\nmaking the debugging of FSM programs easier.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.11421v1"
    },
    {
        "title": "An Abstract Framework for Choreographic Testing",
        "authors": [
            "Alex Coto",
            "Roberto Guanciale",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We initiate the development of a model-driven testing framework for\nmessage-passing systems. The notion of test for communicating systems cannot\nsimply be borrowed from existing proposals. Therefore, we formalize a notion of\nsuitable distributed tests for a given choreography and devise an algorithm\nthat generates tests as projections of global views. Our algorithm abstracts\naway from the actual projection operation, for which we only set basic\nrequirements. The algorithm can be instantiated by reusing existing projection\noperations (designed to generate local implementations of global models) as\nthey satisfy our requirements. Finally, we show the correctness of the approach\nand validate our methodology via an illustrative example.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.07990v1"
    },
    {
        "title": "Bounded Model Checking for Hyperproperties",
        "authors": [
            "Tzu-Han Hsu",
            "Cesar Sanchez",
            "Borzoo Bonakdarpour"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Hyperproperties are properties of systems that relate multiple computation\ntraces, including security and concurrency properties. This paper introduces a\nbounded model checking (BMC) algorithm for hyperproperties expressed in\nHyperLTL, which - to the best of our knowledge - is the first such algorithm.\nJust as the classic BMC technique for LTL primarily aims at finding bugs, our\napproach also targets identifying counterexamples. BMC for LTL is reduced to\nSAT solving, because LTL describes a property via inspecting individual traces.\nHyperLTL allows explicit and simultaneous quantification over traces and\ndescribes properties that involves multiple traces and, hence, our BMC approach\nnaturally reduces to QBF solving. We report on successful and efficient model\nchecking, implemented in a tool called HyperQube, of a rich set of experiments\non a variety of case studies, including security, concurrent data structures,\npath planning for robots, and testing.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.08907v2"
    },
    {
        "title": "On the Number of Closed Factors in a Word",
        "authors": [
            "Golnaz Badkobeh",
            "Gabriele Fici",
            "Zsuzsanna Lipták"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A closed word (a.k.a. periodic-like word or complete first return) is a word\nwhose longest border does not have internal occurrences, or, equivalently,\nwhose longest repeated prefix is not right special. We investigate the\nstructure of closed factors of words. We show that a word of length $n$\ncontains at least $n+1$ distinct closed factors, and characterize those words\nhaving exactly $n+1$ closed factors. Furthermore, we show that a word of length\n$n$ can contain $\\Theta(n^{2})$ many distinct closed factors.\n",
        "pdf_link": "http://arxiv.org/pdf/1305.6395v3"
    },
    {
        "title": "How to measure the topological quality of protein grammars?",
        "authors": [
            "Witold Dyrka",
            "François Coste",
            "Olgierd Unold",
            "Łukasz Culer",
            "Agnieszka Kaczmarek"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Context-free and context-sensitive formal grammars are often regarded as more\nappropriate to model proteins than regular level models such as finite state\nautomata and Hidden Markov Models. In theory, the claim is well founded in the\nfact that many biologically relevant interactions between residues of protein\nsequences have a character of nested or crossed dependencies. In practice,\nthere is hardly any evidence that grammars of higher expressiveness have an\nedge over old good HMMs in typical applications including recognition and\nclassification of protein sequences. This is in contrast to RNA modeling, where\nCFG power some of the most successful tools. There have been proposed several\nexplanations of this phenomenon. On the biology side, one difficulty is that\ninteractions in proteins are often less specific and more \"collective\" in\ncomparison to RNA. On the modeling side, a difficulty is the larger alphabet\nwhich combined with high complexity of CF and CS grammars imposes considerable\ntrade-offs consisting on information reduction or learning sub-optimal\nsolutions. Indeed, some studies hinted that CF level of expressiveness brought\nan added value in protein modeling when CF and regular grammars where\nimplemented in the same framework. However, there have been no systematic study\nof explanatory power provided by various grammatical models. The first step to\nthis goal is define objective criteria of such evaluation. Intuitively, a\ndecent explanatory grammar should generate topology, or the parse tree,\nconsistent with topology of the protein, or its secondary and/or tertiary\nstructure. In this piece of research we build on this intuition and propose a\nset of measures to compare topology of the parse tree of a grammar with\ntopology of the protein structure.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.10078v2"
    },
    {
        "title": "A Graph Grammar for Modelling RNA Folding",
        "authors": [
            "Adane Letta Mamuye",
            "Emanuela Merelli",
            "Luca Tesei"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We propose a new approach for modelling the process of RNA folding as a graph\ntransformation guided by the global value of free energy. Since the folding\nprocess evolves towards a configuration in which the free energy is minimal,\nthe global behaviour resembles the one of a self-adaptive system. Each RNA\nconfiguration is a graph and the evolution of configurations is constrained by\nprecise rules that can be described by a graph grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.01639v1"
    },
    {
        "title": "Runtime enforcement of reactive systems using synchronous enforcers",
        "authors": [
            "Srinivas Pinisetty",
            "Partha S Roop",
            "Steven Smyth",
            "Stavros Tripakis",
            "Reinhard von Hanxleden"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Synchronous programming is a paradigm of choice for the design of\nsafety-critical reactive systems. Runtime enforcement is a technique to ensure\nthat the output of a black-box system satisfies some desired properties. This\npaper deals with the problem of runtime enforcement in the context of\nsynchronous programs. We propose a framework where an enforcer monitors both\nthe inputs and the outputs of a synchronous program and (minimally) edits\nerroneous inputs/outputs in order to guarantee that a given property holds. We\ndefine enforceability conditions, develop an online enforcement algorithm, and\nprove its correctness. We also report on an implementation of the algorithm on\ntop of the KIELER framework for the SCCharts synchronous language. Experimental\nresults show that enforcement has minimal execution time overhead, which\ndecreases proportionally with larger benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.05030v1"
    },
    {
        "title": "Selective Monitoring",
        "authors": [
            "Radu Grigore",
            "Stefan Kiefer"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study selective monitors for labelled Markov chains. Monitors observe the\noutputs that are generated by a Markov chain during its run, with the goal of\nidentifying runs as correct or faulty. A monitor is selective if it skips\nobservations in order to reduce monitoring overhead. We are interested in\nmonitors that minimize the expected number of observations. We establish an\nundecidability result for selectively monitoring general Markov chains. On the\nother hand, we show for non-hidden Markov chains (where any output identifies\nthe state the Markov chain is in) that simple optimal monitors exist and can be\ncomputed efficiently, based on DFA language equivalence. These monitors do not\ndepend on the precise transition probabilities in the Markov chain. We report\non experiments where we compute these monitors for several open-source Java\nprojects.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.06143v2"
    },
    {
        "title": "Finding Short Synchronizing Words for Prefix Codes",
        "authors": [
            "Andrew Ryzhikov",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study the problems of finding a shortest synchronizing word and its length\nfor a given prefix code. This is done in two different settings: when the code\nis defined by an arbitrary decoder recognizing its star and when the code is\ndefined by its literal decoder (whose size is polynomially equivalent to the\ntotal length of all words in the code). For the first case for every\n$\\varepsilon > 0$ we prove $n^{1 - \\varepsilon}$-inapproximability for\nrecognizable binary maximal prefix codes, $\\Theta(\\log n)$-inapproximability\nfor finite binary maximal prefix codes and $n^{\\frac{1}{2} -\n\\varepsilon}$-inapproximability for finite binary prefix codes. By\n$c$-inapproximability here we mean the non-existence of a $c$-approximation\npolynomial time algorithm under the assumption P $\\ne$ NP, and by $n$ the\nnumber of states of the decoder in the input. For the second case, we propose\napproximation and exact algorithms and conjecture that for finite maximal\nprefix codes the problem can be solved in polynomial time. We also study the\nrelated problems of finding a shortest mortal and a shortest avoiding word.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.06299v1"
    },
    {
        "title": "An application of communication complexity, Kolmogorov complexity and\n  extremal combinatorics to parity games",
        "authors": [
            "Alexander Kozachinskiy",
            "Mikhail Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  So-called separation automata are in the core of several recently invented\nquasi-polynomial time algorithms for parity games. An explicit $q$-state\nseparation automaton implies an algorithm for parity games with running time\npolynomial in $q$. It is open whether a polynomial-state separation automaton\nexists. A positive answer will lead to a polynomial-time algorithm for parity\ngames, while a negative answer will at least demonstrate impossibility to\nconstruct such an algorithm using separation approach.\n  In this work we prove exponential lower bound for a restricted class of\nseparation automata. Our technique combines communication complexity and\nKolmogorov complexity. One of our technical contributions belongs to extremal\ncombinatorics. Namely, we prove a new upper bound on the product of sizes of\ntwo families of sets with small pairwise intersection.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.07175v3"
    },
    {
        "title": "Query Learning Algorithm for Residual Symbolic Finite Automata",
        "authors": [
            "Kaizaburo Chubachi",
            "Diptarama Hendrian",
            "Ryo Yoshinaka",
            "Ayumi Shinohara"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose a query learning algorithm for residual symbolic finite automata\n(RSFAs). Symbolic finite automata (SFAs) are finite automata whose transitions\nare labeled by predicates over a Boolean algebra, in which a big collection of\ncharacters leading the same transition may be represented by a single\npredicate. Residual finite automata (RFAs) are a special type of\nnon-deterministic finite automata which can be exponentially smaller than the\nminimum deterministic finite automata and have a favorable property for\nlearning algorithms. RSFAs have both properties of SFAs and RFAs and can have\nmore succinct representation of transitions and fewer states than RFAs and\ndeterministic SFAs accepting the same language. The implementation of our\nalgorithm efficiently learns RSFAs over a huge alphabet and outperforms an\nexisting learning algorithm for deterministic SFAs. The result also shows that\nthe benefit of non-determinism in efficiency is even larger in learning SFAs\nthan non-symbolic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.07417v3"
    },
    {
        "title": "Termination of Linear Loops over the Integers",
        "authors": [
            "Mehran Hosseini",
            "Joël Ouaknine",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider the problem of deciding termination of single-path while loops\nwith integer variables, affine updates, and affine guard conditions. The\nquestion is whether such a loop terminates on all integer initial values. This\nproblem is known to be decidable for the subclass of loops whose update\nmatrices are diagonalisable, but the general case has remained open since being\nconjectured decidable by Tiwari in 2004. In this paper we show decidability of\ndetermining termination for arbitrary update matrices, confirming Tiwari's\nconjecture. For the class of loops considered in this paper, the question of\ndeciding termination on a specific initial value is a longstanding open problem\nin number theory. The key to our decision procedure is in showing how to\ncircumvent the difficulties inherent in deciding termination on a fixed initial\nvalue.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.07465v3"
    },
    {
        "title": "Aperiodic Weighted Automata and Weighted First-Order Logic",
        "authors": [
            "Manfred Droste",
            "Paul Gastin"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  By fundamental results of Sch\\\"utzenberger, McNaughton and Papert from the\n1970s, the classes of first-order definable and aperiodic languages coincide.\nHere, we extend this equivalence to a quantitative setting. For this, weighted\nautomata form a general and widely studied model. We define a suitable notion\nof a weighted first-order logic. Then we show that this weighted first-order\nlogic and aperiodic polynomially ambiguous weighted automata have the same\nexpressive power. Moreover, we obtain such equivalence results for suitable\nweighted sublogics and finitely ambiguous or unambiguous aperiodic weighted\nautomata. Our results hold for general weight structures, including all\nsemirings, average computations of costs, bounded lattices, and others.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.08149v3"
    },
    {
        "title": "Polynomially Ambiguous Probabilistic Automata on Restricted Languages",
        "authors": [
            "Paul C. Bell"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider the computability and complexity of decision questions for\nProbabilistic Finite Automata (PFA) with sub-exponential ambiguity. We show\nthat the emptiness problem for strict and non-strict cut-points of polynomially\nambiguous commutative PFA remains undecidable, implying that the problem is\nundecidable when inputs are from a letter monotonic language. We show that the\nproblem remains undecidable over a binary input alphabet when the input word is\nover a bounded language, in the noncommutative case. In doing so, we introduce\na new technique based upon the Turakainen construction of a PFA from a Weighted\nFinite Automata which can be used to generate PFA of lower dimensions and of\nsubexponential ambiguity. We also study freeness/injectivity problems for\npolynomially ambiguous PFA and study the border of decidability and\ntractability for various cases.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.09407v3"
    },
    {
        "title": "Symbolic Monitoring against Specifications Parametric in Time and Data",
        "authors": [
            "Masaki Waga",
            "Étienne André",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Monitoring consists in deciding whether a log meets a given specification. In\nthis work, we propose an automata-based formalism to monitor logs in the form\nof actions associated with time stamps and arbitrarily data values over\ninfinite domains. Our formalism uses both timing parameters and data\nparameters, and is able to output answers symbolic in these parameters and in\nthe log segments where the property is satisfied or violated. We implemented\nour approach in an ad-hoc prototype SyMon, and experiments show that its high\nexpressive power still allows for efficient online monitoring.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.04486v1"
    },
    {
        "title": "Abelian periods of factors of Sturmian words",
        "authors": [
            "Jarkko Peltomäki"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We study the abelian period sets of Sturmian words, which are codings of\nirrational rotations on a one-dimensional torus. The main result states that\nthe minimum abelian period of a factor of a Sturmian word of angle $\\alpha$\nwith continued fraction expansion $[0; a_1, a_2, \\ldots]$ is either $tq_k$ with\n$1 \\leq t \\leq a_{k+1}$ (a multiple of a denominator $q_k$ of a convergent of\n$\\alpha$) or $q_{k,\\ell}$ (a denominator $q_{k,\\ell}$ of a semiconvergent of\n$\\alpha$). This result generalizes a result of Fici et. al stating that the\nabelian period set of the Fibonacci word is the set of Fibonacci numbers. A\ncharacterization of the Fibonacci word in terms of its abelian period set is\nobtained as a corollary.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.06138v3"
    },
    {
        "title": "Simulations in Rank-Based Büchi Automata Complementation (Technical\n  Report)",
        "authors": [
            "Yu-Fang Chen",
            "Vojtěch Havlena",
            "Ondřej Lengál"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Complementation of B\\\"uchi automata is an essential technique used in some\napproaches for termination analysis of programs. The long search for an optimal\ncomplementation construction climaxed with the work of Schewe, who proposed a\nworst-case optimal rank-based procedure that generates complements of a size\nmatching the theoretical lower bound of $(0.76n)^n$, modulo a polynomial factor\nof $O(n^2)$. Although worst-case optimal, the procedure in many cases produces\nautomata that are unnecessarily large. In this paper, we propose several ways\nof how to use the direct and delayed simulation relations to reduce the size of\nthe automaton obtained in the rank-based complementation procedure. Our\ntechniques are based on either (i) ignoring macrostates that cannot be used for\naccepting a word in the complement or (ii) saturating macrostates with\nsimulation-smaller states, in order to decrease their total number. We\nexperimentally showed that our techniques can indeed considerably decrease the\nsize of the output of the complementation.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.07139v2"
    },
    {
        "title": "ATAC: A Tool for Automating Timed Automata Construction",
        "authors": [
            "Beyazit Yalcinkaya",
            "Ebru Aydin Gol"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper, we focus on the design and verification of timed automata\n(TA). We introduce a new method for assisting construction and verification of\nTA models along with a tool implementing the proposed method, i.e., ATAC:\nAutomated Timed Automata Construction. Our method provides two main\nfunctionalities, i.e., construction of TA models from descriptions and\ngeneration of temporal logic queries from specifications. Both description and\nspecification sentences shall follow our well-defined structured natural\nlanguage definition. TA models constructed from descriptions and temporal logic\nqueries generated from specifications can be imported to UPPAAL, a verification\ntool for TA models. The goal is to accelerate the design phase for real-time\nsystems by assisting the construction and verification of a formal model. We\nbelieve ATAC can be useful especially during the initial phases of the design\nprocess and help designers to avoid erroneous models.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.08169v2"
    },
    {
        "title": "On Collapsing Prefix Normal Words",
        "authors": [
            "Pamela Fleischmann",
            "Mitja Kulczynski",
            "Dirk Nowotka"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Prefix normal words are binary words in which each prefix has at least the\nsame number of $\\so$s as any factor of the same length. Firstly introduced by\nFici and Lipt\\'ak in 2011, the problem of determining the index of the prefix\nequivalence relation is still open. In this paper, we investigate two aspects\nof the problem, namely prefix normal palindromes and so-called collapsing words\n(extending the notion of critical words). We prove characterizations for both\nthe palindromes and the collapsing words and show their connection. Based on\nthis, we show that still open problems regarding prefix normal words can be\nsplit into certain subproblems.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.11847v2"
    },
    {
        "title": "String-to-String Interpretations with Polynomial-Size Output",
        "authors": [
            "Mikołaj Bojańczyk",
            "Sandra Kiefer",
            "Nathan Lhote"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  String-to-string MSO interpretations are like Courcelle's MSO transductions,\nexcept that a single output position can be represented using a tuple of input\npositions instead of just a single input position. In particular, the output\nlength is polynomial in the input length, as opposed to MSO transductions,\nwhich have output of linear length. We show that string-to-string MSO\ninterpretations are exactly the polyregular functions. The latter class has\nvarious characterizations, one of which is that it consists of the\nstring-to-string functions recognized by pebble transducers.\n  Our main result implies the surprising fact that string-to-string MSO\ninterpretations are closed under composition.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.13190v1"
    },
    {
        "title": "Classifying Pattern and Feature Properties to Get a $Θ(n)$ Checker\n  and Reformulation for Sliding Time-Series Constraints",
        "authors": [
            "Nicolas Beldiceanu",
            "Mats Carlsson",
            "Claude-Guy Quimper",
            "Maria-Isabel Restrepo-Ruiz"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Given, a sequence $\\mathcal{X}$ of $n$ variables, a time-series constraint\nctr using the Sum aggregator, and a sliding time-series constraint enforcing\nthe constraint ctr on each sliding window of $\\mathcal{X}$ of $m$ consecutive\nvariables, we describe a $\\Theta(n)$ time complexity checker, as well as a\n$\\Theta(n)$ space complexity reformulation for such sliding constraint.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.01532v1"
    },
    {
        "title": "Prema: A Tool for Precise Requirements Editing, Modeling and Analysis",
        "authors": [
            "Yihao Huang",
            "Jincao Feng",
            "Hanyue Zheng",
            "Jiayi Zhu",
            "Shang Wang",
            "Siyuan Jiang",
            "Weikai Miao",
            "Geguang Pu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present Prema, a tool for Precise Requirement Editing, Modeling and\nAnalysis. It can be used in various fields for describing precise requirements\nusing formal notations and performing rigorous analysis. By parsing the\nrequirements written in formal modeling language, Prema is able to get a model\nwhich aptly depicts the requirements. It also provides different rigorous\nverification and validation techniques to check whether the requirements meet\nusers' expectation and find potential errors. We show that our tool can provide\na unified environment for writing and verifying requirements without using\ntools that are not well inter-related. For experimental demonstration, we use\nthe requirements of the automatic train protection (ATP) system of CASCO signal\nco. LTD., the largest railway signal control system manufacturer of China. The\ncode of the tool cannot be released here because the project is commercially\nconfidential. However, a demonstration video of the tool is available at\nhttps://youtu.be/BX0yv8pRMWs.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.07817v1"
    },
    {
        "title": "Conjunctive Regular Path Queries with String Variables",
        "authors": [
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce the class CXRPQ of conjunctive xregex path queries, which are\nobtained from conjunctive regular path queries (CRPQs) by adding string\nvariables (also called backreferences) as found in practical implementations of\nregular expressions. CXRPQs can be considered user-friendly, since they combine\ntwo concepts that are well-established in practice: pattern-based graph queries\nand regular expressions with backreferences. Due to the string variables,\nCXRPQs can express inter-path dependencies, which are not expressible by CRPQs.\nThe evaluation complexity of CXRPQs, if not further restricted, is PSPACE-hard\nin data-complexity. We identify three natural fragments with more acceptable\nevaluation complexity: their data-complexity is in NL, while their combined\ncomplexity varies between EXPSPACE, PSPACE and NP. In terms of expressive\npower, we compare the CXRPQ-fragments with CRPQs and unions of CRPQs, and with\nextended conjunctive regular path queries (ECRPQs) and unions of ECRPQs.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.09326v1"
    },
    {
        "title": "Speeding up Generalized PSR Parsers by Memoization Techniques",
        "authors": [
            "Mark Minas"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Predictive shift-reduce (PSR) parsing for hyperedge replacement (HR) grammars\nis very efficient, but restricted to a subclass of unambiguous HR grammars. To\novercome this restriction, we have recently extended PSR parsing to generalized\nPSR (GPSR) parsing along the lines of Tomita-style generalized LR parsing.\nUnfortunately, GPSR parsers turned out to be too inefficient without manual\ntuning. This paper proposes to use memoization techniques to speed up GPSR\nparsers without any need of manual tuning, and which has been realized within\nthe graph parser distiller Grappa. We present running time measurements for\nsome example languages; they show a significant speed up by some orders of\nmagnitude when parsing valid graphs. But memoization techniques do not help\nwhen parsing invalid graphs or if all parses of an ambiguous input graph shall\nbe determined.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.09609v1"
    },
    {
        "title": "Lower bounds for the state complexity of probabilistic languages and the\n  language of prime numbers",
        "authors": [
            "Nathanaël Fijalkow"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper studies the complexity of languages of finite words using automata\ntheory. To go beyond the class of regular languages, we consider infinite\nautomata and the notion of state complexity defined by Karp. Motivated by the\nseminal paper of Rabin from 1963 introducing probabilistic automata, we study\nthe (deterministic) state complexity of probabilistic languages and prove that\nprobabilistic languages can have arbitrarily high deterministic state\ncomplexity. We then look at alternating automata as introduced by Chandra,\nKozen and Stockmeyer: such machines run independent computations on the word\nand gather their answers through boolean combinations. We devise a lower bound\ntechnique relying on boundedly generated lattices of languages, and give two\napplications of this technique. The first is a hierarchy theorem, stating that\nthere are languages of arbitrarily high polynomial alternating state\ncomplexity, and the second is a linear lower bound on the alternating state\ncomplexity of the prime numbers written in binary. This second result\nstrengthens a result of Hartmanis and Shank from 1968, which implies an\nexponentially worse lower bound for the same model.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.11396v1"
    },
    {
        "title": "Representing Unordered Data Using Complex-Weighted Multiset Automata",
        "authors": [
            "Justin DeBenedetto",
            "David Chiang"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Unordered, variable-sized inputs arise in many settings across multiple\nfields. The ability for set- and multiset-oriented neural networks to handle\nthis type of input has been the focus of much work in recent years. We propose\nto represent multisets using complex-weighted multiset automata and show how\nthe multiset representations of certain existing neural architectures can be\nviewed as special cases of ours. Namely, (1) we provide a new theoretical and\nintuitive justification for the Transformer model's representation of positions\nusing sinusoidal functions, and (2) we extend the DeepSets model to use complex\nnumbers, enabling it to outperform the existing model on an extension of one of\ntheir tasks.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.00610v3"
    },
    {
        "title": "Hardware/Software Co-verification Using Path-based Symbolic Execution",
        "authors": [
            "Rajdeep Mukherjee",
            "Saurabh Joshi",
            "John O'Leary",
            "Daniel Kroening",
            "Tom Melham"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Conventional tools for formal hardware/software co-verification use bounded\nmodel checking techniques to construct a single monolithic propositional\nformula. Formulas generated in this way are extremely complex and contain a\ngreat deal of irrelevant logic, hence are difficult to solve even by the\nstate-of-the-art Satis ability (SAT) solvers. In a typical hardware/software\nco-design the firmware only exercises a fraction of the hardware state-space,\nand we can use this observation to generate simpler and more concise formulas.\nIn this paper, we present a novel verification algorithm for hardware/software\nco-designs that identify partitions of the firmware and the hardware logic\npertaining to the feasible execution paths by means of path-based symbolic\nsimulation with custom path-pruning, property-guided slicing and incremental\nSAT solving. We have implemented this approach in our tool COVERIF. We have\nexperimentally compared COVERIF with HW-CBMC, a monolithic BMC based\nco-verification tool, and observed an average speed-up of 5X over HW-CBMC for\nproving safety properties as well as detecting critical co-design bugs in an\nopen-source Universal Asynchronous Receiver Transmitter design and a large SoC\ndesign.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.01324v1"
    },
    {
        "title": "VC-dimensions of nondeterministic finite automata for words of equal\n  length",
        "authors": [
            "Bjørn Kjos-Hanssen",
            "Clyde James Felix",
            "Sun Young Kim",
            "Ethan Lamb",
            "Davin Takahashi"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Let $NFA_b(q)$ denote the set of languages accepted by nondeterministic\nfinite automata with $q$ states over an alphabet with $b$ letters. Let $B_n$\ndenote the set of words of length $n$. We give a quadratic lower bound on the\nVC dimension of \\[\n  NFA_2(q)\\cap B_n = \\{L\\cap B_n \\mid L \\in NFA_2(q)\\} \\] as a function of $q$.\n  Next, the work of Gruber and Holzer (2007) gives an upper bound for the\nnondeterministic state complexity of finite languages contained in $B_n$, which\nwe strengthen using our methods.\n  Finally, we give some theoretical and experimental results on the dependence\non $n$ of the VC dimension and testing dimension of $NFA_2(q)\\cap B_n$.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.02309v2"
    },
    {
        "title": "Good-for-games $ω$-Pushdown Automata",
        "authors": [
            "Karoliina Lehtinen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We introduce good-for-games $\\omega$-pushdown automata ($\\omega$-GFG-PDA).\nThese are automata whose nondeterminism can be resolved based on the input\nprocessed so far. Good-for-gameness enables automata to be composed with games,\ntrees, and other automata, applications which otherwise require deterministic\nautomata. Our main results are that $\\omega$-GFG-PDA are more expressive than\ndeterministic $\\omega$- pushdown automata and that solving infinite games with\nwinning conditions specified by $\\omega$-GFG-PDA is EXPTIME-complete. Thus, we\nhave identified a new class of $\\omega$-contextfree winning conditions for\nwhich solving games is decidable. It follows that the universality problem for\n$\\omega$-GFG-PDA is in EXPTIME as well. Moreover, we study closure properties\nof the class of languages recognized by $\\omega$-GFG- PDA and decidability of\ngood-for-gameness of $\\omega$-pushdown automata and languages. Finally, we\ncompare $\\omega$-GFG-PDA to $\\omega$-visibly PDA, study the resources necessary\nto resolve the nondeterminism in $\\omega$-GFG-PDA, and prove that the parity\nindex hierarchy for $\\omega$-GFG-PDA is infinite.\n  This is a corrected version of the paper arXiv:2001.04392v6 published\noriginally on January 7, 2022.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.04392v7"
    },
    {
        "title": "Learning Concise Models from Long Execution Traces",
        "authors": [
            "Natasha Yogananda Jeppu",
            "Tom Melham",
            "Daniel Kroening",
            "John O'Leary"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Abstract models of system-level behaviour have applications in design\nexploration, analysis, testing and verification. We describe a new algorithm\nfor automatically extracting useful models, as automata, from execution traces\nof a HW/SW system driven by software exercising a use-case of interest. Our\nalgorithm leverages modern program synthesis techniques to generate predicates\non automaton edges, succinctly describing system behaviour. It employs trace\nsegmentation to tackle complexity for long traces. We learn concise models\ncapturing transaction-level, system-wide behaviour--experimentally\ndemonstrating the approach using traces from a variety of sources, including\nthe x86 QEMU virtual platform and the Real-Time Linux kernel.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.05230v3"
    },
    {
        "title": "Compressing Permutation Groups into Grammars and Polytopes. A Graph\n  Embedding Approach",
        "authors": [
            "Lars Jaffke",
            "Mateus de Oliveira Oliveira",
            "Hans Raj Tiwary"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  It can be shown that each permutation group $G \\sqsubseteq S_n$ can be\nembedded, in a well defined sense, in a connected graph with $O(n+|G|)$\nvertices. Some groups, however, require much fewer vertices. For instance,\n$S_n$ itself can be embedded in the $n$-clique $K_n$, a connected graph with n\nvertices. In this work, we show that the minimum size of a context-free grammar\ngenerating a finite permutation group $G \\sqsubseteq S_n$ can be upper bounded\nby three structural parameters of connected graphs embedding $G$: the number of\nvertices, the treewidth, and the maximum degree. More precisely, we show that\nany permutation group $G \\sqsubseteq S_n$ that can be embedded into a connected\ngraph with $m$ vertices, treewidth k, and maximum degree $\\Delta$, can also be\ngenerated by a context-free grammar of size $2^{O(k\\Delta\\log\\Delta)}\\cdot\nm^{O(k)}$. By combining our upper bound with a connection between the extension\ncomplexity of a permutation group and the grammar complexity of a formal\nlanguage, we also get that these permutation groups can be represented by\npolytopes of extension complexity $2^{O(k \\Delta\\log \\Delta)}\\cdot m^{O(k)}$.\nThe above upper bounds can be used to provide trade-offs between the index of\npermutation groups, and the number of vertices, treewidth and maximum degree of\nconnected graphs embedding these groups. In particular, by combining our main\nresult with a celebrated $2^{\\Omega(n)}$ lower bound on the grammar complexity\nof the symmetric group $S_n$ we have that connected graphs of treewidth\n$o(n/\\log n)$ and maximum degree $o(n/\\log n)$ embedding subgroups of $S_n$ of\nindex $2^{cn}$ for some small constant $c$ must have $n^{\\omega(1)}$ vertices.\nThis lower bound can be improved to exponential on graphs of treewidth\n$n^{\\varepsilon}$ for $\\varepsilon<1$ and maximum degree $o(n/\\log n)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.05583v1"
    },
    {
        "title": "A direct proof of Agafonov's theorem and an extension to shift of finite\n  type",
        "authors": [
            "Olivier Carton"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We provide a direct proof of Agafonov's theorem which states that finite\nstate selection preserves normality. We also extends this result to the more\ngeneral setting of shifts of finite type by defining selections which are\ncompatible the shift. A slightly more general statement is obtained as we show\nthat any Markov measure is preserved by finite state compatible selection.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.00255v3"
    },
    {
        "title": "Reinforcement learning of minimalist grammars",
        "authors": [
            "Peter beim Graben",
            "Ronald Römer",
            "Werner Meyer",
            "Markus Huber",
            "Matthias Wolff"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Speech-controlled user interfaces facilitate the operation of devices and\nhousehold functions to laymen. State-of-the-art language technology scans the\nacoustically analyzed speech signal for relevant keywords that are subsequently\ninserted into semantic slots to interpret the user's intent. In order to\ndevelop proper cognitive information and communication technologies, simple\nslot-filling should be replaced by utterance meaning transducers (UMT) that are\nbased on semantic parsers and a mental lexicon, comprising syntactic, phonetic\nand semantic features of the language under consideration. This lexicon must be\nacquired by a cognitive agent during interaction with its users. We outline a\nreinforcement learning algorithm for the acquisition of syntax and semantics of\nEnglish utterances, based on minimalist grammar (MG), a recent computational\nimplementation of generative linguistics. English declarative sentences are\npresented to the agent by a teacher in form of utterance meaning pairs (UMP)\nwhere the meanings are encoded as formulas of predicate logic. Since MG\ncodifies universal linguistic competence through inference rules, thereby\nseparating innate linguistic knowledge from the contingently acquired lexicon,\nour approach unifies generative grammar and reinforcement learning, hence\npotentially resolving the still pending Chomsky-Skinner controversy.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.00359v1"
    },
    {
        "title": "Synchronization of Deterministic Visibly Push-Down Automata",
        "authors": [
            "Henning Fernau",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We generalize the concept of synchronizing words for finite automata, which\nmap all states of the automata to the same state, to deterministic visibly\npush-down automata. Here, a synchronizing word w does not only map all states\nto the same state but also fulfills some conditions on the stack content of\neach run after reading w. We consider three types of these stack constraints:\nafter reading w, the stack (1) is empty in each run, (2) contains the same\nsequence of stack symbols in each run, or (3) contains an arbitrary sequence\nwhich is independent of the other runs. We show that in contrast to general\ndeterministic push-down automata, it is decidable for deterministic visibly\npush-down automata whether there exists a synchronizing word with each of these\nstack constraints, i.e., the problems are in EXPTIME. Under the constraint (1)\nthe problem is even in P. For the sub-classes of deterministic very visibly\npush-down automata the problem is in P for all three types of constraints. We\nfurther study variants of the synchronization problem where the number of turns\nin the stack height behavior caused by a synchronizing word is restricted, as\nwell as the problem of synchronizing a variant of a sequential transducer,\nwhich shows some visibly behavior, by a word that synchronizes the states and\nproduces the same output on all runs.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.01374v3"
    },
    {
        "title": "Synchronizing Deterministic Push-Down Automata Can Be Really Hard",
        "authors": [
            "Henning Fernau",
            "Petra Wolf",
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The question if a deterministic finite automaton admits a software reset in\nthe form of a so-called synchronizing word can be answered in polynomial time.\nIn this paper, we extend this algorithmic question to deterministic automata\nbeyond finite automata. We prove that the question of synchronizability becomes\nundecidable even when looking at deterministic one-counter automata. This is\nalso true for another classical mild extension of regularity, namely that of\ndeterministic one-turn push-down automata. However, when we combine both\nrestrictions, we arrive at scenarios with a PSPACE-complete (and hence\ndecidable) synchronizability problem. Likewise, we arrive at a decidable\nsynchronizability problem for (partially) blind deterministic counter automata.\n  There are several interpretations of what synchronizability should mean for\ndeterministic push-down automata. This is depending on the role of the stack:\nshould it be empty on synchronization, should it be always the same or is it\narbitrary? For the automata classes studied in this paper, the complexity or\ndecidability status of the synchronizability problem is mostly independent of\nthis technicality, but we also discuss one class of automata where this makes a\ndifference.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.01381v3"
    },
    {
        "title": "Computational Complexity of Synchronization under Regular Commutative\n  Constraints",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Here we study the computational complexity of the constrained synchronization\nproblem for the class of regular commutative constraint languages. Utilizing a\nvector representation of regular commutative constraint languages, we give a\nfull classification of the computational complexity of the constraint\nsynchronization problem. Depending on the constraint language, our problem\nbecomes PSPACE-complete, NP-complete or polynomial time solvable. In addition,\nwe derive a polynomial time decision procedure for the complexity of the\nconstraint synchronization problem, given some constraint automaton accepting a\ncommutative language as input.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.04042v2"
    },
    {
        "title": "Ideal Separation and General Theorems for Constrained Synchronization\n  and their Application to Small Constraint Automata",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In the constrained synchronization problem we ask if a given automaton admits\na synchronizing word coming from a fixed regular constraint language. We show\nthat intersecting a given constraint language with an ideal language decreases\nthe computational complexity. Additionally, we state a theorem giving\nPSPACE-hardness that broadly generalizes previously used constructions and a\nresult on how to combine languages by concatenation to get polynomial time\nsolvable constrained synchronization problems. We use these results to give a\nclassification of the complexity landscape for small constraint automata of up\nto three states.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.05907v2"
    },
    {
        "title": "Bisimulation Finiteness of Pushdown Systems Is Elementary",
        "authors": [
            "Stefan Göller",
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We show that in case a pushdown system is bisimulation equivalent to a finite\nsystem, there is already a bisimulation equivalent finite system whose size is\nelementarily bounded in the description size of the pushdown system. As a\nconsequence we obtain that it is elementarily decidable if a given pushdown\nsystem is bisimulation equivalent to some finite system. This improves a\npreviously best-known ACKERMANN upper bound for this problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.06285v1"
    },
    {
        "title": "Qualitative Controller Synthesis for Consumption Markov Decision\n  Processes",
        "authors": [
            "František Blahoudek",
            "Tomáš Brázdil",
            "Petr Novotný",
            "Melkior Ornik",
            "Pranay Thangeda",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Consumption Markov Decision Processes (CMDPs) are probabilistic\ndecision-making models of resource-constrained systems. In a CMDP, the\ncontroller possesses a certain amount of a critical resource, such as electric\npower. Each action of the controller can consume some amount of the resource.\nResource replenishment is only possible in special reload states, in which the\nresource level can be reloaded up to the full capacity of the system. The task\nof the controller is to prevent resource exhaustion, i.e. ensure that the\navailable amount of the resource stays non-negative, while ensuring an\nadditional linear-time property. We study the complexity of strategy synthesis\nin consumption MDPs with almost-sure B\\\"uchi objectives. We show that the\nproblem can be solved in polynomial time. We implement our algorithm and show\nthat it can efficiently solve CMDPs modelling real-world scenarios.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.07227v1"
    },
    {
        "title": "On the Power of Unambiguity in Büchi Complementation",
        "authors": [
            "Yong Li",
            "Moshe Y. Vardi",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work, we exploit the power of \\emph{unambiguity} for the\ncomplementation problem of B\\\"uchi automata by utilizing reduced run directed\nacyclic graphs (DAGs) over infinite words, in which each vertex has at most one\npredecessor. We then show how to use this type of reduced run DAGs as a\n\\emph{unified tool} to optimize \\emph{both} rank-based and slice-based\ncomplementation constructions for B\\\"uchi automata with a finite degree of\nambiguity. As a result, given a B\\\"uchi automaton with $n$ states and a finite\ndegree of ambiguity, the number of states in the complementary B\\\"uchi\nautomaton constructed by the classical rank-based and slice-based\ncomplementation constructions can be improved, respectively, to $2^{O(n)}$ from\n$2^{O(n\\log n)}$ and to $O(4^n)$ from $O((3n)^n)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.09125v2"
    },
    {
        "title": "Weighted Prefix Normal Words: Mind the Gap",
        "authors": [
            "Yannik Eikmeier",
            "Pamela Fleischmann",
            "Mitja Kulczynski",
            "Dirk Nowotka"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A prefix normal word is a binary word whose prefixes contain at least as many\n1s as any of its factors of the same length. Introduced by Fici and Lipt\\'ak in\n2011 the notion of prefix normality is so far only defined for words over the\nbinary alphabet. In this work we investigate a generalisation for finite words\nover arbitrary finite alphabets, namely weighted prefix normality. We prove\nthat weighted prefix normality is more expressive than binary prefix normality.\nFurthermore, we investigate the existence of a weighted prefix normal form\nsince weighted prefix normality comes with several new peculiarities that did\nnot already occur in the binary case. We characterise these issues and finally\npresent a standard technique to obtain a generalised prefix normal form for all\nwords overarbitrary, finite alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.09281v3"
    },
    {
        "title": "On the Separability Problem of String Constraints",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "Vrunda Dave",
            "Shankara Narayanan Krishna"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We address the separability problem for straight-line string constraints. The\nseparability problem for languages of a class C by a class S asks: given two\nlanguages A and B in C, does there exist a language I in S separating A and B\n(i.e., I is a superset of A and disjoint from B)? The separability of string\nconstraints is the same as the fundamental problem of interpolation for string\nconstraints. We first show that regular separability of straight line string\nconstraints is undecidable. Our second result is the decidability of the\nseparability problem for straight-line string constraints by piece-wise\ntestable languages, though the precise complexity is open. In our third result,\nwe consider the positive fragment of piece-wise testable languages as a\nseparator, and obtain an EXPSPACE algorithm for the separability of a useful\nclass of straight-line string constraints, and a PSPACE-hardness result.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.09489v2"
    },
    {
        "title": "Infinitude of Primes Using Formal Language Theory",
        "authors": [
            "Aalok Thakkar"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Formal languages are sets of strings of symbols described by a set of rules\nspecific to them. In this note, we discuss a certain class of formal languages,\ncalled regular languages, and put forward some elementary results. The\nproperties of these languages are then employed to prove that there are\ninfinitely many prime numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.10372v1"
    },
    {
        "title": "Minimisation in Logical Form",
        "authors": [
            "Nick Bezhanishvili",
            "Marcello Bonsangue",
            "Helle Hvid Hansen",
            "Dexter Kozen",
            "Clemens Kupke",
            "Prakash Panangaden",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Stone-type dualities provide a powerful mathematical framework for studying\nproperties of logical systems. They have recently been fruitfully explored in\nunderstanding minimisation of various types of automata. In Bezhanishvili et\nal. (2012), a dual equivalence between a category of coalgebras and a category\nof algebras was used to explain minimisation. The algebraic semantics is dual\nto a coalgebraic semantics in which logical equivalence coincides with trace\nequivalence. It follows that maximal quotients of coalgebras correspond to\nminimal subobjects of algebras. Examples include partially observable\ndeterministic finite automata, linear weighted automata viewed as coalgebras\nover finite-dimensional vector spaces, and belief automata, which are\ncoalgebras on compact Hausdorff spaces. In Bonchi et al. (2014), Brzozowski's\ndouble-reversal minimisation algorithm for deterministic finite automata was\ndescribed categorically and its correctness explained via the duality between\nreachability and observability. This work includes generalisations of\nBrzozowski's algorithm to Moore and weighted automata over commutative\nsemirings.\n  In this paper we propose a general categorical framework within which such\nminimisation algorithms can be understood. The goal is to provide a unifying\nperspective based on duality. Our framework consists of a stack of three\ninterconnected adjunctions: a base dual adjunction that can be lifted to a dual\nadjunction between coalgebras and algebras and also to a dual adjunction\nbetween automata. The approach provides an abstract understanding of\nreachability and observability. We illustrate the general framework on range of\nconcrete examples, including deterministic Kripke frames, weighted automata,\ntopological automata (belief automata), and alternating automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.11551v1"
    },
    {
        "title": "Power of Randomization in Automata on Infinite Strings",
        "authors": [
            "Rohit Chadha",
            "A. Prasad Sistla",
            "Mahesh Viswanathan"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Probabilistic B\\\"uchi Automata (PBA) are randomized, finite state automata\nthat process input strings of infinite length. Based on the threshold chosen\nfor the acceptance probability, different classes of languages can be defined.\nIn this paper, we present a number of results that clarify the power of such\nmachines and properties of the languages they define. The broad themes we focus\non are as follows. We present results on the decidability and precise\ncomplexity of the emptiness, universality and language containment problems for\nsuch machines, thus answering questions central to the use of these models in\nformal verification. Next, we characterize the languages recognized by PBAs\ntopologically, demonstrating that though general PBAs can recognize languages\nthat are not regular, topologically the languages are as simple as\n\\omega-regular languages. Finally, we introduce Hierarchical PBAs, which are\nsyntactically restricted forms of PBAs that are tractable and capture exactly\nthe class of \\omega-regular languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1109.2536v2"
    },
    {
        "title": "Asymptotic enumeration of Minimal Automata",
        "authors": [
            "Frederique Bassino",
            "Julien David",
            "Andrea Sportiello"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We determine the asymptotic proportion of minimal automata, within n-state\naccessible deterministic complete automata over a k-letter alphabet, with the\nuniform distribution over the possible transition structures, and a binomial\ndistribution over terminal states, with arbitrary parameter b. It turns out\nthat a fraction ~ 1-C(k,b) n^{-k+2} of automata is minimal, with C(k,b) a\nfunction, explicitly determined, involving the solution of a transcendental\nequation.\n",
        "pdf_link": "http://arxiv.org/pdf/1109.5683v1"
    },
    {
        "title": "Completely reducible sets",
        "authors": [
            "Dominique Perrin"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We study the family of rational sets of words, called completely reducible\nand which are such that the syntactic representation of their characteristic\nseries is completely reducible. This family contains, by a result of\nReutenauer, the submonoids generated by bifix codes and, by a result of Berstel\nand Reutenauer, the cyclic sets. We study the closure properties of this\nfamily. We prove a result on linear representations of monoids which gives a\ngeneralization of the result concerning the complete reducibility of the\nsubmonoid generated by a bifix code to sets called birecurrent. We also give a\nnew proof of the result concerning cyclic sets.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.2035v4"
    },
    {
        "title": "Conformance Verification of Normative Specifications using C-O Diagrams",
        "authors": [
            "Gregorio Díaz",
            "Luis Llana",
            "Valentín Valero",
            "Jose Antonio Mateo"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  C-O Diagrams have been introduced as a means to have a visual representation\nof normative texts and electronic contracts, where it is possible to represent\nthe obligations, permissions and prohibitions of the different signatories, as\nwell as what are the penalties in case of not fulfillment of their obligations\nand prohibitions. In such diagrams we are also able to represent absolute and\nrelative timing constrains.\n  In this paper we consider a formal semantics for C-O Diagrams based on a\nnetwork of timed automata and we present several relations to check the\nconsistency of a contract in terms of realizability, to analyze whether an\nimplementation satisfies the requirements defined on its contract, and to\ncompare several implementations using the executed permissions as criteria.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.2237v1"
    },
    {
        "title": "Binary equality sets are generated by two words",
        "authors": [
            "Štěpán Holub"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We show that the equality language of two non-periodic binary morphisms is\ngenerated by at most two words. If its rank is two, then the generators start\n(and end) with different letters.\n  This in particular implies that any binary language has a test set of\ncardinality at most two.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.4061v1"
    },
    {
        "title": "Runtime Verification Based on Register Automata",
        "authors": [
            "Radu Grigore",
            "Dino Distefano",
            "Rasmus Lerchedahl Petersen",
            "Nikos Tzevelekos"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We propose TOPL automata as a new method for runtime verification of systems\nwith unbounded resource generation. Paradigmatic such systems are\nobject-oriented programs which can dynamically generate an unbounded number of\nfresh object identities during their execution. Our formalism is based on\nregister automata, a particularly successful approach in automata over infinite\nalphabets which administers a finite-state machine with boundedly many\ninput-storing registers. We show that TOPL automata are equally expressive to\nregister automata and yet suitable to express properties of programs. Compared\nto other runtime verification methods, our technique can handle a class of\nproperties beyond the reach of current tools. We show in particular that\nproperties which require value updates are not expressible with current\ntechniques yet are naturally captured by TOPL machines. On the practical side,\nwe present a tool for runtime verification of Java programs via TOPL\nproperties, where the trade-off between the coverage and the overhead of the\nmonitoring system is tunable by means of a number of parameters. We validate\nour technique by checking properties involving multiple objects and chaining of\nvalues on large open source projects.\n",
        "pdf_link": "http://arxiv.org/pdf/1209.5325v3"
    },
    {
        "title": "Profinite Monads, Profinite Equations, and Reiterman's Theorem",
        "authors": [
            "Liang-Ting Chen",
            "Jiri Adamek",
            "Stefan Milius",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Profinite equations are an indispensable tool for the algebraic\nclassification of formal languages. Reiterman's theorem states that they\nprecisely specify pseudovarieties, i.e. classes of finite algebras closed under\nfinite products, subalgebras and quotients. In this paper Reiterman's theorem\nis generalised to finite Eilenberg-Moore algebras for a monad T on a variety D\nof (ordered) algebras: a class of finite T-algebras is a pseudovariety iff it\nis presentable by profinite (in-)equations. As an application, quasivarieties\nof finite algebras are shown to be presentable by profinite implications. Other\nexamples include finite ordered algebras, finite categories, finite\ninfinity-monoids, etc.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.02147v2"
    },
    {
        "title": "Timed Automata for Modelling Caches and Pipelines",
        "authors": [
            "Franck Cassez",
            "Pablo González de Aledo Marugán"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper, we focus on modelling the timing aspects of binary programs\nrunning on architectures featuring caches and pipelines. The objective is to\nobtain a timed automaton model to compute tight bounds for the worst-case\nexecution time (WCET) of the programs using model-checking techniques.\n",
        "pdf_link": "http://arxiv.org/pdf/1511.04172v1"
    },
    {
        "title": "Synthesizing Skeletons for Reactive Systems",
        "authors": [
            "Bernd Finkbeiner",
            "Hazem Torfah"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We present an analysis technique for temporal specifications of reactive\nsystems that identifies, on the level of individual system outputs over time,\nwhich parts of the implementation are determined by the specification, and\nwhich parts are still open. This information is represented in the form of a\nlabeled transition system, which we call skeleton. Each state of the skeleton\nis labeled with a three-valued assignment to the output variables: each output\ncan be true, false, or open, where true or false means that the value must be\ntrue or false, respectively, and open means that either value is still\npossible. We present algorithms for the verification of skeletons and for the\nlearning-based synthesis of skeletons from specifications in linear-time\ntemporal logic (LTL). The algorithm returns a skeleton that satisfies the given\nLTL specification in time polynomial in the size of the minimal skeleton. Our\nnew analysis technique can be used to recognize and repair specifications that\nunderspecify critical situations. The technique thus complements existing\nmethods for the recognition and repair of overspecifications via the\nidentification of unrealizable cores.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.09285v1"
    },
    {
        "title": "A new hierarchy for automaton semigroups",
        "authors": [
            "Laurent Bartholdi",
            "Thibault Godin",
            "Ines Klimann",
            "Matthieu Picantin"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We define a new strict and computable hierarchy for the family of automaton\nsemigroups, which reflects the various asymptotic behaviors of the\nstate-activity growth. This hierarchy extends that given by Sidki for automaton\ngroups, and also gives new insights into the latter. Its exponential part\ncoincides with a notion of entropy for some associated automata.\n  We prove that the Order Problem is decidable when the state-activity is\nbounded. The Order Problem remains open for the next level of this hierarchy,\nthat is, when the state-activity is linear. Gillibert showed that it is\nundecidable in the whole family.\n  The former results are implemented and will be available in the GAP package\nFR developed by the first author.\n",
        "pdf_link": "http://arxiv.org/pdf/1803.09991v2"
    },
    {
        "title": "Formal Specification and Verification of Autonomous Robotic Systems: A\n  Survey",
        "authors": [
            "Matt Luckcuck",
            "Marie Farrell",
            "Louise Dennis",
            "Clare Dixon",
            "Michael Fisher"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Autonomous robotic systems are complex, hybrid, and often safety-critical;\nthis makes their formal specification and verification uniquely challenging.\nThough commonly used, testing and simulation alone are insufficient to ensure\nthe correctness of, or provide sufficient evidence for the certification of,\nautonomous robotics. Formal methods for autonomous robotics has received some\nattention in the literature, but no resource provides a current overview. This\npaper systematically surveys the state-of-the-art in formal specification and\nverification for autonomous robotics. Specially, it identifies and categorises\nthe challenges posed by, the formalisms aimed at, and the formal approaches for\nthe specification and verification of autonomous robotics.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.00048v3"
    },
    {
        "title": "A Formal Approach to Open Multiparty Interactions",
        "authors": [
            "Chiara Bodei",
            "Linda Brodo",
            "Roberto Bruni"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We present a process algebra aimed at describing interactions that are\nmultiparty, i.e. that may involve more than two processes and that are open,\ni.e. the number of the processes they involve is not fixed or known a priori.\nHere we focus on the theory of a core version of a process calculus, without\nmessage passing, called Core Network Algebra (CNA). In CNA communication\nactions are given not in terms of channels but in terms of chains of links that\nrecord the source and the target ends of each hop of interactions. The\noperational semantics of our calculus mildly extends the one of CCS. The\nabstract semantics is given in the style of bisimulation but requires some\ningenuity. Remarkably, the abstract semantics is a congruence for all operators\nof CNA and also with respect to substitutions, which is not the case for strong\nbisimilarity in CCS. As a motivating and running example, we illustrate the\nmodel of a simple software defined network infrastructure.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.03002v2"
    },
    {
        "title": "Streamable Regular Transductions",
        "authors": [
            "Rajeev Alur",
            "Dana Fisman",
            "Konstantinos Mamouras",
            "Mukund Raghothaman",
            "Caleb Stanford"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Motivated by real-time monitoring and data processing applications, we\ndevelop a formal theory of quantitative queries for streaming data that can be\nevaluated efficiently. We consider the model of unambiguous Cost Register\nAutomata (CRAs), which are machines that combine finite-state control (for\nidentifying regular patterns) with a finite set of data registers (for\ncomputing numerical aggregates). The definition of CRAs is parameterized by the\ncollection of numerical operations that can be applied to the registers. These\nmachines give rise to the class of streamable regular transductions (SR), and\nto the class of streamable linear regular transductions (SLR) when the register\nupdates are copyless, i.e. every register appears at most once the\nright-hand-side expressions of the updates. We give a logical characterization\nof the class SR (resp., SLR) using MSO-definable transformations from strings\nto DAGs (resp., trees) without backward edges. Additionally, we establish that\nthe two classes SR and SLR are closed under operations that are relevant for\ndesigning query languages. Finally, we study the relationship with weighted\nautomata (WA), and show that CRAs over a suitably chosen set of operations\ncorrespond to WA, thus establishing that WA are a special case of CRAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.03865v2"
    },
    {
        "title": "Detection and Mitigation of Classes of Attacks in Supervisory Control\n  Systems",
        "authors": [
            "Lilian Kawakami Carvalho",
            "Yi-Chin Wu",
            "Raymond Kwong",
            "Stéphane Lafortune"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The deployment of control systems with network-connected components has made\nfeedback control systems vulnerable to attacks over the network. This paper\nconsiders the problem of intrusion detection and mitigation in supervisory\ncontrol systems, where the attacker has the ability to enable or disable\nvulnerable actuator commands and erase or insert vulnerable sensor readings. We\npresent a mathematical model for the system under certain classes of actuator\nenablement attacks, sensor erasure attacks, or sensor insertion attacks. We\nthen propose a defense strategy that aims to detect such attacks online and\ndisables all controllable events after an attack is detected. We develop an\nalgorithmic procedure for verifying whether the system can prevent damage from\nthe attacks considered with the proposed defense strategy, where damage is\nmodeled as the reachability of a pre-defined set of unsafe system states.The\ntechnical condition of interest that is necessary and sufficient in this\ncontext, termed \"GF-safe controllability\", is characterized. We show that the\nverification of GF-safe controllability can be performed using diagnoser or\nverifier automata. Finally, we illustrate the methodology with a traffic\ncontrol system example.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.04889v1"
    },
    {
        "title": "From LTL to rLTL Monitoring: Improved Monitorability through Robust\n  Semantics",
        "authors": [
            "Corto Mascle",
            "Daniel Neider",
            "Maximilian Schwenger",
            "Paulo Tabuada",
            "Alexander Weinert",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Runtime monitoring is commonly used to detect the violation of desired\nproperties in safety critical cyber-physical systems by observing its\nexecutions. Bauer et al. introduced an influential framework for monitoring\nLinear Temporal Logic (LTL) properties based on a three-valued semantics: the\nformula is already satisfied by the given prefix, it is already violated, or it\nis still undetermined, i.e., it can still be satisfied and violated by\nappropriate extensions. However, a wide range of formulas are not monitorable\nunder this approach, meaning that they have a prefix for which satisfaction and\nviolation will always remain undetermined no matter how it is extended. In\nparticular, Bauer et al. report that 44% of the formulas they consider in their\nexperiments fall into this category.\n  Recently, a robust semantics for LTL was introduced to capture different\ndegrees by which a property can be violated. In this paper we introduce a\nrobust semantics for finite strings and show its potential in monitoring: every\nformula considered by Bauer et al. is monitorable under our approach.\nFurthermore, we discuss which properties that come naturally in LTL monitoring\n- such as the realizability of all truth values - can be transferred to the\nrobust setting. Lastly, we show that LTL formulas with robust semantics can be\nmonitored by deterministic automata and report on a prototype implementation.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.08203v5"
    },
    {
        "title": "Bounded Synthesis of Reactive Programs",
        "authors": [
            "Carsten Gerstacker",
            "Felix Klein",
            "Bernd Finkbeiner"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Most algorithms for the synthesis of reactive systems focus on the\nconstruction of finite-state machines rather than actual programs. This often\nleads to badly structured, unreadable code. In this paper, we present a bounded\nsynthesis approach that automatically constructs, from a given specification in\nlinear-time temporal logic (LTL), a program in Madhusudan's simple imperative\nlanguage for reactive programs. We develop and compare two principal approaches\nfor the reduction of the synthesis problem to a Boolean constraint satisfaction\nproblem. The first reduction is based on a generalization of bounded synthesis\nto two-way alternating automata, the second reduction is based on a direct\nencoding of the program syntax in the constraint system. We report on\npreliminary experience with a prototype implementation, which indicates that\nthe direct encoding outperforms the automata approach.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.09047v1"
    },
    {
        "title": "Bisimilarity Distances for Approximate Differential Privacy",
        "authors": [
            "Dmitry Chistikov",
            "Andrzej S. Murawski",
            "David Purser"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Differential privacy is a widely studied notion of privacy for various models\nof computation. Technically, it is based on measuring differences between\nprobability distributions. We study $\\epsilon,\\delta$-differential privacy in\nthe setting of labelled Markov chains. While the exact differences relevant to\n$\\epsilon,\\delta$-differential privacy are not computable in this framework, we\npropose a computable bisimilarity distance that yields a sound technique for\nmeasuring $\\delta$, the parameter that quantifies deviation from pure\ndifferential privacy. We show this bisimilarity distance is always rational,\nthe associated threshold problem is in NP, and the distance can be computed\nexactly with polynomially many calls to an NP oracle.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.10015v2"
    },
    {
        "title": "Attack-Resilient Supervisory Control of Discrete-Event Systems: A\n  Finite-State Transducer Approach",
        "authors": [
            "Yu Wang",
            "Alper Kamil Bozkurt",
            "Nathan Smith",
            "Miroslav Pajic"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Resilience to sensor and actuator attacks is a major concern in the\nsupervisory control of discrete events in cyber-physical systems (CPS). In this\nwork, we propose a new framework to design supervisors for CPS under attacks\nusing finite-state transducers (FSTs) to model the effects of the discrete\nevents. FSTs can capture a general class of regular-rewriting attacks in which\nan attacker can nondeterministically rewrite sensing/actuation events according\nto a given regular relation. These include common insertion, deletion,\nevent-wise replacement, and finite-memory replay attacks. We propose new\ntheorems and algorithms with polynomial complexity to design resilient\nsupervisors against these attacks. We also develop an open-source tool in\nPython based on the results and illustrate its applicability through a case\nstudy\n",
        "pdf_link": "http://arxiv.org/pdf/1904.03264v3"
    },
    {
        "title": "On Functions Weakly Computable by Pushdown Petri Nets and Related\n  Systems",
        "authors": [
            "J. Leroux",
            "M. Praveen",
            "Ph. Schnoebelen",
            "G. Sutre"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider numerical functions weakly computable by grammar-controlled\nvector addition systems (GVASes, a variant of pushdown Petri nets). GVASes can\nweakly compute all fast growing functions $F_\\alpha$ for\n$\\alpha<\\omega^\\omega$, hence they are computationally more powerful than\nstandard vector addition systems. On the other hand they cannot weakly compute\nthe inverses $F_\\alpha^{-1}$ or indeed any sublinear function. The proof relies\non a pumping lemma for runs of GVASes that is of independent interest.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.04090v3"
    },
    {
        "title": "The many roads to the simulation of reaction systems",
        "authors": [
            "Claudio Ferretti",
            "Alberto Leporati",
            "Luca Manzoni",
            "Antonio E. Porreca"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Reaction systems are a computational model inspired by the bio-chemical\nreactions that happen inside biological cells. They have been and currently are\nstudied for their many nice theoretical properties. They are also a useful\nmodeling tool for biochemical systems, but in order to be able to employ them\neffectively in the field the presence of efficient and widely available\nsimulators is essential. Here we explore three different algorithms and\nimplementations of the simulation, comparing them to the current state of the\nart. We also show that we can obtain performances comparable to GPU-based\nsimulations on real-world systems by using a carefully tuned CPU-based\nsimulator.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.07445v1"
    },
    {
        "title": "Fast algorithms for handling diagonal constraints in timed automata",
        "authors": [
            "Paul Gastin",
            "Sayan Mukherjee",
            "B Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A popular method for solving reachability in timed automata proceeds by\nenumerating reachable sets of valuations represented as zones. A na\\\"ive\nenumeration of zones does not terminate. Various termination mechanisms have\nbeen studied over the years. Coming up with efficient termination mechanisms\nhas been remarkably more challenging when the automaton has diagonal\nconstraints in guards.\n  In this paper, we propose a new termination mechanism for timed automata with\ndiagonal constraints based on a new simulation relation between zones.\nExperiments with an implementation of this simulation show significant gains\nover existing methods.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.08590v1"
    },
    {
        "title": "k-Spectra of weakly-c-Balanced Words",
        "authors": [
            "Joel D. Day",
            "Pamela Fleischmann",
            "Florin Manea",
            "Dirk Nowotka"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A word $u$ is a scattered factor of $w$ if $u$ can be obtained from $w$ by\ndeleting some of its letters. That is, there exist the (potentially empty)\nwords $u_1,u_2,..., u_n$, and $v_0,v_1,..,v_n$ such that $u = u_1u_2...u_n$ and\n$w = v_0u_1v_1u_2v_2...u_nv_n$. We consider the set of length-$k$ scattered\nfactors of a given word w, called here $k$-spectrum and denoted\n$\\ScatFact_k(w)$. We prove a series of properties of the sets $\\ScatFact_k(w)$\nfor binary strictly balanced and, respectively, $c$-balanced words $w$, i.e.,\nwords over a two-letter alphabet where the number of occurrences of each letter\nis the same, or, respectively, one letter has $c$-more occurrences than the\nother. In particular, we consider the question which cardinalities $n=\n|\\ScatFact_k(w)|$ are obtainable, for a positive integer $k$, when $w$ is\neither a strictly balanced binary word of length $2k$, or a $c$-balanced binary\nword of length $2k-c$. We also consider the problem of reconstructing words\nfrom their $k$-spectra.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.09125v2"
    },
    {
        "title": "Translating between models of concurrency",
        "authors": [
            "David Mestel",
            "A. W. Roscoe"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Hoare's Communicating Sequential Processes (CSP) admits a rich universe of\nsemantic models closely related to the van Glabbeek spectrum. In this paper we\nstudy finite observational models, of which at least six have been identified\nfor CSP, namely traces, stable failures, revivals, acceptances, refusal testing\nand finite linear observations. We show how to use the recently-introduced\n\\emph{priority} operator to transform refinement questions in these models into\ntrace refinement (language inclusion) tests. Furthermore, we are able to\ngeneralise this to any (rational) finite observational model. As well as being\nof theoretical interest, this is of practical significance since the\nstate-of-the-art refinement checking tool FDR4 currently only supports two such\nmodels. In particular we study how it is possible to check refinement in a\ndiscrete version of the Timed Failures model that supports Timed CSP.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.09875v1"
    },
    {
        "title": "Deep Packet Inspection in FPGAs via Approximate Nondeterministic\n  Automata",
        "authors": [
            "Milan Češka",
            "Vojtěch Havlena",
            "Lukáš Holík",
            "Jan Kořenek",
            "Ondřej Lengál",
            "Denis Matoušek",
            "Jiří Matoušek",
            "Jakub Semrič",
            "Tomáš Vojnar"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Deep packet inspection via regular expression (RE) matching is a crucial task\nof network intrusion detection systems (IDSes), which secure Internet\nconnection against attacks and suspicious network traffic. Monitoring\nhigh-speed computer networks (100 Gbps and faster) in a single-box solution\ndemands that the RE matching, traditionally based on finite automata (FAs), is\naccelerated in hardware. In this paper, we describe a novel FPGA architecture\nfor RE matching that is able to process network traffic beyond 100 Gbps. The\nkey idea is to reduce the required FPGA resources by leveraging approximate\nnondeterministic FAs (NFAs). The NFAs are compiled into a multi-stage\narchitecture starting with the least precise stage with a high throughput and\nending with the most precise stage with a low throughput. To obtain the reduced\nNFAs, we propose new approximate reduction techniques that take into account\nthe profile of the network traffic. Our experiments showed that using our\napproach, we were able to perform matching of large sets of REs from SNORT, a\npopular IDS, on unprecedented network speeds.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.10786v1"
    },
    {
        "title": "Regular Separability and Intersection Emptiness are Independent Problems",
        "authors": [
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The problem of \\emph{regular separability} asks, given two languages $K$ and\n$L$, whether there exists a regular language $S$ with $K\\subseteq S$ and $S\\cap\nL=\\emptyset$. This problem has recently been studied for various classes of\nlanguages. All the results on regular separability obtained so far exhibited a\nnoteworthy correspondence with the intersection emptiness problem: In eachcase,\nregular separability is decidable if and only if intersection emptiness is\ndecidable. This raises the question whether under mild assumptions, regular\nseparability can be reduced to intersection emptiness and vice-versa.\n  We present counterexamples showing that none of the two problems can be\nreduced to the other. More specifically, we describe language classes\n$\\mathcal{C_1}$, $\\mathcal{D_1}$, $\\mathcal{C_2}$, $\\mathcal{D_2}$ such that\n(i)~intersection emptiness is decidable for $\\mathcal{C_1}$ and\n$\\mathcal{D_1}$, but regular separability is undecidable for $\\mathcal{C_1}$\nand $\\mathcal{D_1}$ and (ii)~regular separability is decidable for\n$\\mathcal{C_2}$ and $\\mathcal{D_2}$, but intersection emptiness is undecidable\nfor $\\mathcal{C_2}$ and $\\mathcal{D_2}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.04038v1"
    },
    {
        "title": "On the expressive power of invariants in parametric timed automata",
        "authors": [
            "Étienne André",
            "Didier Lime",
            "Mathias Ramparison"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The verification of systems combining hard timing constraints with\nconcurrency is challenging. This challenge becomes even harder when some timing\nconstants are missing or unknown. Parametric timed formalisms, such as\nparametric timed automata (PTAs), tackle the synthesis of such timing constants\n(seen as parameters) for which a property holds. Such formalisms are highly\nexpressive, but also undecidable, and few decidable subclasses were proposed.\nWe propose here a syntactic restriction on PTAs consisting in removing guards\n(constraints on transitions) to keep only invariants (constraints on\nlocations). While this restriction preserves the expressiveness of PTAs (and\ntherefore their undecidability), an additional restriction on the type of\nconstraints allows to not only prove decidability, but also to perform the\nexact synthesis of parameter valuations satisfying reachability. This\nformalism, that seems trivial at first sight as it benefits from the\ndecidability of the reachability problem with a better complexity than Timed\nAutomata (TAs), suffers from the undecidability of the whole TCTL logic that\nTAs, on the contrary enjoy. We believe our formalism allows for an interesting\ntrade-off between decidability and practical expressiveness and is therefore\npromising. We show its applicability in a small case study.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.06633v1"
    },
    {
        "title": "Tensor Product Representations of Subregular Formal Languages",
        "authors": [
            "Jonathan Rawski"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper provides a geometric characterization of subclasses of the regular\nlanguages. We use finite model theory to characterize objects like strings and\ntrees as relational structures. Logical statements meeting certain criteria\nover these models define subregular classes of languages. The semantics of such\nstatements can be compiled into tensor structures, using multilinear maps as\nfunction application for evaluation. This method is applied to consider two\nproperly subregular languages over different string models.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.08132v1"
    },
    {
        "title": "An incompressibility theorem for automatic complexity",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Shallit and Wang showed that the automatic complexity $A(x)$ satisfies\n$A(x)\\ge n/13$ for almost all $x\\in{\\{\\mathtt{0},\\mathtt{1}\\}}^n$. They also\nstated that Holger Petersen had informed them that the constant 13 can be\nreduced to 7. Here we show that it can be reduced to $2+\\epsilon$ for any\n$\\epsilon>0$. The result also applies to nondeterministic automatic complexity\n$A_N(x)$. In that setting the result is tight inasmuch as $A_N(x)\\le n/2+1$ for\nall $x$.\n",
        "pdf_link": "http://arxiv.org/pdf/1908.10843v3"
    },
    {
        "title": "Average-based Robustness for Continuous-Time Signal Temporal Logic",
        "authors": [
            "Noushin Mehdipour",
            "Cristian-Ioan Vasile",
            "Calin Belta"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose a new robustness score for continuous-time Signal Temporal Logic\n(STL) specifications. Instead of considering only the most severe point along\nthe evolution of the signal, we use average scores to extract more information\nfrom the signal, emphasizing robust satisfaction of all the specifications'\nsubformulae over their entire time interval domains. We demonstrate the\nadvantages of this new score in falsification and control synthesis problems in\nsystems with complex dynamics and multi-agent systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.00898v1"
    },
    {
        "title": "Explaining SDN Failures via Axiomatisations",
        "authors": [
            "Georgiana Caltais"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This work introduces a concept of explanations with respect to the violation\nof safe behaviours within software defined networks (SDNs) expressible in\nNetKAT. The latter is a network programming language that is based on a\nwell-studied mathematical structure, namely, Kleene Algebra with Tests (KAT).\nAmongst others, the mathematical foundation of NetKAT gave rise to a sound and\ncomplete equational theory. In our setting, a safe behaviour is characterised\nby a NetKAT policy which does not enable forwarding packets from ingress to an\nundesirable egress. Explanations for safety violations are derived in an\nequational fashion, based on a modification of the existing NetKAT\naxiomatisation.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.01745v1"
    },
    {
        "title": "Minimum firing times of firing squad synchronization problems for paths\n  in grid spaces",
        "authors": [
            "Kojiro Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider the firing squad synchronization problems for paths in the two\nand the three-dimensional grid spaces. Minimal-time solutions of these problems\nare not known and are unlikely to exist. However, at present we have no proofs\nof their nonexistence. In this paper we show one result that suggests what type\nof study is necessary in order to prove their nonexistence.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.05406v1"
    },
    {
        "title": "The firing squad synchronization problem for squares with holes",
        "authors": [
            "Kojiro Kobayashi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The firing squad synchronization problem (FSSP, for short) is a problem in\nautomata theory introduced in 1957 by John Myhill. Its goal is to design a\nfinite automaton A such that, if copies of A are placed in a line and connected\nand are started at time 0 with their leftmost copy in a special triggering\nstate, then at some time (the \"firing time\") all copies enter a special \"firing\nstate\" simultaneously for the first time. FSSP has many variations and for many\nof them we know minimal-time solutions (solutions having shortest firing time).\nOne of such variations is the FSSP for squares (denoted by SQ) in which copies\nare placed in a square. In this paper we introduce a variation which we call\nthe FSSP for squares with k holes and denote by SH[k] by slightly modifying SQ\n(k >= 1). In the variation, copies of a finite automaton are placed in a square\nbut there are k positions (\"holes\") in the square where no copies are placed.\nWe show that SH[1] has a minimal-time solution. Moreover, for each problem\ninstance (a placement of copies in a square) C of SH[2], we determine the\nminimum firing time of C (the minimum value of firing times of C by A where A\nranges over all solutions of SH[2]). The variation SQ was introduced and its\nminimal-time solutions were found in 1970's. However, to find minimal-time\nsolutions of SH[k], a very simple modification of SQ, seems to be a very\ndifficult and challenging problem for k >= 2.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.05408v1"
    },
    {
        "title": "On Learning Nominal Automata with Binders",
        "authors": [
            "Yi Xiao",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We investigate a learning algorithm in the context of nominal automata, an\nextension of classical automata to alphabets featuring names. This class of\nautomata captures nominal regular languages; analogously to the classical\nlanguage theory, nominal automata have been shown to characterise nominal\nregular expressions with binders. These formalisms are amenable to abstract\nmodelling resource-aware computations. We propose a learning algorithm on\nnominal regular languages with binders. Our algorithm generalises Angluin's L*\nalgorithm with respect to nominal regular languages with binders. We show the\ncorrectness and study the theoretical complexity of our algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.05974v1"
    },
    {
        "title": "Complexity of Liveness in Parameterized Systems",
        "authors": [
            "Peter Chini",
            "Roland Meyer",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We investigate the fine-grained complexity of liveness verification for\nleader contributor systems. These consist of a designated leader thread and an\narbitrary number of identical contributor threads communicating via a shared\nmemory. The liveness verification problem asks whether there is an infinite\ncomputation of the system in which the leader reaches a final state infinitely\noften. Like its reachability counterpart, the problem is known to be\nNP-complete. Our results show that, even from a fine-grained point of view, the\ncomplexities differ only by a polynomial factor.\n  Liveness verification decomposes into reachability and cycle detection. We\npresent a fixed point iteration solving the latter in polynomial time. For\nreachability, we reconsider the two standard parameterizations. When\nparameterized by the number of states of the leader L and the size of the data\ndomain D, we show an (L + D)^O(L + D)-time algorithm. It improves on a previous\nalgorithm, thereby settling an open problem. When parameterized by the number\nof states of the contributor C, we reuse an O*(2^C)-time algorithm. We show how\nto connect both algorithms with the cycle detection to obtain algorithms for\nliveness verification. The running times of the composed algorithms match those\nof reachability, proving that the fine-grained lower bounds for liveness\nverification are met.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.12004v2"
    },
    {
        "title": "Lyndon words versus inverse Lyndon words: queries on suffixes and\n  bordered words",
        "authors": [
            "Paola Bonizzoni",
            "Clelia De Felice",
            "Rocco Zaccagnino",
            "Rosalba Zizza"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Lyndon words have been largely investigated and showned to be a useful tool\nto prove interesting combinatorial properties of words. In this paper we state\nnew properties of both Lyndon and inverse Lyndon factorizations of a word $w$,\nwith the aim of exploring their use in some classical queries on $w$.\n  The main property we prove is related to a classical query on words. We prove\nthat there are relations between the length of the longest common extension (or\nlongest common prefix) $lcp(x,y)$ of two different suffixes $x,y$ of a word $w$\nand the maximum length $\\mathcal{M}$ of two consecutive factors of the inverse\nLyndon factorization of $w$. More precisely, $\\mathcal{M}$ is an upper bound on\nthe length of $lcp(x,y)$. This result is in some sense stronger than the\ncompatibility property, proved by Mantaci, Restivo, Rosone and Sciortino for\nthe Lyndon factorization and here for the inverse Lyndon factorization.\nRoughly, the compatibility property allows us to extend the mutual order\nbetween local suffixes of (inverse) Lyndon factors to the suffixes of the whole\nword.\n  A main tool used in the proof of the above results is a property that we\nstate for factors $m_i$ with nonempty borders in an inverse Lyndon\nfactorization: a nonempty border of $m_i$ cannot be a prefix of the next factor\n$m_{i+1}$. The last property we prove shows that if two words share a common\noverlap, then their Lyndon factorizations can be used to capture the common\noverlap of the two words.\n  The above results open to the study of new applications of Lyndon words and\ninverse Lyndon words in the field of string comparison.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.01851v1"
    },
    {
        "title": "Aperiodicity, Star-freeness, and First-order Logic Definability of\n  Operator Precedence Languages",
        "authors": [
            "Dino Mandrioli",
            "Matteo Pradella",
            "Stefano Crespi Reghizzi"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A classic result in formal language theory is the equivalence among\nnon-counting, or aperiodic, regular languages, and languages defined through\nstar-free regular expressions, or first-order logic. Past attempts to extend\nthis result beyond the realm of regular languages have met with difficulties:\nfor instance it is known that star-free tree languages may violate the\nnon-counting property and there are aperiodic tree languages that cannot be\ndefined through first-order logic. We extend such classic equivalence results\nto a significant family of deterministic context-free languages, the\noperator-precedence languages (OPL), which strictly includes the widely\ninvestigated visibly pushdown, alias input-driven, family and other structured\ncontext-free languages. The OP model originated in the '60s for defining\nprogramming languages and is still used by high performance compilers; its rich\nalgebraic properties have been investigated initially in connection with\ngrammar learning and recently completed with further closure properties and\nwith monadic second order logic definition. We introduce an extension of\nregular expressions, the OP-expressions (OPE) which define the OPLs and, under\nthe star-free hypothesis, define first-order definable and non-counting OPLs.\nThen, we prove, through a fairly articulated grammar transformation, that\naperiodic OPLs are first-order definable. Thus, the classic equivalence of\nstar-freeness, aperiodicity, and first-order definability is established for\nthe large and powerful class of OPLs. We argue that the same approach can be\nexploited to obtain analogous results for visibly pushdown languages too.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.01236v7"
    },
    {
        "title": "On a Class of Constrained Synchronization Problems in NP",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The class of known constraint automata for which the constrained\nsynchronization problem is in NP all admit a special form. In this work, we\ntake a closer look at them. We characterize a wider class of constraint\nautomata that give constrained synchronization problems in NP, which\nencompasses all known problems in NP. We call these automata polycyclic\nautomata. The corresponding language class of polycyclic languages is\nintroduced. We show various characterizations and closure properties for this\nnew language class. We then give a criterion for NP-completeness and a\ncriterion for polynomial time solvability for polycyclic constraint languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.01903v2"
    },
    {
        "title": "Solenoid Maps, Automatic Sequences, Van Der Put Series, and Mealy-Moore\n  Automata",
        "authors": [
            "Rostislav Grigorchuk",
            "Dmytro Savchuk"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The ring $\\mathbb Z_d$ of $d$-adic integers has a natural interpretation as\nthe boundary of a rooted $d$-ary tree $T_d$. Endomorphisms of this tree (i.e.\nsolenoid maps) are in one-to-one correspondence with 1-Lipschitz mappings from\n$\\mathbb Z_d$ to itself and automorphisms of $T_d$ constitute the group\n$\\mathrm{Isom}(\\mathbb Z_d)$. In the case when $d=p$ is prime, Anashin showed\nthat $f\\in\\mathrm{Lip}^1(\\mathbb Z_p)$ is defined by a finite Mealy automaton\nif and only if the reduced coefficients of its van der Put series constitute a\n$p$-automatic sequence over a finite subset of $\\mathbb Z_p\\cap\\mathbb Q$. We\ngeneralize this result to arbitrary integer $d\\geq 2$, describe the explicit\nconnection between the Moore automaton producing such sequence and the Mealy\nautomaton inducing the corresponding endomorphism. Along the process we produce\ntwo algorithms allowing to convert the Mealy automaton of an endomorphism to\nthe corresponding Moore automaton generating the sequence of the reduced van\nder Put coefficients of the induced map on $\\mathbb Z_d$ and vice versa. We\ndemonstrate examples of applications of these algorithms for the case when the\nsequence of coefficients is Thue-Morse sequence, and also for one of the\ngenerators of the standard automaton representation of the lamplighter group.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.02316v1"
    },
    {
        "title": "Detectability of labeled weighted automata over monoids",
        "authors": [
            "Kuize Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we for the first time obtain characterization of four\nfundamental notions of detectability for general labeled weighted automata over\nmonoids (denoted by $\\mathcal{A}^{\\mathfrak{M}}$ for short), where the four\nnotions are strong (periodic) detectability (SD and SPD) and weak (periodic)\ndetectability (WD and WPD). Firstly, we formulate the notions of concurrent\ncomposition, observer, and detector for $\\mathcal{A}^{\\mathfrak{M}}$. Secondly,\nwe use the concurrent composition to give an equivalent condition for SD, use\nthe detector to give an equivalent condition for SPD, and use the observer to\ngive equivalent conditions for WD and WPD, all for general\n$\\mathcal{A}^{\\mathfrak{M}}$ without any assumption. Thirdly, we prove that for\na labeled weighted automaton over monoid $(\\mathbb{Q}^k,+)$ (denoted by\n$\\mathcal{A}^{\\mathbb{Q}^k}$), its concurrent composition, observer, and\ndetector can be computed in NP, $2$-EXPTIME, and $2$-EXPTIME, respectively, by\ndeveloping novel connections between $\\mathcal{A}^{\\mathbb{Q}^k}$ and the\nNP-complete exact path length problem (proved by [Nyk\\\"{a}nen and Ukkonen,\n2002]) and a subclass of Presburger arithmetic. As a result, we prove that for\n$\\mathcal{A}^{\\mathbb{Q}^k}$, SD can be verified in coNP, while SPD, WD, and\nWPD can be verified in $2$-EXPTIME. Finally, we prove that the problems of\nverifying SD and SPD of deterministic, deadlock-free, and divergence-free\n$\\mathcal{A}^{\\mathbb{N}}$ over monoid $(\\mathbb{N},+)$ are both coNP-hard.\n  The developed original methods will provide foundations for characterizing\nother fundamental properties (e.g., diagnosability, opacity) for\n$\\mathcal{A}^{\\mathfrak{M}}$. We also initially explore detectability in\nlabeled timed automata, and prove that the SD verification problem is\nPSPACE-complete, while WD and WPD are undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.14164v7"
    },
    {
        "title": "Binary intersection formalized",
        "authors": [
            "Štěpán Holub",
            "Štěpán Starosta"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We provide a reformulation and a formalization of the classical result by\nJuhani Karhum\\\"aki characterizing intersections of two languages of the form\n$\\{x,y\\}^*\\cap \\{u,v\\}^*$. We use the terminology of morphisms which allows to\nformulate the result in a shorter and more transparent way, and we formalize\nthe result in the proof assistant Isabelle/HOL.\n",
        "pdf_link": "http://arxiv.org/pdf/2006.16711v1"
    },
    {
        "title": "Proceedings of the Eleventh International Workshop on Graph Computation\n  Models",
        "authors": [
            "Berthold Hoffmann",
            "Mark Minas"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Graphs are common mathematical structures that are visual and intuitive. They\nconstitute a natural and seamless way for system modelling in science,\nengineering and beyond, including computer science, biology, business process\nmodelling, etc. Graph computation models constitute a class of very high-level\nmodels where graphs are first-class citizens. The aim of the International GCM\nWorkshop series is to bring together researchers interested in all aspects of\ncomputation models based on graphs and graph transformation. It promotes the\ncross-fertilizing exchange of ideas and experiences among senior and young\nresearchers from the different communities interested in the foundations,\napplications, and implementations of graph computation models and related\nareas.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.01181v1"
    },
    {
        "title": "Nesting negations in FO2 over infinite words",
        "authors": [
            "Viktor Henriksson",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider two-variable first-order logic FO2 over infinite words.\nRestricting the number of nested negations defines an infinite hierarchy; its\nlevels are often called the half-levels of the FO2 quantifier alternation\nhierarchy. For every level of this hierarchy, we give an effective\ncharacterization. For the lower levels, this characterization is a combination\nof an algebraic and a topological property. For the higher levels, algebraic\nproperties turn out to be sufficient. Within two-variable first-order logic,\neach algebraic property is a single ordered identity of omega-terms. The\ntopological properties are the same as for the lower half-levels of the\nquantifier alternation hierarchy without the two-variable restriction (i.e.,\nthe Cantor topology and the alphabetic topology).\n  Our result generalizes the corresponding result for finite words. The proof\nuses novel techniques and is based on a refinement of Mal'cev products for\nordered monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.01309v1"
    },
    {
        "title": "Describing the syntax of programming languages using conjunctive and\n  Boolean grammars",
        "authors": [
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A classical result by Floyd (\"On the non-existence of a phrase structure\ngrammar for ALGOL 60\", 1962) states that the complete syntax of any sensible\nprogramming language cannot be described by the ordinary kind of formal\ngrammars (Chomsky's ``context-free''). This paper uses grammars extended with\nconjunction and negation operators, known as conjunctive grammars and Boolean\ngrammars, to describe the set of well-formed programs in a simple typeless\nprocedural programming language. A complete Boolean grammar, which defines such\nconcepts as declaration of variables and functions before their use, is\nconstructed and explained. Using the Generalized LR parsing algorithm for\nBoolean grammars, a program can then be parsed in time $O(n^4)$ in its length,\nwhile another known algorithm allows subcubic-time parsing. Next, it is shown\nhow to transform this grammar to an unambiguous conjunctive grammar, with\nsquare-time parsing. This becomes apparently the first specification of the\nsyntax of a programming language entirely by a computationally feasible formal\ngrammar.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.03538v1"
    },
    {
        "title": "Counting ternary square-free words quickly",
        "authors": [
            "Vladislav Makarov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  An efficient, when compared to exhaustive enumeration, algorithm for\ncomputing the number of square-free words of length $n$ over the alphabet $\\{a,\nb, c\\}$ is presented.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.03926v2"
    },
    {
        "title": "A unified implementation of automata and expression structures, and of\n  the associated algorithms using enriched categories",
        "authors": [
            "Ludovic Mignot"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this document, we propose a description, via a Haskell implementation, of\na generalization of the notion of regular expression allowing us to group the\ndefinitions and the methods of (tree or word) automata constructions over one\ngeneric structure, based on enriched category theory tools. We first recall\nseveral methods of conversion from expressions to automata, enlightening the\nsimilarities between the words and trees cases. We then produce an original\nstudy of the power of enriched category theory applied 1) to automata and\nexpressions implementation, and 2) to the study of associated algorithms, using\nadvanced concepts of functional programming, while simultaneously constructing\na Haskell implementation of notions of enriched category theory and associated\nautomata. More precisely, the Haskell implementation and the algebraic\ndefinition of the generic automaton structure are based on the following ideas:\n  - enriched categories, enriched functors, enriched monads, etc. can be\nimplemented in Haskell;\n  - Type level programming can be used to properly encode function arity;\n  - monoids (word structure) and operads (tree structure) can be encoded as\nmonoid objects;\n  - tree and word automata can be represented by the same algebraic structure,\nvia enriched categories.\n  This generalization leads to surprising remarks. As an example, some\nclassical algorithms (determinization, completion, conversion from alternating\nto deterministic automaton) can be regrouped in only one function. We will then\ndefine a notion of generalized expressions based on the notion of monoidal\ntensor product.\n  Haskell sources are available at:\nhttp://ludovicmignot.free.fr/HDR/src-HDR.zip\n",
        "pdf_link": "http://arxiv.org/pdf/2012.10641v1"
    },
    {
        "title": "Analysis of shape grammars: continuity of rules",
        "authors": [
            "Alexandros Haridis",
            "George Stiny"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The rules in a shape grammar apply in terms of embedding to take advantage of\nthe parts that emerge visually in the appearance of shapes. While the shapes\nare kept unanalyzed as a computation moves forward, part-structures for shapes\ncan be defined retrospectively by analyzing how the rules were applied. An\nimportant outcome of this is that rule continuity is not builtin but it is\n\"fabricated\" retrospectively to analyze the computation as a continuous\nprocess. An aspect of continuity analysis that has not been addressed in the\nliterature is how to decide which mapping forms to use to study the continuity\nof rule applications. This is addressed in this paper using recent results on\nshape topology and continuous mappings. A characterization is provided that\ndistinguishes the suitable mapping forms from those that are inherently\ndiscontinuous or practically inconsequential for continuity analysis. It is\nalso shown that certain intrinsic properties of shape topologies and continuous\nmappings provide an effective method of computing topologies algorithmically.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.10949v3"
    },
    {
        "title": "Formal modeling and performance evaluation for hybrid systems:a\n  probabilistic hybrid process algebra-based approach",
        "authors": [
            "Fujun Wang",
            "Zining Cao",
            "Lixing Tan",
            "Zhen Li"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Probabilistic behavior is omnipresent in computer controlled systems, in\nparticular, so-called safety-critical hybrid systems, because of various\nreasons, like uncertain environments, or fundamental properties of nature. In\nthis paper, we extend existing hybrid process algebra $ACP_{hs}^{srt}$ with\nprobability without replacing nondeterministic choice operator. In view of some\nshortcomings in existing approximate probabilistic bisimulation, we relax the\nconstrains and propose a novel approximate probabilistic bisimulation relation.\nAfter that, we present a performance evaluation language, CTRML, to reason over\nprobabilistic systems, which extend the results to real number. Along with the\nspecification language, we present a set of algorithms for the evaluation of\nthe language. Additionally, we transfer the hybrid process algebra to\nprobabilistic transition system and show experimental results.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.12716v1"
    },
    {
        "title": "FOREST: An Interactive Multi-tree Synthesizer for Regular Expressions",
        "authors": [
            "Margarida Ferreira",
            "Miguel Terra-Neves",
            "Miguel Ventura",
            "Inês Lynce",
            "Ruben Martins"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Form validators based on regular expressions are often used on digital forms\nto prevent users from inserting data in the wrong format. However, writing\nthese validators can pose a challenge to some users. We present FOREST, a\nregular expression synthesizer for digital form validations. FOREST produces a\nregular expression that matches the desired pattern for the input values and a\nset of conditions over capturing groups that ensure the validity of integer\nvalues in the input. Our synthesis procedure is based on enumerative search and\nuses a Satisfiability Modulo Theories (SMT) solver to explore and prune the\nsearch space. We propose a novel representation for regular expressions\nsynthesis, multi-tree, which induces patterns in the examples and uses them to\nsplit the problem through a divide-and-conquer approach. We also present a new\nSMT encoding to synthesize capture conditions for a given regular expression.\nTo increase confidence in the synthesized regular expression, we implement user\ninteraction based on distinguishing inputs. We evaluated FOREST on real-world\nform-validation instances using regular expressions. Experimental results show\nthat FOREST successfully returns the desired regular expression in 72% of the\ninstances and outperforms REGEL, a state-of-the-art regular expression\nsynthesizer.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.14235v1"
    },
    {
        "title": "Canonical Representations of k-Safety Hyperproperties",
        "authors": [
            "Bernd Finkbeiner",
            "Lennart Haas",
            "Hazem Torfah"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Hyperproperties elevate the traditional view of trace properties form sets of\ntraces to sets of sets of traces and provide a formalism for expressing\ninformation-flow policies. For trace properties, algorithms for verification,\nmonitoring, and synthesis are typically based on a representation of the\nproperties as omega-automata. For hyperproperties, a similar, canonical\nautomata-theoretic representation is, so far, missing. This is a serious\nobstacle for the development of algorithms, because basic constructions, such\nas learning algorithms, cannot be applied.\n  In this paper, we present a canonical representation for the widely used\nclass of regular k-safety hyperproperties, which includes important polices\nsuch as noninterference. We show that a regular k-safety hyperproperty S can be\nrepresented by a finite automaton, where each word accepted by the automaton\nrepresents a violation of S. The representation provides an automata-theoretic\napproach to regular k-safety hyperproperties and allows us to compare regular\nk-safety hyperproperties, simplify them, and learn such hyperproperties. We\ninvestigate the problem of constructing automata for regular k-safety\nhyperproperties in general and from formulas in HyperLTL, and provide\ncomplexity bounds for the different translations. We also present a learning\nalgorithm for regular k-safety hyperproperties based on the L* learning\nalgorithm for deterministic finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.14586v1"
    },
    {
        "title": "Approximate Automata for Omega-Regular Languages",
        "authors": [
            "Rayna Dimitrova",
            "Bernd Finkbeiner",
            "Hazem Torfah"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Automata over infinite words, also known as omega-automata, play a key role\nin the verification and synthesis of reactive systems. The spectrum of\nomega-automata is defined by two characteristics: the acceptance condition\n(e.g. B\\\"uchi or parity) and the determinism (e.g., deterministic or\nnondeterministic) of an automaton. These characteristics play a crucial role in\napplications of automata theory. For example, certain acceptance conditions can\nbe handled more efficiently than others by dedicated tools and algorithms.\nFurthermore, some applications, such as synthesis and probabilistic model\nchecking, require that properties are represented as some type of deterministic\nomega-automata. However, properties cannot always be represented by automata\nwith the desired acceptance condition and determinism. In this paper we study\nthe problem of approximating linear-time properties by automata in a given\nclass. Our approximation is based on preserving the language up to a\nuser-defined precision given in terms of the size of the finite lasso\nrepresentation of infinite executions that are preserved. We study the state\ncomplexity of different types of approximating automata, and provide\nconstructions for the approximation within different automata classes, for\nexample, for approximating a given automaton by one with a simpler acceptance\ncondition.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.14590v1"
    },
    {
        "title": "Reachability relations of timed pushdown automata",
        "authors": [
            "Lorenzo Clemente",
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Timed pushdown automata (TPDA) are an expressive formalism combining\nrecursion with a rich logic of timing constraints. We prove that reachability\nrelations of TPDA are expressible in linear arithmetic, a rich logic\ngeneralising Presburger arithmetic and rational arithmetic. The main technical\ningredients are a novel quantifier elimination result for clock constraints\n(used to simplify the syntax of TPDA transitions), the use of clock difference\nrelations to express reachability relations of the fractional clock values, and\nan application of Parikh's theorem to reconstruct the integral clock values.\n",
        "pdf_link": "http://arxiv.org/pdf/2012.15291v1"
    },
    {
        "title": "Recursive Prime Factorizations: Dyck Words as Numbers",
        "authors": [
            "Ralph L. Childress"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  I propose a class of numeral systems where numbers are represented by Dyck\nwords, with the systems arising from a generalization of prime factorization.\nAfter describing two proper subsets of the Dyck language capable of uniquely\nrepresenting all natural and rational numbers respectively, I consider\n\"Dyck-complete\" languages, in which every member of the Dyck language\nrepresents a number. I conclude by suggesting possible research directions.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.02777v2"
    },
    {
        "title": "Parallel Hyperedge Replacement String Languages",
        "authors": [
            "Graham Campbell"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  There are many open questions surrounding the characterisation of groups with\ncontext-sensitive word problem. Only in 2018 was it shown that all finitely\ngenerated virtually Abelian groups have multiple context-free word problems,\nand it is a long-standing open question as to where to place the word problems\nof hyperbolic groups in the formal language hierarchy. In this paper, we\nintroduce a new language class called the parallel hyperedge replacement string\nlanguages, show that it contains all multiple context-free and ET0L languages,\nand lay down the foundations for future work that may be able to place the word\nproblems of many hyperbolic groups in this class.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.03164v1"
    },
    {
        "title": "MatchKAT: An Algebraic Foundation For Match-Action",
        "authors": [
            "Xiang Long"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present MatchKAT, an algebraic language for modeling match-action packet\nprocessing in network switches. Although the match-action paradigm has remained\na popular low-level programming model for specifying packet forwarding\nbehavior, little has been done towards giving it formal semantics. With\nMatchKAT, we hope to embark on the first steps in exploring how network\nprograms compiled to match-action rules can be reasoned about formally in a\nreliable, algebraic way. In this paper, we give details of MatchKAT and its\nmetatheory, as well as a formal treatment of match expressions on binary\nstrings that form the basis of \"match\" in match-action. Through a\ncorrespondence with NetKAT, we show that MatchKAT's equational theory is sound\nand complete with regards to a similar packet filtering semantics. We also\ndemonstrate the complexity of deciding equivalence in MatchKAT is\nPSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.07374v1"
    },
    {
        "title": "On Typical Hesitant Fuzzy Languages and Automata",
        "authors": [
            "Valdigleis S. Costa",
            "Benjamín C. Bedregal",
            "Regivan H. N. Santiago"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The idea of nondeterministic typical hesitant fuzzy automata is a\ngeneralization of the fuzzy automata presented by Costa and Bedregal. This\npaper, presents the sufficient and necessary conditions for a typical hesitant\nfuzzy language to be computed by nondeterministic typical hesitant fuzzy\nautomata. Besides, the paper introduces a new class of Typical Hesitant Fuzzy\nAutomata with crisp transitions, and we will show that this new class is\nequivalent to the original class introduced by Costa and Bedregal\n",
        "pdf_link": "http://arxiv.org/pdf/2102.09347v1"
    },
    {
        "title": "Keyboards as a new model of computation",
        "authors": [
            "Yoan Géran",
            "Bastien Laboureix",
            "Corto Mascle",
            "Valentin D. Richard"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a new formalisation of languages, called keyboards. We consider\na set of elementary operations (writing/erasing a letter, going to the right or\nto the left,...) and we define a keyboard as a set of finite sequences of such\noperations, called keys. The corresponding language is the set of words\nobtained by applying some sequence of those keys. Unlike classical models of\ncomputation, every key can be applied anytime. We define various classes of\nlanguages based on different sets of elementary operations, and compare their\nexpressive powers. We also compare them to well-known classes of languages\n(Chomsky hierarchy). We obtain a strict hierarchy of languages, whose\nexpressivity is orthogonal to the one of the aforementionned classical models.\n  --\n  Nous introduisons une nouvelle repr\\'esentation de langages, les claviers. On\nse munit d'un ensemble d'op\\'erations \\'el\\'ementaires (ajout, effacement d'une\nlettre, d\\'eplacement \\`a droite, \\`a gauche, ...), et on d\\'efinit un clavier\ncomme un ensemble de suites finies d'op\\'erations \\'el\\'ementaires, appel\\'ees\ntouches. Son langage sera l'ensemble des mots obtenus en appliquant une suite\nquelconque de touches. Contrairement \\`a des mod\\`eles de calcul classiques,\ntoutes les touches peuvent \\^etre appliqu\\'ees \\`a tout moment. En premier lieu\nnous d\\'efinissons diff\\'erentes classes de claviers en faisant varier\nl'ensemble des op\\'erations \\'el\\'ementaires autoris\\'ees, et nous comparons\nl'expressivit\\'e des classes de langages obtenues. Nous comparons \\'egalement\nces classes \\`a la hi\\'erarchie de Chomsky. Nous obtenons que toutes les\nclasses \\'etudi\\'ees sont diff\\'erentes, et nous caract\\'erisons les classes\ninclues dans les rationnels et les alg\\'ebriques. L'expressivit\\'e des claviers\nsemble orthogonale \\`a celle des mod\\`eles \\'evoqu\\'es pr\\'ec\\'edemment.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.10182v3"
    },
    {
        "title": "A theory of Automated Market Makers in DeFi",
        "authors": [
            "Massimo Bartoletti",
            "James Hsin-yu Chiang",
            "Alberto Lluch-Lafuente"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Automated market makers (AMMs) are one of the most prominent decentralized\nfinance (DeFi) applications. AMMs allow users to trade different types of\ncrypto-tokens, without the need to find a counter-party. There are several\nimplementations and models for AMMs, featuring a variety of sophisticated\neconomic mechanisms. We present a theory of AMMs. The core of our theory is an\nabstract operational model of the interactions between users and AMMs, which\ncan be concretised by instantiating the economic mechanisms. We exploit our\ntheory to formally prove a set of fundamental properties of AMMs,\ncharacterizing both structural and economic aspects. We do this by abstracting\nfrom the actual economic mechanisms used in implementations, and identifying\nsufficient conditions which ensure the relevant properties. Notably, we devise\na general solution to the arbitrage problem, the main game-theoretic foundation\nbehind the economic mechanisms of AMMs.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.11350v7"
    },
    {
        "title": "Explaining Safety Failures in NetKAT",
        "authors": [
            "Georgiana Caltais",
            "Hunkar Can Tunc"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This work introduces a concept of explanations with respect to the violation\nof safe behaviours within software defined networks (SDNs) expressible in\nNetKAT. The latter is a network programming language based on a well-studied\nmathematical structure, namely, Kleene Algebra with Tests (KAT). Amongst\nothers, the mathematical foundation of NetKAT gave rise to a sound and complete\nequational theory. In our setting, a safe behaviour is characterised by a\nNetKAT policy, or program, which does not enable forwarding packets from an\ningress i to an undesirable egress e. We show how explanations for safety\nviolations can be derived in an equational fashion, according to a modification\nof the existing NetKAT axiomatisation. We propose an approach based on the\nMaude system for actually computing the undesired behaviours witnessing the\nforwarding of packets from i to e as above. SDN-SafeCheck is a tool based on\nMaude equational theories satisfying important properties such as Church-Rosser\nand termination. SDN-SafeCheck automatically identifies all the undesired\nbehaviours leading to e, covering forwarding paths up to a user specified size.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.12448v1"
    },
    {
        "title": "MORA -- Automatic Generation of Moment-Based Invariants",
        "authors": [
            "Ezio Bartocci",
            "Laura Kovacs",
            "Miroslav Stankovic"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce MORA, an automated tool for generating invariants of\nprobabilistic programs. Inputs to MORA are so-called Prob-solvable loops, that\nis probabilistic programs with polynomial assignments over random variables and\nparametrized distributions. Combining methods from symbolic computation and\nstatistics, MORA computes invariant properties over higher-order moments of\nloop variables, expressing, for example, statistical properties, such as\nexpected values and variances, over the value distribution of loop variables.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.03908v1"
    },
    {
        "title": "Synthesizing Computable Functions from Rational Specifications over\n  Infinite Words",
        "authors": [
            "Emmanuel Filiot",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The synthesis problem asks to automatically generate, if it exists, an\nalgorithm from a specification of correct input-output pairs. In this paper, we\nconsider the synthesis of computable functions of infinite words, for a\nclassical Turing computability notion over infinite inputs. We consider\nspecifications which are rational relations of infinite words, i.e.,\nspecifications defined non-deterministic parity transducers. We prove that the\nsynthesis problem of computable functions from rational specifications is\nundecidable. We provide an incomplete but sound reduction to some parity game,\nsuch that if Eve wins the game, then the rational specification is realizable\nby a computable function. We prove that this function is even computable by a\ndeterministic two-way transducer. We provide a sufficient condition under which\nthe latter game reduction is complete. This entails the decidability of the\nsynthesis problem of computable functions, which we prove to be\nExpTime-complete, for a large subclass of rational specifications, namely\ndeterministic rational specifications. This subclass contains the class of\nautomatic relations over infinite words, a yardstick in reactive synthesis.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.05674v4"
    },
    {
        "title": "Bounded Invariant Checking for Stateflow Programs",
        "authors": [
            "Predrag Filipovikj",
            "Dilian Gurov",
            "Mattias Nyberg"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Stateflow models are complex software models, often used as part of\nsafety-critical software solutions designed with Matlab Simulink. They\nincorporate design principles that are typically very hard to verify formally.\nIn particular, the standard exhaustive formal verification techniques are\nunlikely to scale well for the complex designs that are developed in industry.\nFurthermore, the Stateflow language lacks a formal semantics, which\nadditionally hinders the formal analysis.\n  To address these challenges, we lay here the foundations of a scalable\ntechnique for provably correct formal analysis of Stateflow models, with\nrespect to invariant properties, based on bounded model checking (BMC) over\nsymbolic executions. The crux of our technique is: i) a representation of the\nstate space of Stateflow models as a symbolic transition system (STS) over the\nsymbolic configurations of the model, as the basis for BMC, and ii) application\nof incremental BMC, to generate verification results after each unrolling of\nthe next-state relation of the transition system. To this end, we develop a\nsymbolic structural operational semantics (SSOS) for Stateflow, starting from\nan existing structural operational semantics (SOS), and show the preservation\nof invariant properties between the two. Next, we define bounded invariant\nchecking for STS over symbolic configurations as a satisfiability problem. We\ndevelop an automated procedure for generating the initial and next-state\npredicates of the STS, and propose an encoding scheme of the bounded invariant\nchecking problem as a set of constraints, ready for automated analysis with\nstandard, off-the-shelf satisfiability solvers. Finally, we present preliminary\nperformance results by applying our tool on an illustrative example.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.06248v3"
    },
    {
        "title": "Ordered Semiautomatic Rings with Applications to Geometry",
        "authors": [
            "Ziyuan Gao",
            "Sanjay Jain",
            "Ji Qi",
            "Philipp Schlicht",
            "Frank Stephan",
            "Jacob Tarr"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The present work looks at semiautomatic rings with automatic addition and\ncomparisons which are dense subrings of the real numbers and asks how these can\nbe used to represent geometric objects such that certain operations and\ntransformations are automatic. The underlying ring has always to be a countable\ndense subring of the real numbers and additions and comparisons and\nmultiplications with constants need to be automatic. It is shown that the ring\ncan be selected such that equilateral triangles can be represented and\nrotations by 30 degrees are possible, while the standard representation of the\nb-adic rationals does not allow this.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.06714v1"
    },
    {
        "title": "Initial nonrepetitive complexity of regular episturmian words and their\n  Diophantine exponents",
        "authors": [
            "Jarkko Peltomäki"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Regular episturmian words are episturmian words whose directive words have a\nregular and restricted form making them behave more like Sturmian words than\ngeneral episturmian words. We present a method to evaluate the initial\nnonrepetitive complexity of regular episturmian words extending the work of\nWojcik on Sturmian words. For this, we develop a theory of generalized\nOstrowski numeration systems and show how to associate with each episturmian\nword a unique sequence of numbers written in this numeration system.\n  The description of the initial nonrepetitive complexity allows us to obtain\nnovel results on the Diophantine exponents of regular episturmian words. We\nprove that the Diophantine exponent of a regular episturmian word is finite if\nand only if its directive word has bounded partial quotients. Moreover, we\nprove that the Diophantine exponent of a regular episturmian word is strictly\ngreater than $2$ if the sequence of partial quotients is eventually at least\n$3$.\n  Given an infinite word $x$ over an integer alphabet, we may consider a real\nnumber $\\xi_x$ having $x$ as a fractional part. The Diophantine exponent of $x$\nis a lower bound for the irrationality exponent of $\\xi_x$. Our results thus\nyield nontrivial lower bounds for the irrationality exponents of real numbers\nwhose fractional parts are regular episturmian words. As a consequence, we\nidentify a new uncountable class of transcendental numbers whose irrationality\nexponents are strictly greater than $2$. This class contains an uncountable\nsubclass of Liouville numbers.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.08351v3"
    },
    {
        "title": "On symmetric higher-dimensional automata and bisimilarity",
        "authors": [
            "Thomas Kahl"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  It is shown that a higher-dimensional automaton is hhp-bisimilar to the free\nsymmetric HDA generated by it. Consequently, up to hereditary\nhistory-preserving bisimilarity, ordinary HDAs and symmetric HDAs are models of\nconcurrency with the same expressive power.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.15223v1"
    },
    {
        "title": "Modular Mix-and-Match Complementation of Büchi Automata (Technical\n  Report)",
        "authors": [
            "Vojtěch Havlena",
            "Ondřej Lengál",
            "Yong Li",
            "Barbora Šmahlíková",
            "Andrea Turrini"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Complementation of nondeterministic B\\\"uchi automata (BAs) is an important\nproblem in automata theory with numerous applications in formal verification,\nsuch as termination analysis of programs, model checking, or in decision\nprocedures of some logics. We build on ideas from a recent work on BA\ndeterminization by Li et al. and propose a new modular algorithm for BA\ncomplementation. Our algorithm allows to combine several BA complementation\nprocedures together, with one procedure for a subset of the BA's strongly\nconnected components (SCCs). In this way, one can exploit the structure of\nparticular SCCs (such as when they are inherently weak or deterministic) and\nuse more efficient specialized algorithms, regardless of the structure of the\nwhole BA. We give a general framework into which partial complementation\nprocedures can be plugged in, and its instantiation with several algorithms.\nThe framework can, in general, produce a complement with an Emerson-Lei\nacceptance condition, which can often be more compact. Using the algorithm, we\nwere able to establish an exponentially better new upper bound of $O(4n)$ for\ncomplementation of the recently introduced class of elevator automata. We\nimplemented the algorithm in a prototype and performed a comprehensive set of\nexperiments on a large set of benchmarks, showing that our framework\ncomplements well the state of the art and that it can serve as a basis for\nfuture efficient BA complementation and inclusion checking algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.01890v1"
    },
    {
        "title": "The Algebra of Nondeterministic Finite Automata",
        "authors": [
            "Roberto Gorrieri"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A process algebra is proposed, whose semantics maps a term to a\nnondeterministic finite automaton (NFA, for short). We prove a representability\ntheorem: for each NFA $N$, there exists a process algebraic term $p$ such that\nits semantics is an NFA isomorphic to $N$. Moreover, we provide a concise\naxiomatization of language equivalence: two NFAs $N_1$ and $N_2$ recognize the\nsame language if and only if the associated terms $p_1$ and $p_2$,\nrespectively, can be equated by means of a set of axioms, comprising 7 axioms\nplus 3 conditional axioms, only.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.03435v2"
    },
    {
        "title": "Refutations of pebble minimization via output languages",
        "authors": [
            "Sandra Kiefer",
            "Lê Thành Dũng Nguyên",
            "Cécilia Pradic"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Polyregular functions are the class of string-to-string functions definable\nby pebble transducers, an extension of finite-state automata with outputs and\nmultiple two-way reading heads (pebbles) with a stack discipline. If a\npolyregular function can be computed with $k$ pebbles, then its output length\nis bounded by a polynomial of degree $k$ in the input length. But Boja\\'nczyk\nhas shown that the converse fails.\n  In this paper, we provide two alternative easier proofs. The first\nestablishes by elementary means that some quadratic polyregular function\nrequires 3 pebbles. The second proof - just as short, albeit less elementary -\nshows a stronger statement: for every $k$, there exists some polyregular\nfunction with quadratic growth whose output language differs from that of any\n$k$-fold composition of macro tree transducers (and which therefore cannot be\ncomputed by a $k$-pebble transducer). Along the way, we also refute a\nconjectured logical characterization of polyblind functions.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.09234v2"
    },
    {
        "title": "Word-Mappings of level $3$",
        "authors": [
            "G. Sénizergues"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Sequences of numbers (either natural integers, or integers or rational) of\nlevel $k \\in \\mathbb{N}$ have been defined in \\cite{Fra05,Fra-Sen06} as the\nsequences which can be computed by deterministic pushdown automata of level\n$k$. This definition has been extended to sequences of {\\em words} indexed by\n{\\em words} in \\cite{Sen07,Fer-Mar-Sen14}. We characterise here the sequences\nof level 3 as the compositions of two HDT0L-systems. Two applications are\nderived:\n  - the sequences of rational numbers of level 3 are characterised by\npolynomial recurrences\n  - the equality problem for sequences of rational numbers of level 3 is\ndecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.09966v2"
    },
    {
        "title": "LTL to Büchi Automata Translation: Fast and More Deterministic",
        "authors": [
            "Tomáš Babiak",
            "Mojmír Křetínský",
            "Vojtěch Řehák",
            "Jan Strejček"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We introduce improvements in the algorithm by Gastin and Oddoux translating\nLTL formulae into B\\\"uchi automata via very weak alternating co-B\\\"uchi\nautomata and generalized B\\\"uchi automata. Several improvements are based on\nspecific properties of any formula where each branch of its syntax tree\ncontains at least one eventually operator and at least one always operator.\nThese changes usually result in faster translations and smaller automata. Other\nimprovements reduce non-determinism in the produced automata. In fact, we\nmodified all the steps of the original algorithm and its implementation known\nas LTL2BA. Experimental results show that our modifications are real\nimprovements. Their implementations within an LTL2BA translation made LTL2BA\nvery competitive with the current version of SPOT, sometimes outperforming it\nsubstantially.\n",
        "pdf_link": "http://arxiv.org/pdf/1201.0682v2"
    },
    {
        "title": "Operads, quasiorders, and regular languages",
        "authors": [
            "Samuele Giraudo",
            "Jean-Gabriel Luque",
            "Ludovic Mignot",
            "Florent Nicart"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We generalize the construction of multitildes in the aim to provide\nmultitilde operators for regular languages. We show that the underliying\nalgebraic structure involves the action of some operads. An operad is an\nalgebraic structure that mimics the composition of the functions. The involved\noperads are described in terms of combinatorial objects. These operads are\nobtained from more primitive objects, namely precompositions, whose algebraic\ncounter-parts are investigated. One of these operads acts faithfully on\nlanguages in the sense that two different operators act in two different ways.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.2010v2"
    },
    {
        "title": "Deterministic Logics for UL",
        "authors": [
            "Paritosh K. Pandya",
            "Simoni S. Shah"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The class of Unambiguous Star-Free Regular Languages (UL) was defined by\nSchutzenberger as the class of languages defined by Unambiguous Polynomials. UL\nhas been variously characterized (over finite words) by logics such as\nTL[X_a,Y_a], UITL, TL[F,P], FO2[<], the variety DA of monoids, as well as\npartially-ordered two-way DFA (po2DFA). We revisit this language class with\nemphasis on notion of unambiguity and develop on the concept of Deterministic\nLogics for UL. The formulas of deterministic logics uniquely parse a word in\norder to evaluate satisfaction. We show that several deterministic logics\nrobustly characterize UL. Moreover, we derive constructive reductions from\nthese logics to the po2DFA automata. These reductions also allow us to show\nNP-complete satisfaction complexity for the deterministic logics considered.\n  Logics such as TL[F,P], FO2[<] are not deterministic and have been shown to\ncharacterize UL using algebraic methods. However there has been no known\nconstructive reduction from these logics to po2DFA. We use deterministic logics\nto bridge this gap. The language-equivalent po2DFA for a given TL[F,P] formula\nis constructed and we analyze its size relative to the size of the TL[F,P]\nformula. This is an efficient reduction which gives an alternate proof to\nNP-complete satisfiability complexity of TL[F,P] formulas.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.2714v1"
    },
    {
        "title": "Synthesis of Sequential Extended Regular Expressions for Verification",
        "authors": [
            "Mohamad Noureddine",
            "Fadi A. Zaraket",
            "Ali S. Elzein"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Synthesis techniques take realizable Linear Temporal Logic specifications and\nproduce correct cir- cuits that implement the specifications. The generated\ncircuits can be used directly, or as miters that check the correctness of a\nlogic design. Typically, those techniques generate non-deterministic finite\nstate automata, which can be determinized at a possibly exponential cost.\nRecent results show multiple advantages of using deterministic automata in\nsymbolic and bounded model checking of LTL safety properties. In this paper, we\npresent a technique with a supporting tool that takes a sequential extended\nregular expression specification {\\Phi}, and a logic design implementation S,\nand generates a sequential circuit C, expressed as an And-Inverted-Graph, that\nchecks whether S satisfies {\\Phi}. The technique passes the generated circuit C\nto ABC, a bounded model checker, to validate correctness. We use free input\nvariables to encode the non- determinism in {\\Phi} and we obtain a number of\nstates in miter linear in the size of {\\Phi}. Our technique succeeds to\ngenerate the input to the model checker while other techniques fail because of\nthe exponential blowup, and in most cases, ABC succeeds to either find defects\nin the design that was otherwise uncheckable, or validate the design. We\nevaluated our technique against several industrial benchmarks including the IBM\narbiter, a load balancer, and a traffic light system, and compared our results\nwith the NuSMV framework. Our method found defects and validated systems NuSMV\ncould not validate.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.3173v1"
    },
    {
        "title": "Exact and Approximate Determinization of Discounted-Sum Automata",
        "authors": [
            "Udi Boker",
            "Thomas A. Henzinger"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  A discounted-sum automaton (NDA) is a nondeterministic finite automaton with\nedge weights, valuing a run by the discounted sum of visited edge weights. More\nprecisely, the weight in the i-th position of the run is divided by\n$\\lambda^i$, where the discount factor $\\lambda$ is a fixed rational number\ngreater than 1. The value of a word is the minimal value of the automaton runs\non it. Discounted summation is a common and useful measuring scheme, especially\nfor infinite sequences, reflecting the assumption that earlier weights are more\nimportant than later weights. Unfortunately, determinization of NDAs, which is\noften essential in formal verification, is, in general, not possible. We\nprovide positive news, showing that every NDA with an integral discount factor\nis determinizable. We complete the picture by proving that the integers\ncharacterize exactly the discount factors that guarantee determinizability: for\nevery nonintegral rational discount factor $\\lambda$, there is a\nnondeterminizable $\\lambda$-NDA. We also prove that the class of NDAs with\nintegral discount factors enjoys closure under the algebraic operations min,\nmax, addition, and subtraction, which is not the case for general NDAs nor for\ndeterministic NDAs. For general NDAs, we look into approximate determinization,\nwhich is always possible as the influence of a word's suffix decays. We show\nthat the naive approach, of unfolding the automaton computations up to a\nsufficient level, is doubly exponential in the discount factor. We provide an\nalternative construction for approximate determinization, which is singly\nexponential in the discount factor, in the precision, and in the number of\nstates. We also prove matching lower bounds, showing that the exponential\ndependency on each of these three parameters cannot be avoided. All our results\nhold equally for automata over finite words and for automata over infinite\nwords.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.3957v2"
    },
    {
        "title": "The existential fragment of S1S over element and successor is the\n  co-Buchi languages",
        "authors": [
            "Egor Ianovski"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Buchi's theorem, in establishing the equivalence between languages definable\nin S1S over element and < and the omega-regular languages also demonstrated\nthat S1S over element and < is no more expressive than its existential\nfragment. It is also easy to see that S1S over element and < is equi-expressive\nwith S1S over element and successor. However, it is not immediately obvious\nwhether it is possible to adapt Buchi's argument to establish equivalence\nbetween expressivity in S1S over element and successor and its existential\nfragment. In this paper we show that it is not: the existential fragment of S1S\nover element and successor is strictly less expressive, and is in fact\nequivalent to the co-Buchi languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.4932v1"
    },
    {
        "title": "Determinising Parity Automata",
        "authors": [
            "Sven Schewe",
            "Thomas Varghese"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Parity word automata and their determinisation play an important role in\nautomata and game theory. We discuss a determinisation procedure for\nnondeterministic parity automata through deterministic Rabin to deterministic\nparity automata. We prove that the intermediate determinisation to Rabin\nautomata is optimal. We show that the resulting determinisation to parity\nautomata is optimal up to a small constant. Moreover, the lower bound refers to\nthe more liberal Streett acceptance. We thus show that determinisation to\nStreett would not lead to better bounds than determinisation to parity. As a\nside-result, this optimality extends to the determinisation of B\\\"uchi\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.5394v1"
    },
    {
        "title": "Quantum, Stochastic, and Pseudo Stochastic Languages with Few States",
        "authors": [
            "Arseny M. Shur",
            "Abuzer Yakaryilmaz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Stochastic languages are the languages recognized by probabilistic finite\nautomata (PFAs) with cutpoint over the field of real numbers. More general\ncomputational models over the same field such as generalized finite automata\n(GFAs) and quantum finite automata (QFAs) define the same class. In 1963, Rabin\nproved the set of stochastic languages to be uncountable presenting a single\n2-state PFA over the binary alphabet recognizing uncountably many languages\ndepending on the cutpoint. In this paper, we show the same result for unary\nstochastic languages. Namely, we exhibit a 2-state unary GFA, a 2-state unary\nQFA, and a family of 3-state unary PFAs recognizing uncountably many languages;\nall these numbers of states are optimal. After this, we completely characterize\nthe class of languages recognized by 1-state GFAs, which is the only nontrivial\nclass of languages recognized by 1-state automata. Finally, we consider the\nvariations of PFAs, QFAs, and GFAs based on the notion of inclusive/exclusive\ncutpoint, and present some results on their expressive power.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.0055v2"
    },
    {
        "title": "A new approach to the $2$-regularity of the $\\ell$-abelian complexity of\n  $2$-automatic sequences",
        "authors": [
            "Aline Parreau",
            "Michel Rigo",
            "Eric Rowland",
            "Elise Vandomme"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We prove that a sequence satisfying a certain symmetry property is\n$2$-regular in the sense of Allouche and Shallit, i.e., the $\\mathbb{Z}$-module\ngenerated by its $2$-kernel is finitely generated. We apply this theorem to\ndevelop a general approach for studying the $\\ell$-abelian complexity of\n$2$-automatic sequences. In particular, we prove that the period-doubling word\nand the Thue--Morse word have $2$-abelian complexity sequences that are\n$2$-regular. Along the way, we also prove that the $2$-block codings of these\ntwo words have $1$-abelian complexity sequences that are $2$-regular.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.3532v2"
    },
    {
        "title": "Saturation algorithms for model-checking pushdown systems",
        "authors": [
            "Arnaud Carayol",
            "Matthew Hague"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present a survey of the saturation method for model-checking pushdown\nsystems.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5593v1"
    },
    {
        "title": "Cooperating Distributed Grammar Systems of Finite Index Working in\n  Hybrid Modes",
        "authors": [
            "Henning Fernau",
            "Rudolf Freund",
            "Markus Holzer"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study cooperating distributed grammar systems working in hybrid modes in\nconnection with the finite index restriction in two different ways: firstly, we\ninvestigate cooperating distributed grammar systems working in hybrid modes\nwhich characterize programmed grammars with the finite index restriction;\nlooking at the number of components of such systems, we obtain surprisingly\nrich lattice structures for the inclusion relations between the corresponding\nlanguage families. Secondly, we impose the finite index restriction on\ncooperating distributed grammar systems working in hybrid modes themselves,\nwhich leads us to new characterizations of programmed grammars of finite index.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5606v1"
    },
    {
        "title": "Buffered Simulation Games for Büchi Automata",
        "authors": [
            "Milka Hutagalung",
            "Martin Lange",
            "Etienne Lozes"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Simulation relations are an important tool in automata theory because they\nprovide efficiently computable approximations to language inclusion. In recent\nyears, extensions of ordinary simulations have been studied, for instance\nmulti-pebble and multi-letter simulations which yield better approximations and\nare still polynomial-time computable.\n  In this paper we study the limitations of approximating language inclusion in\nthis way: we introduce a natural extension of multi-letter simulations called\nbuffered simulations. They are based on a simulation game in which the two\nplayers share a FIFO buffer of unbounded size. We consider two variants of\nthese buffered games called continuous and look-ahead simulation which differ\nin how elements can be removed from the FIFO buffer. We show that look-ahead\nsimulation, the simpler one, is already PSPACE-hard, i.e. computationally as\nhard as language inclusion itself. Continuous simulation is even EXPTIME-hard.\nWe also provide matching upper bounds for solving these games with infinite\nstate spaces.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.5609v1"
    },
    {
        "title": "Classical automata on promise problems",
        "authors": [
            "Viliam Geffert",
            "Abuzer Yakaryilmaz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Promise problems were mainly studied in quantum automata theory. Here we\nfocus on state complexity of classical automata for promise problems. First, it\nwas known that there is a family of unary promise problems solvable by quantum\nautomata by using a single qubit, but the number of states required by\ncorresponding one-way deterministic automata cannot be bounded by a constant.\nFor this family, we show that even two-way nondeterminism does not help to save\na single state. By comparing this with the corresponding state complexity of\nalternating machines, we then get a tight exponential gap between two-way\nnondeterministic and one-way alternating automata solving unary promise\nproblems. Second, despite of the existing quadratic gap between Las Vegas\nrealtime probabilistic automata and one-way deterministic automata for language\nrecognition, we show that, by turning to promise problems, the tight gap\nbecomes exponential. Last, we show that the situation is different for one-way\nprobabilistic automata with two-sided bounded-error. We present a family of\nunary promise problems that is very easy for these machines; solvable with only\ntwo states, but the number of states in two-way alternating or any simpler\nautomata is not limited by a constant. Moreover, we show that one-way\nbounded-error probabilistic automata can solve promise problems not solvable at\nall by any other classical model.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.6671v2"
    },
    {
        "title": "Symbolic Algorithms for Language Equivalence and Kleene Algebra with\n  Tests",
        "authors": [
            "Damien Pous"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We first propose algorithms for checking language equivalence of finite\nautomata over a large alphabet. We use symbolic automata, where the transition\nfunction is compactly represented using a (multi-terminal) binary decision\ndiagrams (BDD). The key idea consists in computing a bisimulation by exploring\nreachable pairs symbolically, so as to avoid redundancies. This idea can be\ncombined with already existing optimisations, and we show in particular a nice\nintegration with the disjoint sets forest data-structure from Hopcroft and\nKarp's standard algorithm. Then we consider Kleene algebra with tests (KAT), an\nalgebraic theory that can be used for verification in various domains ranging\nfrom compiler optimisation to network programming analysis. This theory is\ndecidable by reduction to language equivalence of automata on guarded strings,\na particular kind of automata that have exponentially large alphabets. We\npropose several methods allowing to construct symbolic automata out of KAT\nexpressions, based either on Brzozowski's derivatives or standard automata\nconstructions. All in all, this results in efficient algorithms for deciding\nequivalence of KAT expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.3213v1"
    },
    {
        "title": "A New Model of Array Grammar for generating Connected Patterns on an\n  Image Neighborhood",
        "authors": [
            "G. Vishnu Murthy",
            "Pavan Kumar C.",
            "Vakulabharanam Vijaya Kumar"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Study of patterns on images is recognized as an important step in\ncharacterization and classification of image. The ability to efficiently\nanalyze and describe image patterns is thus of fundamental importance. The\nstudy of syntactic methods of describing pictures has been of interest for\nresearchers. Array Grammars can be used to represent and recognize connected\npatterns. In any image the patterns are recognized using connected patterns. It\nis very difficult to represent all connected patterns (CP) even on a small 3 x\n3 neighborhood in a pictorial way. The present paper proposes the model of\narray grammar capable of generating any kind of simple or complex pattern and\nderivation of connected pattern in an image neighborhood using the proposed\ngrammar is discussed.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.8337v1"
    },
    {
        "title": "Broadcasting Automata and Patterns on Z^2",
        "authors": [
            "Thomas Nickson",
            "Igor Potapov"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The Broadcasting Automata model draws inspiration from a variety of sources\nsuch as Ad-Hoc radio networks, cellular automata, neighbourhood se- quences and\nnature, employing many of the same pattern forming methods that can be seen in\nthe superposition of waves and resonance. Algorithms for broad- casting\nautomata model are in the same vain as those encountered in distributed\nalgorithms using a simple notion of waves, messages passed from automata to au-\ntomata throughout the topology, to construct computations. The waves generated\nby activating processes in a digital environment can be used for designing a\nvari- ety of wave algorithms. In this chapter we aim to study the geometrical\nshapes of informational waves on integer grid generated in broadcasting\nautomata model as well as their potential use for metric approximation in a\ndiscrete space. An explo- ration of the ability to vary the broadcasting radius\nof each node leads to results of categorisations of digital discs, their form,\ncomposition, encodings and gener- ation. Results pertaining to the nodal\npatterns generated by arbitrary transmission radii on the plane are explored\nwith a connection to broadcasting sequences and ap- proximation of discrete\nmetrics of which results are given for the approximation of astroids, a\npreviously unachievable concave metric, through a novel application of the\naggregation of waves via a number of explored functions.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.0573v1"
    },
    {
        "title": "Logics with rigidly guarded data tests",
        "authors": [
            "Gabriele Puppis",
            "Thomas Colcombet",
            "Clemens Ley"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The notion of orbit finite data monoid was recently introduced by Bojanczyk\nas an algebraic object for defining recognizable languages of data words.\nFollowing Buchi's approach, we introduce a variant of monadic second-order\nlogic with data equality tests that captures precisely the data languages\nrecognizable by orbit finite data monoids. We also establish, following this\ntime the approach of Schutzenberger, McNaughton and Papert, that the\nfirst-order fragment of this logic defines exactly the data languages\nrecognizable by aperiodic orbit finite data monoids. Finally, we consider\nanother variant of the logic that can be interpreted over generic structures\nwith data. The data languages defined in this variant are also recognized by\nunambiguous finite memory automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.2022v3"
    },
    {
        "title": "Analysing oscillatory trends of discrete-state stochastic processes\n  through HASL statistical model checking",
        "authors": [
            "Paolo Ballarini"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The application of formal methods to the analysis of stochastic oscillators\nhas been at the focus of several research works in recent times. In this paper\nwe provide insights on the application of an expressive temporal logic\nformalism, namely the Hybrid Automata Stochastic Logic (HASL), to that issue.\nWe show how one can take advantage of the expressive power of the HASL logic to\ndefine and assess relevant characteristics of (stochastic) oscillators.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.4027v1"
    },
    {
        "title": "On Torsion-Free Semigroups Generated by Invertible Reversible Mealy\n  Automata",
        "authors": [
            "Thibault Godin",
            "Ines Klimann",
            "Matthieu Picantin"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  This paper addresses the torsion problem for a class of automaton semigroups,\ndefined as semigroups of transformations induced by Mealy automata, aka\nletter-by-letter transducers with the same input and output alphabet. The\ntorsion problem is undecidable for automaton semigroups in general, but is\nknown to be solvable within the well-studied class of (semi)groups generated by\ninvertible bounded Mealy automata. We focus on the somehow antipodal class of\ninvertible reversible Mealy automata and prove that for a wide subclass the\ngenerated semigroup is torsion-free.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.4488v2"
    },
    {
        "title": "A Survey on the Local Divisor Technique",
        "authors": [
            "Volker Diekert",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Local divisors allow a powerful induction scheme on the size of a monoid. We\nsurvey this technique by giving several examples of this proof method. These\napplications include linear temporal logic, rational expressions with Kleene\nstars restricted to prefix codes with bounded synchronization delay,\nChurch-Rosser congruential languages, and Simon's Factorization Forest Theorem.\nWe also introduce the notion of localizable language class as a new abstract\nconcept which unifies some of the proofs for the results above. The current\narXiv-version includes some additional material about codes of bounded\nsynchronization delay as well as some updates concerning related literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.6026v4"
    },
    {
        "title": "From Orchestration to Choreography through Contract Automata",
        "authors": [
            "Davide Basile",
            "Pierpaolo Degano",
            "Gian-Luigi Ferrari",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the relations between a contract automata and an interaction model.\nIn the former model, distributed services are abstracted away as automata -\noblivious of their partners - that coordinate with each other through an\norchestrator. The interaction model relies on channel-based asynchronous\ncommunication and choreography to coordinate distributed services.\n  We define a notion of strong agreement on the contract model, exhibit a\nnatural mapping from the contract model to the interaction model, and give\nconditions to ensure that strong agreement corresponds to well-formed\nchoreography.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.7471v1"
    },
    {
        "title": "Cost Preserving Bisimulations for Probabilistic Automata",
        "authors": [
            "Andrea Turrini",
            "Holger Hermanns"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Probabilistic automata constitute a versatile and elegant model for\nconcurrent probabilistic systems. They are equipped with a compositional theory\nsupporting abstraction, enabled by weak probabilistic bisimulation serving as\nthe reference notion for summarising the effect of abstraction. This paper\nconsiders probabilistic automata augmented with costs. It extends the notions\nof weak transitions in probabilistic automata in such a way that the costs\nincurred along a weak transition are captured. This gives rise to\ncost-preserving and cost-bounding variations of weak probabilistic\nbisimilarity, for which we establish compositionality properties with respect\nto parallel composition. Furthermore, polynomial-time decision algorithms are\nproposed, that can be effectively used to compute reward-bounding abstractions\nof Markov decision processes in a compositional manner.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.8314v3"
    },
    {
        "title": "Profinite Techniques for Probabilistic Automata and the Markov Monoid\n  Algorithm",
        "authors": [
            "Nathanaël Fijalkow"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider the value 1 problem for probabilistic automata over finite words:\nit asks whether a given probabilistic automaton accepts words with probability\narbitrarily close to 1. This problem is known to be undecidable. However,\ndifferent algorithms have been proposed to partially solve it; it has been\nrecently shown that the Markov Monoid algorithm, based on algebra, is the most\ncorrect algorithm so far. The first contribution of this paper is to give a\ncharacterisation of the Markov Monoid algorithm. The second contribution is to\ndevelop a profinite theory for probabilistic automata, called the prostochastic\ntheory. This new framework gives a topological account of the value 1 problem,\nwhich in this context is cast as an emptiness problem. The above\ncharacterisation is reformulated using the prostochastic theory, allowing us to\ngive a simple and modular proof.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.02997v4"
    },
    {
        "title": "The ModelCC Model-Based Parser Generator",
        "authors": [
            "Luis Quesada",
            "Fernando Berzal",
            "Juan-Carlos Cubero"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Formal languages let us define the textual representation of data with\nprecision. Formal grammars, typically in the form of BNF-like productions,\ndescribe the language syntax, which is then annotated for syntax-directed\ntranslation and completed with semantic actions. When, apart from the textual\nrepresentation of data, an explicit representation of the corresponding data\nstructure is required, the language designer has to devise the mapping between\nthe suitable data model and its proper language specification, and then develop\nthe conversion procedure from the parse tree to the data model instance.\nUnfortunately, whenever the format of the textual representation has to be\nmodified, changes have to propagated throughout the entire language processor\ntool chain. These updates are time-consuming, tedious, and error-prone.\nBesides, in case different applications use the same language, several copies\nof the same language specification have to be maintained. In this paper, we\nintroduce ModelCC, a model-based parser generator that decouples language\nspecification from language processing, hence avoiding many of the problems\ncaused by grammar-driven parsers and parser generators. ModelCC incorporates\nreference resolution within the parsing process. Therefore, instead of\nreturning mere abstract syntax trees, ModelCC is able to obtain abstract syntax\ngraphs from input strings.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.03458v1"
    },
    {
        "title": "A One-Dimensional Physically Universal Cellular Automaton",
        "authors": [
            "Ville Salo",
            "Ilkka Törmä"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Physical universality of a cellular automaton was defined by Janzing in 2010\nas the ability to implement an arbitrary transformation of spatial patterns. In\n2014, Schaeffer gave a construction of a two-dimensional physically universal\ncellular automaton. We construct a one-dimensional version of the automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.03988v2"
    },
    {
        "title": "On the Control of Asynchronous Automata",
        "authors": [
            "Hugo Gimbert"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The decidability of the distributed version of the Ramadge and Wonham\ncontroller synthesis problem,where both the plant and the controllers are\nmodeled as asynchronous automataand the controllers have causal memoryis a\nchallenging open problem.There exist three classes of plants for which the\nexistence of a correct controller with causal memory has been shown decidable:\nwhen the dependency graph of actions is series-parallel, when the processes are\nconnectedly communicating and when the dependency graph of processes is a tree.\nWe design a class of plants, called decomposable games, with a decidable\ncontroller synthesis problem.This provides a unified proof of the three\nexisting decidability results as well as new examples of decidable plants.\n",
        "pdf_link": "http://arxiv.org/pdf/1601.05176v12"
    },
    {
        "title": "Nominal Automata with Name Binding",
        "authors": [
            "Lutz Schröder",
            "Dexter Kozen",
            "Stefan Milius",
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Automata models for data languages (i.e. languages over infinite alphabets)\noften feature either global or local freshness operators. We show that Bollig\net al.'s session automata, which focus on global freshness, are equivalent to\nregular nondeterministic nominal automata (RNNA), a natural nominal automaton\nmodel with explicit name binding that has appeared implicitly in the semantics\nof nominal Kleene algebra (NKA), an extension of Kleene algebra with name\nbinding. The expected Kleene theorem for NKA is known to fail in one direction,\ni.e. there are nominal languages that can be accepted by an RNNA but are not\ndefinable in NKA; via session automata, we obtain a full Kleene theorem for\nRNNAs for an expression language that extends NKA with unscoped name binding.\nBased on the equivalence with RNNAs, we then slightly rephrase the known\nequivalence checking algorithm for session automata. Reinterpreting the data\nlanguage semantics of name binding by unrestricted instead of clean\nalpha-equivalence, we obtain a local freshness semantics as a quotient of the\nglobal freshness semantics. Under local freshness semantics, RNNAs turn out to\nbe equivalent to a natural subclass of Bojanczyk et al.'s nondeterministic\norbit-finite automata. We establish decidability of inclusion under local\nfreshness by modifying the RNNA-based algorithm; in summary, we obtain a\nformalism for local freshness in data languages that is reasonably expressive\nand has a decidable inclusion problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.01455v4"
    },
    {
        "title": "Prediction of Infinite Words with Automata",
        "authors": [
            "Tim Smith"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In the classic problem of sequence prediction, a predictor receives a\nsequence of values from an emitter and tries to guess the next value before it\nappears. The predictor masters the emitter if there is a point after which all\nof the predictor's guesses are correct. In this paper we consider the case in\nwhich the predictor is an automaton and the emitted values are drawn from a\nfinite set; i.e., the emitted sequence is an infinite word. We examine the\npredictive capabilities of finite automata, pushdown automata, stack automata\n(a generalization of pushdown automata), and multihead finite automata. We\nrelate our predicting automata to purely periodic words, ultimately periodic\nwords, and multilinear words, describing novel prediction algorithms for\nmastering these sequences.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.02597v1"
    },
    {
        "title": "Solutions of Word Equations over Partially Commutative Structures",
        "authors": [
            "Volker Diekert",
            "Artur Jeż",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We give NSPACE(n log n) algorithms solving the following decision problems.\nSatisfiability: Is the given equation over a free partially commutative monoid\nwith involution (resp. a free partially commutative group) solvable?\nFiniteness: Are there only finitely many solutions of such an equation? PSPACE\nalgorithms with worse complexities for the first problem are known, but so far,\na PSPACE algorithm for the second problem was out of reach. Our results are\nmuch stronger: Given such an equation, its solutions form an EDT0L language\neffectively representable in NSPACE(n log n). In particular, we give an\neffective description of the set of all solutions for equations with\nconstraints in free partially commutative monoids and groups.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.02966v1"
    },
    {
        "title": "A short proof that $O_2$ is an MCFL",
        "authors": [
            "Mark-Jan Nederhof"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present a new proof that $O_2$ is a multiple context-free language. It\ncontrasts with a recent proof by Salvati (2015) in its avoidance of concepts\nthat seem specific to two-dimensional geometry, such as the complex exponential\nfunction. Our simple proof creates realistic prospects of widening the results\nto higher dimensions. This finding is of central importance to the relation\nbetween extreme free word order and classes of grammars used to describe the\nsyntax of natural language.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.03610v1"
    },
    {
        "title": "A Short Note on Infinite Union/Intersection of Omega Regular Languages",
        "authors": [
            "Wanwei Liu"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We in this paper show that omega regular languages are not closed under\ninfinite union and intersection. As an attempt, we propose to add step\nvariables and quantifiers to temporal logics to enhance the expressiveness of\nthe underlying logic. We also show that doing this would cause undecidability\nin satisfiability, even if for a rather limited fragment of temporal logic.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.05426v1"
    },
    {
        "title": "On the star-height of factor counting languages and their relationship\n  to Rees zero-matrix semigroups",
        "authors": [
            "Tom Bourne",
            "Nik Ruskuc"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Given a word $w$ over a finite alphabet, we consider, in three special cases,\nthe generalised star-height of the languages in which $w$ occurs as a\ncontiguous subword (factor) an exact number of times and of the languages in\nwhich $w$ occurs as a contiguous subword modulo a fixed number, and prove that\nin each case it is at most one. We use these combinatorial results to show that\nany language recognised by a Rees (zero-)matrix semigroup over an abelian group\nis of generalised star-height at most one.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.06236v2"
    },
    {
        "title": "Array Folds Logic",
        "authors": [
            "Przemysław Daca",
            "Thomas A. Henzinger",
            "Andrey Kupriyanov"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present an extension to the quantifier-free theory of integer arrays which\nallows us to express counting. The properties expressible in Array Folds Logic\n(AFL) include statements such as \"the first array cell contains the array\nlength,\" and \"the array contains equally many minimal and maximal elements.\"\nThese properties cannot be expressed in quantified fragments of the theory of\narrays, nor in the theory of concatenation. Using reduction to counter\nmachines, we show that the satisfiability problem of AFL is PSPACE-complete,\nand with a natural restriction the complexity decreases to NP. We also show\nthat adding either universal quantifiers or concatenation leads to\nundecidability.\n  AFL contains terms that fold a function over an array. We demonstrate that\nfolding, a well-known concept from functional languages, allows us to concisely\nsummarize loops that count over arrays, which occurs frequently in real-life\nprograms. We provide a tool that can discharge proof obligations in AFL, and we\ndemonstrate on practical examples that our decision procedure can solve a broad\nrange of problems in symbolic testing and program verification.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.06850v3"
    },
    {
        "title": "Weighted Pushdown Systems with Indexed Weight Domains",
        "authors": [
            "Yasuhiko Minamide"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The reachability analysis of weighted pushdown systems is a very powerful\ntechnique in verification and analysis of recursive programs. Each transition\nrule of a weighted pushdown system is associated with an element of a bounded\nsemiring representing the weight of the rule. However, we have realized that\nthe restriction of the boundedness is too strict and the formulation of\nweighted pushdown systems is not general enough for some applications. To\ngeneralize weighted pushdown systems, we first introduce the notion of stack\nsignatures that summarize the effect of a computation of a pushdown system and\nformulate pushdown systems as automata over the monoid of stack signatures. We\nthen generalize weighted pushdown systems by introducing semirings indexed by\nthe monoid and weaken the boundedness to local boundedness.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.07790v3"
    },
    {
        "title": "The Diagonal Problem for Higher-Order Recursion Schemes is Decidable",
        "authors": [
            "Lorenzo Clemente",
            "Paweł Parys",
            "Sylvain Salvati",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  A non-deterministic recursion scheme recognizes a language of finite trees.\nThis very expressive model can simulate, among others, higher-order pushdown\nautomata with collapse. We show decidability of the diagonal problem for\nschemes. This result has several interesting consequences. In particular, it\ngives an algorithm that computes the downward closure of languages of words\nrecognized by schemes. In turn, this has immediate application to separability\nproblems and reachability analysis of concurrent systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.00371v1"
    },
    {
        "title": "Topological language for RNA",
        "authors": [
            "Fenix W. D. Huang",
            "Christian M. Reidys"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper we introduce a novel, context-free grammar, {\\it\nRNAFeatures$^*$}, capable of generating any RNA structure including pseudoknot\nstructures (pk-structure). We represent pk-structures as orientable fatgraphs,\nwhich naturally leads to a filtration by their topological genus. Within this\nframework, RNA secondary structures correspond to pk-structures of genus zero.\n{\\it RNAFeatures$^*$} acts on formal, arc-labeled RNA secondary structures,\ncalled $\\lambda$-structures. $\\lambda$-structures correspond one-to-one to\npk-structures together with some additional information. This information\nconsists of the specific rearrangement of the backbone, by which a pk-structure\ncan be made cross-free. {\\it RNAFeatures$^*$} is an extension of the grammar\nfor secondary structures and employs an enhancement by labelings of the symbols\nas well as the production rules. We discuss how to use {\\it RNAFeatures$^*$} to\nobtain a stochastic context-free grammar for pk-structures, using data of RNA\nsequences and structures. The induced grammar facilitates fast Boltzmann\nsampling and statistical analysis. As a first application, we present an $O(n\nlog(n))$ runtime algorithm which samples pk-structures based on ninety tRNA\nsequences and structures from the Nucleic Acid Database (NDB).\n",
        "pdf_link": "http://arxiv.org/pdf/1605.02628v1"
    },
    {
        "title": "A Relatively Small Turing Machine Whose Behavior Is Independent of Set\n  Theory",
        "authors": [
            "Adam Yedidia",
            "Scott Aaronson"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Since the definition of the Busy Beaver function by Rado in 1962, an\ninteresting open question has been the smallest value of n for which BB(n) is\nindependent of ZFC set theory. Is this n approximately 10, or closer to\n1,000,000, or is it even larger? In this paper, we show that it is at most\n7,910 by presenting an explicit description of a 7,910-state Turing machine Z\nwith 1 tape and a 2-symbol alphabet that cannot be proved to run forever in ZFC\n(even though it presumably does), assuming ZFC is consistent. The machine is\nbased on the work of Harvey Friedman on independent statements involving\norder-invariant graphs. In doing so, we give the first known upper bound on the\nhighest provable Busy Beaver number in ZFC. To create Z, we develop and use a\nhigher-level language, Laconic, which is much more convenient than direct state\nmanipulation. We also use Laconic to design two Turing machines, G and R, that\nhalt if and only if there are counterexamples to Goldbach's Conjecture and the\nRiemann Hypothesis, respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.04343v1"
    },
    {
        "title": "Montre: A Tool for Monitoring Timed Regular Expressions",
        "authors": [
            "Dogan Ulus"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We present Montre, a monitoring tool to search patterns specified by timed\nregular expressions over real-time behaviors. We use timed regular expressions\nas a compact, natural, and highly-expressive pattern specification language for\nmonitoring applications involving quantitative timing constraints. Our tool\nessentially incorporates online and offline timed pattern matching algorithms\nso it is capable of finding all occurrences of a given pattern over both logged\nand streaming behaviors. Furthermore, Montre is designed to work with other\ntools via standard interfaces to perform more complex and versatile tasks for\nanalyzing and reasoning about cyber-physical systems. As the first of its kind,\nwe believe Montre will enable a new line of inquiries and techniques in these\nfields.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.05963v2"
    },
    {
        "title": "Learning Moore Machines from Input-Output Traces",
        "authors": [
            "Georgios Giantamidis",
            "Stavros Tripakis"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The problem of learning automata from example traces (but no equivalence or\nmembership queries) is fundamental in automata learning theory and practice. In\nthis paper we study this problem for finite state machines with inputs and\noutputs, and in particular for Moore machines. We develop three algorithms for\nsolving this problem: (1) the PTAP algorithm, which transforms a set of\ninput-output traces into an incomplete Moore machine and then completes the\nmachine with self-loops; (2) the PRPNI algorithm, which uses the well-known\nRPNI algorithm for automata learning to learn a product of automata encoding a\nMoore machine; and (3) the MooreMI algorithm, which directly learns a Moore\nmachine using PTAP extended with state merging. We prove that MooreMI has the\nfundamental identification in the limit property. We also compare the\nalgorithms experimentally in terms of the size of the learned machine and\nseveral notions of accuracy, introduced in this paper. Finally, we compare with\nOSTIA, an algorithm that learns a more general class of transducers, and find\nthat OSTIA generally does not learn a Moore machine, even when fed with a\ncharacteristic sample.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.07805v2"
    },
    {
        "title": "Amenability of groups is characterized by Myhill's Theorem",
        "authors": [
            "Laurent Bartholdi",
            "Dawid Kielak"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We prove a converse to Myhill's \"Garden-of-Eden\" theorem and obtain in this\nmanner a characterization of amenability in terms of cellular automata: \"A\ngroup $G$ is amenable if and only if every cellular automaton with carrier $G$\nthat has gardens of Eden also has mutually erasable patterns.\"\n  This answers a question by Schupp, and solves a conjecture by\nCeccherini-Silberstein, Mach\\`i and Scarabotti.\n  An appendix by Dawid Kielak proves that group rings without zero divisors are\nOre domains precisely when the group is amenable, answering a conjecture\nattributed to Guba.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.09133v2"
    },
    {
        "title": "On level-transitivity and exponential growth",
        "authors": [
            "Ines Klimann"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We prove that if the group generated by a Mealy automaton acts\nlevel-transitively on a regular rooted tree, then the semigroup generated by\nthe dual automaton has exponential growth, hence giving a decision procedure of\nexponential growth for a restricted family of automaton semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.09579v2"
    },
    {
        "title": "One-way definability of two-way word transducers",
        "authors": [
            "Félix Baschenis",
            "Olivier Gauwin",
            "Anca Muscholl",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Functional transductions realized by two-way transducers (or, equally, by\nstreaming transducers or MSO transductions) are the natural and standard notion\nof \"regular\" mappings from words to words. It was shown in 2013 that it is\ndecidable if such a transduction can be implemented by some one-way transducer,\nbut the given algorithm has non-elementary complexity. We provide an algorithm\nof different flavor solving the above question, that has doubly exponential\nspace complexity. In the special case of sweeping transducers the complexity is\none exponential less. We also show how to construct an equivalent one-way\ntransducer, whenever it exists, in doubly or triply exponential time, again\ndepending on whether the input transducer is sweeping or two-way. In the\nsweeping case our construction is shown to be optimal.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.01668v3"
    },
    {
        "title": "Turing Completeness of Finite, Epistemic Programs",
        "authors": [
            "Dominik Klein",
            "Rasmus K. Rendsvig"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  In this note, we show the class of finite, epistemic programs to be Turing\ncomplete. Epistemic programs is a widely used update mechanism used in\nepistemic logic, where it such are a special type of action models: One which\ndoes not contain postconditions.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.06845v1"
    },
    {
        "title": "On Nonnegative Integer Matrices and Short Killing Words",
        "authors": [
            "Stefan Kiefer",
            "Corto Mascle"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Let $n$ be a natural number and $\\mathcal{M}$ a set of $n \\times n$-matrices\nover the nonnegative integers such that the joint spectral radius of\n$\\mathcal{M}$ is at most one. We show that if the zero matrix $0$ is a product\nof matrices in $\\mathcal{M}$, then there are $M_1, \\ldots, M_{n^5} \\in\n\\mathcal{M}$ with $M_1 \\cdots M_{n^5} = 0$. This result has applications in\nautomata theory and the theory of codes. Specifically, if $X \\subset \\Sigma^*$\nis a finite incomplete code, then there exists a word $w \\in \\Sigma^*$ of\nlength polynomial in $\\sum_{x \\in X} |x|$ such that $w$ is not a factor of any\nword in $X^*$. This proves a weak version of Restivo's conjecture.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.00940v4"
    },
    {
        "title": "TeSSLa: Temporal Stream-based Specification Language",
        "authors": [
            "Lukas Convent",
            "Sebastian Hungerecker",
            "Martin Leucker",
            "Torben Scheffel",
            "Malte Schmitz",
            "Daniel Thoma"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Runtime verification is concerned with monitoring program traces. In\nparticular, stream runtime verification (SRV) takes the program trace as input\nstreams and incrementally derives output streams. SRV can check logical\nproperties and compute temporal metrics and statistics from the trace. We\npresent TeSSLa, a temporal stream-based specification language for SRV. TeSSLa\nsupports timestamped events natively and is hence suitable for streams that are\nboth sparse and fine-grained, which often occur in practice. We prove results\non TeSSLa's expressiveness and compare different TeSSLa fragments to (timed)\nautomata, thereby inheriting various decidability results. Finally, we present\na monitor implementation and prove its correctness.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.10717v1"
    },
    {
        "title": "Regular omega-Languages with an Informative Right Congruence",
        "authors": [
            "Dana Angluin",
            "Dana Fisman"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  A regular language is almost fully characterized by its right congruence\nrelation. Indeed, a regular language can always be recognized by a DFA\nisomorphic to the automaton corresponding to its right congruence, henceforth\nthe Rightcon automaton. The same does not hold for regular omega-languages. The\nright congruence of a regular omega-language is not informative enough; many\nregular omega-languages have a trivial right congruence, and in general it is\nnot always possible to define an omega-automaton recognizing a given language\nthat is isomorphic to the rightcon automaton.\n  The class of weak regular omega-languages does have an informative right\ncongruence. That is, any weak regular omega-language can always be recognized\nby a deterministic B\\\"uchi automaton that is isomorphic to the rightcon\nautomaton. Weak regular omega-languages reside in the lower levels of the\nexpressiveness hierarchy of regular omega-languages. Are there more expressive\nsub-classes of regular omega languages that have an informative right\ncongruence? Can we fully characterize the class of languages with a trivial\nright congruence? In this paper we try to place some additional pieces of this\nbig puzzle.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.03108v1"
    },
    {
        "title": "Bounded Synthesis of Register Transducers",
        "authors": [
            "Ayrat Khalimov",
            "Benedikt Maderbacher",
            "Roderick Bloem"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Reactive synthesis aims at automatic construction of systems from their\nbehavioural specifications. The research mostly focuses on synthesis of systems\ndealing with Boolean signals. But real-life systems are often described using\nbit-vectors, integers, etc. Bit-blasting would make such systems unreadable,\nhit synthesis scalability, and is not possible for infinite data-domains. One\nstep closer to real-life systems are register transducers: they can store\ndata-input into registers and later output the content of a register, but they\ndo not directly depend on the data-input, only on its comparison with the\nregisters. Previously it was proven that synthesis of register transducers from\nregister automata is undecidable, but there the authors considered transducers\nequipped with the unbounded queue of registers. First, we prove the problem\nbecomes decidable if bound the number of registers in transducers, by reducing\nthe problem to standard synthesis of Boolean systems. Second, we show how to\nuse quantified temporal logic, instead of automata, for specifications.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.05017v1"
    },
    {
        "title": "The Reachability Problem for Petri Nets is Not Elementary",
        "authors": [
            "Wojciech Czerwinski",
            "Slawomir Lasota",
            "Ranko Lazic",
            "Jerome Leroux",
            "Filip Mazowiecki"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Petri nets, also known as vector addition systems, are a long established\nmodel of concurrency with extensive applications in modelling and analysis of\nhardware, software and database systems, as well as chemical, biological and\nbusiness processes. The central algorithmic problem for Petri nets is\nreachability: whether from the given initial configuration there exists a\nsequence of valid execution steps that reaches the given final configuration.\nThe complexity of the problem has remained unsettled since the 1960s, and it is\none of the most prominent open questions in the theory of verification.\nDecidability was proved by Mayr in his seminal STOC 1981 work, and the\ncurrently best published upper bound is non-primitive recursive Ackermannian of\nLeroux and Schmitz from LICS 2019. We establish a non-elementary lower bound,\ni.e. that the reachability problem needs a tower of exponentials of time and\nspace. Until this work, the best lower bound has been exponential space, due to\nLipton in 1976. The new lower bound is a major breakthrough for several\nreasons. Firstly, it shows that the reachability problem is much harder than\nthe coverability (i.e., state reachability) problem, which is also ubiquitous\nbut has been known to be complete for exponential space since the late 1970s.\nSecondly, it implies that a plethora of problems from formal languages, logic,\nconcurrent systems, process calculi and other areas, that are known to admit\nreductions from the Petri nets reachability problem, are also not elementary.\nThirdly, it makes obsolete the currently best lower bounds for the reachability\nproblems for two key extensions of Petri nets: with branching and with a\npushdown stack.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.07115v4"
    },
    {
        "title": "Towards a classification of Lindenmayer systems",
        "authors": [
            "Diego Krivochen",
            "Douglas Saddy"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper we will attempt to classify Lindenmayer systems based on\nproperties of sets of rules and the kind of strings those rules generate. This\nclassification will be referred to as a parametrization of the L-space: the\nL-space is the phase space in which all possible L-developments are\nrepresented. This space is infinite, because there is no halting algorithm for\nL-grammars; but it is also subjected to hard conditions, because there are\ngrammars and developments which are not possible states of an L-system: a very\nwell-known example is the space of normal grammars. Just as the space of normal\ngrammars is parametrized into Regular, Context-Free, Context-Sensitive, and\nUnrestricted (with proper containment relations holding among them; see\nChomsky, 1959: Theorem 1), we contend here that the L-space is a very rich\nlandscape of grammars which cluster into kinds that are not mutually\ntranslatable.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.10542v1"
    },
    {
        "title": "De Bruijn graphs and powers of $3/2$",
        "authors": [
            "Oleksiy Kurganskyy",
            "Igor Potapov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper we consider the set ${\\mathbb Z}^{\\pm\\omega}_{6}$ of two-way\ninfinite words $\\xi$ over the alphabet $\\{0,1,2,3,4,5\\}$ with the integer left\npart $\\lfloor\\xi\\rfloor$ and the fractional right part $\\{\\xi\\}$ separated by a\nradix point. For such words, the operation of multiplication by integers and\ndivision by $6$ are defined as the column multiplication and division in base 6\nnumerical system. The paper develops a finite automata approach for analysis of\nsequences $\\left (\\left \\lfloor \\xi \\left (\\frac{3}{2} \\right)^n \\right \\rfloor\n\\right)_{n \\in {\\mathbb Z}}$ for the words $\\xi \\in {\\mathbb Z}^{\\pm\n\\omega}_{6}$ that have some common properties with $Z$-numbers in Mahler's\n$3/2$-problem. Such sequence of $Z$-words written under each other with the\nsame digit positions in the same column is an infinite $2$-dimensional word\nover the alphabet ${\\mathbb Z}_6$. The automata representation of the columns\nin the integer part of $2$-dimensional $Z$-words has the nice structural\nproperties of the de Bruijn graphs. This way provides some sufficient\nconditions for the emptiness of the set of $Z$-numbers. Our approach has been\ninitially inspirated by the proposition 2.5 in [1] where authors applies\ncellular automata for analysis of\n$\\left(\\left\\{\\xi\\left(\\frac{3}{2}\\right)^n\\right\\} \\right)_{n\\in{\\mathbb Z}}$,\n$\\xi\\in{\\mathbb R}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.02254v2"
    },
    {
        "title": "Decision Procedures for Path Feasibility of String-Manipulating Programs\n  with Complex Operations",
        "authors": [
            "Taolue Chen",
            "Matthew Hague",
            "Anthony W. Lin",
            "Philipp Rümmer",
            "Zhilin Wu"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  The design and implementation of decision procedures for checking path\nfeasibility in string-manipulating programs is an important problem, whose\napplications include symbolic execution and automated detection of cross-site\nscripting (XSS) vulnerabilities. A (symbolic) path is a finite sequence of\nassignments and assertions (i.e. without loops), and checking its feasibility\namounts to determining the existence of inputs that yield a successful\nexecution.\n  We give two general semantic conditions which together ensure the\ndecidability of path feasibility: (1) each assertion admits regular monadic\ndecomposition, and (2) each assignment uses a (possibly nondeterministic)\nfunction whose inverse relation preserves regularity. We show these conditions\nare expressive since they are satisfied by a multitude of string operations.\nThey also strictly subsume existing decidable string theories, and most\nexisting benchmarks (e.g. most of Kaluza's, and all of SLOG's, Stranger's, and\nSLOTH's). We give a simple decision procedure and an extensible architecture of\na string solver in that a user may easily incorporate his/her own string\nfunctions. We show the general fragment has a tight, but high complexity. To\naddress this, we propose to allow only partial string functions (i.e., prohibit\nnondeterminism) in condition (2). When nondeterministic functions are needed,\nwe also provide a syntactic fragment that provides a support of\nnondeterministic functions but can be reduced to an existing solver SLOTH.\n  We provide an efficient implementation of our decision procedure for\ndeterministic partial string functions in a new string solver OSTRICH. It\nprovides built-in support for concatenation, reverse, functional transducers,\nand replaceall and provides a framework for extensibility to support further\nstring functions. We demonstrate the efficacy of our new solver against other\ncompetitive solvers.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.03167v1"
    },
    {
        "title": "Formal FocusST Specification of CAN",
        "authors": [
            "Maria Spichkova"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  This paper presents a formal specification of the Controller Area Network\n(CAN) protocol using FocusST framework. We formally describe core components of\nthe protocol, which provides a basis for further formal analysis using the\nIsabelle/HOL theorem prover.\n",
        "pdf_link": "http://arxiv.org/pdf/1811.08128v1"
    },
    {
        "title": "On the Structure Theory of Partial Automaton Semigroups",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study automaton structures, i.e. groups, monoids and semigroups generated\nby an automaton, which, in this context, means a deterministic finite-state\nletter-to-letter transducer. Instead of considering only complete automata, we\nspecifically investigate semigroups generated by partial automata. First, we\nshow that the class of semigroups generated by partial automata coincides with\nthe class of semigroups generated by complete automata if and only if the\nlatter class is closed under removing a previously adjoined zero, which is an\nopen problem in (complete) automaton semigroup theory stated by Cain. Then, we\nshow that no semidirect product (and, thus, also no direct product) of an\narbitrary semigroup with a (non-trivial) subsemigroup of the free monogenic\nsemigroup is an automaton semigroup. Finally, we concentrate on inverse\nsemigroups generated by invertible but partial automata, which we call\nautomaton-inverse semigroups, and show that any inverse automaton semigroup can\nbe generated by such an automaton (showing that automaton-inverse semigroups\nand inverse automaton semigroups coincide).\n",
        "pdf_link": "http://arxiv.org/pdf/1811.09420v3"
    },
    {
        "title": "Causality Analysis for Concurrent Reactive Systems (Extended Abstract)",
        "authors": [
            "Rayna Dimitrova",
            "Rupak Majumdar",
            "Vinayak S. Prabhu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present a comprehensive language theoretic causality analysis framework\nfor explaining safety property violations in the setting of concurrent reactive\nsystems. Our framework allows us to uniformly express a number of causality\nnotions studied in the areas of artificial intelligence and formal methods, as\nwell as define new ones that are of potential interest in these areas.\nFurthermore, our formalization provides means for reasoning about the\nrelationships between individual notions which have mostly been considered\nindependently in prior work; and allows us to judge the appropriateness of the\ndifferent definitions for various applications in system design. In particular,\nwe consider causality analysis notions for debugging, error resilience, and\nliability resolution in concurrent reactive systems. Finally, we present\nautomata-based algorithms for computing various causal sets based on our\nlanguage-theoretic encoding, and derive the algorithmic complexities.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.00589v1"
    },
    {
        "title": "Equivalence Checking of Quantum Finite-State Machines",
        "authors": [
            "Qisheng Wang",
            "Junyi Liu",
            "Mingsheng Ying"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper, we introduce the model of quantum Mealy machines and study the\nequivalence checking and minimisation problems of them. Two efficient\nalgorithms are developed for checking equivalence of two states in the same\nmachine and for checking equivalence of two machines. As an application, they\nare used in equivalence checking of quantum circuits. Moreover, the\nminimisation problem is proved to be in $\\textbf{PSPACE}$.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.02173v3"
    },
    {
        "title": "Languages ordered by the subword order",
        "authors": [
            "Dietrich Kuske",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We consider a language together with the subword relation, the cover\nrelation, and regular predicates. For such structures, we consider the\nextension of first-order logic by threshold- and modulo-counting quantifiers.\nDepending on the language, the used predicates, and the fragment of the logic,\nwe determine four new combinations that yield decidable theories. These results\nextend earlier ones where only the language of all words without the cover\nrelation and fragments of first-order logic were considered.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.02194v1"
    },
    {
        "title": "A model for a Lindenmayer reconstruction algorithm",
        "authors": [
            "Diego Gabriel Krivochen",
            "Beth Phillips"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Given an input string s and a specific Lindenmayer system (the so-called\nFibonacci grammar), we define an automaton which is capable of (i) determining\nwhether s belongs to the set of strings that the Fibonacci grammar can generate\n(in other words, if s corresponds to a generation of the grammar) and, if so,\n(ii) reconstructing the previous generation.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.08407v1"
    },
    {
        "title": "Logics for Reversible Regular Languages and Semigroups with Involution",
        "authors": [
            "Paul Gastin",
            "Amaldev Manuel",
            "R. Govind"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We present MSO and FO logics with predicates `between' and `neighbour' that\ncharacterise various fragments of the class of regular languages that are\nclosed under the reverse operation. The standard connections that exist between\nMSO and FO logics and varieties of finite semigroups extend to this setting\nwith semigroups extended with an involution. The case is different for FO with\nneighbour relation where we show that one needs additional equations to\ncharacterise the class.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01214v1"
    },
    {
        "title": "Timed Basic Parallel Processes",
        "authors": [
            "Lorenzo Clemente",
            "Piotr Hofman",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Timed basic parallel processes (TBPP) extend communication-free Petri nets\n(aka. BPP or commutative context-free grammars) by a global notion of time.\nTBPP can be seen as an extension of timed automata (TA) with context-free\nbranching rules, and as such may be used to model networks of independent timed\nautomata with process creation.\n  We show that the coverability and reachability problems (with unary encoded\ntarget multiplicities) are PSPACE-complete and EXPTIME-complete, respectively.\nFor the special case of 1-clock TBPP, both are NP-complete and hence not more\ncomplex than for untimed BPP. This contrasts with known\nsuper-Ackermannian-completeness and undecidability results for general timed\nPetri nets.\n  As a result of independent interest, and basis for our NP upper bounds, we\nshow that the reachability relation of 1-clock TA can be expressed by a formula\nof polynomial size in the existential fragment of linear arithmetic, which\nimproves on recent results from the literature.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01240v2"
    },
    {
        "title": "Computing Probabilistic Bisimilarity Distances for Probabilistic\n  Automata",
        "authors": [
            "Giorgio Bacci",
            "Giovanni Bacci",
            "Kim G. Larsen",
            "Radu Mardare",
            "Qiyi Tang",
            "Franck van Breugel"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The probabilistic bisimilarity distance of Deng et al. has been proposed as a\nrobust quantitative generalization of Segala and Lynch's probabilistic\nbisimilarity for probabilistic automata. In this paper, we present a\ncharacterization of the bisimilarity distance as the solution of a simple\nstochastic game. The characterization gives us an algorithm to compute the\ndistances by applying Condon's simple policy iteration on these games. The\ncorrectness of Condon's approach, however, relies on the assumption that the\ngames are stopping. Our games may be non-stopping in general, yet we are able\nto prove termination for this extended class of games. Already other algorithms\nhave been proposed in the literature to compute these distances, with\ncomplexity in $\\textbf{UP} \\cap \\textbf{coUP}$ and \\textbf{PPAD}. Despite the\ntheoretical relevance, these algorithms are inefficient in practice. To the\nbest of our knowledge, our algorithm is the first practical solution.\n  The characterization of the probabilistic bisimilarity distance mentioned\nabove crucially uses a dual presentation of the Hausdorff distance due to\nM\\'emoli. As an additional contribution, in this paper we show that M\\'emoli's\nresult can be used also to prove that the bisimilarity distance bounds the\ndifference in the maximal (or minimal) probability of two states to satisfying\narbitrary $\\omega$-regular properties, expressed, eg., as LTL formulas.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01768v8"
    },
    {
        "title": "Deciding Fast Termination for Probabilistic VASS with Nondeterminism",
        "authors": [
            "Tomáš Brázdil",
            "Krishnendu Chatterjee",
            "Antonín Kučera",
            "Petr Novotný",
            "Dominik Velan"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  A probabilistic vector addition system with states (pVASS) is a finite state\nMarkov process augmented with non-negative integer counters that can be\nincremented or decremented during each state transition, blocking any behaviour\nthat would cause a counter to decrease below zero. The pVASS can be used as\nabstractions of probabilistic programs with many decidable properties. The use\nof pVASS as abstractions requires the presence of nondeterminism in the model.\nIn this paper, we develop techniques for checking fast termination of pVASS\nwith nondeterminism.\n  That is, for every initial configuration of size n, we consider the worst\nexpected number of transitions needed to reach a configuration with some\ncounter negative (the expected termination time). We show that the problem\nwhether the asymptotic expected termination time is linear is decidable in\npolynomial time for a certain natural class of pVASS with nondeterminism.\nFurthermore, we show the following dichotomy: if the asymptotic expected\ntermination time is not linear, then it is at least quadratic, i.e., in\n$\\Omega(n^2)$.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.11010v1"
    },
    {
        "title": "Synchronization under Dynamic Constraints",
        "authors": [
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Imagine an assembly line where a box with a lid and liquid in it enters in\nsome unknown orientation. The box should leave the line with the open lid\nfacing upwards with the liquid still in it. To save costs there are no complex\nsensors or image recognition software available on the assembly line, so a\nreset sequence needs to be computed. But how can the dependencies of the\ndeforming impact of a transformation of the box, such as 'do not tilt the box\nover when the lid is open' or 'open the lid again each time it gets closed' be\nmodeled? We present three attempts to model constraints of these kinds on the\norder in which the states of an automaton are transitioned by a synchronizing\nword. The first two concepts relate the last visits of states and form\nconstraints on which states still need to be reached, whereas the third concept\nconcerns the first visits of states and forms constraints on which states might\nstill be reached. We examine the computational complexity of different variants\nof the problem, whether an automaton can be synchronized with a word that\nrespects the constraints defined in the respective concept, and obtain nearly a\nfull classification. While most of the problems are PSPACE-complete we also\nobserve NP-complete variants and variants solvable in polynomial time. We will\nalso observe a drop of the complexity if we track the orders of states on\nseveral paths simultaneously instead of tracking the set of active states.\nFurther, we give upper bounds on the length of a synchronizing word depending\non the size of the input relation and show that the Cerny conjecture holds for\npartial weakly acyclic automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.01935v6"
    },
    {
        "title": "Succinct Determinisation of Counting Automata via Sphere Construction\n  (Technical Report)",
        "authors": [
            "Lukáš Holík",
            "Ondřej Lengál",
            "Olli Saarikivi",
            "Lenka Turoňová",
            "Margus Veanes",
            "Tomáš Vojnar"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose an efficient algorithm for determinising counting automata (CAs),\ni.e., finite automata extended with bounded counters. The algorithm avoids\nunfolding counters into control states, unlike the na\\\"ive approach, and thus\nproduces much smaller deterministic automata. We also develop a simplified and\nfaster version of the general algorithm for the sub-class of so-called monadic\nCAs (MCAs), i.e., CAs with counting loops on character classes, which are\ncommon in practice. Our main motivation is (besides applications in\nverification and decision procedures of logics) the application of\ndeterministic (M)CAs in pattern matching regular expressions with counting,\nwhich are very common in e.g. network traffic processing and log analysis. We\nhave evaluated our algorithm against practical benchmarks from these\napplication domains and concluded that compared to the na\\\"ive approach, our\nalgorithm is much less prone to explode, produces automata that can be several\norders of magnitude smaller, and is overall faster.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.01996v1"
    },
    {
        "title": "The Well Structured Problem for Presburger Counter Machines",
        "authors": [
            "Alain Finkel",
            "Ekanshdeep Gupta"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce the well structured problem as the question of whether a model\n(here a counter machine) is well structured (here for the usual ordering on\nintegers). We show that it is undecidable for most of the (Presburger-defined)\ncounter machines except for Affine VASS of dimension one. However, the strong\nwell structured problem is decidable for all Presburger counter machines. While\nAffine VASS of dimension one are not, in general, well structured, we give an\nalgorithm that computes the set of predecessors of a configuration; as a\nconsequence this allows to decide the well structured problem for 1-Affine\nVASS.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.02736v2"
    },
    {
        "title": "Generating Posets Beyond N",
        "authors": [
            "Uli Fahrenberg",
            "Christian Johansen",
            "Georg Struth",
            "Ratan Bahadur Thapa"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We introduce iposets---posets with interfaces---equipped with a novel gluing\ncomposition along interfaces and the standard parallel composition. We study\ntheir basic algebraic properties as well as the hierarchy of gluing-parallel\nposets generated from singletons by finitary applications of the two\ncompositions. We show that not only series-parallel posets, but also interval\norders, which seem more interesting for modelling concurrent and distributed\nsystems, can be generated, but not all posets. Generating posets is also\nimportant for constructing free algebras for concurrent semirings and Kleene\nalgebras that allow compositional reasoning about such systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.06162v1"
    },
    {
        "title": "Abstract Transducers",
        "authors": [
            "Andreas Stahlbauer"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Several abstract machines that operate on symbolic input alphabets have been\nproposed in the last decade, for example, symbolic automata or lattice\nautomata. Applications of these types of automata include software security\nanalysis and natural language processing. While these models provide means to\ndescribe words over infinite input alphabets, there is no considerable work on\nsymbolic output (as present in transducers) alphabets, or even abstraction\n(widening) thereof. Furthermore, established approaches for transforming, for\nexample, minimizing or reducing, finite-state machines that produce output on\nstates or transitions are not applicable. A notion of equivalence of this type\nof machines is needed to make statements about whether or not transformations\nmaintain the semantics. We present abstract transducers as a new form of\nfinite-state transducers. Both their input alphabet and the output alphabet is\ncomposed of abstract words, where one abstract word represents a set of\nconcrete words. The mapping between these representations is described by\nabstract word domains. By using words instead of single letters, abstract\ntransducers provide the possibility of lookaheads to decide on state\ntransitions to conduct. Since both the input symbol and the output symbol on\neach transition is an abstract entity, abstraction techniques can be applied\nnaturally. We apply abstract transducers as the foundation for sharing task\nartifacts for reuse in context of program analysis and verification, and\ndescribe task artifacts as abstract words. A task artifact is any entity that\ncontributes to an analysis task and its solution, for example, candidate\ninvariants or source code to weave.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.07583v1"
    },
    {
        "title": "Checking Timed Bisimulation with Bounded Zone-History Graphs --\n  Technical Report",
        "authors": [
            "Lars Luthmann",
            "Hendrik Göttmann",
            "Isabelle Bacher",
            "Malte Lochau"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Timed automata (TA) are a well-established formalism for specifying\ndiscrete-state/continuous-time behavior of time-critical reactive systems.\nConcerning the fundamental analysis problem of comparing a candidate\nimplementation against a specification, both given as TA, it has been shown\nthat timed trace equivalence is undecidable, whereas timed bisimulation\nequivalence is decidable. The corresponding proof utilizes region graphs, a\nfinite, but generally very space-consuming characterization of TA semantics.\nHence, most practical TA tools utilize zone graphs instead, a symbolic and\ngenerally more efficient representation of TA semantics, to automate analysis\ntasks. However, zone graphs only produce sound results for analysis tasks being\nreducible to plain reachability problems thus being too imprecise for checking\ntimed bisimilarity. In this paper, we propose bounded zone-history graphs, a\nnovel characterization of TA semantics facilitating an adjustable trade-off\nbetween precision and scalability of timed-bisimilarity checking. Our tool\nTimBrCheck is, to the best of our knowledge, the only currently available tool\nfor effectively checking timed bisimilarity and even supports non-deterministic\nTA with silent moves. We further present experimental results gained from\napplying our tool to a collection of community benchmarks, providing insights\ninto trade-offs between precision and efficiency, depending on the bound value.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.08992v3"
    },
    {
        "title": "Complexity Results on Register Pushdown Automata",
        "authors": [
            "Ryoma Senda",
            "Yoshiaki Takata",
            "Hiroyuki Seki"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Register pushdown automata (RPDA) is an extension of classical pushdown\nautomata to handle data values in a restricted way. RPDA attracts attention as\na model of a query language for structured documents with data values. The\nmembership and emptiness problems for RPDA are known to be EXPTIME-complete.\nThis paper shows the membership problem becomes PSPACE-complete and NP-complete\nfor nondecreasing and growing RPDA, respectively, while the emptiness problem\nremains EXPTIME-complete for these subclasses.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.10357v1"
    },
    {
        "title": "A compositional semantics for Repairable Fault Trees with general\n  distributions",
        "authors": [
            "Raul E. Monti",
            "Pedro R. D'Argenio",
            "Carlos E. Budde"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Fault Tree Analysis (FTA) is a prominent technique in industrial and\nscientific risk assessment. Repairable Fault Trees (RFT) enhance the classical\nFault Tree (FT) model by introducing the possibility to describe complex\ndependent repairs of system components. Usual frameworks for analyzing FTs such\nas BDD, SBDD, and Markov chains fail to assess the desired properties over RFT\ncomplex models, either because these become too large, or due to cyclic\nbehaviour introduced by dependent repairs. Simulation is another way to carry\nout this kind of analysis. In this paper we review the RFT model with Repair\nBoxes as introduced by Daniele Codetta-Raiteri. We present compositional\nsemantics for this model in terms of Input/Output Stochastic Automata, which\nallows for the modelling of events occurring according to general continuous\ndistribution. Moreover, we prove that the semantics generates (weakly)\ndeterministic models, hence suitable for discrete event simulation, and\nprominently for Rare Event Simulation using the FIG tool.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.10507v1"
    },
    {
        "title": "A note on commutative Kleene algebra",
        "authors": [
            "Paul Brunet"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper we present a detailed proof of an important result of algebraic\nlogic: namely that the free commutative Kleene algebra is the space of\nsemilinear sets. The first proof of this result was proposed by Redko in 1964,\nand simplified and corrected by Pilling in his 1970 thesis. However, we feel\nthat a new account of this proof is needed now. This result has acquired a\nparticular importance in recent years, since it is a key component in the\ncompleteness proofs of several algebraic models of concurrent computations\n(bi-Kleene algebra, concurrent Kleene algebra...). To that effect, we present a\nnew proof of this result.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.14381v1"
    },
    {
        "title": "An Abstraction-Based Framework for Neural Network Verification",
        "authors": [
            "Yizhak Yisrael Elboher",
            "Justin Gottschlich",
            "Guy Katz"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Deep neural networks are increasingly being used as controllers for\nsafety-critical systems. Because neural networks are opaque, certifying their\ncorrectness is a significant challenge. To address this issue, several neural\nnetwork verification approaches have recently been proposed. However, these\napproaches afford limited scalability, and applying them to large networks can\nbe challenging. In this paper, we propose a framework that can enhance neural\nnetwork verification techniques by using over-approximation to reduce the size\nof the network - thus making it more amenable to verification. We perform the\napproximation such that if the property holds for the smaller (abstract)\nnetwork, it holds for the original as well. The over-approximation may be too\ncoarse, in which case the underlying verification tool might return a spurious\ncounterexample. Under such conditions, we perform counterexample-guided\nrefinement to adjust the approximation, and then repeat the process. Our\napproach is orthogonal to, and can be integrated with, many existing\nverification techniques. For evaluation purposes, we integrate it with the\nrecently proposed Marabou framework, and observe a significant improvement in\nMarabou's performance. Our experiments demonstrate the great potential of our\napproach for verifying larger neural networks.\n",
        "pdf_link": "http://arxiv.org/pdf/1910.14574v2"
    },
    {
        "title": "Scattered Factor-Universality of Words",
        "authors": [
            "Laura Barker",
            "Pamela Fleischmann",
            "Katharina Harwardt",
            "Florin Manea",
            "Dirk Nowotka"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  A word $u=u_1\\dots u_n$ is a scattered factor of a word $w$ if $u$ can be\nobtained from $w$ by deleting some of its letters: there exist the (potentially\nempty) words $v_0,v_1,..,v_n$ such that $w = v_0u_1v_1...u_nv_n$. The set of\nall scattered factors up to length $k$ of a word is called its full\n$k$-spectrum. Firstly, we show an algorithm deciding whether the $k$-spectra\nfor given $k$ of two words are equal or not, running in optimal time. Secondly,\nwe consider a notion of scattered-factors universality: the word $w$, with\n$\\letters(w)=\\Sigma$, is called $k$-universal if its $k$-spectrum includes all\nwords of length $k$ over the alphabet $\\Sigma$; we extend this notion to\n$k$-circular universality. After a series of preliminary combinatorial results,\nwe present an algorithm computing, for a given $k'$-universal word $w$ the\nminimal $i$ such that $w^i$ is $k$-universal for some $k>k'$. Several other\nconnected problems~are~also~considered.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.04629v1"
    },
    {
        "title": "Regular Intersection Emptiness of Graph Problems: Finding a Needle in a\n  Haystack of Graphs with the Help of Automata",
        "authors": [
            "Petra Wolf",
            "Henning Fernau"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The Int_reg-problem of a combinatorial problem P asks, given a\nnondeterministic automaton M as input, whether the language L(M) accepted by M\ncontains any positive instance of the problem P. We consider the\nInt_reg-problem for a number of different graph problems and give general\ncriteria that give decision procedures for these Int_reg-problems. To achieve\nthis goal, we consider a natural graph encoding so that the language of all\ngraph encodings is regular. Then, we draw the connection between classical\npumping- and interchange-arguments from the field of formal language theory\nwith the graph operations induced on the encoded graph. Our techniques apply\namong others to the Int_reg-problem of well-known graph problems like Vertex\nCover and Independent Set, as well as to subgraph problems, graph-edit problems\nand graph-partitioning problems, including coloring problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.05826v1"
    },
    {
        "title": "An Approach to Regular Separability in Vector Addition Systems",
        "authors": [
            "Wojciech Czerwiński",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study the problem of regular separability of languages of vector addition\nsystems with states (VASS). It asks whether for two given VASS languages K and\nL, there exists a regular language R that includes K and is disjoint from L.\nWhile decidability of the problem in full generality remains an open question,\nthere are several subclasses for which decidability has been shown: It is\ndecidable for (i) one-dimensional VASS, (ii) VASS coverability languages, (iii)\nlanguages of integer VASS, and (iv) commutative VASS languages. We propose a\ngeneral approach to deciding regular separability. We use it to decide regular\nseparability of an arbitrary VASS language from any language in the classes\n(i), (ii), and (iii). This generalizes all previous results, including (iv).\n",
        "pdf_link": "http://arxiv.org/pdf/2007.00111v1"
    },
    {
        "title": "Incremental methods for checking real-time consistency",
        "authors": [
            "Thierry Jéron",
            "Nicolas Markey",
            "David Mentré",
            "Reiya Noguchi",
            "Ocan Sankur"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Requirements engineering is a key phase in the development process. Ensuring\nthat requirements are consistent is essential so that they do not conflict and\nadmit implementations. We consider the formal verification of rt-consistency,\nwhich imposes that the inevitability of definitive errors of a requirement\nshould be anticipated, and that of partial consistency, which was recently\nintroduced as a more effective check. We generalize and formalize both notions\nfor discrete-time timed automata, develop three incremental algorithms, and\npresent experimental results.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.01014v2"
    },
    {
        "title": "Proving Non-Inclusion of Büchi Automata based on Monte Carlo Sampling",
        "authors": [
            "Yong Li",
            "Andrea Turrini",
            "Xuechao Sun",
            "Lijun Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The search for a proof of correctness and the search for counterexamples\n(bugs) are complementary aspects of verification. In order to maximize the\npractical use of verification tools it is better to pursue them at the same\ntime. While this is well-understood in the termination analysis of programs,\nthis is not the case for the language inclusion analysis of B\\\"uchi automata,\nwhere research mainly focused on improving algorithms for proving language\ninclusion, with the search for counterexamples left to the expensive\ncomplementation operation.\n  In this paper, we present $\\mathsf{IMC}^2$, a specific algorithm for proving\nB\\\"uchi automata non-inclusion $\\mathcal{L}(\\mathcal{A}) \\not\\subseteq\n\\mathcal{L}(\\mathcal{B})$, based on Grosu and Smolka's algorithm\n$\\mathsf{MC}^2$ developed for Monte Carlo model checking against LTL formulas.\nThe algorithm we propose takes $M = \\lceil \\ln \\delta / \\ln (1-\\epsilon)\n\\rceil$ random lasso-shaped samples from $\\mathcal{A}$ to decide whether to\nreject the hypothesis $\\mathcal{L}(\\mathcal{A}) \\not\\subseteq\n\\mathcal{L}(\\mathcal{B})$, for given error probability $\\epsilon$ and\nconfidence level $1 - \\delta$. With such a number of samples, $\\mathsf{IMC}^2$\nensures that the probability of witnessing $\\mathcal{L}(\\mathcal{A})\n\\not\\subseteq \\mathcal{L}(\\mathcal{B})$ via further sampling is less than\n$\\delta$, under the assumption that the probability of finding a lasso\ncounterexample is larger than $\\epsilon$. Extensive experimental evaluation\nshows that $\\mathsf{IMC}^2$ is a fast and reliable way to find counterexamples\nto B\\\"uchi automata inclusion.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.02282v2"
    },
    {
        "title": "A Classification of Weak Asynchronous Models of Distributed Computing",
        "authors": [
            "Javier Esparza",
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We conduct a systematic study of asynchronous models of distributed computing\nconsisting of identical finite-state devices that cooperate in a network to\ndecide if the network satisfies a given graph-theoretical property. Models\ndiscussed in the literature differ in the detection capabilities of the agents\nresiding at the nodes of the network (detecting the set of states of their\nneighbors, or counting the number of neighbors in each state), the notion of\nacceptance (acceptance by halting in a particular configuration, or by stable\nconsensus), the notion of step (synchronous move, interleaving, or arbitrary\ntiming), and the fairness assumptions (non-starving, or stochastic-like). We\nstudy the expressive power of the combinations of these features, and show that\nthe initially twenty possible combinations fit into seven equivalence classes.\nThe classification is the consequence of several equi-expressivity results with\na clear interpretation. In particular, we show that acceptance by halting\nconfiguration only has non-trivial expressive power if it is combined with\ncounting, and that synchronous and interleaving models have the same power as\nthose in which an arbitrary set of nodes can move at the same time. We also\nidentify simple graph properties that distinguish the expressive power of the\nseven classes.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.03291v1"
    },
    {
        "title": "A Myhill-Nerode Theorem for Register Automata and Symbolic Trace\n  Languages",
        "authors": [
            "Frits Vaandrager",
            "Abhisek Midya"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We propose a new symbolic trace semantics for register automata (extended\nfinite state machines) which records both the sequence of input symbols that\noccur during a run as well as the constraints on input parameters that are\nimposed by this run. Our main result is a generalization of the classical\nMyhill-Nerode theorem to this symbolic setting. Our generalization requires the\nuse of three relations to capture the additional structure of register\nautomata. Location equivalence $\\equiv_l$ captures that symbolic traces end in\nthe same location, transition equivalence $\\equiv_t$ captures that they share\nthe same final transition, and a partial equivalence relation $\\equiv_r$\ncaptures that symbolic values $v$ and $v'$ are stored in the same register\nafter symbolic traces $w$ and $w'$, respectively. A symbolic language is\ndefined to be regular if relations $\\equiv_l$, $\\equiv_t$ and $\\equiv_r$ exist\nthat satisfy certain conditions, in particular, they all have finite index. We\nshow that the symbolic language associated to a register automaton is regular,\nand we construct, for each regular symbolic language, a register automaton that\naccepts this language. Our result provides a foundation for grey-box learning\nalgorithms in settings where the constraints on data parameters can be\nextracted from code using e.g. tools for symbolic/concolic execution or\ntainting. We believe that moving to a grey-box setting is essential to overcome\nthe scalability problems of state-of-the-art black-box learning algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.03540v2"
    },
    {
        "title": "Nondeterministic Automata and JSL-dfas",
        "authors": [
            "Robert Samuel Ralph Myers"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We introduce the category of dependency automata. A dependency automaton\nconsists of two nondeterministic finite automata, with a relation between their\nstates satisfying conditions. This category is equivalent to deterministic\nfinite automata interpreted in join-semilattices i.e. JSL-dfas. The canonical\ndependency automaton accepting $L$ amounts to the state-minimal dfas for $L$\nand $rev(L)$ connected by the `dependency relation'.\n  We describe many canonical JSL-dfas as dependency automata and also\nexplain/extend Brzozowski's algorithm. Call an nfa `subatomic' if its\nindividual states accept a language in the closure of $\\{L\\}$ under left/right\nquotients and set-theoretic boolean operations. We prove an nfa $N$ is\nsubatomic iff $rsc(rev(N))$'s transition monoid is syntactic.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.06031v1"
    },
    {
        "title": "The Big-O Problem",
        "authors": [
            "Dmitry Chistikov",
            "Stefan Kiefer",
            "Andrzej S. Murawski",
            "David Purser"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Given two weighted automata, we consider the problem of whether one is big-O\nof the other, i.e., if the weight of every finite word in the first is not\ngreater than some constant multiple of the weight in the second.\n  We show that the problem is undecidable, even for the instantiation of\nweighted automata as labelled Markov chains. Moreover, even when it is known\nthat one weighted automaton is big-O of another, the problem of finding or\napproximating the associated constant is also undecidable.\n  Our positive results show that the big-O problem is polynomial-time solvable\nfor unambiguous automata, coNP-complete for unlabelled weighted automata (i.e.,\nwhen the alphabet is a single character) and decidable, subject to Schanuel's\nconjecture, when the language is bounded (i.e., a subset of $w_1^*\\dots w_m^*$\nfor some finite words $w_1,\\dots,w_m$) or when the automaton has finite\nambiguity.\n  On labelled Markov chains, the problem can be restated as a ratio total\nvariation distance, which, instead of finding the maximum difference between\nthe probabilities of any two events, finds the maximum ratio between the\nprobabilities of any two events. The problem is related to\n$\\varepsilon$-differential privacy, for which the optimal constant of the big-O\nnotation is exactly $\\exp(\\varepsilon)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.07694v6"
    },
    {
        "title": "Completely Reachable Automata, Primitive Groups and the State Complexity\n  of the Set of Synchronizing Words",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We give a new characterization of primitive permutation groups tied to the\nnotion of completely reachable automata. Also, we introduce sync-maximal\npermutation groups tied to the state complexity of the set of synchronizing\nwords of certain associated automata and show that they are contained between\nthe $2$-homogeneous and the primitive groups. Lastly, we define $k$-reachable\ngroups in analogy with synchronizing groups and motivated by our\ncharacterization of primitive permutation groups. But the results show that a\n$k$-reachable permutation group of degree $n$ with $6 \\le k \\le n - 6$ is\neither the alternating or the symmetric group.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.09104v2"
    },
    {
        "title": "On the Orbits of Automaton Semigroups and Groups",
        "authors": [
            "Daniele D'Angeli",
            "Dominik Francoeur",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We investigate the orbits of automaton semigroups and groups to obtain\nalgorithmic and structural results, both for general automata but also for some\nspecial subclasses. First, we show that a more general version of the\nfiniteness problem for automaton groups is undecidable. This problem is\nequivalent to the finiteness problem for left principal ideals in automaton\nsemigroups generated by complete and reversible automata. Then, we look at\n$\\omega$-word (i.e. right infinite words) with a finite orbit. We show that\nevery automaton yielding an $\\omega$-word with a finite orbit already yields an\nultimately periodic one, which is not periodic in general, however. On the\nalgorithmic side, we observe that it is not possible to decide whether a given\nperiodic $\\omega$-word has an infinite orbit and that we cannot check whether a\ngiven reversible and complete automaton admits an $\\omega$-word with a finite\norbit, a reciprocal problem to the finiteness problem for automaton semigroups\nin the reversible case. Finally, we look at automaton groups generated by\nreversible but not bi-reversible automata and show that many words have\ninfinite orbits under the action of such automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.10273v1"
    },
    {
        "title": "Universality Problem for Unambiguous VASS",
        "authors": [
            "Wojciech Czerwiński",
            "Diego Figueira",
            "Piotr Hofman"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study languages of unambiguous VASS, that is, Vector Addition Systems with\nStates, whose transitions read letters from a finite alphabet, and whose\nacceptance condition is defined by a set of final states (i.e., the\ncoverability language). We show that the problem of universality for\nunambiguous VASS is ExpSpace-complete, in sheer contrast to\nAckermann-completeness for arbitrary VASS, even in dimension 1. When the\ndimension d is fixed, the universality problem is PSpace-complete if d is at\nleast 2, and coNP-hard for 1-dimensional VASSes (also known as One Counter\nNets).\n",
        "pdf_link": "http://arxiv.org/pdf/2007.10907v1"
    },
    {
        "title": "Multitape automata and finite state transducers with lexicographic\n  weights",
        "authors": [
            "Aleksander Mendoza-Drosik"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Finite state transducers, multitape automata and weighted automata have a lot\nin common. By studying their universal foundations, one can discover some new\ninsights into all of them. The main result presented here is the introduction\nof lexicographic finite state transducers, that could be seen as intermediate\nmodel between multitape automata and weighted transducers. Their most\nsignificant advantage is being equivalent, but often exponentially smaller than\neven smallest nondeterministic automata without weights. Lexicographic\ntransducers were discovered by taking inspiration from Eilenberg's algebraic\napproach to automata and Solomonoff's treatment of a priori probability.\nTherefore, a quick and concise survey of those topics is presented, prior to\nintroducing lexicographic transducers.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.12940v4"
    },
    {
        "title": "Learning Languages in the Limit from Positive Information with Finitely\n  Many Memory Changes",
        "authors": [
            "Timo Kötzing",
            "Karen Seidel"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We investigate learning collections of languages from texts by an inductive\ninference machine with access to the current datum and a bounded memory in form\nof states. Such a bounded memory states (BMS) learner is considered successful\nin case it eventually settles on a correct hypothesis while exploiting only\nfinitely many different states.\n  We give the complete map of all pairwise relations for an established\ncollection of criteria of successfull learning. Most prominently, we show that\nnon-U-shapedness is not restrictive, while conservativeness and (strong)\nmonotonicity are. Some results carry over from iterative learning by a general\nlemma showing that, for a wealth of restrictions (the semantic restrictions),\niterative and bounded memory states learning are equivalent. We also give an\nexample of a non-semantic restriction (strongly non-U-shapedness) where the two\nsettings differ.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.04782v3"
    },
    {
        "title": "Collapsible Pushdown Parity Games",
        "authors": [
            "Christopher H. Broadbent",
            "Arnaud Carayol",
            "Matthew Hague",
            "Andrzej S. Murawski",
            "C. -H. Luke Ong",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This paper studies a large class of two-player perfect-information turn-based\nparity games on infinite graphs, namely those generated by collapsible pushdown\nautomata. The main motivation for studying these games comes from the\nconnections from collapsible pushdown automata and higher-order recursion\nschemes, both models being equi-expressive for generating infinite trees. Our\nmain result is to establish the decidability of such games and to provide an\neffective representation of the winning region as well as of a winning\nstrategy. Thus, the results obtained here provide all necessary tools for an\nin-depth study of logical properties of trees generated by collapsible pushdown\nautomata/recursion schemes.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.06361v1"
    },
    {
        "title": "Parametric non-interference in timed automata",
        "authors": [
            "Étienne André",
            "Aleksander Kryukov"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider a notion of non-interference for timed automata (TAs) that allows\nto quantify the frequency of an attack; that is, we infer values of the minimal\ntime between two consecutive actions of the attacker, so that (s)he disturbs\nthe set of reachable locations. We also synthesize valuations for the timing\nconstants of the TA (seen as parameters) guaranteeing non-interference. We show\nthat this can reduce to reachability synthesis in parametric timed automata. We\napply our method to a model of the Fischer mutual exclusion protocol and obtain\npreliminary results.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.09527v1"
    },
    {
        "title": "A Linear-Time Nominal $μ$-Calculus with Name Allocation",
        "authors": [
            "Daniel Hausmann",
            "Stefan Milius",
            "Lutz Schröder"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Logics and automata models for languages over infinite alphabets, such as\nFreeze LTL and register automata, serve the verification of processes or\ndocuments with data. They relate tightly to formalisms over nominal sets, such\nas nondetermininistic orbit-finite automata (NOFAs), where names play the role\nof data. Reasoning problems in such formalisms tend to be computationally hard.\nName-binding nominal automata models such as regular nondeterministic nominal\nautomata (RNNAs) have been shown to be computationally more tractable. In the\npresent paper, we introduce a linear-time fixpoint logic Bar-muTL for finite\nwords over an infinite alphabet, which features full negation and freeze\nquantification via name binding. We show by a nontrivial reduction to extended\nregular nondeterministic nominal automata that even though Bar-muTL allows\nunrestricted nondeterminism and unboundedly many registers, model checking\nBar-muTL over RNNAs and satisfiability checking both have elementary\ncomplexity. For example, model checking is in 2ExpSpace, more precisely in\nparametrized ExpSpace, effectively with the number of registers as the\nparameter.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.10912v4"
    },
    {
        "title": "Approximating the Minimal Lookahead Needed to Win Infinite Games",
        "authors": [
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We present an exponential-time algorithm approximating the minimal lookahead\nnecessary to win an $\\omega$-regular delay game.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.11706v2"
    },
    {
        "title": "A Semantic Framework for PEGs",
        "authors": [
            "Sérgio Medeiros",
            "Carlos Olarte"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Parsing Expression Grammars (PEGs) are a recognition-based formalism which\nallows to describe the syntactical and the lexical elements of a language. The\nmain difference between Context-Free Grammars (CFGs) and PEGs relies on the\ninterpretation of the choice operator: while the CFGs' unordered choice e | e'\nis interpreted as the union of the languages recognized by e and e, the PEGs'\nprioritized choice e/e' discards e' if e succeeds. Such subtle, but important\ndifference, changes the language recognized and yields more efficient parsing\nalgorithms. This paper proposes a rewriting logic semantics for PEGs. We start\nwith a rewrite theory giving meaning to the usual constructs in PEGs. Later, we\nshow that cuts, a mechanism for controlling backtracks in PEGs, finds also a\nnatural representation in our framework. We generalize such mechanism, allowing\nfor both local and global cuts with a precise, unified and formal semantics.\nHence, our work strives at better understanding and controlling backtracks in\nparsers for PEGs. The semantics we propose is executable and, besides being a\nparser with modest efficiency, it can be used as a playground to test different\noptimization ideas. More importantly, it is a mathematical tool that can be\nused for different analyses.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.04360v1"
    },
    {
        "title": "Context-Bounded Verification of Liveness Properties for Multithreaded\n  Shared-Memory Programs",
        "authors": [
            "Pascal Baumann",
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We study context-bounded verification of liveness properties of\nmulti-threaded, shared-memory programs, where each thread can spawn additional\nthreads. Our main result shows that context-bounded fair termination is\ndecidable for the model; context-bounded implies that each spawned thread can\nbe context switched a fixed constant number of times. Our proof is technical,\nsince fair termination requires reasoning about the composition of unboundedly\nmany threads each with unboundedly large stacks. In fact, techniques for\nrelated problems, which depend crucially on replacing the pushdown threads with\nfinite-state threads, are not applicable. Instead, we introduce an extension of\nvector addition systems with states (VASS), called VASS with balloons (VASSB),\nas an intermediate model; it is an infinite-state model of independent\ninterest. A VASSB allows tokens that are themselves markings (balloons). We\nshow that context bounded fair termination reduces to fair termination for\nVASSB. We show the latter problem is decidable by showing a series of\nreductions: from fair termination to configuration reachability for VASSB and\nthence to the reachability problem for VASS. For a lower bound, fair\ntermination is known to be non-elementary already in the special case where\nthreads run to completion (no context switches).\n  We also show that the simpler problem of context-bounded termination is\n2EXPSPACE-complete, matching the complexity bound---and indeed the\ntechniques---for safety verification. Additionally, we show the related problem\nof fair starvation, which checks if some thread can be starved along a fair\nrun, is also decidable in the context-bounded case. The decidability employs an\nintricate reduction from fair starvation to fair termination. Like fair\ntermination, this problem is also non-elementary.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.04581v2"
    },
    {
        "title": "A translation of weighted LTL formulas to weighted Büchi automata over\n  ω-valuation monoids",
        "authors": [
            "Eleni Mandrali"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper we introduce a weighted LTL over product $\\omega$-valuation\nmonoids that satisfy specific properties. We also introduce weighted\ngeneralized B\\\"uchi automata with $\\varepsilon$-transitions, as well as\nweighted B\\\"uchi automata with $\\varepsilon$-transitions over product\n$\\omega$-valuation monoids and prove that these two models are expressively\nequivalent and also equivalent to weighted B\\\"uchi automata already introduced\nin the literature. We prove that every formula of a syntactic fragment of our\nlogic can be effectively translated to a weighted generalized B\\\"uchi automaton\nwith $\\varepsilon$-transitions. For generalized product $\\omega$-valuation\nmonoids that satisfy specific properties we define a weighted LTL, weighted\ngeneralized B\\\"uchi automata with $\\varepsilon$-transitions, and weighted\nB\\\"uchi automata with $\\varepsilon$-transitions, and we prove the\naforementioned results for generalized product $\\omega$-valuation monoids as\nwell. The translation of weighted LTL formulas to weighted generalized B\\\"uchi\nautomata with $\\varepsilon$-transitions is now obtained for a restricted\nsyntactical fragment of the logic.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.05027v5"
    },
    {
        "title": "On the Complexity of Symbolic Finite-State Automata",
        "authors": [
            "Dana Fisman",
            "Hadar Frenkel",
            "Sandra Zilles"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We revisit the complexity of procedures on SFAs (such as intersection,\nemptiness, etc.) and analyze them according to the measures we find suitable\nfor symbolic automata: the number of states, the maximal number of transitions\nexiting a state, and the size of the most complex transition predicate. We pay\nattention to the special forms of SFAs: {normalized SFAs} and {neat SFAs}, as\nwell as to SFAs over a {monotonic} effective Boolean algebra.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.05389v3"
    },
    {
        "title": "Reachability in two-parametric timed automata with one parameter is\n  EXPSPACE-complete",
        "authors": [
            "Stefan Göller",
            "Mathieu Hilaire"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Parametric timed automata (PTA) are an extension of timed automata in which\nclocks can be compared against parameters. The reachability problem asks for\nthe existence of an assignment of the parameters to the non-negative integers\nsuch that reachability holds in the underlying timed automaton. The\nreachability problem for PTA is long known to be undecidable, already over\nthree parametric clocks.\n  A few years ago, Bundala and Ouaknine proved that for PTA over two parametric\nclocks and one parameter the reachability problem is decidable and also showed\na lower bound for the complexity class PSPACE^NEXP. Our main result is that the\nreachability problem for two-parametric timed automata with one parameter is\nEXPSPACE-complete. Our contribution is two-fold.\n  For the EXPSPACE lower bound we make use of deep results from complexity\ntheory, namely a serializability characterization of EXPSPACE (based on\nBarrington's Theorem) and a logspace translation of numbers in chinese\nremainder representation to binary representation.\n  For the EXPSPACE upper bound, we give a careful exponential time reduction\nfrom PTA over two parametric clocks and one parameter to a slight subclass of\nparametric one-counter automata (POCA) over one parameter based on a minor\nadjustment of a construction due to Bundala and Ouaknine. We provide a series\nof techniques to partition a fictitious run of a POCA into several carefully\nchosen subruns that allow us to prove that it is sufficient to consider a\nparameter value of exponential magnitude only. This allows us to show a\ndoubly-exponential upper bound on the value of the only parameter of a PTA over\ntwo parametric clocks and one parameter. We hope that extensions of our\ntechniques lead to finally establishing decidability of the long-standing open\nproblem of reachability in parametric timed automata with two parametric clocks\n(and arbitrarily many parameters).\n",
        "pdf_link": "http://arxiv.org/pdf/2011.07091v1"
    },
    {
        "title": "Learning of Structurally Unambiguous Probabilistic Grammars",
        "authors": [
            "Dolav Nitay",
            "Dana Fisman",
            "Michal Ziv-Ukelson"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The problem of identifying a probabilistic context free grammar has two\naspects: the first is determining the grammar's topology (the rules of the\ngrammar) and the second is estimating probabilistic weights for each rule.\nGiven the hardness results for learning context-free grammars in general, and\nprobabilistic grammars in particular, most of the literature has concentrated\non the second problem. In this work we address the first problem. We restrict\nattention to structurally unambiguous weighted context-free grammars (SUWCFG)\nand provide a query learning algorithm for structurally unambiguous\nprobabilistic context-free grammars (SUPCFG). We show that SUWCFG can be\nrepresented using co-linear multiplicity tree automata (CMTA), and provide a\npolynomial learning algorithm that learns CMTAs. We show that the learned CMTA\ncan be converted into a probabilistic grammar, thus providing a complete\nalgorithm for learning a structurally unambiguous probabilistic context free\ngrammar (both the grammar topology and the probabilistic weights) using\nstructured membership queries and structured equivalence queries. We\ndemonstrate the usefulness of our algorithm in learning PCFGs over genomic\ndata.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.07472v2"
    },
    {
        "title": "Safety Synthesis Sans Specification",
        "authors": [
            "Roderick Bloem",
            "Hana Chockler",
            "Masoud Ebrahimi",
            "Dana Fisman",
            "Heinz Riener"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We define the problem of learning a transducer ${S}$ from a target language\n$U$ containing possibly conflicting transducers, using membership queries and\nconjecture queries. The requirement is that the language of ${S}$ be a subset\nof $U$. We argue that this is a natural question in many situations in hardware\nand software verification. We devise a learning algorithm for this problem and\nshow that its time and query complexity is polynomial with respect to the rank\nof the target language, its incompatibility measure, and the maximal length of\na given counterexample. We report on experiments conducted with a prototype\nimplementation.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.07630v2"
    },
    {
        "title": "Conformance Checking of Mixed-paradigm Process Models",
        "authors": [
            "Boudewijn van Dongen",
            "Johannes De Smedt",
            "Claudio Di Ciccio",
            "Jan Mendling"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Mixed-paradigm process models integrate strengths of procedural and\ndeclarative representations like Petri nets and Declare. They are specifically\ninteresting for process mining because they allow capturing complex behaviour\nin a compact way. A key research challenge for the proliferation of\nmixed-paradigm models for process mining is the lack of corresponding\nconformance checking techniques. In this paper, we address this problem by\ndevising the first approach that works with intertwined state spaces of\nmixed-paradigm models. More specifically, our approach uses an alignment-based\nreplay to explore the state space and compute trace fitness in a procedural\nway. In every state, the declarative constraints are separately updated, such\nthat violations disable the corresponding activities. Our technique provides\nfor an efficient replay towards an optimal alignment by respecting all\northogonal Declare constraints. We have implemented our technique in ProM and\ndemonstrate its performance in an evaluation with real-world event logs.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.11551v1"
    },
    {
        "title": "Quantitative Corner Case Feature Analysis of Hybrid Automata with\n  ForFET$^{SMT}$",
        "authors": [
            "Antonio Anastasio Bruto da Costa",
            "Pallab Dasgupta",
            "Nikolaos Kekatos"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The analysis and verification of hybrid automata (HA) models against rich\nformal properties can be a challenging task. Existing methods and tools can\nmainly reason whether a given property is satisfied or violated. However, such\nqualitative answers might not provide sufficient information about the model\nbehaviors. This paper presents the ForFET$^{SMT}$ tool which can be used to\nreason quantitatively about such properties. It employs feature automata and\ncan evaluate quantitative property corners of HA. ForFET$^{SMT}$ uses two\nthird-party formal verification tools as its backbone: the SpaceEx reachability\ntool and the SMT solver dReach/dReal. Herein, we describe the design and\nimplementation of ForFET$^{SMT}$ and present its functionalities and modules.\nTo improve the usability of the tool for non-expert users, we also provide a\nlist of quantitative property templates.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.01255v1"
    },
    {
        "title": "Parallel Hyperedge Replacement Grammars",
        "authors": [
            "Graham Campbell"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In 2018, it was shown that all finitely generated virtually Abelian groups\nhave multiple context-free word problems, and it is still an open problem as to\nwhere to precisely place the word problems of hyperbolic groups in the formal\nlanguage hierarchy. Motivated by this, we introduce a new language class, the\nparallel hyperedge replacement string languages, containing all multiple\ncontext-free and ET0L languages. We show that parallel hyperedge replacement\ngrammars can be \"synchronised\", which allows us to establish many useful formal\nlanguage closure results relating to both the hypergraph and string languages\ngenerated by various families of parallel hyperedge replacement grammars,\nlaying the foundations for future work in this area.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.02310v1"
    },
    {
        "title": "On Satisficing in Quantitative Games",
        "authors": [
            "Suguman Bansal",
            "Krishnendu Chatterjee",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Several problems in planning and reactive synthesis can be reduced to the\nanalysis of two-player quantitative graph games. {\\em Optimization} is one form\nof analysis. We argue that in many cases it may be better to replace the\noptimization problem with the {\\em satisficing problem}, where instead of\nsearching for optimal solutions, the goal is to search for solutions that\nadhere to a given threshold bound.\n  This work defines and investigates the satisficing problem on a two-player\ngraph game with the discounted-sum cost model. We show that while the\nsatisficing problem can be solved using numerical methods just like the\noptimization problem, this approach does not render compelling benefits over\noptimization. When the discount factor is, however, an integer, we present\nanother approach to satisficing, which is purely based on automata methods. We\nshow that this approach is algorithmically more performant -- both\ntheoretically and empirically -- and demonstrates the broader applicability of\nsatisficing overoptimization.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.02594v1"
    },
    {
        "title": "Synchronizing Strongly Connected Partial DFAs",
        "authors": [
            "Mikhail V. Berlinkov",
            "Robert Ferens",
            "Andrew Ryzhikov",
            "Marek Szykuła"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study synchronizing partial DFAs, which extend the classical concept of\nsynchronizing complete DFAs and are a special case of synchronizing unambiguous\nNFAs. A partial DFA is called synchronizing if it has a word (called a reset\nword) whose action brings a non-empty subset of states to a unique state and is\nundefined for all other states. While in the general case the problem of\nchecking whether a partial DFA is synchronizing is PSPACE-complete, we show\nthat in the strongly connected case this problem can be efficiently reduced to\nthe same problem for a complete DFA. Using combinatorial, algebraic, and formal\nlanguages methods, we develop techniques that relate main synchronization\nproblems for strongly connected partial DFAs with the same problems for\ncomplete DFAs. In particular, this includes the \\v{C}ern\\'{y} and the rank\nconjectures, the problem of finding a reset word, and upper bounds on the\nlength of the shortest reset words of literal automata of finite prefix codes.\nWe conclude that solving fundamental synchronization problems is equally hard\nin both models, as an essential improvement of the results for one model\nimplies an improvement for the other.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.05057v1"
    },
    {
        "title": "Computability of Data-Word Transductions over Different Data Domains",
        "authors": [
            "Léo Exibard",
            "Emmanuel Filiot",
            "Nathan Lhote",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we investigate the problem of synthesizing computable\nfunctions of infinite words over an infinite alphabet (data $\\omega$-words).\nThe notion of computability is defined through Turing machines with infinite\ninputs which can produce the corresponding infinite outputs in the limit. We\nuse non-deterministic transducers equipped with registers, an extension of\nregister automata with outputs, to describe specifications. Being\nnon-deterministic, such transducers may not define functions but more generally\nrelations of data $\\omega$-words. In order to increase the expressive power of\nthese machines, we even allow guessing of arbitrary data values when updating\ntheir registers.\n  For functions over data $\\omega$-words, we identify a sufficient condition\n(the possibility of determining the next letter to be outputted, which we call\nnext letter problem) under which computability (resp. uniform computability)\nand continuity (resp. uniform continuity) coincide.\n  We focus on two kinds of data domains: first, the general setting of\noligomorphic data, which encompasses any data domain with equality, as well as\nthe setting of rational numbers with linear order; and second, the set of\nnatural numbers equipped with linear order. For both settings, we prove that\nfunctionality, i.e. determining whether the relation recognized by the\ntransducer is actually a function, is decidable. We also show that the\nso-called next letter problem is decidable, yielding equivalence between\n(uniform) continuity and (uniform) computability. Last, we provide\ncharacterizations of (uniform) continuity, which allow us to prove that these\nnotions, and thus also (uniform) computability, are decidable. We even show\nthat all these decision problems are PSpace-complete for $(\\mathbb{N},<)$ and\nfor a large class of oligomorphic data domains, including for instance\n$(\\mathbb{Q},<)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.07038v4"
    },
    {
        "title": "One-way resynchronizability of word transducers",
        "authors": [
            "Sougata Bose",
            "S. N. Krishna",
            "Anca Muscholl",
            "Gabriele Puppis"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The origin semantics for transducers was proposed in 2014, and led to various\ncharacterizations and decidability results that are in contrast with the\nclassical semantics. In this paper we add a further decidability result for\ncharacterizing transducers that are close to one-way transducers in the origin\nsemantics. We show that it is decidable whether a non-deterministic two-way\nword transducer can be resynchronized by a bounded, regular resynchronizer into\nan origin-equivalent one-way transducer. The result is in contrast with the\nusual semantics, where it is undecidable to know if a non-deterministic two-way\ntransducer is equivalent to some one-way transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.08011v1"
    },
    {
        "title": "Synthesizing Context-free Grammars from Recurrent Neural Networks\n  (Extended Version)",
        "authors": [
            "Daniel M. Yellin",
            "Gail Weiss"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present an algorithm for extracting a subclass of the context free\ngrammars (CFGs) from a trained recurrent neural network (RNN). We develop a new\nframework, pattern rule sets (PRSs), which describe sequences of deterministic\nfinite automata (DFAs) that approximate a non-regular language. We present an\nalgorithm for recovering the PRS behind a sequence of such automata, and apply\nit to the sequences of automata extracted from trained RNNs using the L*\nalgorithm. We then show how the PRS may converted into a CFG, enabling a\nfamiliar and useful presentation of the learned language.\n  Extracting the learned language of an RNN is important to facilitate\nunderstanding of the RNN and to verify its correctness. Furthermore, the\nextracted CFG can augment the RNN in classifying correct sentences, as the\nRNN's predictive accuracy decreases when the recursion depth and distance\nbetween matching delimiters of its input sequences increases.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.08200v3"
    },
    {
        "title": "General Decidability Results for Asynchronous Shared-Memory Programs:\n  Higher-Order and Beyond",
        "authors": [
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The model of asynchronous programming arises in many contexts, from low-level\nsystems software to high-level web programming. We take a language-theoretic\nperspective and show general decidability and undecidability results for\nasynchronous programs that capture all known results as well as show\ndecidability of new and important classes. As a main consequence, we show\ndecidability of safety, termination and boundedness verification for\nhigher-order asynchronous programs -- such as OCaml programs using Lwt -- and\nundecidability of liveness verification already for order-2 asynchronous\nprograms. We show that under mild assumptions, surprisingly, safety and\ntermination verification of asynchronous programs with handlers from a language\nclass are decidable iff emptiness is decidable for the underlying language\nclass. Moreover, we show that configuration reachability and liveness (fair\ntermination) verification are equivalent, and decidability of these problems\nimplies decidability of the well-known \"equal-letters\" problem on languages.\nOur results close the decidability frontier for asynchronous programs.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.08611v4"
    },
    {
        "title": "Leafy Automata for Higher-Order Concurrency",
        "authors": [
            "Alex Dixon",
            "Ranko Lazić",
            "Andrzej S. Murawski",
            "Igor Walukiewicz"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Finitary Idealized Concurrent Algol (FICA) is a prototypical programming\nlanguage combining functional, imperative, and concurrent computation. There\nexists a fully abstract game model of FICA, which in principle can be used to\nprove equivalence and safety of FICA programs. Unfortunately, the problems are\nundecidable for the whole language, and only very rudimentary decidable\nsub-languages are known. We propose leafy automata as a dedicated\nautomata-theoretic formalism for representing the game semantics of FICA. The\nautomata use an infinite alphabet with a tree structure. We show that the game\nsemantics of any FICA term can be represented by traces of a leafy automaton.\nConversely, the traces of any leafy automaton can be represented by a FICA\nterm. Because of the close match with FICA, we view leafy automata as a\npromising starting point for finding decidable subclasses of the language and,\nmore generally, to provide a new perspective on models of higher-order\nconcurrent computation. Moreover, we identify a fragment of FICA that is\namenable to verification by translation into a particular class of leafy\nautomata. Using a locality property of the latter class, where communication\nbetween levels is restricted and every other level is bounded, we show that\ntheir emptiness problem is decidable by reduction to Petri net reachability.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.08720v1"
    },
    {
        "title": "Continuous One-Counter Automata",
        "authors": [
            "Michael Blondin",
            "Tim Leys",
            "Filip Mazowiecki",
            "Philip Offtermatt",
            "Guillermo A. Pérez"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the reachability problem for continuous one-counter automata, COCA\nfor short. In such automata, transitions are guarded by upper and lower bound\ntests against the counter value. Additionally, the counter updates associated\nwith taking transitions can be (non-deterministically) scaled down by a nonzero\nfactor between zero and one. Our three main results are as follows: (1) We\nprove that the reachability problem for COCA with global upper and lower bound\ntests is in NC2; (2) that, in general, the problem is decidable in polynomial\ntime; and (3) that it is decidable in the polynomial hierarchy for COCA with\nparametric counter updates and bound tests.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.11996v2"
    },
    {
        "title": "The Theory of Universal Graphs for Infinite Duration Games",
        "authors": [
            "Thomas Colcombet",
            "Nathanaël Fijalkow",
            "Paweł Gawrychowski",
            "Pierre Ohlmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce the notion of universal graphs as a tool for constructing\nalgorithms solving games of infinite duration such as parity games and mean\npayoff games. In the first part we develop the theory of universal graphs, with\ntwo goals: showing an equivalence and normalisation result between different\nrecently introduced related models, and constructing generic value iteration\nalgorithms for any positionally determined objective. In the second part we\ngive four applications: to parity games, to mean payoff games, to a disjunction\nbetween a parity and a mean payoff objective, and to disjunctions of several\nmean payoff objectives. For each of these four cases we construct algorithms\nachieving or improving over the best known time and space complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.05262v8"
    },
    {
        "title": "Affine automata verifiers",
        "authors": [
            "Aliya Khadieva",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We initiate the study of the verification power of AfAs as part of\nArthur-Merlin (AM) proof systems. We show that every unary language is verified\nby a real-valued AfA verifier. Then, we focus on the verifiers restricted to\nhave only integer-valued or rational-valued transitions. We observe that\nrational-valued verifiers can be simulated by integer-valued verifiers, and,\ntheir protocols can be simulated in nondeterministic polynomial time. We show\nthat this bound tight by presenting an AfA verifier for NP-complete problem\nSUBSETSUM. We also show that AfAs can verify certain non-affine and\nnon-stochastic unary languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.11192v1"
    },
    {
        "title": "Active Learning of Sequential Transducers with Side Information about\n  the Domain",
        "authors": [
            "Raphaël Berthon",
            "Adrien Boiret",
            "Guillermo A. Perez",
            "Jean-François Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Active learning is a setting in which a student queries a teacher, through\nmembership and equivalence queries, in order to learn a language. Performance\non these algorithms is often measured in the number of queries required to\nlearn a target, with an emphasis on costly equivalence queries. In graybox\nlearning, the learning process is accelerated by foreknowledge of some\ninformation on the target. Here, we consider graybox active learning of\nsubsequential string transducers, where a regular overapproximation of the\ndomain is known by the student. We show that there exists an algorithm using\nstring equation solvers that uses this knowledge to learn subsequential string\ntransducers with a better guarantee on the required number of equivalence\nqueries than classical active learning.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.11758v1"
    },
    {
        "title": "Parikh's theorem for infinite alphabets",
        "authors": [
            "Piotr Hofman",
            "Marta Juzepczuk",
            "Sławomir Lasota",
            "Mohnish Pattathurajan"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate commutative images of languages recognised by register\nautomata and grammars. Semi-linear and rational sets can be naturally extended\nto this setting by allowing for orbit-finite unions instead of only finite\nones. We prove that commutative images of languages of one-register automata\nare not always semi-linear, but they are always rational. We also lift the\nlatter result to grammars: commutative images of one-register context-free\nlanguages are rational, and in consequence commutatively equivalent to register\nautomata. We conjecture analogous results for automata and grammars with\narbitrarily many registers.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.12018v1"
    },
    {
        "title": "Temporal Reasoning Through Automatic Translation of tock-CSP into Timed\n  Automata",
        "authors": [
            "Abdulrazaq Abba",
            "Ana Cavalcanti",
            "Jeremy Jacob"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this work, we consider translating tock-CSP into Timed Automata for UPPAAL\nto facilitate using UPPAAL in reasoning about temporal specifications of\ntock-CSP models. The process algebra tock-CSP provides textual notations for\nmodelling discrete-time behaviours, with the support of tools for automatic\nverification. Similarly, automatic verification of Timed Automata (TA) with a\ngraphical notation is supported by the UPPAAL real-time verification toolbox\n\\uppaal. The two modelling approaches, TA and tock-CSP, differ in both\nmodelling and verification approaches, temporal logic and refinement,\nrespectively, as well as their provided facilities for automatic verification.\nFor instance, liveness requirements are difficult to specify with the\nconstructs of tock-CSP, but they are easy to specify and verify in UPPAAL. To\ntake advantage of temporal logic, we translate tock-CSP into TA for \\uppaal; we\nhave developed a translation technique and its supporting tool. We provide\nrules for translating tock-CSP into a network of small TAs for capturing the\ncompositional structure of tock-CSP that is not available in TA. For\nvalidation, we start with an experimental approach based on finite\napproximations to trace sets. Then, we explore mathematical proof to establish\nthe correctness of the rules for covering infinite traces.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.13434v1"
    },
    {
        "title": "Reachability in Vector Addition Systems is Ackermann-complete",
        "authors": [
            "Wojciech Czerwiński",
            "Łukasz Orlikowski"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Vector Addition Systems and equivalent Petri nets are a well established\nmodels of concurrency. The central algorithmic problem for Vector Addition\nSystems with a long research history is the reachability problem asking whether\nthere exists a run from one given configuration to another. We settle its\ncomplexity to be Ackermann-complete thus closing the problem open for 45 years.\nIn particular we prove that the problem is $\\mathcal{F}_k$-hard for Vector\nAddition Systems with States in dimension $6k$, where $\\mathcal{F}_k$ is the\n$k$-th complexity class from the hierarchy of fast-growing complexity classes.\n",
        "pdf_link": "http://arxiv.org/pdf/2104.13866v4"
    },
    {
        "title": "A structural operational semantics for interactions with a look at loops",
        "authors": [
            "Erwan Mahe",
            "Christophe Gaston",
            "Pascale Le Gall"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Message Sequence Charts & Sequence Diagrams are graphical models that\nrepresent the behavior of distributed and concurrent systems via the scheduling\nof discrete and local emission and reception events. We propose an Interaction\nLanguage (IL) to formalize such models, defined as a term algebra which\nincludes strict and weak sequencing, alternative and parallel composition and\nfour kinds of loops. This IL is equipped with a denotational-style semantics\nassociating a set of traces (sequences of observed events) to each interaction.\nWe then define a structural operational semantics in the style of process\nalgebras and formally prove the equivalence of both semantics.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.00208v1"
    },
    {
        "title": "Signal automata and hidden Markov models",
        "authors": [
            "Teodor Knapik"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A generic method for inferring a dynamical hidden Markov model from a time\nseries is proposed. Under reasonable hypothesis, the model is updated in\nconstant time whenever a new measurement arrives.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.01341v1"
    },
    {
        "title": "Simulation by Rounds of Letter-to-Letter Transducers",
        "authors": [
            "Antonio Abu Nassar",
            "Shaull Almagor"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Letter-to-letter transducers are a standard formalism for modeling reactive\nsystems. Often, two transducers that model similar systems differ locally from\none another, by behaving similarly, up to permutations of the input and output\nletters within \"rounds\". In this work, we introduce and study notions of\nsimulation by rounds and equivalence by rounds of transducers. In our setting,\nwords are partitioned to consecutive subwords of a fixed length $k$, called\nrounds. Then, a transducer $\\mathcal{T}_1$ is $k$-round simulated by transducer\n$\\mathcal{T}_2$ if, intuitively, for every input word $x$, we can permute the\nletters within each round in $x$, such that the output of $\\mathcal{T}_2$ on\nthe permuted word is itself a permutation of the output of $\\mathcal{T}_1$ on\n$x$. Finally, two transducers are $k$-round equivalent if they simulate each\nother.\n  We solve two main decision problems, namely whether $\\mathcal{T}_2$ $k$-round\nsimulates $\\mathcal{T}_1$ (1) when $k$ is given as input, and (2) for an\nexistentially quantified $k$.\n  We demonstrate the usefulness of the definitions by applying them to process\nsymmetry: a setting in which a permutation in the identities of processes in a\nmulti-process system naturally gives rise to two transducers, whose $k$-round\nequivalence corresponds to stability against such permutations.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.01512v6"
    },
    {
        "title": "A Bit of Nondeterminism Makes Pushdown Automata Expressive and Succinct",
        "authors": [
            "Shibashis Guha",
            "Ismaël Jecker",
            "Karoliina Lehtinen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the expressiveness and succinctness of history-deterministic\npushdown automata (HD-PDA) over finite words, that is, pushdown automata whose\nnondeterminism can be resolved based on the run constructed so far, but\nindependently of the remainder of the input word. These are also known as\ngood-for-games pushdown automata. We prove that HD-PDA recognise more languages\nthan deterministic PDA (DPDA) but not all context-free languages (CFL). This\nclass is orthogonal to unambiguous CFL. We further show that HD-PDA can be\nexponentially more succinct than DPDA, while PDA can be double-exponentially\nmore succinct than HD-PDA. We also study HDness in visibly pushdown automata\n(VPA), which enjoy better closure properties than PDA, and for which we show\nthat deciding HDness is ExpTime-complete. HD-VPA can be exponentially more\nsuccinct than deterministic VPA, while VPA can be exponentially more succinct\nthan HD-VPA. Both of these lower bounds are tight. We then compare HD-PDA with\nPDA for which composition with games is well-behaved, i.e. good-for-games\nautomata. We show that these two notions coincide, but only if we consider\npotentially infinitely branching games. Finally, we study the complexity of\nresolving nondeterminism in HD-PDA. Every HDPDA has a positional resolver, a\nfunction that resolves nondeterminism and that is only dependant on the current\nconfiguration. Pushdown transducers are sufficient to implement the resolvers\nof HD-VPA, but not those of HD-PDA. HD-PDA with finite-state resolvers are\ndeterminisable.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.02611v5"
    },
    {
        "title": "Branching Frequency and Markov Entropy of Repetition-Free Languages",
        "authors": [
            "Elena A. Petrova",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We define a new quantitative measure for an arbitrary factorial language: the\nentropy of a random walk in the prefix tree associated with the language; we\ncall it Markov entropy. We relate Markov entropy to the growth rate of the\nlanguage and to the parameters of branching of its prefix tree. We show how to\ncompute Markov entropy for a regular language. Finally, we develop a framework\nfor experimental study of Markov entropy by modelling random walks and present\nthe results of experiments with power-free and Abelian-power-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.02750v1"
    },
    {
        "title": "Executable Interval Temporal Logic Specifications",
        "authors": [
            "Antonio Cau",
            "Stefan Kuhn",
            "James Hoey"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper the reversibility of executable Interval Temporal Logic (ITL)\nspecifications is investigated. ITL allows for the reasoning about systems in\nterms of behaviours which are represented as non-empty sequences of states. It\nallows for the specification of systems at different levels of abstraction. At\na high level this specification is in terms of properties, for instance safety\nand liveness properties. At concrete level one can specify a system in terms of\nprogramming constructs. One can execute these concrete specification, i.e.,\ntest and simulate the behaviour of the system. In this paper we will formalise\nthis notion of executability of ITL specifications. ITL also has a reflection\noperator which allows for the reasoning about reversed behaviours. We will\ninvestigate the reversibility of executable ITL specifications, i.e., how one\ncan use this reflection operator to reverse the concrete behaviour of a\nparticular system.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.03375v1"
    },
    {
        "title": "A new version of Toom's proof",
        "authors": [
            "Peter Gacs"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  There are several proofs now for the stability of Toom's example of a\ntwo-dimensional stable cellular automaton and its application to fault-tolerant\ncomputation. Simon and Berman simplified and strengthened Toom's original\nproof: the present report is a simplified exposition of their proof.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.05968v1"
    },
    {
        "title": "Improved Ackermannian lower bound for the Petri nets reachability\n  problem",
        "authors": [
            "Sławomir Lasota"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Petri nets, equivalently presentable as vector addition systems with states,\nare an established model of concurrency with widespread applications. The\nreachability problem, where we ask whether from a given initial configuration\nthere exists a sequence of valid execution steps reaching a given final\nconfiguration, is the central algorithmic problem for this model. The\ncomplexity of the problem has remained, until recently, one of the hardest open\nquestions in verification of concurrent systems. A first upper bound has been\nprovided only in 2015 by Leroux and Schmitz, then refined by the same authors\nto non-primitive recursive Ackermannian upper bound in 2019. The exponential\nspace lower bound, shown by Lipton already in 1976, remained the only known for\nover 40 years until a breakthrough non-elementary lower bound by\nCzerwi{\\'n}ski, Lasota, Lazic, Leroux and Mazowiecki in 2019. Finally, a\nmatching Ackermannian lower bound announced this year by Czerwi{\\'n}ski and\nOrlikowski, and independently by Leroux, established the complexity of the\nproblem.\n  Our primary contribution is an improvement of the former construction, making\nit conceptually simpler and more direct. On the way we improve the lower bound\nfor vector addition systems with states in fixed dimension (or, equivalently,\nPetri nets with fixed number of places): while Czerwi{\\'n}ski and Orlikowski\nprove $F_k$-hardness (hardness for $k$th level in Grzegorczyk Hierarchy) in\ndimension $6k$, our simplified construction yields $F_k$-hardness already in\ndimension $3k+2$.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.08551v4"
    },
    {
        "title": "Deciding FO2 Alternation for Automata over Finite and Infinite Words",
        "authors": [
            "Viktor Henriksson",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We consider two-variable first-order logic $\\text{FO}^2$ and its quantifier\nalternation hierarchies over both finite and infinite words. Our main results\nare forbidden patterns for deterministic automata (finite words) and for\nCarton-Michel automata (infinite words). In order to give concise patterns, we\nallow the use of subwords on paths in finite graphs. This concept is formalized\nas subword-patterns. For certain types of subword-patterns there exists a\nnon-deterministic logspace algorithm to decide their presence or absence in a\ngiven automaton. In particular, this leads to $\\mathbf{NL}$ algorithms for\ndeciding the levels of the $\\text{FO}^2$ quantifier alternation hierarchies.\nThis applies to both full and half levels, each over finite and infinite words.\nMoreover, we show that these problems are $\\mathbf{NL}$-hard and, hence,\n$\\mathbf{NL}$-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.09291v3"
    },
    {
        "title": "Decision Questions for Probabilistic Automata on Small Alphabets",
        "authors": [
            "Paul C. Bell",
            "Pavel Semukhin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the emptiness and $\\lambda$-reachability problems for unary and\nbinary Probabilistic Finite Automata (PFA) and characterise the complexity of\nthese problems in terms of the degree of ambiguity of the automaton and the\nsize of its alphabet. Our main result is that emptiness and\n$\\lambda$-reachability are solvable in EXPTIME for polynomially ambiguous unary\nPFA and if, in addition, the transition matrix is binary, we show they are in\nNP. In contrast to the Skolem-hardness of the $\\lambda$-reachability and\nemptiness problems for exponentially ambiguous unary PFA, we show that these\nproblems are NP-hard even for finitely ambiguous unary PFA. For binary\npolynomially ambiguous PFA with fixed and commuting transition matrices, we\nprove NP-hardness of the $\\lambda$-reachability (dimension 9), nonstrict\nemptiness (dimension 37) and strict emptiness (dimension 40) problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.10293v5"
    },
    {
        "title": "Fast zone-based algorithms for reachability in pushdown timed automata",
        "authors": [
            "S. Akshay",
            "Paul Gastin",
            "Karthik R Prakash"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Given the versatility of timed automata a huge body of work has evolved that\nconsiders extensions of timed automata. One extension that has received a lot\nof interest is timed automata with a, possibly unbounded, stack, also called\nthe pushdown timed automata (PDTA) model. While different algorithms have been\ngiven for reachability in different variants of this model, most of these\nresults are purely theoretical and do not give rise to efficient\nimplementations. One main reason for this is that none of these algorithms (and\nthe implementations that exist) use the so-called zone-based abstraction, but\nrely either on the region-abstraction or other approaches, which are\nsignificantly harder to implement.\n  In this paper, we show that a naive extension of the zone based reachability\nalgorithm for the control state reachability problem of timed automata is not\nsound in the presence of a stack. To understand this better we give an\ninductive rule based view of the zone reachability algorithm for timed\nautomata. This alternate view allows us to analyze and adapt the rules to also\nwork for pushdown timed automata. We obtain the first zone-based algorithm for\nPDTA which is terminating, sound and complete. We implement our algorithm in\nthe tool TChecker and perform experiments to show its efficacy, thus leading\nthe way for more practical approaches to the verification of pushdown timed\nsystems.\n",
        "pdf_link": "http://arxiv.org/pdf/2105.13683v2"
    },
    {
        "title": "On (co-lex) Ordering Automata",
        "authors": [
            "Giovanna D'Agostino",
            "Nicola Cotumaccio",
            "Alberto Policriti",
            "Nicola Prezza"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The states of a deterministic finite automaton A can be identified with\ncollections of words in Pf(L(A)) -- the set of prefixes of words belonging to\nthe regular language accepted by A. But words can be ordered and among the many\npossible orders a very natural one is the co-lexicographic one. Such\nnaturalness stems from the fact that it suggests a transfer of the order from\nwords to the automaton's states. In a number of papers automata admitting a\ntotal ordering of states coherent with the ordering of the set of words\nreaching them have been proposed. Such class of ordered automata -- the Wheeler\nautomata -- turned out to be efficiently stored/searched using an index.\nUnfortunately not all automata can be totally ordered as previously outlined.\nHowever, automata can always be partially ordered and an intrinsic measure of\ntheir complexity can be defined and effectively determined, as the minimum\nwidth of one of their admissible partial orders. As shown in previous works,\nthis new concept of width of an automaton has useful consequences in the fields\nof graph compression, indexing data structures, and automata theory. In this\npaper we prove that a canonical, minimum-width, partially-ordered automaton\naccepting a language L -- dubbed the Hasse automaton H of L -- can be\nexhibited. H provides, in a precise sense, the best possible way to (partially)\norder the states of any automaton accepting L, as long as we want to maintain\nan operational link with the (co-lexicographic) order of Pf(L(A)). Using H we\nprove that the width of the language can be effectively computed from the\nminimum automaton recognizing the language. Finally, we explore the\nrelationship between two (often conflicting) objectives: minimizing the width\nand minimizing the number of states of an automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.02309v1"
    },
    {
        "title": "Connectivity of spaces of directed paths in geometric models for\n  concurrent computation",
        "authors": [
            "Martin Raussen"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Higher Dimensional Automata (HDA) are higher dimensional relatives to\ntransition systems in concurrency theory taking into account to which degree\nvarious actions commute. Mathematically, they take the form of labelled cubical\ncomplexes. It is important to know, and challenging from a\ngeometric/topological perspective, whether the space of directed paths\n(executions in the model) between two vertices (states) is connected; more\ngenerally, to estimate higher connectedness of these path spaces.\n  This paper presents an approach for such an estimation for particularly\nsimple HDA modelling the access of a number of processors to a number of\nresources with given limited capacity each. It defines a spare capacity for a\nconcurrent program with prescribed periods of access of the processors to the\nresources. It shows that the connectedness of spaces of directed paths can be\nestimated (from above) by spare capacities. Moreover, spare capacities can also\nbe used to detect deadlocks and critical states in such a HDA.\n  The key theoretical ingredient is a transition from the calculation of local\nconnectedness bounds (of the upper links of vertices of an HDA) to global ones\nby applying a version of the nerve lemma due to Anders Bj\\\"orner.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.11703v3"
    },
    {
        "title": "Generalising Projection in Asynchronous Multiparty Session Types",
        "authors": [
            "Rupak Majumdar",
            "Madhavan Mukund",
            "Felix Stutz",
            "Damien Zufferey"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Multiparty session types (MSTs) provide an efficient methodology for\nspecifying and verifying message passing software systems. In the theory of\nMSTs, a global type specifies the interaction among the roles at the global\nlevel. A local specification for each role is generated by projecting from the\nglobal type on to the message exchanges it participates in. Whenever a global\ntype can be projected on to each role, the composition of the projections is\ndeadlock free and has exactly the behaviours specified by the global type. The\nkey to the usability of MSTs is the projection operation: a more expressive\nprojection allows more systems to be type-checked but requires a more difficult\nsoundness argument. In this paper, we generalise the standard projection\noperation in MSTs. This allows us to model and type-check many design patterns\nin distributed systems, such as load balancing, that are rejected by the\nstandard projection. The key to the new projection is an analysis that tracks\ncausality between messages. Our soundness proof uses novel graph-theoretic\ntechniques from the theory of message-sequence charts. We demonstrate the\nefficacy of the new projection operation by showing many global types for\ncommon patterns that can be projected under our projection but not under the\nstandard projection operation.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.03984v3"
    },
    {
        "title": "Composition of choreography automata",
        "authors": [
            "Franco Barbanera",
            "Ivan Lanese",
            "Emilio Tuosto"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Choreography automata are an automata-based model of choreographies, that we\nshow to be a compositional one. Choreography automata represent global views of\nchoreographies (and rely on the well-known model of communicating finite-state\nmachines to model local behaviours). The projections of well-formed global\nviews are live as well as lock- and deadlock-free. In the class of choreography\nautomata we define an internal operation of {\\em composition}, which connects\ntwo global views via roles acting as interfaces. We show that under mild\nconditions the composition of well-formed choreography automata is well-formed.\nThe composition operation enables for a flexible modular mechanism at the\ndesign level.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.06727v1"
    },
    {
        "title": "Logics Meet 2-Way 1-Clock Alternating Timed Automata",
        "authors": [
            "Shankara Narayanan Krishna",
            "Khushraj Nanik Madnani",
            "Manuel Mazo Jr.",
            "Paritosh K. Pandya"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we study the extension of 1-clock Alternating Timed Automata\n(1-ATA) with the ability to read in both forward and backward direction, the\n2-Way 1-clock Alternating Timed Automata (2-Way 1-ATA). We show that subclass\nof 2-Way 1-ATA with reset free loops (2-Way 1-ATA-rfl) is expressively\nequivalent to MSO[<] extended with Guarded Metric Quantifiers (GQMSO).\nEmptiness Checking problem for 2-Way 1-ATA-rfl (and hence GQMSO) is\nundecidable, in general. We propose a \"non-punctuality\" like restriction,\ncalled non-adjacency, for 2-Way 1-ATA-rfl, and also for GQMSO, for which the\nemptiness (respectively, satisfiability) checking becomes decidable.\nNon-Adjacent 2-Way 1-ATA is the first such class of Timed Automata with\nalternations and 2-wayness for which the emptiness checking is decidable (and\nthat too with elementary complexity). We also show that 2-Way 1-ATA-rfl, even\nwith the non-adjacent restrictions, can express properties is not recognizable\nusing 1-ATA.\n",
        "pdf_link": "http://arxiv.org/pdf/2107.12986v2"
    },
    {
        "title": "Featured Team Automata",
        "authors": [
            "Maurice H. ter Beek",
            "Guillermina Cledou",
            "Rolf Hennicker",
            "José Proença"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We propose featured team automata to support variability in the development\nand analysis of teams, which are systems of reactive components that\ncommunicate according to specified synchronisation types. A featured team\nautomaton concisely describes a family of concrete product models for specific\nconfigurations determined by feature selection. We focus on the analysis of\ncommunication-safety properties, but doing so product-wise quickly becomes\nimpractical. Therefore, we investigate how to lift notions of receptiveness (no\nmessage loss) to the level of family models. We show that featured (weak)\nreceptiveness of featured team automata characterises (weak) receptiveness for\nall product instantiations. A prototypical tool supports the developed theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.01784v1"
    },
    {
        "title": "Composition Machines: Programming Self-Organising Software Models for\n  the Emergence of Sequential Program Spaces",
        "authors": [
            "Damian Arellanes"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We are entering a new era in which software systems are becoming more and\nmore complex and larger. So, the composition of such systems is becoming\ninfeasible by manual means. To address this challenge, self-organising software\nmodels represent a promising direction since they allow the (bottom-up)\nemergence of complex computational structures from simple rules. In this paper,\nwe propose an abstract machine, called the composition machine, which allows\nthe definition and the execution of such models. Unlike typical abstract\nmachines, our proposal does not compute individual programs but enables the\nemergence of multiple programs at once. We particularly present the machine's\nsemantics and provide examples to demonstrate its operation with well-known\nrules from the realm of Boolean logic and elementary cellular automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.05402v1"
    },
    {
        "title": "Automating System Configuration",
        "authors": [
            "Nestan Tsiskaridze",
            "Maxwell Strange",
            "Makai Mann",
            "Kavya Sreedhar",
            "Qiaoyi Liu",
            "Mark Horowitz",
            "Clark Barrett"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The increasing complexity of modern configurable systems makes it critical to\nimprove the level of automation in the process of system configuration. Such\nautomation can also improve the agility of the development cycle, allowing for\nrapid and automated integration of decoupled workflows. In this paper, we\npresent a new framework for automated configuration of systems representable as\nstate machines. The framework leverages model checking and satisfiability\nmodulo theories (SMT) and can be applied to any application domain\nrepresentable using SMT formulas. Our approach can also be applied modularly,\nimproving its scalability. Furthermore, we show how optimization can be used to\nproduce configurations that are best according to some metric and also more\nlikely to be understandable to humans. We showcase this framework and its\nflexibility by using it to configure a CGRA memory tile for various image\nprocessing applications.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.05987v2"
    },
    {
        "title": "Constrained Synchronization and Subset Synchronization Problems for\n  Weakly Acyclic Automata",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We investigate the constrained synchronization problem for weakly acyclic, or\npartially ordered, input automata. We show that, for input automata of this\ntype, the problem is always in NP. Furthermore, we give a full classification\nof the realizable complexities for constraint automata with at most two states\nand over a ternary alphabet. We find that most constrained problems that are\nPSPACE-complete in general become NP-complete. However, there also exist\nconstrained problems that are PSPACE-complete in the general setting but become\npolynomial time solvable when considered for weakly acyclic input automata. We\nalso investigate two problems related to subset synchronization, namely if\nthere exists a word mapping all states into a given target subset of states,\nand if there exists a word mapping one subset into another. Both problems are\nPSPACE-complete in general, but in our setting the former is polynomial time\nsolvable and the latter is NP-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.06984v1"
    },
    {
        "title": "On balanced sequences and their critical exponent",
        "authors": [
            "Francesco Dolce",
            "Lubomira Dvorakova",
            "Edita Pelantova"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study aperiodic balanced sequences over finite alphabets. A sequence vv of\nthis type is fully characterised by a Sturmian sequence u and two constant gap\nsequences y and y'. We show that the language of v is eventually dendric and we\nfocus on return words to its factors. We develop a method for computing the\ncritical exponent and asymptotic critical exponent of balanced sequences,\nprovided the associated Sturmian sequence u has a quadratic slope. The method\nis based on looking for the shortest return words to bispecial factors in v. We\nillustrate our method on several examples; in particular we confirm a\nconjecture of Rampersad, Shallit and Vandomme that two specific sequences have\nthe least critical exponent among all balanced sequences over 9-letter (resp.,\n$0-letter) alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.07503v2"
    },
    {
        "title": "The n-ary Initial Literal and Literal Shuffle",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The literal and the initial literal shuffle have been introduced to model the\nbehavior of two synchronized processes. However, it is not possible to describe\nthe synchronization of multiple processes. Furthermore, both restricted forms\nof shuffling are not associative. Here, we extend the literal shuffle and the\ninitial literal shuffle to multiple arguments. We also introduce iterated\nversions, much different from the iterated ones previously introduced for the\nbinary literal and initial literal shuffle. We investigate formal properties,\nand show that in terms of expressive power, in a full trio, they coincide with\nthe general shuffle. Furthermore, we look at closure properties with respect to\nthe regular, context-free, context-sensitive, recursive and recursively\nenumerable languages for all operations introduced. Then, we investigate\nvarious decision problems motivated by analogous problems for the (ordinary)\nshuffle operation. Most problems we look at are tractable, but we also identify\none intractable decision problem.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.09282v1"
    },
    {
        "title": "Second-Order Finite Automata",
        "authors": [
            "Alexsander Andrade de Melo",
            "Mateus de Oliveira Oliveira"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Traditionally, finite automata theory has been used as a framework for the\nrepresentation of possibly infinite sets of strings. In this work, we introduce\nthe notion of second-order finite automata, a formalism that combines finite\nautomata with ordered decision diagrams, with the aim of representing possibly\ninfinite {\\em sets of sets} of strings. Our main result states that\nsecond-order finite automata can be canonized with respect to the second-order\nlanguages they represent. Using this canonization result, we show that sets of\nsets of strings represented by second-order finite automata are closed under\nthe usual Boolean operations, such as union, intersection, difference and even\nunder a suitable notion of complementation. Additionally, emptiness of\nintersection and inclusion are decidable.\n  We provide two algorithmic applications for second-order automata. First, we\nshow that several width/size minimization problems for deterministic and\nnondeterministic ODDs are solvable in fixed-parameter tractable time when\nparameterized by the width of the input ODD. In particular, our results imply\nFPT algorithms for corresponding width/size minimization problems for ordered\nbinary decision diagrams (OBDDs) with a fixed variable ordering. Previously,\nonly algorithms that take exponential time in the size of the input OBDD were\nknown for width minimization, even for OBDDs of constant width. Second, we show\nthat for each $k$ and $w$ one can count the number of distinct functions\ncomputable by ODDs of width at most $w$ and length $k$ in time\n$h(|\\Sigma|,w)\\cdot k^{O(1)}$, for a suitable $h:\\mathbb{N}\\times\n\\mathbb{N}\\rightarrow \\mathbb{N}$. This improves exponentially on the time\nnecessary to explicitly enumerate all such functions, which is exponential in\nboth the width parameter $w$ and in the length $k$ of the ODDs.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.12751v1"
    },
    {
        "title": "Parameterizations of Logarithmic-Space Reductions, Stack-State\n  Complexity of Nonuniform Families of Pushdown Automata, and a Road to the\n  LOGCFL$\\subseteq$LOGDCFL/poly Question",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The complexity class LOGCFL (resp., LOGDCFL) consists of all languages that\nare many-one reducible to context-free (resp., deterministic context-free)\nlanguages using logarithmic space. These complexity classes have been studied\nover five decades in connection to parallel computation since they are located\nbetween Nick's classes $\\mathrm{NC}^1$ and $\\mathrm{NC}^2$. In contrast, the\nstate complexity of nonuniform finite-automaton families was first discussed in\nthe 1970s and it has been extensively explored lately for various\nfinite-automata families. We extend this old subject to the stack-state\ncomplexity (i.e., the total number of inner states plus simultaneously pushable\nstack symbol series) of nonuniform families of various pushdown automata. We\nintroduce reasonable \"parameterizations\" of LOGCFL and LOGDCFL and apply them\nas a technical tool to establish a close connection between the\nLOGCFL$\\subseteq$LOGDCFL/poly question and the polynomial stack-state\ncomplexity of nonuniform families of two-way pushdown automata. We also discuss\nthe precise computational complexity of polynomial-size one-way pushdown\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.12779v1"
    },
    {
        "title": "Coalgebras for Bisimulation of Weighted Automata over Semirings",
        "authors": [
            "Purandar Bhaduri"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Weighted automata are a generalization of nondeterministic automata that\nassociate a weight drawn from a semiring $K$ with every transition and every\nstate. Their behaviours can be formalized either as weighted language\nequivalence or weighted bisimulation. In this paper we explore the properties\nof weighted automata in the framework of coalgebras over (i) the category\n$\\mathsf{SMod}$ of semimodules over a semiring $K$ and $K$-linear maps, and\n(ii) the category $\\mathsf{Set}$ of sets and maps. We show that the behavioural\nequivalences defined by the corresponding final coalgebras in these two cases\ncharacterize weighted language equivalence and weighted bisimulation,\nrespectively. These results extend earlier work by Bonchi et al. using the\ncategory $\\mathsf{Vect}$ of vector spaces and linear maps as the underlying\nmodel for weighted automata with weights drawn from a field $K$. The key step\nin our work is generalizing the notions of linear relation and linear\nbisimulation of Boreale from vector spaces to semimodules using the concept of\nthe kernel of a $K$-linear map in the sense of universal algebra. We also\nprovide an abstract procedure for forward partition refinement for computing\nweighted language equivalence. Since for weighted automata defined over\nsemirings the problem is undecidable in general, it is guaranteed to halt only\nin special cases. We provide sufficient conditions for the termination of our\nprocedure. Although the results are similar to those of Bonchi et al., many of\nour proofs are new, especially those about the coalgebra in $\\mathsf{SMod}$\ncharacterizing weighted language equivalence.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.00732v4"
    },
    {
        "title": "A Survey of Practical Formal Methods for Security",
        "authors": [
            "Tomas Kulik",
            "Brijesh Dongol",
            "Peter Gorm Larsen",
            "Hugo Daniel Macedo",
            "Steve Schneider",
            "Peter Würtz Vinther Tran-Jørgensen",
            "Jim Woodcock"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In today's world, critical infrastructure is often controlled by computing\nsystems. This introduces new risks for cyber attacks, which can compromise the\nsecurity and disrupt the functionality of these systems. It is therefore\nnecessary to build such systems with strong guarantees of resiliency against\ncyber attacks. One way to achieve this level of assurance is using formal\nverification, which provides proofs of system compliance with desired cyber\nsecurity properties. The use of Formal Methods (FM) in aspects of cyber\nsecurity and safety-critical systems are reviewed in this article. We split FM\ninto the three main classes: theorem proving, model checking and lightweight\nFM. To allow the different uses of FM to be compared, we define a common set of\nterms. We further develop categories based on the type of computing system FM\nare applied in. Solutions in each class and category are presented, discussed,\ncompared and summarised. We describe historical highlights and developments and\npresent a state-of-the-art review in the area of FM in cyber security. This\nreview is presented from the point of view of FM practitioners and researchers,\ncommenting on the trends in each of the classes and categories. This is\nachieved by considering all types of FM, several types of security and safety\ncritical systems and by structuring the taxonomy accordingly. The article hence\nprovides a comprehensive overview of FM and techniques available to system\ndesigners of security-critical systems, simplifying the process of choosing the\nright tool for the task. The article concludes by summarising the discussion of\nthe review, focusing on best practices, challenges, general future trends and\ndirections of research within this field.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.01362v1"
    },
    {
        "title": "Constrained Synchronization for Commutative Automata and Automata with\n  Simple Idempotents",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  For general input automata, there exist regular constraint languages such\nthat asking if a given input automaton admits a synchronizing word in the\nconstraint language is PSPACE-complete or NP-complete. Here, we investigate\nthis problem for commutative automata over an arbitrary alphabet and automata\nwith simple idempotents over a binary alphabet as input automata. The latter\nclass contains, for example, the \\v{C}ern\\'y family of automata. We find that\nfor commutative input automata, the problem is always solvable in polynomial\ntime, for every constraint language. For input automata with simple idempotents\nover a binary alphabet and with a constraint language given by a partial\nautomaton with up to three states, the constrained synchronization problem is\nalso solvable in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.02743v1"
    },
    {
        "title": "Adapting to the Behavior of Environments with Bounded Memory",
        "authors": [
            "Dhananjay Raju",
            "Rüdiger Ehlers",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the problem of synthesizing implementations from temporal logic\nspecifications that need to work correctly in all environments that can be\nrepresented as transducers with a limited number of states. This problem was\noriginally defined and studied by Kupferman, Lustig, Vardi, and Yannakakis.\nThey provide NP and 2-EXPTIME lower and upper bounds (respectively) for the\ncomplexity of this problem, in the size of the transducer. We tighten the gap\nby providing a PSPACE lower bound, thereby showing that algorithms for solving\nthis problem are unlikely to scale to large environment sizes. This result is\nsomewhat unfortunate as solving this problem enables tackling some high-level\ncontrol problems in which an agent has to infer the environment behavior from\nobservations. To address this observation, we study a modified synthesis\nproblem in which the synthesized controller must gather information about the\nenvironment's behavior safely. We show that the problem of determining whether\nthe behavior of such an environment can be safely learned is only\nco-NP-complete. Furthermore, in such scenarios, the behavior of the environment\ncan be learned using a Turing machine that requires at most polynomial space in\nthe size of the environment's transducer.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.08316v1"
    },
    {
        "title": "Expressiveness of Extended Bounded Response LTL",
        "authors": [
            "Alessandro Cimatti",
            "Luca Geatti",
            "Nicola Gigante",
            "Angelo Montanari",
            "Stefano Tonetta"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Extended Bounded Response LTL with Past (LTLEBR+P) is a safety fragment of\nLinear Temporal Logic with Past (LTL+P) that has been recently introduced in\nthe context of reactive synthesis. The strength of LTLEBR+P is a fully symbolic\ncompilation of formulas into symbolic deterministic automata. Its syntax is\norganized in four levels. The first three levels feature (a particular\ncombination of) future temporal modalities, the last one admits only past\ntemporal operators. At the base of such a structuring there are algorithmic\nmotivations: each level corresponds to a step of the algorithm for the\nautomaton construction. The complex syntax of LTLEBR+P made it difficult to\nprecisely characterize its expressive power, and to compare it with other LTL+P\nsafety fragments.\n  In this paper, we first prove that LTLEBR+P is expressively complete with\nrespect to the safety fragment of LTL+P, that is, any safety language definable\nin LTL+P can be formalized in LTLEBR+P, and vice versa. From this, it follows\nthat LTLEBR+P and Safety-LTL are expressively equivalent. Then, we show that\npast modalities play an essential role in LTLEBR+P: we prove that the future\nfragment of LTLEBR+P is strictly less expressive than full LTLEBR+P.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.08319v1"
    },
    {
        "title": "A Nivat Theorem for Weighted Alternating Automata over Commutative\n  Semirings",
        "authors": [
            "Gustav Grabolle"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we give a Nivat-like characterization for weighted alternating\nautomata over commutative semirings (WAFA). To this purpose we prove that\nweighted alternating can be characterized as the concatenation of weighted\nfinite tree automata (WFTA) and a specific class of tree homomorphism. We show\nthat the class of series recognized by weighted alternating automata is closed\nunder inverses of homomorphisms, but not under homomorphisms. We give a logical\ncharacterization of weighted alternating automata, which uses weighted MSO\nlogic for trees. Finally we investigate the strong connection between weighted\nalternating automata and polynomial automata. Using the corresponding result\nfor polynomial automata, we are able to prove that the ZERONESS problem for\nweighted alternating automata with the rational numbers as weights is\ndecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.08323v1"
    },
    {
        "title": "Lower Bounds for Unambiguous Automata via Communication Complexity",
        "authors": [
            "Mika Göös",
            "Stefan Kiefer",
            "Weiqiang Yuan"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We use results from communication complexity, both new and old ones, to prove\nlower bounds for unambiguous finite automata (UFAs). We show three results.\n  $\\textit{Complement:}$ There is a language $L$ recognised by an $n$-state UFA\nsuch that the complement language $\\overline{L}$ requires NFAs with\n$n^{\\tilde{\\Omega}(\\log n)}$ states. This improves on a lower bound by Raskin.\n  $\\textit{Union:}$ There are languages $L_1$, $L_2$ recognised by $n$-state\nUFAs such that the union $L_1\\cup L_2$ requires UFAs with\n$n^{\\tilde{\\Omega}(\\log n)}$ states.\n  $\\textit{Separation:}$ There is a language $L$ such that both $L$ and\n$\\overline{L}$ are recognised by $n$-state NFAs but such that $L$ requires UFAs\nwith $n^{\\Omega(\\log n)}$ states. This refutes a conjecture by Colcombet.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.09155v2"
    },
    {
        "title": "Approximate Bisimulation Minimisation",
        "authors": [
            "Stefan Kiefer",
            "Qiyi Tang"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We propose polynomial-time algorithms to minimise labelled Markov chains\nwhose transition probabilities are not known exactly, have been perturbed, or\ncan only be obtained by sampling. Our algorithms are based on a new notion of\nan approximate bisimulation quotient, obtained by lumping together states that\nare exactly bisimilar in a slightly perturbed system. We present experiments\nthat show that our algorithms are able to recover the structure of the\nbisimulation quotient of the unperturbed system.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.00326v1"
    },
    {
        "title": "What can we learn from universal Turing machines?",
        "authors": [
            "Maurice Margenstern"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In the present paper, we construct what we call a pedagogical universal\nTuring machine. We try to understand which comparisons with biological\nphenomena can be deduced from its encoding and from its working.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.08511v1"
    },
    {
        "title": "Turing Tumble is Turing-Complete",
        "authors": [
            "Lenny Pitt"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  It is shown that the toy Turing Tumble, suitably extended with an infinitely\nlong game board and unlimited supply of pieces, is Turing-Complete. This is\nachieved via direct simulation of a Turing machine. Unlike previously\ninformally presented constructions, we do not encode the finite control\ninfinitely many times, we need only one trigger/ball-hopper pair, and we prove\nour construction correct. We believe this is the first natural extension of a\nmarble-based computer that has been shown to be universal.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.09343v1"
    },
    {
        "title": "Investigating Reversibility of Steps in Petri Nets",
        "authors": [
            "David de Frutos Escrig",
            "Maciej Koutny",
            "Łukasz Mikulski"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In reversible computations one is interested in the development of mechanisms\nallowing to undo the effects of executed actions. The past research has been\nconcerned mainly with reversing single actions. In this paper, we consider the\nproblem of reversing the effect of the execution of groups of actions (steps).\n  Using Petri nets as a system model, we introduce concepts related to this new\nscenario, generalising notions used in the single action case. We then present\nproperties arising when reverse actions are allowed in place/transition nets\n(pt-nets). We obtain both positive and negative results, showing that allowing\nsteps makes reversibility more problematic than in the interleaving/sequential\ncase. In particular, we demonstrate that there is a crucial difference between\nreversing steps which are sets and those which are true multisets. Moreover, in\ncontrast to sequential semantics, splitting reverses does not lead to a general\nmethod for reversing bounded pt-nets. We then show that a suitable solution can\nbe obtained by combining split reverses with weighted read arcs.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.10535v2"
    },
    {
        "title": "The No Endmarker Theorem for One-Way Probabilistic Pushdown Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In various models of one-way pushdown automata, the explicit use of two\ndesignated endmarkers on a read-once input tape has proven to be extremely\nuseful for making a conscious, final decision on the acceptance/rejection of\neach input word right after reading the right endmarker. With no endmarkers, by\ncontrast, a machine must constantly stay in either accepting or rejecting\nstates at any moment since it never notices the end of the input instance. This\nsituation, however, helps us analyze the behavior of the machine whose tape\nhead makes the consecutive moves on all prefixes of a given extremely long\ninput word. Since those two machine formulations have their own advantages, it\nis natural to ask whether the endmarkers are truly necessary to correctly\nrecognize languages. In the deterministic and nondeterministic models, it is\nwell-known that the endmarkers are removable without changing the acceptance\ncriteria of each input instance. This paper proves that, for a more general\nmodel of one-way probabilistic pushdown automata, the endmarkers are also\nremovable. This is proven by employing probabilistic transformations from an\n\"endmarker\" machine to an equivalent \"no-endmarker\" machine at the cost of\ndouble exponential state complexity without compromising its error probability.\nBy setting this error probability appropriately, our proof also provides an\nalternative proof to both the deterministic and the nondeterministic models as\nwell.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.02688v2"
    },
    {
        "title": "Model Checking Temporal Properties of Recursive Probabilistic Programs",
        "authors": [
            "Tobias Winkler",
            "Christina Gehnen",
            "Joost-Pieter Katoen"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Probabilistic pushdown automata (pPDA) are a standard operational model for\nprogramming languages involving discrete random choices and recursive\nprocedures. Temporal properties are useful for specifying the chronological\norder of events during program execution. Existing approaches for model\nchecking pPDA against temporal properties have focused mostly on\n$\\omega$-regular and LTL properties. In this paper, we give decidability and\ncomplexity results for the model checking problem of pPDA against\n$\\omega$-visibly pushdown languages that can be described by specification\nlogics such as CaRet. These logical formulae allow specifying properties that\nexplicitly take the structured computations arising from procedural programs\ninto account. For example, CaRet is able to match procedure calls with their\ncorresponding future returns, and thus allows to express fundamental program\nproperties such as total and partial correctness.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.03501v6"
    },
    {
        "title": "Behavioral Strengths and Weaknesses of Various Models of Limited\n  Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We examine the behaviors of various models of $k$-limited automata, which\nnaturally extend Hibbard's [Inf. Control, vol. 11, pp. 196--238, 1967] scan\nlimited automata, each of which is a single-tape linear-bounded automaton\nsatisfying the $k$-limitedness requirement that the content of each tape cell\nshould be modified only during the first $k$ visits of a tape head. One central\ncomputation model is a probabilistic $k$-limited automaton (abbreviated as a\n$k$-lpa), which accepts an input exactly when its accepting states are\nreachable from its initial state with probability more than 1/2 within expected\npolynomial time. We also study the behaviors of one-sided-error and\nbounded-error variants of such $k$-lpa's as well as the deterministic,\nnondeterministic, and unambiguous models of $k$-limited automata, which can be\nviewed as natural restrictions of $k$-lpa's. We discuss fundamental properties\nof these machine models and obtain inclusions and separations among language\nfamilies induced by them. In due course, we study special features -- the blank\nskipping property and the closure under reversal -- which are keys to the\nrobustness of $k$-lpa's.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.05000v1"
    },
    {
        "title": "A Diamond Structure in the Transducer Hierarchy",
        "authors": [
            "Noah Kaufmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We answer an open question in the theory of transducer degrees initially\nposed in [1] on the existence of a diamond structure in the transducer\nhierarchy. Transducer degrees are the equivalence classes formed by word\ntransformations which can be realized by a finite state transducer, which form\nan order based on which words can be transformed into other words. We provide a\nconstruction which proves the existence of a diamond structure, while also\nintroducing a new function on streams which may be useful for proving more\nresults about the transducer hierarchy.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.05481v3"
    },
    {
        "title": "Classifying All Degrees Below $N^3$",
        "authors": [
            "Noah Kaufmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We answer an open question in the theory of transducer degrees initially\nposed in [3], on the structure of polynomial transducer degrees, in particular\nthe question of what degrees, if any, lie below the degree of $n^3$. Transducer\ndegrees are the equivalence classes formed by word transformations which can be\nrealized by a finite-state transducer. While there are no general techniques to\ntell if a word $w_1$ can be transformed into $w_2$ via an FST, the work of\nEndrullis et al. in [2] provides a test for the class of spiralling functions,\nwhich includes all polynomials. We classify fully the degrees of all cubic\npolynomials which are below $n^3$, and many of the methods can also be used to\nclassify the degrees of polynomials of higher orders.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.06505v1"
    },
    {
        "title": "Developing a Prototype of a Mechanical Ventilator Controller from\n  Requirements to Code with ASMETA",
        "authors": [
            "Andrea Bombarda",
            "Silvia Bonfanti",
            "Angelo Gargantini",
            "Elvinia Riccobene"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Rigorous development processes aim to be effective in developing critical\nsystems, especially if failures can have catastrophic consequences for humans\nand the environment. Such processes generally rely on formal methods, which can\nguarantee, thanks to their mathematical foundation, model preciseness, and\nproperties assurance. However, they are rarely adopted in practice. In this\npaper, we report our experience in using the Abstract State Machine formal\nmethod and the ASMETA framework in developing a prototype of the control\nsoftware of the MVM (Mechanical Ventilator Milano), a mechanical lung\nventilator that has been designed, successfully certified, and deployed during\nthe COVID-19 pandemic. Due to time constraints and lack of skills, no formal\nmethod was applied for the MVM project. However, we here want to assess the\nfeasibility of developing (part of) the ventilator by using a formal\nmethod-based approach. Our development process starts from a high-level formal\nspecification of the system to describe the MVM main operation modes. Then,\nthrough a sequence of refined models, all the other requirements are captured,\nup to a level in which a C++ implementation of a prototype of the MVM\ncontroller is automatically generated from the model, and tested. Along the\nprocess, at each refinement level, different model validation and verification\nactivities are performed, and each refined model is proved to be a correct\nrefinement of the previous level. By means of the MVM case study, we evaluate\nthe effectiveness and usability of our formal approach.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.08204v1"
    },
    {
        "title": "Context-Bounded Verification of Thread Pools",
        "authors": [
            "Pascal Baumann",
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Thread pooling is a common programming idiom in which a fixed set of worker\nthreads are maintained to execute tasks concurrently. The workers repeatedly\npick tasks and execute them to completion. Each task is sequential, with\npossibly recursive code, and tasks communicate over shared memory. Executing a\ntask can lead to more new tasks being spawned. We consider the safety\nverification problem for thread-pooled programs. We parameterize the problem\nwith two parameters: the size of the thread pool as well as the number of\ncontext switches for each task. The size of the thread pool determines the\nnumber of workers running concurrently. The number of context switches\ndetermines how many times a worker can be swapped out while executing a single\ntask - like many verification problems for multithreaded recursive programs,\nthe context bounding is important for decidability.\n  We show that the safety verification problem for thread-pooled,\ncontext-bounded, Boolean programs is EXPSPACE-complete, even if the size of the\nthread pool and the context bound are given in binary. Our main result, the\nEXPSPACE upper bound, is derived using a sequence of new succinct encoding\ntechniques of independent language-theoretic interest. In particular, we show a\npolynomial-time construction of downward closures of languages accepted by\nsuccinct pushdown automata as doubly succinct nondeterministic finite automata.\nWhile there are explicit doubly exponential lower bounds on the size of\nnondeterministic finite automata accepting the downward closure, our result\nshows these automata can be compressed. We show that thread pooling\nsignificantly reduces computational power: in contrast, if only the context\nbound is provided in binary, but there is no thread pooling, the safety\nverification problem becomes 3EXPSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.09022v1"
    },
    {
        "title": "On formally undecidable propositions in nondeterministic languages",
        "authors": [
            "Martin Kolář"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Any class of languages $\\mathbf{L}$ accepted in time $\\mathbf{T}$ has a\ncounterpart $\\mathbf{NL}$ accepted in nondeterministic time $\\mathbf{NT}$. It\nfollows from the definition of nondeterministic languages that $\\mathbf{L}\n\\subseteq \\mathbf{NL}$. This work shows that every sufficiently powerful\nlanguage in $\\mathbf{L}$ contains a string corresponding to G\\\"{o}del's\nundecidable proposition, but this string is not contained in its\nnondeterministic counterpart. This inconsistency in the definition of\nnondeterministic languages shows that certain questions regarding\nnondeterministic time complexity equivalences are irrevocably ill-posed.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.14807v1"
    },
    {
        "title": "Active Learning of Abstract System Models from Traces using Model\n  Checking [Extended]",
        "authors": [
            "Natasha Yogananda Jeppu",
            "Tom Melham",
            "Daniel Kroening"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present a new active model-learning approach to generating abstractions of\na system implementation, as finite state automata (FSAs), from execution\ntraces. Given an implementation and a set of observable system variables, the\ngenerated automata admit all system behaviours over the given variables and\nprovide useful insight in the form of invariants that hold on the\nimplementation. To achieve this, the proposed approach uses a pluggable model\nlearning component that can generate an FSA from a given set of traces.\nConditions that encode a completeness hypothesis are then extracted from the\nFSA under construction and used to evaluate its degree of completeness by\nchecking their truth value against the system using software model checking.\nThis generates new traces that express any missing behaviours. The new trace\ndata is used to iteratively refine the abstraction, until all system behaviours\nare admitted by the learned abstraction. To evaluate the approach, we\nreverse-engineer a set of publicly available Simulink Stateflow models from\ntheir C implementations.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.05990v1"
    },
    {
        "title": "Verification of Component-based Systems with Recursive Architectures",
        "authors": [
            "Marius Bozga",
            "Radu Iosif",
            "Joseph Sifakis"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study a sound verification method for parametric component-based systems.\nThe method uses a resource logic, a new formal specification language for\ndistributed systems consisting of a finite yet unbounded number of components.\nThe logic allows the description of architecture configurations coordinating\ninstances of a finite number of types of components, by means of inductive\ndefinitions similar to the ones used to describe algebraic data types or\nrecursive data structures. For parametric systems specified in this logic, we\nshow that decision problems such as reaching deadlock or violating critical\nsection are undecidable, in general. Despite this negative result, we provide\nfor these decision problems practical semi-algorithms relying on the automatic\nsynthesis of structural invariants allowing the proof of general safety\nproperties. The invariants are defined using the WSkS fragment of the monadic\nsecond order logic, known to be decidable by a classical automata-logic\nconnection, thus reducing a verification problem to checking satisfiability of\na WSkS formula.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.08292v1"
    },
    {
        "title": "Intersection and Union Hierarchies of Deterministic Context-Free\n  Languages and Pumping Lemmas",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study the computational complexity of finite intersections and unions of\ndeterministic context-free (dcf) languages. Earlier, Wotschke [J. Comput.\nSystem Sci. 16 (1978) 456--461] demonstrated that intersections of $(d+1)$ dcf\nlanguages are in general more powerful than intersections of $d$ dcf languages\nfor any positive integer $d$ based on the intersection hierarchy separation of\nLiu and Weiner [Math. Systems Theory 7 (1973) 185--192]. The argument of Liu\nand Weiner, however, works only on bounded languages of particular forms, and\ntherefore Wotschke's result is not directly extendable to disprove any given\nlanguage to be written in the form of $d$ intersection of dcf languages. To\ndeal with the non-membership of a wide range of languages, we circumvent the\nspecialization of their proof argument and devise a new and practical technical\ntool: two pumping lemmas for finite unions of dcf languages. Since the family\nof dcf languages is closed under complementation and also under intersection\nwith regular languages, these pumping lemmas help us establish a non-membership\nrelation of languages formed by finite intersections of non-bounded languages\nas well. We also refer to a relationship to deterministic limited automata of\nHibbard [Inf. Control 11 (1967) 196--238] in this regard.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.09383v1"
    },
    {
        "title": "Proceedings Twelfth International Workshop on Graph Computational Models",
        "authors": [
            "Berthold Hoffmann",
            "Mark Minas"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This volume contains the post-proceedings of the Twelfth International\nWorkshop on Graph Computation Models (GCM 2021). The workshop was part of STAF\n2021 (Software Technologies: Applications and Foundations) as an\nonline-workshop on 22nd June 2021.\n  Graphs are common mathematical structures that are visual and intuitive. They\nconstitute a natural and seamless way for system modelling in science,\nengineering and beyond, including computer science, biology, business process\nmodelling, etc. Graph computation models constitute a class of very high-level\nmodels where graphs are first-class citizens. The aim of the International GCM\nWorkshop series is to bring together researchers interested in all aspects of\ncomputation models based on graphs and graph transformation. It promotes the\ncross-fertilizing exchange of ideas and experiences among senior and young\nresearchers from the different communities interested in the foundations,\napplications, and implementations of graph computation models and related\nareas.\n",
        "pdf_link": "http://arxiv.org/pdf/2112.10217v1"
    },
    {
        "title": "Grammars Based on a Logic of Hypergraph Languages",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The hyperedge replacement grammar (HRG) formalism is a natural and well-known\ngeneralization of context-free grammars. HRGs inherit a number of properties of\ncontext-free grammars, e.g. the pumping lemma. This lemma turns out to be a\nstrong restriction in the hypergraph case: it implies that languages of\nunbounded connectivity cannot be generated by HRGs. We introduce a formalism\nthat turns out to be more powerful than HRGs while having the same algorithmic\ncomplexity (NP-complete). Namely, we introduce hypergraph Lambek grammars; they\nare based on the hypergraph Lambek calculus, which may be considered as a logic\nof hypergraph languages. We explain the underlying principles of hypergraph\nLambek grammars, establish their basic properties, and show some languages of\nunbounded connectivity that can be generated by them (e.g. the language of all\ngraphs, the language of all bipartite graphs, the language of all regular\ngraphs).\n",
        "pdf_link": "http://arxiv.org/pdf/2112.11033v1"
    },
    {
        "title": "Decision trees for binary subword-closed languages",
        "authors": [
            "Mikhail Moshkov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper, we study arbitrary subword-closed languages over the alphabet\n$\\{0,1\\}$ (binary subword-closed languages). For the set of words $L(n)$ of the\nlength $n$ belonging to a binary subword-closed language $L$, we investigate\nthe depth of decision trees solving the recognition and the membership problems\ndeterministically and nondeterministically. In the case of recognition problem,\nfor a given word from $L(n)$, we should recognize it using queries each of\nwhich, for some $i\\in \\{1,\\ldots ,n\\}$, returns the $i$th letter of the word.\nIn the case of membership problem, for a given word over the alphabet $\\{0,1\\}$\nof the length $n$, we should recognize if it belongs to the set $L(n)$ using\nthe same queries. With the growth of $n$, the minimum depth of decision trees\nsolving the problem of recognition deterministically is either bounded from\nabove by a constant, or grows as a logarithm, or linearly. For other types of\ntrees and problems (decision trees solving the problem of recognition\nnondeterministically, and decision trees solving the membership problem\ndeterministically and nondeterministically), with the growth of $n$, the\nminimum depth of decision trees is either bounded from above by a constant or\ngrows linearly. We study joint behavior of minimum depths of the considered\nfour types of decision trees and describe five complexity classes of binary\nsubword-closed languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.01493v1"
    },
    {
        "title": "Decision trees for regular factorial languages",
        "authors": [
            "Mikhail Moshkov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper, we study arbitrary regular factorial languages over a finite\nalphabet $\\Sigma$. For the set of words $L(n)$ of the length $n$ belonging to a\nregular factorial language $L$, we investigate the depth of decision trees\nsolving the recognition and the membership problems deterministically and\nnondeterministically. In the case of recognition problem, for a given word from\n$L(n)$, we should recognize it using queries each of which, for some $ i\\in\n\\{1,\\ldots ,n\\}$, returns the $i$th letter of the word. In the case of\nmembership problem, for a given word over the alphabet $\\Sigma$ of the length\n$n$, we should recognize if it belongs to the set $L(n)$ using the same\nqueries. For a given problem and type of trees, instead of the minimum depth\n$h(n)$ of a decision tree of the considered type solving the problem for\n$L(n)$, we study the smoothed minimum depth $H(n)=\\max\\{h(m):m\\le n\\}$. With\nthe growth of $n$, the smoothed minimum depth of decision trees solving the\nproblem of recognition deterministically is either bounded from above by a\nconstant, or grows as a logarithm, or linearly. For other cases (decision trees\nsolving the problem of recognition nondeterministically, and decision trees\nsolving the membership problem deterministically and nondeterministically),\nwith the growth of $n$, the smoothed minimum depth of decision trees is either\nbounded from above by a constant or grows linearly. As corollaries of the\nobtained results, we study joint behavior of smoothed minimum depths of\ndecision trees for the considered four cases and describe five complexity\nclasses of regular factorial languages. We also investigate the class of\nregular factorial languages over the alphabet $\\{0,1\\}$ each of which is given\nby one forbidden word.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.01952v1"
    },
    {
        "title": "On the Translation of Automata to Linear Temporal Logic",
        "authors": [
            "Udi Boker",
            "Karoliina Lehtinen",
            "Salomon Sickert"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  While the complexity of translating future linear temporal logic (LTL) into\nautomata on infinite words is well-understood, the size increase involved in\nturning automata back to LTL is not. In particular, there is no known\nelementary bound on the complexity of translating deterministic\n$\\omega$-regular automata to LTL. Our first contribution consists of tight\nbounds for LTL over a unary alphabet: alternating, nondeterministic and\ndeterministic automata can be exactly exponentially, quadratically and linearly\nmore succinct, respectively, than any equivalent LTL formula. Our main\ncontribution consists of a translation of general counter-free deterministic\n$\\omega$-regular automata into LTL formulas of double exponential\ntemporal-nesting depth and triple exponential length, using an intermediate\nKrohn-Rhodes cascade decomposition of the automaton. To our knowledge, this is\nthe first elementary bound on this translation. Furthermore, our translation\npreserves the acceptance condition of the automaton in the sense that it turns\na looping, weak, B\\\"uchi, coB\\\"uchi or Muller automaton into a formula that\nbelongs to the matching class of the syntactic future hierarchy. In particular,\nit can be used to translate an LTL formula recognising a safety language to a\nformula belonging to the safety fragment of LTL (over both finite and infinite\nwords).\n",
        "pdf_link": "http://arxiv.org/pdf/2201.10267v2"
    },
    {
        "title": "Kleene Theorem for Higher-Dimensional Automata",
        "authors": [
            "Uli Fahrenberg",
            "Christian Johansen",
            "Georg Struth",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We prove a Kleene theorem for higher-dimensional automata. It states that the\nlanguages they recognise are precisely the rational subsumption-closed sets of\nfinite interval pomsets. The rational operations on these languages include a\ngluing composition, for which we equip pomsets with interfaces. For our proof,\nwe introduce higher-dimensional automata with interfaces, which are modelled as\npresheaves over labelled precube categories, and develop tools and techniques\ninspired by algebraic topology, such as cylinders and (co)fibrations.\nHigher-dimensional automata form a general model of non-interleaving\nconcurrency, which subsumes many other approaches. Interval orders are used as\nmodels for concurrent and distributed systems where events extend in time. Our\ntools and techniques may therefore yield templates for Kleene theorems in\nvarious models and applications.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.03791v6"
    },
    {
        "title": "The amazing mixed polynomial closure and its applications to\n  two-variable first-order logic",
        "authors": [
            "Thomas Place"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Polynomial closure is a standard operator which is applied to a class of\nregular languages. In the paper, we investigate three restrictions called left\n(LPol), right (RPol) and mixed polynomial closure (MPol). The first two were\nknown while MPol is new. We look at two decision problems that are defined for\nevery class C. Membership takes a regular language as input and asks if it\nbelongs to C. Separation takes two regular languages as input and asks if there\nexists a third language in C including the first one and disjoint from the\nsecond. We prove that LPol, RPol and MPol preserve the decidability of\nmembership under mild hypotheses on the input class, and the decidability of\nseparation under much stronger hypotheses. We apply these results to natural\nhierarchies.\n  First, we look at several language theoretic hierarchies that are built by\napplying LPol, RPol and MPol recursively to a single input class. We prove that\nthese hierarchies can actually be defined using almost exclusively MPol. We\nalso consider quantifier alternation hierarchies for two-variable first-order\nlogic and prove that one can climb them using MPol. The result is generic in\nthe sense that it holds for most standard choices of signatures. We use it to\nprove that for most of these choices, membership is decidable for all levels in\nthe hierarchy. Finally, we prove that separation is decidable for the hierarchy\nof two-variable first-order logic equipped with only the linear order.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.03989v3"
    },
    {
        "title": "Language Inclusion for Boundedly-Ambiguous Vector Addition Systems is\n  Decidable",
        "authors": [
            "Wojciech Czerwiński",
            "Piotr Hofman"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider the problems of language inclusion and language equivalence for\nVector Addition Systems with States (VASSes) with the acceptance condition\ndefined by the set of accepting states (and more generally by some\nupward-closed conditions). In general the problem of language equivalence is\nundecidable even for one-dimensional VASSes, thus to get decidability we\ninvestigate restricted subclasses. On one hand we show that the problem of\nlanguage inclusion of a VASS in k-ambiguous VASS (for any natural k) is\ndecidable and even in Ackermann. On the other hand we prove that the language\nequivalence problem is Ackermann-hard already for deterministic VASSes. These\ntwo results imply Ackermann-completeness for language inclusion and equivalence\nin several possible restrictions. Some of our techniques can be also applied in\nmuch broader generality in infinite-state systems, namely for some subclass of\nwell-structured transition systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.08033v4"
    },
    {
        "title": "Weak Muller Conditions Make Delay Games Hard",
        "authors": [
            "Sarah Winter",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We show that solving delay games with winning conditions given by\ndeterministic and nondeterministic weak Muller automata is 2EXPTIME-complete\nrespectively 3EXPTIME-complete. Furthermore, doubly and triply exponential\nlookahead is necessary and sufficient to win such games. These results are the\nfirst that show that the succinctness of the automata types used to specify the\nwinning conditions has an influence on the complexity of these problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.03404v2"
    },
    {
        "title": "Lower Bounds for the Reachability Problem in Fixed Dimensional VASSes",
        "authors": [
            "Wojciech Czerwiński",
            "Łukasz Orlikowski"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study the complexity of the reachability problem for Vector Addition\nSystems with States (VASSes) in fixed dimensions. We provide four lower bounds\nimproving the currently known state-of-the-art: 1) \\np-hardness for unary flat\n$4$-VASSes (VASSes in dimension 4), 2) \\pspace-hardness for unary $5$-VASSes,\n3) \\expspace-hardness for binary $6$-VASSes and 4) \\tower-hardness for unary\n$8$-VASSes.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.04243v1"
    },
    {
        "title": "Between SC and LOGDCFL: Families of Languages Accepted by\n  Logarithmic-Space Deterministic Auxiliary Depth-k Storage Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The closure of deterministic context-free languages under logarithmic-space\nmany-one reductions ($\\mathrm{L}$-m-reductions), known as LOGDCFL, has been\nstudied in depth from an aspect of parallel computability because it is nicely\nsituated between $\\mathrm{L}$ and $\\mathrm{AC}^{1}\\cap\\mathrm{SC}^2$. By\nreplacing a memory device from pushdown stacks with access-controlled storage\ntapes, we introduce a computational model of one-way deterministic depth-$k$\nstorage automata ($k$-sda's) whose tape cells are freely modified during the\nfirst $k$ accesses and then become blank forever. These $k$-sda's naturally\ninduce the language family $k\\mathrm{SDA}$. Similarly to $\\mathrm{LOGDCFL}$, we\nstudy the closure $\\mathrm{LOG}k\\mathrm{SDA}$ of all languages in\n$k\\mathrm{SDA}$ under $\\mathrm{L}$-m-reductions. We demonstrate that\n$\\mathrm{DCFL}\\subseteq k\\mathrm{SDA}\\subseteq \\mathrm{SC}^k$ by significantly\nextending Cook's early result (1979) of $\\mathrm{DCFL}\\subseteq \\mathrm{SC}^2$.\nThe entire hierarch of $\\mathrm{LOG}k\\mathrm{SDA}$ for all $k\\geq1$ therefore\nlies between $\\mathrm{LOGDCFL}$ and $\\mathrm{SC}$. As an immediate consequence,\nwe obtain the same simulation bounds for Hibbard's limited automata. We further\ncharacterize $\\mathrm{LOG}k\\mathrm{SDA}$ in terms of a new machine model,\ncalled logarithmic-space deterministic auxiliary depth-$k$ storage automata\nthat run in polynomial time. These machines are as powerful as a\npolynomial-time two-way multi-head deterministic depth-$k$ storage automata. We\nalso provide a ``generic'' $\\mathrm{LOG}k\\mathrm{SDA}$-complete language under\n$\\mathrm{L}$-m-reductions by constructing a two-way universal simulator working\nfor all $k$-sda's.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.10193v2"
    },
    {
        "title": "Reduction of Register Pushdown Systems with Freshness Property to\n  Pushdown Systems in LTL Model Checking",
        "authors": [
            "Yoshiaki Takata",
            "Ryoma Senda",
            "Hiroyuki Seki"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Pushdown systems (PDS) are known as an abstract model of recursive programs,\nand model checking methods for PDS have been studied. Register PDS (RPDS) are\nPDS augmented by registers to deal with data values from an infinite domain in\na restricted way. A linear temporal logic (LTL) model checking method for RPDS\nwith regular valuations has been proposed; however, the method requires the\nregister automata (RA) used for representing a regular valuation to be\nbackward-deterministic. This paper proposes another approach to the same\nproblem, in which the model checking problem for RPDS is reduced to that\nproblem for PDS by constructing a PDS bisimulation equivalent to a given RPDS.\nThe construction in the proposed method is simpler than the previous model\nchecking method and does not require RAs deterministic or\nbackward-deterministic, and the bisimulation equivalence clearly guarantees the\ncorrectness of this reduction. On the other hand, the proposed method requires\nevery RPDS (and RA) to have the freshness property, in which whenever the RPDS\nupdates a register with a data value not stored in any register or the stack\ntop, the value should be fresh. This paper also shows that this model checking\nproblem with regular valuations defined by general RA is undecidable, and thus\nthe freshness constraint is essential in the proposed method.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.11826v1"
    },
    {
        "title": "Zone extrapolations in parametric timed automata",
        "authors": [
            "Johan Arcile",
            "Étienne André"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Timed automata (TAs) are an efficient formalism to model and verify systems\nwith hard timing constraints, and concurrency. While TAs assume exact timing\nconstants with infinite precision, parametric TAs (PTAs) leverage this\nlimitation and increase their expressiveness, at the cost of undecidability. A\npractical explanation for the efficiency of TAs is zone extrapolation, where\nclock valuations beyond a given constant are considered equivalent. This\nconcept cannot be easily extended to PTAs, due to the fact that parameters can\nbe unbounded. In this work, we propose several definitions of extrapolation for\nPTAs based on the M-extrapolation, and we study their correctness. Our\nexperiments show an overall decrease of the computation time and, most\nimportantly, allow termination of some previously unsolvable benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.13173v1"
    },
    {
        "title": "Exemplifying parametric timed specifications over signals with bounded\n  behavior",
        "authors": [
            "Étienne André",
            "Masaki Waga",
            "Natsuki Urabe",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Specifying properties can be challenging work. In this paper, we propose an\nautomated approach to exemplify properties given in the form of automata\nextended with timing constraints and timing parameters, and that can also\nencode constraints over real-valued signals. That is, given such a\nspecification and given an admissible automaton for each signal, we output\nconcrete runs exemplifying real (or impossible) runs for this specification.\nSpecifically, our method takes as input a specification, and a set of\nadmissible behaviors, all given as a subclass of rectangular hybrid automata,\nnamely timed automata extended with arbitrary clock rates, signal constraints,\nand timing parameters. Our method then generates concrete runs exemplifying the\nspecification.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.13247v1"
    },
    {
        "title": "Sublinear-Time Probabilistic Cellular Automata",
        "authors": [
            "Augusto Modanese"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose and investigate a probabilistic model of sublinear-time\none-dimensional cellular automata. In particular, we modify the model of ACA\n(which are cellular automata that accept if and only if all cells\nsimultaneously accept) so that every cell changes its state not only dependent\non the states it sees in its neighborhood but also on an unbiased coin toss of\nits own. The resulting model is dubbed probabilistic ACA (PACA). We consider\none- and two-sided error versions of the model (in the same spirit as the\nclasses $\\mathsf{RP}$ and $\\mathsf{BPP}$) and establish a separation between\nthe classes of languages they can recognize all the way up to $o(\\sqrt{n})$\ntime. As a consequence, we have a $\\Omega(\\sqrt{n})$ lower bound for\nderandomizing constant-time two-sided error PACAs (using deterministic ACAs).\nWe also prove that derandomization of $T(n)$-time PACAs (to polynomial-time\ndeterministic cellular automata) for various regimes of $T(n) = \\omega(\\log n)$\nimplies non-trivial derandomization results for the class $\\mathsf{RP}$ (e.g.,\n$\\mathsf{P} = \\mathsf{RP}$). The main contribution is an almost full\ncharacterization of the constant-time PACA classes: For one-sided error, the\nclass equals that of the deterministic model; that is, constant-time one-sided\nerror PACAs can be fully derandomized with only a constant multiplicative\noverhead in time complexity. As for two-sided error, we identify a natural\nclass we call the linearly testable languages ($\\mathsf{LLT}$) and prove that\nthe languages decidable by constant-time two-sided error PACAs are \"sandwiched\"\nin-between the closure of $\\mathsf{LLT}$ under union and intersection and the\nclass of locally threshold testable languages ($\\mathsf{LTT}$).\n",
        "pdf_link": "http://arxiv.org/pdf/2203.14614v5"
    },
    {
        "title": "On the Expressive Power of the Normal Form for Branching-Time Temporal\n  Logics",
        "authors": [
            "Alexander Bolotov"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  With the emerging applications that involve complex distributed systems\nbranching-time specifications are specifically important as they reflect\ndynamic and non-deterministic nature of such applications. We describe the\nexpressive power of a simple yet powerful branching-time specification\nframework -- branching-time normal form (BNF), which has been developed as part\nof clausal resolution for branching-time temporal logics. We show the encoding\nof Buchi Tree Automata in the language of the normal form, thus representing,\nsyntactically, tree automata in a high-level way. Thus we can treat BNF as a\nnormal form for the latter. These results enable us (1) to translate given\nproblem specifications into the normal form and apply as a verification method\na deductive reasoning technique -- the clausal temporal resolution; (2) to\napply one of the core components of the resolution method -- the loop searching\nto extract, syntactically, hidden invariants in a wide range of complex\ntemporal specifications.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.06736v1"
    },
    {
        "title": "A* shortest string decoding for non-idempotent semirings",
        "authors": [
            "Kyle Gorman",
            "Cyril Allauzen"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The single shortest path algorithm is undefined for weighted finite-state\nautomata over non-idempotent semirings because such semirings do not guarantee\nthe existence of a shortest path. However, in non-idempotent semirings\nadmitting an order satisfying a monotonicity condition (such as the plus-times\nor log semirings), the notion of shortest string is well-defined. We describe\nan algorithm which finds the shortest string for a weighted non-deterministic\nautomaton over such semirings using the backwards shortest distance of an\nequivalent deterministic automaton (DFA) as a heuristic for A* search performed\nover a companion idempotent semiring, which is proven to return the shortest\nstring. While there may be exponentially more states in the DFA, this algorithm\nneeds to visit only a small fraction of them if determinization is performed\n\"on the fly\".\n",
        "pdf_link": "http://arxiv.org/pdf/2204.07236v2"
    },
    {
        "title": "Formal Languages via Theories over Strings",
        "authors": [
            "Joel D. Day",
            "Vijay Ganesh",
            "Nathan Grewal",
            "Florin Manea"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We investigate the properties of formal languages expressible in terms of\nformulas over quantifier-free theories of word equations, arithmetic over\nlength constraints, and language membership predicates for the classes of\nregular, visibly pushdown, and deterministic context-free languages. In total,\nwe consider 20 distinct theories and decidability questions for problems such\nas emptiness and universality for formal languages over them. First, we discuss\ntheir relative expressive power and observe a rough division into two\nhierarchies based on whether or not word equations are present. Second, we\nconsider the decidability status of several important decision problems, such\nas emptiness and universality. Note that the emptiness problem is equivalent to\nthe satisfiability problem over the corresponding theory. Third, we consider\nthe problem of whether a language in one theory is expressible in another and\nshow several negative results in which this problem is undecidable. These\nresults are particularly relevant in the context of normal forms in both\npractical and theoretical aspects of string solving.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.00475v1"
    },
    {
        "title": "A Fibonacci analogue of the two's complement numeration system",
        "authors": [
            "Sébastien Labbé",
            "Jana Lepšová"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Using the classic two's complement notation of signed integers, the\nfundamental arithmetic operations of addition, subtraction, and multiplication\nare identical to those for unsigned binary numbers. We introduce a\nFibonacci-equivalent of the two's complement notation and we show that addition\nin this numeration system can be performed by a deterministic finite-state\ntransducer. The result is based on the Berstel adder, which performs addition\nof the usual Fibonacci representations of nonnegative integers and for which we\nprovide a new constructive proof. Moreover, we characterize the\nFibonacci-equivalent of the two's complement notation as an increasing\nbijection between $\\mathbb{Z}$ and a particular language.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.02574v5"
    },
    {
        "title": "Analyzing FreeRTOS Scheduling Behaviors with the Spin Model Checker",
        "authors": [
            "Chen-Kai Lin",
            "Bow-Yaw Wang"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  FreeRTOS is a real-time operating system with configurable scheduling\npolicies. Its portability and configurability make FreeRTOS one of the most\npopular real-time operating systems for embedded devices. We formally analyze\nthe FreeRTOS scheduler on ARM Cortex-M4 processor in this work. Specifically,\nwe build a formal model for the FreeRTOS ARM Cortex-M4 port and apply model\nchecking to find errors in our models for FreeRTOS example applications.\nIntriguingly, several errors are found in our application models under\ndifferent scheduling policies. In order to confirm our findings, we modify\napplication programs distributed by FreeRTOS and reproduce assertion failures\non the STM32F429I-DISC1 board.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.07480v2"
    },
    {
        "title": "Strong Equivalence of TAG and CCG",
        "authors": [
            "Andreas Maletti",
            "Lena Katharina Schiffer"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Tree-adjoining grammar (TAG) and combinatory categorial grammar (CCG) are two\nwell-established mildly context-sensitive grammar formalisms that are known to\nhave the same expressive power on strings (i.e., generate the same class of\nstring languages). It is demonstrated that their expressive power on trees also\nessentially coincides. In fact, CCG without lexicon entries for the empty\nstring and only first-order rules of degree at most 2 are sufficient for its\nfull expressive power.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.07743v1"
    },
    {
        "title": "On eventual non-negativity and positivity for the weighted sum of powers\n  of matrices",
        "authors": [
            "S Akshay",
            "Supratik Chakraborty",
            "Debtanu Pal"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The long run behaviour of linear dynamical systems is often studied by\nlooking at eventual properties of matrices and recurrences that underlie the\nsystem. A basic problem that lies at the core of many questions in this setting\nis the following: given a set of pairs of rational weights and matrices {(w_1 ,\nA_1 ), . . . , (w_m , A_m )}, we ask if the weighted sum of powers of these\nmatrices is eventually non-negative P (resp. n positive), i.e., does there\nexist an integer N s.t for all n greater than N , (w_1 A_1^n + ... + w_m A_m^n)\nis atmost 0 (resp. greater than 0). The restricted setting when m = w_1 = 1,\nresults in so-called eventually non-negative (or eventually positive) matrices,\nwhich enjoy nice spectral properties and have been well-studied in control\ntheory. More applications arise in varied contexts, ranging from program\nverification to partially observable and multi-modal systems.\n  Our goal is to investigate this problem and its link to linear recurrence\nsequences. Our first result is that for m at least 2, the problem is as hard as\nthe ultimate positivity of linear recurrences, a long standing open question\n(known to be coNP-hard). Our second result is a reduction in the other\ndirection showing that for any m at least 1, the problem reduces to ultimate\npositivity of linear recurrences. This shows precise upper bounds for several\nsubclasses of matrices by exploiting known results on linear recurrence\nsequences. Our third main result is a novel reduction technique for a large\nclass of problems (including those mentioned above) over rational\ndiagonalizable matrices to the corresponding problem over simple real-algebraic\nmatrices. This yields effective decision procedures for diagonalizable\nmatrices.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.09190v1"
    },
    {
        "title": "The boundedness and zero isolation problems for weighted automata over\n  nonnegative rationals",
        "authors": [
            "Wojciech Czerwiński",
            "Engel Lefaucheux",
            "Filip Mazowiecki",
            "David Purser",
            "Markus A. Whiteland"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider linear cost-register automata (equivalent to weighted automata)\nover the semiring of nonnegative rationals, which generalise probabilistic\nautomata. The two problems of boundedness and zero isolation ask whether there\nis a sequence of words that converge to infinity and to zero, respectively. In\nthe general model both problems are undecidable so we focus on the copyless\nlinear restriction. There, we show that the boundedness problem is decidable.\n  As for the zero isolation problem we need to further restrict the class. We\nobtain a model, where zero isolation becomes equivalent to universal\ncoverability of orthant vector addition systems (OVAS), a new model in the VAS\nfamily interesting on its own. In standard VAS runs are considered only in the\npositive orthant, while in OVAS every orthant has its own set of vectors that\ncan be applied in that orthant. Assuming Schanuel's conjecture is true, we\nprove decidability of universal coverability for three-dimensional OVAS, which\nimplies decidability of zero isolation in a model with at most three\nindependent registers.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.13516v1"
    },
    {
        "title": "Complementing Büchi Automata with Ranker (Technical Report)",
        "authors": [
            "Vojtěch Havlena",
            "Ondřej Lengál",
            "Barbora Šmahlíková"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We present the tool Ranker for complementing B\\\"uchi automata (BAs). Ranker\nbuilds on our previous optimizations of rank-based BA complementation and\npushes them even further using numerous heuristics to produce even smaller\nautomata. Moreover, it contains novel optimizations of specialized\nconstructions for complementing (i) inherently weak automata and (ii)\nsemi-deterministic automata, all delivered in a robust tool. The optimizations\nsignificantly improve the usability of Ranker, as shown in an extensive\nexperimental evaluation with real-world benchmarks, where Ranker produced in\nthe majority of cases a strictly smaller complement than other state-of-the-art\ntools.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.01946v1"
    },
    {
        "title": "Computing Real Numbers with Large-Population Protocols Having a\n  Continuum of Equilibria",
        "authors": [
            "Xiang Huang",
            "Rachel N. Huls"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Bournez, Fraigniaud, and Koegler defined a number in [0,1] as computable by\ntheir Large-Population Protocol (LPP) model, if the proportion of agents in a\nset of marked states converges to said number over time as the population grows\nto infinity. The notion, however, restricts the ordinary differential equations\n(ODEs) associated with an LPP to have only finitely many equilibria. This\nrestriction places an intrinsic limitation on the model. As a result, a number\nis computable by an LPP if and only if it is algebraic, namely, not a single\ntranscendental number can be computed under this notion.\n  In this paper, we lift the finitary requirement on equilibria. That is, we\nconsider systems with a continuum of equilibria. We show that essentially all\nnumbers in [0,1] that are computable by bounded general-purpose analog\ncomputers (GPACs) or chemical reaction networks (CRNs) can also be computed by\nLPPs under this new definition. This implies a rich series of numbers (e.g.,\nthe reciprocal of Euler's constant, $\\pi/4$, Euler's $\\gamma$, Catalan's\nconstant, and Dottie number) are all computable by LPPs. Our proof is\nconstructive: We develop an algorithm that transfers bounded GPACs/CRNs into\nLPPs. Our algorithm also fixes a gap in Bournez et al.'s construction of LPPs\ndesigned to compute any arbitrary algebraic number in [0,1].\n",
        "pdf_link": "http://arxiv.org/pdf/2206.06594v1"
    },
    {
        "title": "Specification sketching for Linear Temporal Logic",
        "authors": [
            "Simon Lutz",
            "Daniel Neider",
            "Rajarshi Roy"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Virtually all verification and synthesis techniques assume that the formal\nspecifications are readily available, functionally correct, and fully match the\nengineer's understanding of the given system. However, this assumption is often\nunrealistic in practice: formalizing system requirements is notoriously\ndifficult, error-prone, and requires substantial training. To alleviate this\nsevere hurdle, we propose a fundamentally novel approach to writing formal\nspecifications, named specification sketching for Linear Temporal Logic (LTL).\nThe key idea is that an engineer can provide a partial LTL formula, called an\nLTL sketch, where parts that are hard to formalize can be left out. Given a set\nof examples describing system behaviors that the specification should or should\nnot allow, the task of a so-called sketching algorithm is then to complete a\ngiven sketch such that the resulting LTL formula is consistent with the\nexamples. We show that deciding whether a sketch can be completed falls into\nthe complexity class NP and present two SAT-based sketching algorithms. We also\ndemonstrate that sketching is a practical approach to writing formal\nspecifications using a prototype implementation.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.06722v1"
    },
    {
        "title": "Analyzing Büchi Automata with Graph Neural Networks",
        "authors": [
            "Christophe Stammet",
            "Prisca Dotti",
            "Ulrich Ultes-Nitsche",
            "Andreas Fischer"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  B\\\"uchi Automata on infinite words present many interesting problems and are\nused frequently in program verification and model checking. A lot of these\nproblems on B\\\"uchi automata are computationally hard, raising the question if\na learning-based data-driven analysis might be more efficient than using\ntraditional algorithms. Since B\\\"uchi automata can be represented by graphs,\ngraph neural networks are a natural choice for such a learning-based analysis.\nIn this paper, we demonstrate how graph neural networks can be used to reliably\npredict basic properties of B\\\"uchi automata when trained on automatically\ngenerated random automata datasets.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.09619v1"
    },
    {
        "title": "Learning from Positive and Negative Examples: New Proof for Binary\n  Alphabets",
        "authors": [
            "Jonas Lingg",
            "Mateus de Oliveira Oliveira",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  One of the most fundamental problems in computational learning theory is the\nthe problem of learning a finite automaton $A$ consistent with a finite set $P$\nof positive examples and with a finite set $N$ of negative examples. By\nconsistency, we mean that $A$ accepts all strings in $P$ and rejects all\nstrings in $N$. It is well known that this problem is NP-complete. In the\nliterature, it is stated that this NP-hardness holds even in the case of a\nbinary alphabet. As a standard reference for this theorem, the work of Gold\nfrom 1978 is either cited or adapted. But as a crucial detail, the work of Gold\nactually considered Mealy machines and not deterministic finite state automata\n(DFAs) as they are considered nowadays. As Mealy automata are equipped with an\noutput function, they can be more compact than DFAs which accept the same\nlanguage. We show that the adaptions of Gold's construction for Mealy machines\nstated in the literature have some issues and give a new construction for DFAs\nwith a binary alphabet ourselves.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.10025v1"
    },
    {
        "title": "Maximal automatic complexity and context-free languages",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Let $A_N$ denote nondeterministic automatic complexity and \\[\n  L_{k,c}=\\{x\\in [k]^* : A_N(x)> |x|/c\\}. \\] In particular, $L_{k,2}$ is the\nlanguage of all $k$-ary words for which $A_N$ is maximal, while $L_{k,3}$ gives\na rough dividing line between complex and simple. Let $\\mathbf{CFL}$ denote the\ncomplexity class consisting of all context-free languages. While it is not\nknown that $L_{2,2}$ is infinite, Kjos-Hanssen (2017) showed that $L_{3,2}$ is\n$\\mathbf{CFL}$-immune but not $\\mathbf{coCFL}$-immune. We complete the picture\nby showing that $L_{3,2}\\not\\in\\mathbf{coCFL}$.\n  Turning to Boolean circuit complexity, we show that $L_{2,3}$ is\n$\\mathbf{SAC}^0$-immune and $\\mathbf{SAC}^0$-coimmune. Here $\\mathbf{SAC}^0$\ndenotes the complexity class consisting of all languages computed by\n(non-uniform) constant-depth circuits with semi-unbounded fanin.\n  As for arithmetic circuits, we show that\n$\\{x:A_N(x)>1\\}\\not\\in\\oplus\\mathbf{SAC}^0$. In particular,\n$\\mathbf{SAC}^0\\not\\subseteq\\oplus \\mathbf{SAC}^0$, which resolves an open\nimplication from the Complexity Zoo.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.10130v1"
    },
    {
        "title": "Extending Shinohara's Algorithm for Computing Descriptive\n  (Angluin-Style) Patterns to Subsequence Patterns",
        "authors": [
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The introduction of pattern languages in the seminal work [Angluin, ``Finding\nPatterns Common to a Set of Strings'', JCSS 1980] has revived the classical\nmodel of inductive inference (learning in the limit, gold-style learning). In\n[Shinohara, ``Polynomial Time Inference of Pattern Languages and Its\nApplication'', 7th IBM Symposium on Mathematical Foundations of Computer\nScience 1982] a simple and elegant algorithm has been introduced that, based on\nmembership queries, computes a pattern that is descriptive for a given sample\nof input strings (and, consequently, can be employed in strategies for\ninductive inference). In this paper, we give a brief survey of the recent work\n[Kleest-Mei{\\ss}ner et al., ``Discovering Event Queries from Traces: Laying\nFoundations for Subsequence-Queries with Wildcards and Gap-Size Constraints'',\nICDT 2022], where the classical concepts of Angluin-style (descriptive)\npatterns and the respective Shinohara's algorithm are extended to a query class\nwith applications in complex event recognition -- a modern topic from\ndatabases.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.13918v1"
    },
    {
        "title": "Monitoring Timed Properties (Revisited)",
        "authors": [
            "Thomas Møller Grosen",
            "Sean Kauffman",
            "Kim Guldstrand Larsen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this paper we revisit monitoring real-time systems with respect to\nproperties expressed either in Metric Interval Temporal Logic or as Timed\nB\\\"uchi Automata. We offer efficient symbolic online monitoring algorithms in a\nnumber of settings, exploiting so-called zones well-known from efficient model\nchecking of Timed Automata. The settings considered include new, much\nsimplified treatment of time divergence, monitoring under timing uncertainty,\nand extension of monitoring to offer minimum time estimates before conclusive\nverdicts can be made.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.14590v3"
    },
    {
        "title": "Probabilistic Model Checking for Strategic Equilibria-based Decision\n  Making: Advances and Challenges",
        "authors": [
            "Marta Kwiatkowska",
            "Gethin Norman",
            "David Parker",
            "Gabriel Santos",
            "Rui Yan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Game-theoretic concepts have been extensively studied in economics to provide\ninsight into competitive behaviour and strategic decision making. As computing\nsystems increasingly involve concurrently acting autonomous agents,\ngame-theoretic approaches are becoming widespread in computer science as a\nfaithful modelling abstraction. These techniques can be used to reason about\nthe competitive or collaborative behaviour of multiple rational agents with\ndistinct goals or objectives. This paper provides an overview of recent\nadvances in developing a modelling, verification and strategy synthesis\nframework for concurrent stochastic games implemented in the probabilistic\nmodel checker PRISM-games. This is based on a temporal logic that supports\nfinite- and infinite-horizon temporal properties in both a zero-sum and\nnonzero-sum setting, the latter using Nash and correlated equilibria with\nrespect to two optimality criteria, social welfare and social fairness. We\nsummarise the key concepts, logics and algorithms and the currently available\ntool support. Future challenges and recent progress in adapting the framework\nand algorithmic solutions to continuous environments and neural networks are\nalso outlined.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.15148v1"
    },
    {
        "title": "Regular Monoidal Languages",
        "authors": [
            "Matthew Earnshaw",
            "Paweł Sobociński"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We introduce regular languages of morphisms in free monoidal categories, with\ntheir associated grammars and automata. These subsume the classical theory of\nregular languages of words and trees, but also open up a much wider class of\nlanguages over string diagrams. We use the algebra of monoidal and cartesian\nrestriction categories to investigate the properties of regular monoidal\nlanguages, and provide sufficient conditions for their recognizability by\ndeterministic monoidal automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.00526v1"
    },
    {
        "title": "Interactive Learning from Natural Language and Demonstrations using\n  Signal Temporal Logic",
        "authors": [
            "Sara Mohammadinejad",
            "Jesse Thomason",
            "Jyotirmoy V. Deshmukh"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Natural language is an intuitive way for humans to communicate tasks to a\nrobot. While natural language (NL) is ambiguous, real world tasks and their\nsafety requirements need to be communicated unambiguously. Signal Temporal\nLogic (STL) is a formal logic that can serve as a versatile, expressive, and\nunambiguous formal language to describe robotic tasks. On one hand, existing\nwork in using STL for the robotics domain typically requires end-users to\nexpress task specifications in STL, a challenge for non-expert users.\n  On the other, translating from NL to STL specifications is currently\nrestricted to specific fragments. In this work, we propose DIALOGUESTL, an\ninteractive approach for learning correct and concise STL formulas from (often)\nambiguous NL descriptions. We use a combination of semantic parsing,\npre-trained transformer-based language models, and user-in-the-loop\nclarifications aided by a small number of user demonstrations to predict the\nbest STL formula to encode NL task descriptions. An advantage of mapping NL to\nSTL is that there has been considerable recent work on the use of reinforcement\nlearning (RL) to identify control policies for robots. We show we can use Deep\nQ-Learning techniques to learn optimal policies from the learned STL\nspecifications. We demonstrate that DIALOGUESTL is efficient, scalable, and\nrobust, and has high accuracy in predicting the correct STL formula with a few\nnumber of demonstrations and a few interactions with an oracle user.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.00627v1"
    },
    {
        "title": "Learning state machines via efficient hashing of future traces",
        "authors": [
            "Robert Baumgartner",
            "Sicco Verwer"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  State machines are popular models to model and visualize discrete systems\nsuch as software systems, and to represent regular grammars. Most algorithms\nthat passively learn state machines from data assume all the data to be\navailable from the beginning and they load this data into memory. This makes it\nhard to apply them to continuously streaming data and results in large memory\nrequirements when dealing with large datasets. In this paper we propose a\nmethod to learn state machines from data streams using the count-min-sketch\ndata structure to reduce memory requirements. We apply state merging using the\nwell-known red-blue-framework to reduce the search space. We implemented our\napproach in an established framework for learning state machines, and evaluated\nit on a well know dataset to provide experimental data, showing the\neffectiveness of our approach with respect to quality of the results and\nrun-time.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.01516v1"
    },
    {
        "title": "Affinity Classification Problem by Stochastic Cellular Automata",
        "authors": [
            "Kamalika Bhattacharjee",
            "Subrata Paul",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This work introduces a new problem, named as, affinity classification problem\nwhich is a generalization of the density classification problem. To solve this\nproblem, we introduce temporally stochastic cellular automata where two rules\nare stochastically applied in each step on all cells of the automata. Our model\nis defined on 2-dimensional grid having affection capability. We show that this\nmodel can be used in several applications like modeling self-healing systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.05446v1"
    },
    {
        "title": "Parikh Automata over Infinite Words",
        "authors": [
            "Shibashis Guha",
            "Ismaël Jecker",
            "Karoliina Lehtinen",
            "Martin Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parikh automata extend finite automata by counters that can be tested for\nmembership in a semilinear set, but only at the end of a run, thereby\npreserving many of the desirable algorithmic properties of finite automata.\nHere, we study the extension of the classical framework onto infinite inputs:\nWe introduce reachability, safety, B\\\"uchi, and co-B\\\"uchi Parikh automata on\ninfinite words and study expressiveness, closure properties, and the complexity\nof verification problems.\n  We show that almost all classes of automata have pairwise incomparable\nexpressiveness, both in the deterministic and the nondeterministic case; a\nresult that sharply contrasts with the well-known hierarchy in the\n$\\omega$-regular setting. Furthermore, emptiness is shown decidable for Parikh\nautomata with reachability or B\\\"uchi acceptance, but undecidable for safety\nand co-B\\\"uchi acceptance. Most importantly, we show decidability of model\nchecking with specifications given by deterministic Parikh automata with safety\nor co-B\\\"uchi acceptance, but also undecidability for all other types of\nautomata. Finally, solving games is undecidable for all types.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.07694v3"
    },
    {
        "title": "Natural Colors of Infinite Words",
        "authors": [
            "Rüdiger Ehlers",
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  While finite automata have minimal DFAs as a simple and natural normal form,\ndeterministic omega-automata do not currently have anything similar. One reason\nfor this is that a normal form for omega-regular languages has to speak about\nmore than acceptance - for example, to have a normal form for a parity\nlanguage, it should relate every infinite word to some natural color for this\nlanguage. This raises the question of whether or not a concept such as a\nnatural color of an infinite word (for a given language) exists, and, if it\ndoes, how it relates back to automata.\n  We define the natural color of a word purely based on an omega-regular\nlanguage, and show how this natural color can be traced back from any\ndeterministic parity automaton after two cheap and simple automaton\ntransformations. The resulting streamlined automaton does not necessarily\naccept every word with its natural color, but it has a 'co-run', which is like\na run, but can once move to a language equivalent state, whose color is the\nnatural color, and no co-run with a higher color exists.\n  The streamlined automaton defines, for every color c, a good-for-games\nco-B\\\"uchi automaton that recognizes the words whose natural colors w.r.t. the\nrepresented language are at least c. This provides a canonical representation\nfor every $\\omega$-regular language, because good-for-games co-B\\\"uchi automata\nhave a canonical minimal (and cheap to obtain) representation for every\nco-B\\\"uchi language.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.11000v1"
    },
    {
        "title": "Active Learning of One-Clock Timed Automata using Constraint Solving",
        "authors": [
            "Runqing Xu",
            "Jie An",
            "Bohua Zhan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Active automata learning in the framework of Angluin's $L^*$ algorithm has\nbeen applied to learning many kinds of automata models. In applications to\ntimed models such as timed automata, the main challenge is to determine guards\non the clock value in transitions as well as which transitions reset the clock.\nIn this paper, we introduce a new algorithm for active learning of\ndeterministic one-clock timed automata and timed Mealy machines. The algorithm\nuses observation tables that do not commit to specific choices of reset, but\ninstead rely on constraint solving to determine reset choices that satisfy\nreadiness conditions. We evaluate our algorithm on randomly-generated examples\nas well as practical case studies, showing that it is applicable to larger\nmodels, and competitive with existing work for learning other forms of timed\nmodels.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.00412v1"
    },
    {
        "title": "On the homology language of HDA models of transition systems",
        "authors": [
            "Thomas Kahl"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Given a transition system with an independence relation on the alphabet of\nlabels, one can associate with it a usually very large symmetric\nhigher-dimensional automaton. The purpose of this paper is to show that by\nchoosing an acyclic relation whose symmetric closure is the given independence\nrelation, it is possible to construct a much smaller nonsymmetric HDA with the\nsame homology language.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.02286v1"
    },
    {
        "title": "Watson-Crick conjugates of words and languages",
        "authors": [
            "Kalpana Mahalingam",
            "Anuran Maity"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper explores the concept of Watson-Crick conjugates, also known as\n$\\theta$-conjugates, of words and languages. This concept extends the classical\nidea of conjugates by incorporating the Watson-Crick complementarity of DNA\nsequences, from the perspective of DNA computing. Our investigation initially\nfocuses on the properties of $\\theta$-conjugates of words. We then define\n$\\theta$-conjugates of a language and study closure properties of certain\nfamilies of languages under the $\\theta$-conjugate operation. Furthermore, we\nanalyze the iterated $\\theta$-conjugate of both words and languages. Finally,\nwe delve into the idea of $\\theta$-conjugate-free languages and examine the\ndecidability problems surrounding $\\theta$-conjugate-freeness for different\nclasses of languages\n",
        "pdf_link": "http://arxiv.org/pdf/2208.03123v2"
    },
    {
        "title": "Comparing Channel Restrictions of Communicating State Machines,\n  High-level Message Sequence Charts, and Multiparty Session Types",
        "authors": [
            "Felix Stutz",
            "Damien Zufferey"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Communicating state machines provide a formal foundation for distributed\ncomputation. Unfortunately, they are Turing-complete and, thus, challenging to\nanalyse. In this paper, we classify restrictions on channels which have been\nproposed to work around the undecidability of verification questions. We\ncompare half-duplex communication, existential B-boundedness, and\nk-synchronisability. These restrictions do not prevent the communication\nchannels from growing arbitrarily large but still restrict the power of the\nmodel. Each restriction gives rise to a set of languages so, for every pair of\nrestrictions, we check whether one subsumes the other or if they are\nincomparable. We investigate their relationship in two different contexts:\nfirst, the one of communicating state machines, and, second, the one of\ncommunication protocol specifications using high-level message sequence charts.\nSurprisingly, these two contexts yield different conclusions. In addition, we\nintegrate multiparty session types, another approach to specify communication\nprotocols, into our classification. We show that multiparty session type\nlanguages are half-duplex, existentially 1-bounded, and 1-synchronisable.\nTo~show this result, we provide the first formal embedding of multiparty\nsession types into high-level message sequence charts.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.05559v1"
    },
    {
        "title": "Synthesis of Parametric Hybrid Automata from Time Series",
        "authors": [
            "Miriam García Soto",
            "Thomas A. Henzinger",
            "Christian Schilling"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose an algorithmic approach for synthesizing linear hybrid automata\nfrom time-series data. Unlike existing approaches, our approach provides a\nwhole family of models. Each model in the family is guaranteed to capture the\ninput data up to a precision error {\\epsilon}, in the following sense: For each\ntime series, the model contains an execution that is {\\epsilon}-close to the\ndata points. Our construction allows to effectively choose a model from this\nfamily with minimal precision error {\\epsilon}. We demonstrate the algorithm's\nefficiency and its ability to find precise models in two case studies.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.06383v1"
    },
    {
        "title": "A robust class of languages of 2-nested words",
        "authors": [
            "Séverine Fratani",
            "Guillaume Maurras",
            "Pierre-Alain Reynier"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Regular nested word languages (a.k.a. visibly pushdown languages) strictly\nextend regular word languages, while preserving their main closure and\ndecidability properties. Previous works have shown that considering languages\nof 2-nested words, i.e. words enriched with two matchings (a.k.a. 2-visibly\npushdown languages), is not as successful: the corresponding model of automata\nis not closed under determinization. In this work, inspired by homomorphic\nrepresentations of indexed languages, we identify a subclass of 2-nested words,\nwhich we call 2-wave words. This class strictly extends the class of nested\nwords, while preserving its main properties. More precisely, we prove closure\nunder determinization of the corresponding automaton model, we provide a\nlogical characterization of the recognized languages, and show that the\ncorresponding graphs have bounded treewidth. As a consequence, we derive\nimportant closure and decidability properties. Last, we show that the word\nprojections of the languages we define belong to the class of linear indexed\nlanguages.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.10347v1"
    },
    {
        "title": "Tree-Based Adaptive Model Learning",
        "authors": [
            "Tiago Ferreira",
            "Gerco van Heerdt",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We extend the Kearns-Vazirani learning algorithm to be able to handle systems\nthat change over time. We present a new learning algorithm that can reuse and\nupdate previously learned behavior, implement it in the LearnLib library, and\nevaluate it on large examples, to which we make small adjustments between two\nruns of the algorithm. In these experiments our algorithm significantly\noutperforms both the classic Kearns-Vazirani learning algorithm and the current\nstate-of-the-art adaptive algorithm.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.00122v2"
    },
    {
        "title": "Computing the linear hull: Deciding Deterministic? and Unambiguous? for\n  weighted automata over fields",
        "authors": [
            "Jason P. Bell",
            "Daniel Smertnig"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The (left) linear hull of a weighted automaton over a field is a topological\ninvariant. If the automaton is minimal, the linear hull can be used to\ndetermine whether or not the automaton is equivalent to a deterministic one.\nFurthermore, the linear hull can also be used to determine whether the minimal\nautomaton is equivalent to an unambiguous one. We show how to compute the\nlinear hull, and thus prove that it is decidable whether or not a given\nautomaton over a number field is equivalent to a deterministic one. In this\ncase we are also able to compute an equivalent deterministic automaton. We also\nshow the analogous decidability and computability result for the unambiguous\ncase. Our results resolve a problem posed in a 2006 survey by Lombardy and\nSakarovitch.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.02260v2"
    },
    {
        "title": "On the Intersection of Context-Free and Regular Languages",
        "authors": [
            "Clemente Pasti",
            "Andreas Opedal",
            "Tiago Pimentel",
            "Tim Vieira",
            "Jason Eisner",
            "Ryan Cotterell"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The Bar-Hillel construction is a classic result in formal language theory. It\nshows, by a simple construction, that the intersection of a context-free\nlanguage and a regular language is itself context-free. In the construction,\nthe regular language is specified by a finite-state automaton. However, neither\nthe original construction (Bar-Hillel et al., 1961) nor its weighted extension\n(Nederhof and Satta, 2003) can handle finite-state automata with\n$\\varepsilon$-arcs. While it is possible to remove $\\varepsilon$-arcs from a\nfinite-state automaton efficiently without modifying the language, such an\noperation modifies the automaton's set of paths. We give a construction that\ngeneralizes the Bar-Hillel in the case where the desired automaton has\n$\\varepsilon$-arcs, and further prove that our generalized construction leads\nto a grammar that encodes the structure of both the input automaton and grammar\nwhile retaining the asymptotic size of the original construction.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.06809v2"
    },
    {
        "title": "Practical LR Parser Generation",
        "authors": [
            "Joe Zimmerman"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parsing is a fundamental building block in modern compilers, and for\nindustrial programming languages, it is a surprisingly involved task. There are\nknown approaches to generate parsers automatically, but the prevailing\nconsensus is that automatic parser generation is not practical for real\nprogramming languages: LR/LALR parsers are considered to be far too restrictive\nin the grammars they support, and LR parsers are often considered too\ninefficient in practice. As a result, virtually all modern languages use\nrecursive-descent parsers written by hand, a lengthy and error-prone process\nthat dramatically increases the barrier to new programming language\ndevelopment.\n  In this work we demonstrate that, contrary to the prevailing consensus, we\ncan have the best of both worlds: for a very general, practical class of\ngrammars -- a strict superset of Knuth's canonical LR -- we can generate\nparsers automatically, and the resulting parser code, as well as the generation\nprocedure itself, is highly efficient. This advance relies on several new\nideas, including novel automata optimization procedures; a new grammar\ntransformation (\"CPS\"); per-symbol attributes; recursive-descent actions; and\nan extension of canonical LR parsing, which we refer to as XLR, which endows\nshift/reduce parsers with the power of bounded nondeterministic choice.\n  With these ingredients, we can automatically generate efficient parsers for\nvirtually all programming languages that are intuitively easy to parse -- a\nclaim we support experimentally, by implementing the new algorithms in a new\nsoftware tool called langcc, and running them on syntax specifications for\nGolang 1.17.8 and Python 3.9.12. The tool handles both languages automatically,\nand the generated code, when run on standard codebases, is 1.2x faster than the\ncorresponding hand-written parser for Golang, and 4.3x faster than the CPython\nparser, respectively.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.08383v1"
    },
    {
        "title": "Grammars over the Lambek Calculus with Permutation: Recognizing Power\n  and Connection to Branching Vector Addition Systems with States",
        "authors": [
            "Tikhon Pshenitsyn"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In (Van Benthem, 1991) it is proved that all permutation closures of\ncontext-free languages can be generated by grammars over the Lambek calculus\nwith the permutation rule (LP-grammars); however, to our best knowledge, it is\nnot established whether the converse holds or not. In this paper, we show that\nLP-grammars are equivalent to linearly-restricted branching vector addition\nsystems with states and with additional memory (shortly, lBVASSAM), which are\nmodified branching vector addition systems with states. Then an example of such\nan lBVASSAM is presented, which generates a non-semilinear set of vectors; this\nyields that LP-grammars generate more than permutation closures of context-free\nlanguages. Moreover, equivalence of LP-grammars and lBVASSAM allows us to\npresent a normal form for LP-grammars and, as a consequence, prove that\nLP-grammars are equivalent to LP-grammars without product. Finally, we prove\nthat the class of languages generated by LP-grammars is closed under\nintersection.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.08415v2"
    },
    {
        "title": "A Hierarchy of Nondeterminism",
        "authors": [
            "Bader Abu Radi",
            "Orna Kupferman",
            "Ofer Leshkowitz"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study three levels in a hierarchy of nondeterminism: A nondeterministic\nautomaton $\\mathcal{A}$ is determinizable by pruning (DBP) if we can obtain a\ndeterministic automaton equivalent to $\\mathcal{A}$ by removing some of its\ntransitions. Then, $\\mathcal{A}$ is history deterministic (HD) if its\nnondeterministic choices can be resolved in a way that only depends on the\npast. Finally, $\\mathcal{A}$ is semantically deterministic (SD) if different\nnondeterministic choices in $\\mathcal{A}$ lead to equivalent states. Some\napplications of automata in formal methods require deterministic automata, yet\nin fact can use automata with some level of nondeterminism. For example, DBP\nautomata are useful in the analysis of online algorithms, and HD automata are\nuseful in synthesis and control. For automata on finite words, the three levels\nin the hierarchy coincide. We study the hierarchy for B\\\"uchi, co-B\\\"uchi, and\nweak automata on infinite words. We show that the hierarchy is strict, study\nthe expressive power of the different levels in it, as well as the complexity\nof deciding the membership of a language in a given level. Finally, we describe\na probability-based analysis of the hierarchy, which relates the level of\nnondeterminism with the probability that a random run on a word in the language\nis accepting. We relate the latter to nondeterministic automata that can be\nused when reasoning about probabilistic systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.09866v3"
    },
    {
        "title": "Schema-Based Automata Determinization",
        "authors": [
            "Joachim Niehren",
            "Momar Sakho",
            "Antonio Al Serhali"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose an algorithm for schema-based determinization of finite automata\non words and of step-wise hedge automata on nested words. The idea is to\nintegrate schema-based cleaning directly into automata determinization. We\nprove the correctness of our new algorithm and show that it is alway smore\nefficient than standard determinization followed by schema-based cleaning. Our\nimplementation permits to obtain a small deterministic automaton for an example\nof an XPath query, where standard determinization yields a huge stepwise hedge\nautomaton for which schema-based cleaning runs out of memory.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.10312v1"
    },
    {
        "title": "Analyzing Robustness of Angluin's L* Algorithm in Presence of Noise",
        "authors": [
            "Igor Khmelnitsky",
            "Serge Haddad",
            "Lina Ye",
            "Benoît Barbot",
            "Benedikt Bollig",
            "Martin Leucker",
            "Daniel Neider",
            "Rajarshi Roy"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Angluin's L* algorithm learns the minimal (complete) deterministic finite\nautomaton (DFA) of a regular language using membership and equivalence queries.\nIts probabilistic approximatively correct (PAC) version substitutes an\nequivalence query by a large enough set of random membership queries to get a\nhigh level confidence to the answer. Thus it can be applied to any kind of\n(also non-regular) device and may be viewed as an algorithm for synthesizing an\nautomaton abstracting the behavior of the device based on observations. Here we\nare interested on how Angluin's PAC learning algorithm behaves for devices\nwhich are obtained from a DFA by introducing some noise. More precisely we\nstudy whether Angluin's algorithm reduces the noise and produces a DFA closer\nto the original one than the noisy device. We propose several ways to introduce\nthe noise: (1) the noisy device inverts the classification of words w.r.t. the\nDFA with a small probability, (2) the noisy device modifies with a small\nprobability the letters of the word before asking its classification w.r.t. the\nDFA, and (3) the noisy device combines the classification of a word w.r.t. the\nDFA and its classification w.r.t. a counter automaton. Our experiments were\nperformed on several hundred DFAs.\n  Our main contributions, bluntly stated, consist in showing that: (1)\nAngluin's algorithm behaves well whenever the noisy device is produced by a\nrandom process, (2) but poorly with a structured noise, and, that (3) almost\nsurely randomness yields systems with non-recursively enumerable languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.10315v1"
    },
    {
        "title": "Characterising memory in infinite games",
        "authors": [
            "Antonio Casares",
            "Pierre Ohlmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper is concerned with games of infinite duration played over\npotentially infinite graphs. Recently, Ohlmann (LICS 2022) presented a\ncharacterisation of objectives admitting optimal positional strategies, by\nmeans of universal graphs: an objective is positional if and only if it admits\nwell-ordered monotone universal graphs. We extend Ohlmann's characterisation to\nencompass (finite or infinite) memory upper bounds.\n  We prove that objectives admitting optimal strategies with\n$\\varepsilon$-memory less than $m$ (a memory that cannot be updated when\nreading an $\\varepsilon$-edge) are exactly those which admit well-founded\nmonotone universal graphs whose antichains have size bounded by $m$. We also\ngive a characterisation of chromatic memory by means of appropriate universal\nstructures. Our results apply to finite as well as infinite memory bounds (for\ninstance, to objectives with finite but unbounded memory, or with countable\nmemory strategies).\n  We illustrate the applicability of our framework by carrying out a few case\nstudies, we provide examples witnessing limitations of our approach, and we\ndiscuss general closure properties which follow from our results.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.12044v5"
    },
    {
        "title": "A Framework for Formal Verification of DRAM Controllers",
        "authors": [
            "Lukas Steiner",
            "Chirag Sudarshan",
            "Matthias Jung",
            "Dominik Stoffel",
            "Norbert Wehn"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The large number of recent JEDEC DRAM standard releases and their increasing\nfeature set makes it difficult for designers to rapidly upgrade the memory\ncontroller IPs to each new standard. Especially the hardware verification is\nchallenging due to the higher protocol complexity of standards like DDR5,\nLPDDR5 or HBM3 in comparison with their predecessors. With traditional\nsimulation-based verification it is laborious to guarantee the coverage of all\npossible states, especially for control flow rich memory controllers. This has\na direct impact on the time-to-market. A promising alternative is formal\nverification because it allows to ensure protocol compliance based on\nmathematical proofs. However, with regard to memory controllers no\nfully-automated verification process has been presented in the state-of-the-art\nyet, which means there is still a potential risk of human error. In this paper\nwe present a framework that automatically generates SystemVerilog Assertions\nfor a DRAM protocol. In addition, we show how the framework can be used\nefficiently for different tasks of memory controller development.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.14021v1"
    },
    {
        "title": "SkiNet, A Petri Net Generation Tool for the Verification of\n  Skillset-based Autonomous Systems",
        "authors": [
            "Baptiste Pelletier",
            "Charles Lesire",
            "David Doose",
            "Karen Godary-Dejean",
            "Charles Dramé-Maigné"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The need for high-level autonomy and robustness of autonomous systems for\nmissions in dynamic and remote environment has pushed developers to come up\nwith new software architectures. A common architecture style is to summarize\nthe capabilities of the robotic system into elementary actions, called skills,\non top of which a skill management layer is implemented to structure, test and\ncontrol the functional layer. However, current available verification tools\nonly provide either mission-specific verification or verification on a model\nthat does not replicate the actual execution of the system, which makes it\ndifficult to ensure its robustness to unexpected events. To that end, a tool,\nSkiNet, has been developed to transform the skill-based architecture of a\nsystem into a Petri net modeling the state-machine behaviors of the skills and\nthe resources they handle. The Petri net allows the use of model-checking, such\nas Linear Temporal Logic (LTL) or Computational Tree Logic (CTL), for the user\nto analyze and verify the model of the system.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.14039v1"
    },
    {
        "title": "Learning Signal Temporal Logic through Neural Network for Interpretable\n  Classification",
        "authors": [
            "Danyang Li",
            "Mingyu Cai",
            "Cristian-Ioan Vasile",
            "Roberto Tron"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Machine learning techniques using neural networks have achieved promising\nsuccess for time-series data classification. However, the models that they\nproduce are challenging to verify and interpret. In this paper, we propose an\nexplainable neural-symbolic framework for the classification of time-series\nbehaviors. In particular, we use an expressive formal language, namely Signal\nTemporal Logic (STL), to constrain the search of the computation graph for a\nneural network. We design a novel time function and sparse softmax function to\nimprove the soundness and precision of the neural-STL framework. As a result,\nwe can efficiently learn a compact STL formula for the classification of\ntime-series data through off-the-shelf gradient-based tools. We demonstrate the\ncomputational efficiency, compactness, and interpretability of the proposed\nmethod through driving scenarios and naval surveillance case studies, compared\nwith state-of-the-art baselines.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.01910v2"
    },
    {
        "title": "Computing Threshold Budgets in Discrete-Bidding Games",
        "authors": [
            "Guy Avni",
            "Suman Sadhukhan"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In a two-player zero-sum graph game, the players move a token throughout a\ngraph to produce an infinite play, which determines the winner of the game.\n\\emph{Bidding games} are graph games in which in each turn, an auction\n(bidding) determines which player moves the token: the players have budgets,\nand in each turn, both players simultaneously submit bids that do not exceed\ntheir available budgets, the higher bidder moves the token, and pays the bid to\nthe lower bidder (called {\\em Richman} bidding). We focus on {\\em\ndiscrete}-bidding games, in which, motivated by practical applications, the\ngranularity of the players' bids is restricted, e.g., bids must be given in\ncents.\n  A central quantity in bidding games is are {\\em threshold budgets}: a\nnecessary and sufficient initial budget for winning the game. Previously,\nthresholds were shown to exist in parity games, but their structure was only\nunderstood for reachability games. Moreover, the previously-known algorithms\nhave a worst-case exponential running time for both reachability and parity\nobjectives, and output strategies that use exponential memory. We describe two\nalgorithms for finding threshold budgets in parity discrete-bidding games. The\nfirst is a fixed-point algorithm. It reveals, for the first time, the structure\nof threshold budgets in parity discrete-bidding games. Based on this structure,\nwe develop a second algorithm that shows that the problem of finding threshold\nbudgets is in \\NP and co\\NP for both reachability and parity objectives.\nMoreover, our algorithm constructs strategies that use only linear memory.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.02773v2"
    },
    {
        "title": "Automata Equipped with Auxiliary Data Structures and Regular\n  Realizability Problems",
        "authors": [
            "Alexander Rubtsov",
            "Mikhail Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider general computational models: one-way and two-way finite\nautomata, and logarithmic space Turing machines, all equipped with an auxiliary\ndata structure (ADS). The definition of an ADS is based on the language of\nprotocols of work with the ADS. We describe the connection of automata-based\nmodels with ``Balloon automata'' that are another general formalization of\nautomata equipped with an ADS presented by Hopcroft and Ullman in 1967.\n  This definition establishes the connection between the non-emptiness problem\nfor one-way automata with ADS, languages recognizable by nondeterministic\nlog-space Turing machines equipped with the same ADS, and a regular\nrealizability problem (NRR) for the language of ADS' protocols. The NRR problem\nis to verify whether the regular language on the input has a non-empty\nintersection with the language of protocols. The computational complexity of\nthese problems (and languages) is the same up to log-space reductions.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.03934v1"
    },
    {
        "title": "Model-checking lock-sharing systems against regular constraints",
        "authors": [
            "Corto Mascle"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study the verification of distributed systems where processes are finite\nautomata with access to a shared pool of locks. We consider objectives that are\nboolean combinations of local regular constraints. We show that the problem,\nPSPACE-complete in general, falls in NP with the right assumptions on the\nsystem. We use restrictions on the number of locks a process can access and the\norder in which locks can be released. We provide tight complexity bounds, as\nwell as a subcase of interest that can be solved in PTIME.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.07914v1"
    },
    {
        "title": "Verifying And Interpreting Neural Networks using Finite Automata",
        "authors": [
            "Marco Sälzer",
            "Eric Alsmann",
            "Florian Bruse",
            "Martin Lange"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Verifying properties and interpreting the behaviour of deep neural networks\n(DNN) is an important task given their ubiquitous use in applications,\nincluding safety-critical ones, and their black-box nature. We propose an\nautomata-theoric approach to tackling problems arising in DNN analysis. We show\nthat the input-output behaviour of a DNN can be captured precisely by a\n(special) weak B\\\"uchi automaton and we show how these can be used to address\ncommon verification and interpretation tasks of DNN like adversarial robustness\nor minimum sufficient reasons.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.01022v3"
    },
    {
        "title": "Geometry of Reachability sets of Vector Addition Systems",
        "authors": [
            "Roland Guttenberg",
            "Mikhail Raskin",
            "Javier Esparza"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Vector Addition Systems (VAS), aka Petri nets, are a popular model of\nconcurrency. The reachability set of a VAS is the set of configurations\nreachable from the initial configuration. Leroux has studied the geometric\nproperties of VAS reachability sets, and used them to derive decision\nprocedures for important analysis problems. In this paper we continue the\ngeometric study of reachability sets. We show that every reachability set\nadmits a finite decomposition into disjoint almost hybridlinear sets enjoying\nnice geometric properties. Further, we prove that the decomposition of the\nreachability set of a given VAS is effectively computable. As a corollary, we\nderive a simple algorithm for deciding semilinearity of VAS reachability sets,\nthe first one since Hauschildt's 1990 algorithm. As a second corollary, we\nprove that the complement of a reachability set always contains an infinite\nlinear set.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.02889v3"
    },
    {
        "title": "Factor-balanced $S$-adic languages",
        "authors": [
            "Léo Poirier",
            "Wolfgang Steiner"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  A set of words, also called a language, is letter-balanced if the number of\noccurrences of each letter only depends on the length of the word, up to a\nconstant. Similarly, a language is factor-balanced if the difference of the\nnumber of occurrences of any given factor in words of the same length is\nbounded. The most prominent example of a letter-balanced but not\nfactor-balanced language is given by the Thue-Morse sequence. We establish\nconnections between the two notions, in particular for languages given by\nsubstitutions and, more generally, by sequences of substitutions. We show that\nthe two notions essentially coincide when the sequence of substitutions is\nproper. For the example of Thue-Morse-Sturmian languages, we give a full\ncharacterisation of factor-balancedness.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.14076v1"
    },
    {
        "title": "P(Expression|Grammar): Probability of deriving an algebraic expression\n  with a probabilistic context-free grammar",
        "authors": [
            "Urh Primožič",
            "Ljupčo Todorovski",
            "Matej Petković"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Probabilistic context-free grammars have a long-term record of use as\ngenerative models in machine learning and symbolic regression. When used for\nsymbolic regression, they generate algebraic expressions. We define the latter\nas equivalence classes of strings derived by grammar and address the problem of\ncalculating the probability of deriving a given expression with a given\ngrammar. We show that the problem is undecidable in general. We then present\nspecific grammars for generating linear, polynomial, and rational expressions,\nwhere algorithms for calculating the probability of a given expression exist.\nFor those grammars, we design algorithms for calculating the exact probability\nand efficient approximation with arbitrary precision.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.00751v2"
    },
    {
        "title": "Automaton-Based Representations of Task Knowledge from Generative\n  Language Models",
        "authors": [
            "Yunhao Yang",
            "Jean-Raphaël Gaglione",
            "Cyrus Neary",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Automaton-based representations of task knowledge play an important role in\ncontrol and planning for sequential decision-making problems. However,\nobtaining the high-level task knowledge required to build such automata is\noften difficult. Meanwhile, large-scale generative language models (GLMs) can\nautomatically generate relevant task knowledge. However, the textual outputs\nfrom GLMs cannot be formally verified or used for sequential decision-making.\nWe propose a novel algorithm named GLM2FSA, which constructs a finite state\nautomaton (FSA) encoding high-level task knowledge from a brief\nnatural-language description of the task goal. GLM2FSA first sends queries to a\nGLM to extract task knowledge in textual form, and then it builds an FSA to\nrepresent this text-based knowledge. The proposed algorithm thus fills the gap\nbetween natural-language task descriptions and automaton-based representations,\nand the constructed FSA can be formally verified against user-defined\nspecifications. We accordingly propose a method to iteratively refine the\nqueries to the GLM based on the outcomes, e.g., counter-examples, from\nverification. We demonstrate GLM2FSA's ability to build and refine\nautomaton-based representations of everyday tasks (e.g., crossing a road), and\nalso of tasks that require highly-specialized knowledge (e.g., executing secure\nmulti-party computation).\n",
        "pdf_link": "http://arxiv.org/pdf/2212.01944v5"
    },
    {
        "title": "Efficient Convex Zone Merging in Parametric Timed Automata",
        "authors": [
            "Étienne André",
            "Dylan Marinho",
            "Laure Petrucci",
            "Jaco van de Pol"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Parametric timed automata are a powerful formalism for reasoning on\nconcurrent real-time systems with unknown or uncertain timing constants.\nReducing their state space is a significant way to reduce the inherently large\nanalysis times. We present here different merging reduction techniques based on\nconvex union of constraints (parametric zones), allowing to decrease the number\nof states while preserving the correctness of verification and synthesis\nresults. We perform extensive experiments, and identify the best heuristics in\npractice, bringing a significant decrease in the computation time on a\nbenchmarks library.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.04802v1"
    },
    {
        "title": "Reactive Synthesis for DECLARE via symbolic automata",
        "authors": [
            "Luca Geatti",
            "Marco Montali",
            "Andrey Rivkin"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Given a specification of linear-time temporal logic interpreted over finite\ntraces (LTLf), the reactive synthesis problem asks to find a\nfinitely-representable, terminating controller that reacts to the\nuncontrollable actions of an environment in order to enforce a desired system\nspecification. In this paper we study, for the first time, the reactive\nsynthesis problem for DECLARE - a fragment of LTLf extensively used both in\ntheory and practice for specifying declarative, constraint-based business\nprocesses. We provide a threefold contribution. First, we give a naive, doubly\nexponential time synthesis algorithm for this problem. Second, we show how an\narbitrary DECLARE specification can be compactly encoded into an equivalent\npure past one in LTLf, and we exploit this to define an optimized, singly\nexponential time algorithm for DECLARE synthesis. Third, we derive a symbolic\nversion of this algorithm, by introducing a novel translation of pure-past\ntemporal formulas into symbolic deterministic finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.10875v1"
    },
    {
        "title": "An Elementary Proof of the FMP for Kleene Algebra",
        "authors": [
            "Tobias Kappé"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Kleene Algebra (KA) is a useful tool for proving that two programs are\nequivalent. Because KA's equational theory is decidable, it integrates well\nwith interactive theorem provers. This raises the question: which equations can\nwe (not) prove using the laws of KA? Moreover, which models of KA are complete,\nin the sense that they satisfy exactly the provable equations? Kozen (1994)\nanswered these questions by characterizing KA in terms of its language model.\nConcretely, equivalences provable in KA are exactly those that hold for regular\nexpressions.\n  Pratt (1980) observed that KA is complete w.r.t. relational models, i.e.,\nthat its provable equations are those that hold for any relational\ninterpretation. A less known result due to Palka (2005) says that finite models\nare complete for KA, i.e., that provable equivalences coincide with equations\nsatisfied by all finite KAs. Phrased contrapositively, the latter is a finite\nmodel property (FMP): any unprovable equation is falsified by a finite KA. Both\nresults can be argued using Kozen's theorem, but the implication is mutual:\ngiven that KA is complete w.r.t. finite (resp. relational) models, Palka's\n(resp. Pratt's) arguments show that it is complete w.r.t. the language model.\n  We embark on a study of the different complete models of KA, and the\nconnections between them. This yields a novel result subsuming those of Palka\nand Pratt, namely that KA is complete w.r.t. finite relational models. Next, we\nput an algebraic spin on Palka's techniques, which yield a new elementary proof\nof the finite model property, and by extension, of Kozen's and Pratt's\ntheorems. In contrast with earlier approaches, this proof relies not on\nminimality or bisimilarity of automata, but rather on representing the regular\nexpressions involved in terms of transformation automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.10931v3"
    },
    {
        "title": "Real-valued affine automata compute beyond Turing machines",
        "authors": [
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We show that bounded-error affine finite automata recognize uncountably many\n(and so some non-Turing recognizable) languages when using real-valued\ntransitions.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.11834v1"
    },
    {
        "title": "Parameterized Verification under TSO with Data Types",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "Florian Furbach",
            "Adwait Godbole",
            "Yacoub G. Hendi",
            "Shankaranarayanan Krishna",
            "Stephan Spengler"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider parameterized verification of systems executing according to the\ntotal store ordering (TSO) semantics. The processes manipulate abstract data\ntypes over potentially infinite domains. We present a framework that translates\nthe reachability problem for such systems to the reachability problem for\nregister machines enriched with the given abstract data type. We use the\ntranslation to obtain tight complexity bounds for TSO-based parameterized\nverification over several abstract data types, such as push-down automata,\nordered multi push-down automata, one-counter nets, one-counter automata, and\nPetri nets. We apply the framework to get complexity bounds for higher order\nstack and counter variants as well.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.02163v3"
    },
    {
        "title": "Timed I/O Automata: It is never too late to complete your timed\n  specification theory",
        "authors": [
            "Martijn A. Goorden",
            "Kim G. Larsen",
            "Axel Legay",
            "Florian Lorber",
            "Ulrik Nyman",
            "Andrzej Wasowski"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A specification theory combines notions of specifications and implementations\nwith a satisfaction relation, a refinement relation and a set of operators\nsupporting stepwise design. We develop a complete specification framework for\nreal-time systems using Timed I/O Automata as the specification formalism, with\nthe semantics expressed in terms of Timed I/O Transition Systems. We provide\nconstructs for refinement, consistency checking, logical and structural\ncomposition, and quotient of specifications -- all indispensable ingredients of\na compositional design methodology. The theory is backed by rigorous proofs and\nis being implemented in the open-source tool ECDAR.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.04529v2"
    },
    {
        "title": "Recognizability in S-adic shifts",
        "authors": [
            "Marie-Pierre Béal",
            "Dominique Perrin",
            "Antonio Restivo",
            "Wolfgang Steiner"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We investigate questions related to the notion of recognizability of\nsequences of morphisms, a generalization of Moss{\\'e}'s Theorem. We consider\nthe most general class of morphisms including ones with erasable letters. The\nmain result states that a sequence of morphisms with finite alphabet rank is\neventually recognizable for aperiodic points, improving and simplifying a\nresult of Berth{\\'e} et al. (2019). This also provides a new simple proof for\nthe recognizability of a single morphism on its shift space. The main\ningredient of the proof are elementary morphisms.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06258v2"
    },
    {
        "title": "Languages given by Finite Automata over the Unary Alphabet",
        "authors": [
            "Wojciech Czerwiński",
            "Maciej Dębski",
            "Tomasz Gogasz",
            "Gordon Hoi",
            "Sanjay Jain",
            "Michał Skrzypczak",
            "Frank Stephan",
            "Christopher Tan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper studies the complexity of operations on finite automata and the\ncomplexity of their decision problems when the alphabet is unary. Let $n$\ndenote the maximum of the number of states of the input finite automata\nconsidered in the corresponding results. The following main results are\nobtained:\n  (1) Given two unary NFAs recognising $L$ and $H$, respectively, one can\ndecide whether $L \\subseteq H$ as well as whether $L = H$ in time $2^{O((n \\log\nn)^{1/3})}$. The previous upper bound on time was $2^{O((n \\log n)^{1/2})}$ as\ngiven by Chrobak (1986), and this bound was not significantly improved since\nthen.\n  (2) Given two unary UFAs (unambiguous finite automata) recognising $L$ and\n$H$, respectively, one can determine a UFA recognising $L \\cup H$ and a UFA\nrecognising complement of $L$, where these output UFAs have the number of\nstates bounded by a quasipolynomial in $n$. However, in the worst case, a UFA\nfor recognising concatenation of languages recognised by two $n$-state UFAs,\nuses $2^{\\Theta((n \\log^2 n)^{1/3})}$ states.\n  (3) Given a unary language $L$, if $L$ contains the word of length $k$, then\nlet $L(k)=1$ else let $L(k)=0$. Let $\\omega_L$ be the $\\omega$-word\n$L(0)L(1)\\ldots$ and let $\\cal L$ be a fixed $\\omega$-regular language. The\nlast section studies how difficult it is to decide, given an $n$-state UFA or\nNFA\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06435v3"
    },
    {
        "title": "Deterministic regular functions of infinite words",
        "authors": [
            "Olivier Carton",
            "Gaëtan Douéneau-Tabot",
            "Emmanuel Filiot",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Regular functions of infinite words are (partial) functions realized by\ndeterministic two-way transducers with infinite look-ahead. Equivalently, Alur\net. al. have shown that they correspond to functions realized by deterministic\nMuller streaming string transducers, and to functions defined by\nMSO-transductions. Regular functions are however not computable in general (for\na classical extension of Turing computability to infinite inputs), and we\nconsider in this paper the class of deterministic regular functions of infinite\nwords, realized by deterministic two-way transducers without look-ahead. We\nprove that it is a well-behaved class of functions: they are computable, closed\nunder composition, characterized by the guarded fragment of MSO-transductions,\nby deterministic B\\\"uchi streaming string transducers, by deterministic two-way\ntransducers with finite look-ahead, and by finite compositions of sequential\nfunctions and one fixed basic function called map-copy-reverse.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.06672v1"
    },
    {
        "title": "The Word Problem for Finitary Automaton Groups",
        "authors": [
            "Maximilian Kotowsky",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A finitary automaton group is a group generated by an invertible,\ndeterministic finite-state letter-to-letter transducer whose only cycles are\nself-loops at an identity state. We show that, for this presentation of finite\ngroups, the uniform word problem is coNP-complete. Here, the input consists of\na finitary automaton together with a finite state sequence and the question is\nwhether the sequence acts trivially on all input words. Additionally, we also\nshow that the respective compressed word problem, where the state sequence is\ngiven as a straight-line program, is PSpace-complete. In both cases, we give a\ndirect reduction from the satisfiability problem for (quantified) boolean\nformulae and we further show that the problems remain complete for their\nrespective classes if we restrict the input alphabet of the automata to a\nbinary one.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.10670v2"
    },
    {
        "title": "An Educational Tool for Exploring the Pumping Lemma Property for Regular\n  Languages",
        "authors": [
            "Josue N. Rivera",
            "Haiping Xu"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Pumping lemma has been a very difficult topic for students to understand in a\ntheoretical computer science course due to a lack of tool support. In this\npaper, we present an active learning tool called MInimum PUmping length (MIPU)\neducational software to explore the pumping lemma property for regular\nlanguages. For a given regular language, MIPU offers three major\nfunctionalities: determining the membership of an input string, generating a\nlist of short strings that belong to the language, and automatically\ncalculating the minimal pumping length of the language. The software tool has\nbeen developed to provide educational assistance to students to better\nunderstand the concepts of pumping lemma and minimum pumping length, and\npromote active learning through hand-on practice.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.12941v1"
    },
    {
        "title": "Revisiting Variable Ordering for Real Quantifier Elimination using\n  Machine Learning",
        "authors": [
            "John Hester",
            "Briland Hitaj",
            "Grant Passmore",
            "Sam Owre",
            "Natarajan Shankar",
            "Eric Yeh"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Cylindrical Algebraic Decomposition (CAD) is a key proof technique for formal\nverification of cyber-physical systems. CAD is computationally expensive, with\nworst-case doubly-exponential complexity. Selecting an optimal variable\nordering is paramount to efficient use of CAD. Prior work has demonstrated that\nmachine learning can be useful in determining efficient variable orderings.\nMuch of this work has been driven by CAD problems extracted from applications\nof the MetiTarski theorem prover. In this paper, we revisit this prior work and\nconsider issues of bias in existing training and test data. We observe that the\nclassical MetiTarski benchmarks are heavily biased towards particular variable\norderings. To address this, we apply symmetries to create a new dataset\ncontaining more than 41K MetiTarski challenges designed to remove bias.\nFurthermore, we evaluate issues of information leakage, and test the\ngeneralizability of our models on the new dataset.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.14038v1"
    },
    {
        "title": "Infinite Words and Morphic Languages Formalized in Isabelle/HOL",
        "authors": [
            "Štěpán Starosta"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We present a formalization of basics related to infinite words in the generic\nproof assistant Isabelle/HOL. Furthermore, we present a formalization of purely\nmorphic and morphic languages. Finally, we present a formalized definition of\nSturmian words as lower mechanical words and prove some very elementary facts.\nThe formalization is based on an ongoing larger project of formalization of\ncombinatorics on words.\n",
        "pdf_link": "http://arxiv.org/pdf/2303.11445v1"
    },
    {
        "title": "History-deterministic Timed Automata",
        "authors": [
            "Sougata Bose",
            "Thomas A. Henzinger",
            "Karoliina Lehtinen",
            "Sven Schewe",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We explore the notion of history-determinism in the context of timed automata\n(TA) over infinite timed words. History-deterministic (HD) automata are those\nin which nondeterminism can be resolved on the fly, based on the run\nconstructed thus far. History-determinism is a robust property that admits\ndifferent game-based characterisations, and HD specifications allow for\ngame-based verification without an expensive determinization step.\n  We show that the class of timed $\\omega$-languages recognized by HD timed\nautomata strictly extends that of deterministic ones, and is strictly included\nin those recognised by fully non-deterministic TA.\n  For non-deterministic timed automata it is known that universality is already\nundecidable for safety/reachability TA. For history-deterministic TA with\narbitrary parity acceptance, we show that timed universality, inclusion, and\nsynthesis all remain decidable and are EXPTIME-complete.\n  For the subclass of TA with safety or reachability acceptance, one can decide\n(in EXPTIME) whether such an automaton is history-deterministic. If so, it can\neffectively determinized without introducing new automaton states.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.03183v7"
    },
    {
        "title": "The Big-O Problem for Max-Plus Automata is Decidable (PSPACE-Complete)",
        "authors": [
            "Laure Daviaud",
            "David Purser",
            "Marie Tcheng"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We show that the big-O problem for max-plus automata is decidable and\nPSPACE-complete. The big-O (or affine domination) problem asks whether, given\ntwo max-plus automata computing functions f and g, there exists a constant c\nsuch that f < cg+ c. This is a relaxation of the containment problem asking\nwhether f < g, which is undecidable. Our decidability result uses Simon's\nforest factorisation theorem, and relies on detecting specific elements, that\nwe call witnesses, in a finite semigroup closed under two special operations:\nstabilisation and flattening.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.05229v2"
    },
    {
        "title": "Robustness Measures and Monitors for Time Window Temporal Logic",
        "authors": [
            "Ahmad Ahmad",
            "Cristian-Ioan Vasile",
            "Roberto Tron",
            "Calin Belta"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Temporal logics (TLs) have been widely used to formalize interpretable tasks\nfor cyber-physical systems. Time Window Temporal Logic (TWTL) has been recently\nproposed as a specification language for dynamical systems. In particular, it\ncan easily express robotic tasks, and it allows for efficient, automata-based\nverification and synthesis of control policies for such systems. In this paper,\nwe define two quantitative semantics for this logic, and two corresponding\nmonitoring algorithms, which allow for real-time quantification of satisfaction\nof formulas by trajectories of discrete-time systems. We demonstrate the new\nsemantics and their runtime monitors on numerical examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.06645v1"
    },
    {
        "title": "Quantitative estimates for the size of an intersection of sparse\n  automatic sets",
        "authors": [
            "Seda Albayrak",
            "Jason Bell"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  A theorem of Cobham says that if $k$ and $\\ell$ are two multiplicatively\nindependent natural numbers then a subset of the natural numbers that is both\n$k$- and $\\ell$-automatic is eventually periodic. A multidimensional extension\nwas later given by Semenov. In this paper, we give a quantitative version of\nthe Cobham-Semenov theorem for sparse automatic sets, showing that the\nintersection of a sparse $k$-automatic subset of $\\mathbb{N}^d$ and a sparse\n$\\ell$-automatic subset of $\\mathbb{N}^d$ is finite with size that can be\nexplicitly bounded in terms of data from the automata that accept these sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.09223v1"
    },
    {
        "title": "On Certificates, Expected Runtimes, and Termination in Probabilistic\n  Pushdown Automata",
        "authors": [
            "Tobias Winkler",
            "Joost-Pieter Katoen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Probabilistic pushdown automata (pPDA) are a natural operational model for a\nvariety of recursive discrete stochastic processes. In this paper, we study\ncertificates - succinct and easily verifiable proofs - for upper and lower\nbounds on various quantitative properties of a given pPDA. We reveal an\nintimate, yet surprisingly simple connection between the existence of such\ncertificates and the expected time to termination of the pPDA at hand. This is\nestablished by showing that certain intrinsic properties, like the spectral\nradius of the Jacobian of the pPDA's underlying polynomial equation system, are\ndirectly related to expected runtimes. As a consequence, we obtain that there\nalways exist easy-to-check proofs for positive almost-sure termination: does a\npPDA terminate in finite expected time?\n",
        "pdf_link": "http://arxiv.org/pdf/2304.09997v2"
    },
    {
        "title": "Revisiting Membership Problems in Subclasses of Rational Relations",
        "authors": [
            "Pascal Bergsträßer",
            "Moses Ganardi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We revisit the membership problem for subclasses of rational relations over\nfinite and infinite words: Given a relation R in a class C_2, does R belong to\na smaller class C_1? The subclasses of rational relations that we consider are\nformed by the deterministic rational relations, synchronous (also called\nautomatic or regular) relations, and recognizable relations. For almost all\nversions of the membership problem, determining the precise complexity or even\ndecidability has remained an open problem for almost two decades. In this\npaper, we provide improved complexity and new decidability results. (i) Testing\nwhether a synchronous relation over infinite words is recognizable is\nNL-complete (PSPACE-complete) if the relation is given by a deterministic\n(nondeterministic) omega-automaton. This fully settles the complexity of this\nrecognizability problem, matching the complexity of the same problem over\nfinite words. (ii) Testing whether a deterministic rational binary relation is\nrecognizable is decidable in polynomial time, which improves a previously known\ndouble exponential time upper bound. For relations of higher arity, we present\na randomized exponential time algorithm. (iii) We provide the first algorithm\nto decide whether a deterministic rational relation is synchronous. For binary\nrelations the algorithm even runs in polynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.11034v2"
    },
    {
        "title": "Probabilistic Planning with Prioritized Preferences over Temporal Logic\n  Objectives",
        "authors": [
            "Lening Li",
            "Hazhar Rahmani",
            "Jie Fu"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper studies temporal planning in probabilistic environments, modeled\nas labeled Markov decision processes (MDPs), with user preferences over\nmultiple temporal goals. Existing works reflect such preferences as a\nprioritized list of goals. This paper introduces a new specification language,\ntermed prioritized qualitative choice linear temporal logic on finite traces,\nwhich augments linear temporal logic on finite traces with prioritized\nconjunction and ordered disjunction from prioritized qualitative choice logic.\nThis language allows for succinctly specifying temporal objectives with\ncorresponding preferences accomplishing each temporal task. The finite traces\nthat describe the system's behaviors are ranked based on their dissatisfaction\nscores with respect to the formula. We propose a systematic translation from\nthe new language to a weighted deterministic finite automaton. Utilizing this\ncomputational model, we formulate and solve a problem of computing an optimal\npolicy that minimizes the expected score of dissatisfaction given user\npreferences. We demonstrate the efficacy and applicability of the logic and the\nalgorithm on several case studies with detailed analyses for each.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.11641v1"
    },
    {
        "title": "Multiplicity Problems on Algebraic Series and Context-Free Grammars",
        "authors": [
            "Nikhil Balaji",
            "Lorenzo Clemente",
            "Klara Nosan",
            "Mahsa Shirmohammadi",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we obtain complexity bounds for computational problems on\nalgebraic power series over several commuting variables. The power series are\nspecified by systems of polynomial equations: a formalism closely related to\nweighted context-free grammars. We focus on three problems -- decide whether a\ngiven algebraic series is identically zero, determine whether all but finitely\nmany coefficients are zero, and compute the coefficient of a specific monomial.\nWe relate these questions to well-known computational problems on arithmetic\ncircuits and thereby show that all three problems lie in the counting\nhierarchy. Our main result improves the best known complexity bound on deciding\nzeroness of an algebraic series. This problem is known to lie in PSPACE by\nreduction to the decision problem for the existential fragment of the theory of\nreal closed fields. Here we show that the problem lies in the counting\nhierarchy by reduction to the problem of computing the degree of a polynomial\ngiven by an arithmetic circuit. As a corollary we obtain new complexity bounds\non multiplicity equivalence of context-free grammars restricted to a bounded\nlanguage, language inclusion of a nondeterministic finite automaton in an\nunambiguous context-free grammar, and language inclusion of a non-deterministic\ncontext-free grammar in an unambiguous finite automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.14145v2"
    },
    {
        "title": "Coverability in VASS Revisited: Improving Rackoff's Bound to Obtain\n  Conditional Optimality",
        "authors": [
            "Marvin Künnemann",
            "Filip Mazowiecki",
            "Lia Schütze",
            "Henry Sinclair-Banks",
            "Karol Węgrzycki"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Seminal results establish that the coverability problem for Vector Addition\nSystems with States (VASS) is in EXPSPACE (Rackoff, '78) and is EXPSPACE-hard\nalready under unary encodings (Lipton, '76). More precisely, Rosier and Yen\nlater utilise Rackoff's bounding technique to show that if coverability holds\nthen there is a run of length at most $n^{2^{\\mathcal{O}(d \\log d)}}$, where\n$d$ is the dimension and $n$ is the size of the given unary VASS. Earlier,\nLipton showed that there exist instances of coverability in $d$-dimensional\nunary VASS that are only witnessed by runs of length at least\n$n^{2^{\\Omega(d)}}$. Our first result closes this gap. We improve the upper\nbound by removing the twice-exponentiated $\\log(d)$ factor, thus matching\nLipton's lower bound. This closes the corresponding gap for the exact space\nrequired to decide coverability. This also yields a deterministic\n$n^{2^{\\mathcal{O}(d)}}$-time algorithm for coverability. Our second result is\na matching lower bound, that there does not exist a deterministic\n$n^{2^{o(d)}}$-time algorithm, conditioned upon the Exponential Time\nHypothesis.\n  When analysing coverability, a standard proof technique is to consider VASS\nwith bounded counters. Bounded VASS make for an interesting and popular model\ndue to strong connections with timed automata. Withal, we study a natural\nsetting where the counter bound is linear in the size of the VASS. Here the\ntrivial exhaustive search algorithm runs in $\\mathcal{O}(n^{d+1})$-time. We\ngive evidence to this being near-optimal. We prove that in dimension one this\ntrivial algorithm is conditionally optimal, by showing that $n^{2-o(1)}$-time\nis required under the $k$-cycle hypothesis. In general fixed dimension $d$, we\nshow that $n^{d-2-o(1)}$-time is required under the 3-uniform hyperclique\nhypothesis.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.01581v1"
    },
    {
        "title": "History-deterministic Vector Addition Systems",
        "authors": [
            "Sougata Bose",
            "David Purser",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider history-determinism, a restricted form of non-determinism, for\nVector Addition Systems with States (VASS) when used as acceptors to recognise\nlanguages of finite words. History-determinism requires that the\nnon-deterministic choices can be resolved on-the-fly; based on the past and\nwithout jeopardising acceptance of any possible continuation of the input word.\n  Our results show that the history-deterministic (HD) VASS sit strictly\nbetween deterministic and non-deterministic VASS regardless of the number of\ncounters. We compare the relative expressiveness of HD systems, and\nclosure-properties of the induced language classes, with coverability and\nreachability semantics, and with and without $\\varepsilon$-labelled\ntransitions.\n  Whereas in dimension 1, inclusion and regularity remain decidable, from\ndimension two onwards, HD-VASS with suitable resolver strategies, are\nessentially able to simulate 2-counter Minsky machines, leading to several\nundecidability results: It is undecidable whether a VASS is\nhistory-deterministic, or if a language equivalent history-deterministic VASS\nexists. Checking language inclusion between history-deterministic 2-VASS is\nalso undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.01981v2"
    },
    {
        "title": "Symbolic Solution of Emerson-Lei Games for Reactive Synthesis",
        "authors": [
            "Daniel Hausmann",
            "Mathieu Lehaut",
            "Nir Pitermann"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Emerson-Lei conditions have recently attracted attention due to their\nsuccinctness and compositionality properties. In the current work, we show how\ninfinite-duration games with Emerson-Lei objectives can be analyzed in two\ndifferent ways. First, we show that the Zielonka tree of the Emerson-Lei\ncondition gives rise naturally to a new reduction to parity games. This\nreduction, however, does not result in optimal analysis. Second, we show based\non the first reduction (and the Zielonka tree) how to provide a direct\nfixpoint-based characterization of the winning region. The fixpoint-based\ncharacterization allows for symbolic analysis. It generalizes the solutions of\ngames with known winning conditions such as B\\\"uchi, GR[1], parity, Streett,\nRabin and Muller objectives, and in the case of these conditions reproduces\npreviously known symbolic algorithms and complexity results.\n  We also show how the capabilities of the proposed algorithm can be exploited\nin reactive synthesis, suggesting a new expressive fragment of LTL that can be\nhandled symbolically. Our fragment combines a safety specification and a\nliveness part. The safety part is unrestricted and the liveness part allows to\ndefine Emerson-Lei conditions on occurrences of letters. The symbolic treatment\nis enabled due to the simplicity of determinization in the case of safety\nlanguages and by using our new algorithm for game solving. This approach\nmaximizes the number of steps solved symbolically in order to maximize the\npotential for efficient symbolic implementations.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.02793v2"
    },
    {
        "title": "From Muller to Parity and Rabin Automata: Optimal Transformations\n  Preserving (History) Determinism",
        "authors": [
            "Antonio Casares",
            "Thomas Colcombet",
            "Nathanaël Fijalkow",
            "Karoliina Lehtinen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study transformations of automata and games using Muller conditions into\nequivalent ones using parity or Rabin conditions. We present two\ntransformations, one that turns a deterministic Muller automaton into an\nequivalent deterministic parity automaton, and another that provides an\nequivalent history-deterministic Rabin automaton. We show a strong optimality\nresult: the obtained automata are minimal amongst those that can be derived\nfrom the original automaton by duplication of states. We introduce the notions\nof locally bijective morphisms and history-deterministic mappings to formalise\nthe correctness and optimality of these transformations.\n  The proposed transformations are based on a novel structure, called the\nalternating cycle decomposition, inspired by and extending Zielonka trees. In\naddition to providing optimal transformations of automata, the alternating\ncycle decomposition offers fundamental information on their structure. We use\nthis information to give crisp characterisations on the possibility of\nrelabelling automata with different acceptance conditions and to perform a\nsystematic study of a normal form for parity automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.04323v3"
    },
    {
        "title": "Finitely Presentable Higher-Dimensional Automata and the Irrationality\n  of Process Replication",
        "authors": [
            "Henning Basold",
            "Thomas Baronner",
            "Márton Hablicsek"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Higher-dimensional automata (HDA) are a formalism to model the behaviour of\nconcurrent systems. They are similar to ordinary automata but allow transitions\nin higher dimensions, effectively enabling multiple actions to happen\nsimultaneously. For ordinary automata, there is a correspondence between\nregular languages and finite automata. However, regular languages are\ninherently sequential and one may ask how such a correspondence carries over to\nHDA, in which several actions can happen at the same time. It has been shown by\nFahrenberg et al. that finite HDA correspond with interfaced interval pomset\nlanguages generated by sequential and parallel composition and non-empty\niteration. In this paper, we seek to extend the correspondence to process\nreplication, also known as parallel Kleene closure. This correspondence cannot\nbe with finite HDA and we instead focus here on locally compact and finitely\nbranching HDA. In the course of this, we extend the notion of interval ipomset\nlanguages to arbitrary HDA, show that the category of HDA is locally finitely\npresentable with compact objects being finite HDA, and we prove language\npreservation results of colimits. We then define parallel composition as a\ntensor product of HDA and show that the repeated parallel composition can be\nexpressed as locally compact and as finitely branching HDA, but also that the\nlatter requires infinitely many initial states.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.06428v1"
    },
    {
        "title": "Weighted Context-Free-Language Ordered Binary Decision Diagrams",
        "authors": [
            "Meghana Sistla",
            "Swarat Chaudhuri",
            "Thomas Reps"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper presents a new data structure, called \\emph{Weighted\nContext-Free-Language Ordered BDDs} (WCFLOBDDs), which are a hierarchically\nstructured decision diagram, akin to Weighted BDDs (WBDDs) enhanced with a\nprocedure-call mechanism. For some functions, WCFLOBDDs are exponentially more\nsuccinct than WBDDs. They are potentially beneficial for representing functions\nof type $\\mathbb{B}^n \\rightarrow D$, when a function's image $V \\subseteq D$\nhas many different values. We apply WCFLOBDDs in quantum-circuit simulation,\nand find that they perform better than WBDDs on certain benchmarks. With a\n15-minute timeout, the number of qubits that can be handled by WCFLOBDDs is\n1-64$\\times$ that of WBDDs (and 1-128$\\times$ that of CFLOBDDs, which are an\nunweighted version of WCFLOBDDs). These results support the conclusion that for\nthis application -- from the standpoint of problem size, measured as the number\nof qubits -- WCFLOBDDs provide the best of both worlds: performance roughly\nmatches whichever of WBDDs and CFLOBDDs is better. (From the standpoint of\nrunning time, the results are more nuanced.)\n",
        "pdf_link": "http://arxiv.org/pdf/2305.13610v2"
    },
    {
        "title": "A Term-based Approach for Generating Finite Automata from Interaction\n  Diagrams",
        "authors": [
            "Erwan Mahe",
            "Boutheina Bannour",
            "Christophe Gaston",
            "Arnault Lapitre",
            "Pascale Le Gall"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Non-deterministic Finite Automata (NFA) represent regular languages\nconcisely, increasing their appeal for applications such as word recognition.\nThis paper proposes a new approach to generate NFA from an interaction language\nsuch as UML Sequence Diagrams or Message Sequence Charts. Via an operational\nsemantics, we generate a NFA from a set of interactions reachable using the\nassociated execution relation. In addition, by applying simplifications on\nreachable interactions to merge them, it is possible to obtain reduced NFA\nwithout relying on costly NFA reduction techniques. Experimental results\nregarding NFA generation and their application in trace analysis are also\npresented.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.02983v2"
    },
    {
        "title": "Kunz languages for numerical semigroups are context sensitive",
        "authors": [
            "Manuel Delgado",
            "Jaume Usó i Cubertorer"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  There is a one-to-one and onto correspondence between the class of numerical\nsemigroups of depth $n$, where $n$ is an integer, and a certain language over\nthe alphabet $\\{1,\\ldots,n\\}$ which we call a Kunz language of depth $n$. The\nKunz language associated with the numerical semigroups of depth $2$ is the\nregular language $\\{1,2\\}^*2\\{1,2\\}^*$. We prove that Kunz languages associated\nwith numerical semigroups of larger depth are context-sensitive but not\nregular.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.03308v2"
    },
    {
        "title": "Convergence and Diversity in the Control Hierarchy",
        "authors": [
            "Alexandra Butoi",
            "Ryan Cotterell",
            "David Chiang"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Weir has defined a hierarchy of language classes whose second member\n($\\mathcal{L}_2$) is generated by tree-adjoining grammars (TAG), linear indexed\ngrammars (LIG), combinatory categorial grammars, and head grammars. The\nhierarchy is obtained using the mechanism of control, and $\\mathcal{L}_2$ is\nobtained using a context-free grammar (CFG) whose derivations are controlled by\nanother CFG. We adapt Weir's definition of a controllable CFG to give a\ndefinition of controllable pushdown automata (PDAs). This yields three new\ncharacterizations of $\\mathcal{L}_2$ as the class of languages generated by\nPDAs controlling PDAs, PDAs controlling CFGs, and CFGs controlling PDAs. We\nshow that these four formalisms are not only weakly equivalent but equivalent\nin a stricter sense that we call d-weak equivalence. Furthermore, using an even\nstricter notion of equivalence called d-strong equivalence, we make precise the\nintuition that a CFG controlling a CFG is a TAG, a PDA controlling a PDA is an\nembedded PDA, and a PDA controlling a CFG is a LIG. The fourth member of this\nfamily, a CFG controlling a PDA, does not correspond to any formalism we know\nof, so we invent one and call it a Pushdown Adjoining Automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.03628v1"
    },
    {
        "title": "Reachability in 3-VASS is in Tower",
        "authors": [
            "Qizhe Yang",
            "Yuxi Fu"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The reachability problem for vector addition systems with states (VASS) has\nbeen shown to be \\textsc{Ackermann}-complete. For every $k\\geq 3$, a\ncompleteness result for the $k$-dimensional VASS reachability problem is not\nyet available. It is shown in this paper that the $3$-dimensional VASS\nreachability problem is in \\textsc{Tower}, improving upon the current best\nupper bound $\\mathbf{F}_7$ established by Leroux and Schmidt in 2019.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.05710v2"
    },
    {
        "title": "Analyzing Robustness of Angluin's L$^*$ Algorithm in Presence of Noise",
        "authors": [
            "Lina Ye",
            "Igor Khmelnitsky",
            "Serge Haddad",
            "Benoît Barbot",
            "Benedikt Bollig",
            "Martin Leucker",
            "Daniel Neider",
            "Rajarshi Roy"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Angluin's L$^*$ algorithm learns the minimal deterministic finite automaton\n(DFA) of a regular language using membership and equivalence queries. Its\nprobabilistic approximatively correct (PAC) version substitutes an equivalence\nquery by numerous random membership queries to get a high level confidence to\nthe answer. Thus it can be applied to any kind of device and may be viewed as\nan algorithm for synthesizing an automaton abstracting the behavior of the\ndevice based on observations. Here we are interested on how Angluin's PAC\nlearning algorithm behaves for devices which are obtained from a DFA by\nintroducing some noise. More precisely we study whether Angluin's algorithm\nreduces the noise and produces a DFA closer to the original one than the noisy\ndevice. We propose several ways to introduce the noise: (1) the noisy device\ninverts the classification of words w.r.t. the DFA with a small probability,\n(2) the noisy device modifies with a small probability the letters of the word\nbefore asking its classification w.r.t. the DFA, (3) the noisy device combines\nthe classification of a word w.r.t. the DFA and its classification w.r.t. a\ncounter automaton, and (4) the noisy DFA is obtained by a random process from\ntwo DFA such that the language of the first one is included in the second one.\nThen when a word is accepted (resp. rejected) by the first (resp. second) one,\nit is also accepted (resp. rejected) and in the remaining cases, it is accepted\nwith probability 0.5. Our main experimental contributions consist in showing\nthat: (1) Angluin's algorithm behaves well whenever the noisy device is\nproduced by a random process, (2) but poorly with a structured noise, and, that\n(3) is able to eliminate pathological behaviours specified in a regular way.\nTheoretically, we show that randomness almost surely yields systems with\nnon-recursively enumerable languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.08266v5"
    },
    {
        "title": "String Diagrammatic Trace Theory",
        "authors": [
            "Matthew Earnshaw",
            "Paweł Sobociński"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We extend the theory of formal languages in monoidal categories to the\nmulti-sorted, symmetric case, and show how this theory permits a graphical\ntreatment of topics in concurrency. In particular, we show that Mazurkiewicz\ntrace languages are precisely symmetric monoidal languages over monoidal\ndistributed alphabets. We introduce symmetric monoidal automata, which define\nthe class of regular symmetric monoidal languages. Furthermore, we prove that\nZielonka's asynchronous automata coincide with symmetric monoidal automata over\nmonoidal distributed alphabets. Finally, we apply the string diagrams for\nsymmetric premonoidal categories to derive serializations of traces.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.16341v1"
    },
    {
        "title": "Towards a Self-Replicating Turing Machine",
        "authors": [
            "Ralph P. Lano"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We provide partial implementations of von Neumann's universal constructor and\nuniversal copier, starting out with three types of simple building blocks using\nminimal assumptions. Using the same principles, we also construct Turing\nmachines. Combining both, we arrive at a proposal for a self-replicating Turing\nmachine. Our construction allows for mutations if desired, and we give a simple\ndescription language.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.16872v1"
    },
    {
        "title": "A Local-Time Semantics for Negotiations",
        "authors": [
            "Madhavan Mukund",
            "Adwitee Roy",
            "B Srivathsan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Negotiations, introduced by Esparza et al., are a model for concurrent\nsystems where computations involving a set of agents are described in terms of\ntheir interactions. In many situations, it is natural to impose timing\nconstraints between interactions -- for instance, to limit the time available\nto enter the PIN after inserting a card into an ATM. To model this, we\nintroduce a real-time aspect to negotiations. In our model of local-timed\nnegotiations, agents have local reference times that evolve independently.\nInspired by the model of networks of timed automata, each agent is equipped\nwith a set of local clocks. Similar to timed automata, the outcomes of a\nnegotiation contain guards and resets over the local clocks.\n  As a new feature, we allow some interactions to force the reference clocks of\nthe participating agents to synchronize. This synchronization constraint allows\nus to model interesting scenarios. Surprisingly, it also gives unlimited\ncomputing power. We show that reachability is undecidable for local-timed\nnegotiations with a mixture of synchronized and unsynchronized interactions. We\nstudy restrictions on the use of synchronized interactions that make the\nproblem decidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.06691v1"
    },
    {
        "title": "Contextual Behavioural Metrics (Extended Version)",
        "authors": [
            "Ugo Dal Lago",
            "Maurizio Murgia"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce contextual behavioural metrics (CBMs) as a novel way of\nmeasuring the discrepancy in behaviour between processes, taking into account\nboth quantitative aspects and contextual information. This way, process\ndistances by construction take the environment into account: two\n(non-equivalent) processes may still exhibit very similar behaviour in some\ncontexts, e.g., when certain actions are never performed. We first show how\nCBMs capture many well-known notions of equivalence and metric, including\nLarsen's environmental parametrized bisimulation. We then study compositional\nproperties of CBMs with respect to some common process algebraic operators,\nnamely prefixing, restriction, non-deterministic sum, parallel composition and\nreplication.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.07400v2"
    },
    {
        "title": "A generic characterization of generalized unary temporal logic and\n  two-variable first-order logic",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We investigate an operator on classes of languages. For each class $C$, it\noutputs a new class $FO^2(I_C)$ associated with a variant of two-variable\nfirst-order logic equipped with a signature$I_C$ built from $C$. For $C =\n\\{\\emptyset, A^*\\}$, we get the variant $FO^2(<)$ equipped with the linear\norder. For $C = \\{\\emptyset, \\{\\varepsilon\\},A^+, A^*\\}$, we get the variant\n$FO^2(<,+1)$, which also includes the successor. If $C$ consists of all Boolean\ncombinations of languages $A^*aA^*$ where $a$ is a letter, we get the variant\n$FO^2(<,Bet)$, which also includes \"between relations\". We prove a generic\nalgebraic characterization of the classes $FO^2(I_C)$. It smoothly and\nelegantly generalizes the known ones for all aforementioned cases. Moreover, it\nimplies that if $C$ has decidable separation (plus mild properties), then\n$FO^2(I_C)$ has a decidable membership problem.\n  We actually work with an equivalent definition of \\fodc in terms of unary\ntemporal logic. For each class $C$, we consider a variant $TL(C)$ of unary\ntemporal logic whose future/past modalities depend on $C$ and such that $TL(C)\n= FO^2(I_C)$. Finally, we also characterize $FL(C)$ and $PL(C)$, the\npure-future and pure-past restrictions of $TL(C)$. These characterizations as\nwell imply that if \\Cs is a class with decidable separation, then $FL(C)$ and\n$PL(C)$ have decidable membership.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.09349v2"
    },
    {
        "title": "Closing star-free closure",
        "authors": [
            "Thomas Place",
            "Marc Zeitoun"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce an operator on classes of regular languages, the star-free\nclosure. Our motivation is to generalize standard results of automata theory\nwithin a unified framework. Given an arbitrary input class $C$, the star-free\nclosure operator outputs the least class closed under Boolean operations and\nlanguage concatenation, and containing all languages of $C$ as well as all\nfinite languages. We establish several equivalent characterizations of\nstar-free closure: in terms of regular expressions, first-order logic, pure\nfuture and future-past temporal logic, and recognition by finite monoids. A key\ningredient is that star-free closure coincides with another closure operator,\ndefined in terms of regular operations where Kleene stars are allowed in\nrestricted~contexts.\n  A consequence of this first result is that we can decide membership of a\nregular language in the star-free closure of a class whose separation problem\nis decidable. Moreover, we prove that separation itself is decidable for the\nstar-free closure of any finite class, and of any class of group languages\nhaving itself decidable separation (plus mild additional properties). We\nactually show decidability of a stronger property, called covering.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.09376v1"
    },
    {
        "title": "Synthesis of Procedural Models for Deterministic Transition Systems",
        "authors": [
            "Javier Segovia-Aguas",
            "Jonathan Ferrer-Mestres",
            "Sergio Jiménez"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This paper introduces a general approach for synthesizing procedural models\nof the state-transitions of a given discrete system. The approach is general in\nthat it accepts different target languages for modeling the state-transitions\nof a discrete system; different model acquisition tasks with different target\nlanguages, such as the synthesis of STRIPS action models, or the update rule of\na cellular automaton, fit as particular instances of our general approach. We\nfollow an inductive approach to synthesis meaning that a set of examples of\nstate-transitions, represented as (pre-state, action, post-state) tuples, are\ngiven as input. The goal is to synthesize a structured program that, when\nexecuted on a given pre-state, outputs its associated post-state. Our synthesis\nmethod implements a combinatorial search in the space of well-structured\nterminating programs that can be built using a Random-Access Machine (RAM),\nwith a minimalist instruction set, and a finite amount of memory. The\ncombinatorial search is guided with functions that asses the complexity of the\ncandidate programs, as well as their fitness to the given input set of\nexamples.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.14368v1"
    },
    {
        "title": "Automata in toposes, and general Myhill-Nerode theorems",
        "authors": [
            "Victor Iwaniack"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We extend the functorial approach to automata by Colcombet and Petri\\c{s}an\n[arXiv:1712.07121] from the category of sets to any elementary topos with a\nnatural number object and establish general Myhill-Nerode theorems in our\nsetting. As a special case we recover the result of Boja\\'nczyk, Klin and\nLasota [arXiv:1402.0897] for orbit-finite nominal automata by considering\nautomata in the Myhill-Schanuel topos of nominal sets.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.14855v1"
    },
    {
        "title": "Coordination Sequences of Periodic Structures are Rational via Automata\n  Theory",
        "authors": [
            "Eryk Kopczynski"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We prove the conjecture of Grosse-Kunstleve et al. that coordination\nsequences of periodic structures in n-dimensional Euclidean space are rational.\nThis has been recently proven by Nakamura et al.; however, our proof is a\nstraightforward application of classic techniques from automata theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.15803v1"
    },
    {
        "title": "On Some Closure Properties of nc-eNCE Graph Grammars",
        "authors": [
            "Jayakrishna Vijayakumar",
            "Lisa Mathew"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In the study of automata and grammars, closure properties of the associated\nlanguages have been studied extensively. In particular, closure properties of\nvarious types of graph grammars have been examined in (Rozenberg and Welzl,\nInf. and Control,1986) and (Rozenberg and Welzl, Acta Informatica,1986). In\nthis paper we examine some critical closure properties of the nc-eNCE graph\ngrammars discussed in (Jayakrishna and Mathew, Symmetry 2023) and (Jayakrishna\nand Mathew, ICMICDS 2022).\n",
        "pdf_link": "http://arxiv.org/pdf/2308.05943v2"
    },
    {
        "title": "An Analysis of On-the-fly Determinization of Finite-state Automata",
        "authors": [
            "Ivan Baburin",
            "Ryan Cotterell"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we establish an abstraction of on-the-fly determinization of\nfinite-state automata using transition monoids and demonstrate how it can be\napplied to bound the asymptotics. We present algebraic and combinatorial\nproperties that are sufficient for a polynomial state complexity of the\ndeterministic automaton constructed on-the-fly. A special case of our findings\nis that automata with many non-deterministic transitions almost always admit a\ndeterminization of polynomial complexity. Furthermore, we extend our ideas to\nweighted finite-state automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.14077v1"
    },
    {
        "title": "Conditional automatic complexity and its metrics",
        "authors": [
            "Bjørn Kjos-Hanssen"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Li, Chen, Li, Ma, and Vit\\'anyi (2004) introduced a similarity metric based\non Kolmogorov complexity. It followed work by Shannon in the 1950s on a metric\nbased on entropy. We define two computable similarity metrics, analogous to the\nJaccard distance and Normalized Information Distance, based on conditional\nautomatic complexity and show that they satisfy all axioms of metric spaces.\n",
        "pdf_link": "http://arxiv.org/pdf/2308.16292v1"
    },
    {
        "title": "Feasability of Learning Weighted Automata on a Semiring",
        "authors": [
            "Laure Daviaud",
            "Marianne Johnson"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Since the seminal work by Angluin, active learning of automata, by membership\nand equivalence queries, has been extensively studied and several\ngeneralisations have been developed to learn various extensions of automata.\nFor weighted automata, restricted cases have been tackled in the literature and\nin this paper we chart the boundaries of the Angluin approach (using a class of\nhypothesis automata constructed from membership and equivalence queries)\napplied to learning weighted automata over a general semiring. We show\nprecisely the theoretical limitations of this approach and classify functions\nwith respect to how guessable they are (corresponding to the existence and\nabundance of solutions of certain systems of equations). We provide a syntactic\ndescription of the boundary condition for a correct hypothesis of the\nprescribed form to exist. Of course, from an algorithmic standpoint, knowing\nthat (many) solutions exist need not translate into an effective algorithm to\nfind one; we conclude with a discussion of some known conditions (and variants\nthereof) that suffice to ensure this, illustrating the ideas over several\nfamiliar semirings (including the natural numbers) and pose some open questions\nfor future research.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.07806v3"
    },
    {
        "title": "Generating Semantic Graph Corpora with Graph Expansion Grammar",
        "authors": [
            "Eric Andersson",
            "Johanna Björklund",
            "Frank Drewes",
            "Anna Jonsson"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We introduce Lovelace, a tool for creating corpora of semantic graphs. The\nsystem uses graph expansion grammar as a representational language, thus\nallowing users to craft a grammar that describes a corpus with desired\nproperties. When given such grammar as input, the system generates a set of\noutput graphs that are well-formed according to the grammar, i.e., a graph\nbank. The generation process can be controlled via a number of configurable\nparameters that allow the user to, for example, specify a range of desired\noutput graph sizes. Central use cases are the creation of synthetic data to\naugment existing corpora, and as a pedagogical tool for teaching formal\nlanguage theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.08714v1"
    },
    {
        "title": "Derivative Based Extended Regular Expression Matching Supporting\n  Intersection, Complement and Lookarounds",
        "authors": [
            "Ian Erik Varatalu",
            "Margus Veanes",
            "Juhan-Peep Ernits"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Regular expressions are widely used in software. Various regular expression\nengines support different combinations of extensions to classical regular\nconstructs such as Kleene star, concatenation, nondeterministic choice (union\nin terms of match semantics). The extensions include e.g. anchors, lookarounds,\ncounters, backreferences. The properties of combinations of such extensions\nhave been subject of active recent research.\n  In the current paper we present a symbolic derivatives based approach to\nfinding matches to regular expressions that, in addition to the classical\nregular constructs, also support complement, intersection and lookarounds (both\nnegative and positive lookaheads and lookbacks). The theory of computing\nsymbolic derivatives and determining nullability given an input string is\npresented that shows that such a combination of extensions yields a match\nsemantics that corresponds to an effective Boolean algebra, which in turn opens\nup possibilities of applying various Boolean logic rewrite rules to optimize\nthe search for matches.\n  In addition to the theoretical framework we present an implementation of the\ncombination of extensions to demonstrate the efficacy of the approach\naccompanied with practical examples.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.14401v1"
    },
    {
        "title": "Conflict-Aware Active Automata Learning",
        "authors": [
            "Tiago Ferreira",
            "Léo Henry",
            "Raquel Fernandes da Silva",
            "Alexandra Silva"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Active automata learning algorithms cannot easily handle conflict in the\nobservation data (different outputs observed for the same inputs). This\ninherent inability to recover after a conflict impairs their effective\napplicability in scenarios where noise is present or the system under learning\nis mutating. We propose the Conflict-Aware Active Automata Learning (C3AL)\nframework to enable handling conflicting information during the learning\nprocess. The core idea is to consider the so-called observation tree as a\nfirst-class citizen in the learning process. Though this idea is explored in\nrecent work, we take it to its full effect by enabling its use with any\nexisting learner and minimizing the number of tests performed on the system\nunder learning, specially in the face of conflicts. We evaluate C3AL in a large\nset of benchmarks, covering over 30 different realistic targets, and over\n18,000 different scenarios. The results of the evaluation show that C3AL is a\nsuitable alternative framework for closed-box learning that can better handle\nnoise and mutations.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.01003v1"
    },
    {
        "title": "Acyclic Petri and Workflow Nets with Resets",
        "authors": [
            "Dmitry Chistikov",
            "Wojciech Czerwiński",
            "Piotr Hofman",
            "Filip Mazowiecki",
            "Henry Sinclair-Banks"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we propose two new subclasses of Petri nets with resets, for\nwhich the reachability and coverability problems become tractable. Namely, we\nadd an acyclicity condition that only applies to the consumptions and\nproductions, not the resets. The first class is acyclic Petri nets with resets,\nand we show that coverability is PSPACE-complete for them. This contrasts the\nknown Ackermann-hardness for coverability in (not necessarily acyclic) Petri\nnets with resets. We prove that the reachability problem remains undecidable\nfor acyclic Petri nets with resets. The second class concerns workflow nets, a\npractically motivated and natural subclass of Petri nets. Here, we show that\nboth coverability and reachability in acyclic workflow nets with resets are\nPSPACE-complete. Without the acyclicity condition, reachability and\ncoverability in workflow nets with resets are known to be equally hard as for\nPetri nets with resets, that being Ackermann-hard and undecidable,\nrespectively.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.01992v2"
    },
    {
        "title": "Determinisation and Unambiguisation of Polynomially-Ambiguous Rational\n  Weighted Automata",
        "authors": [
            "Ismaël Jecker",
            "Filip Mazowiecki",
            "David Purser"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the determinisation and unambiguisation problems of weighted\nautomata over the rational field: Given a weighted automaton, can we determine\nwhether there exists an equivalent deterministic, respectively unambiguous,\nweighted automaton? Recent results by Bell and Smertnig show that the problem\nis decidable, however they do not provide any complexity bounds. We show that\nboth problems are in PSPACE for polynomially-ambiguous weighted automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.02204v1"
    },
    {
        "title": "Logical Languages Accepted by Transformer Encoders with Hard Attention",
        "authors": [
            "Pablo Barcelo",
            "Alexander Kozachinskiy",
            "Anthony Widjaja Lin",
            "Vladimir Podolskii"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We contribute to the study of formal languages that can be recognized by\ntransformer encoders. We focus on two self-attention mechanisms: (1) UHAT\n(Unique Hard Attention Transformers) and (2) AHAT (Average Hard Attention\nTransformers). UHAT encoders are known to recognize only languages inside the\ncircuit complexity class ${\\sf AC}^0$, i.e., accepted by a family of poly-sized\nand depth-bounded boolean circuits with unbounded fan-ins. On the other hand,\nAHAT encoders can recognize languages outside ${\\sf AC}^0$), but their\nexpressive power still lies within the bigger circuit complexity class ${\\sf\nTC}^0$, i.e., ${\\sf AC}^0$-circuits extended by majority gates. We first show a\nnegative result that there is an ${\\sf AC}^0$-language that cannot be\nrecognized by an UHAT encoder. On the positive side, we show that UHAT encoders\ncan recognize a rich fragment of ${\\sf AC}^0$-languages, namely, all languages\ndefinable in first-order logic with arbitrary unary numerical predicates. This\nlogic, includes, for example, all regular languages from ${\\sf AC}^0$. We then\nshow that AHAT encoders can recognize all languages of our logic even when we\nenrich it with counting terms. We apply these results to derive new results on\nthe expressive power of UHAT and AHAT up to permutation of letters (a.k.a.\nParikh images).\n",
        "pdf_link": "http://arxiv.org/pdf/2310.03817v1"
    },
    {
        "title": "Characterizations of Monadic Second Order Definable Context-Free Sets of\n  Graphs",
        "authors": [
            "Radu Iosif",
            "Florian Zuleger"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We give a characterization of the sets of graphs that are both definable in\nCounting Monadic Second Order Logic (CMSO) and context-free, i.e., least\nsolutions of Hyperedge-Replacement (HR) grammars introduced by Courcelle and\nEngelfriet. We prove the equivalence of these sets with: (a) recognizable sets\n(in the algebra of graphs with HR-operations) of bounded tree-width; we refine\nthis condition further and show equivalence with recognizability in a finitely\ngenerated subalgebra of the HR-algebra of graphs; (b) parsable sets, for which\nthere is an MSO-definable transduction from graphs to a set of derivation trees\nlabelled by HR operations, such that the set of graphs is the image of the set\nof derivation trees under the canonical evaluation of the HR operations; (c)\nimages of recognizable unranked sets of trees under an MSO-definable\ntransduction, whose inverse is also MSO-definable. We rely on a novel\nconnection between two seminal results, a logical characterization of\ncontext-free graph languages in terms of tree to graph MSO-definable\ntransductions, by Courcelle and Engelfriet and a proof that an optimal-width\ntree decomposition of a graph can be built by an MSO-definable transduction, by\nBojanczyk and Pilipczuk.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.04764v4"
    },
    {
        "title": "Visualizing a Nondeterministic to Deterministic Finite-State Machine\n  Transformation",
        "authors": [
            "Tijana Minic",
            "Marco T. Morazán"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The transformation of a nondeterministic finite-state automaton into a\ndeterministic finite-state automaton is an integral part of any course on\nformal languages and automata theory. For some students, understanding this\ntransformation is challenging. Common problems encountered include not\ncomprehending how the states of the deterministic finite-state automaton are\ndetermined and not comprehending the role that all the edges of the\nnondeterministic finite-state automaton have in the deterministic finite-state\nautomaton's construction. To aid students in understanding, transformation\nvisualization tools have been developed. Although useful in helping students,\nthese tools do not properly illustrate the relationship between the states of\nthe deterministic finite-state automaton and the edges of the nondeterministic\nfinite-state automaton. This article presents a novel interactive visualization\ntool to illustrate the transformation that highlights this relationship and\nthat is integrated into the FSM programming language. In addition, the\nimplementation of the visualization is sketched.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.08248v1"
    },
    {
        "title": "New Lower Bounds for Reachability in Vector Addition Systems",
        "authors": [
            "Wojciech Czerwiński",
            "Ismaël Jecker",
            "Sławomir Lasota",
            "Jérôme Leroux",
            "Łukasz Orlikowski"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We investigate the dimension-parametric complexity of the reachability\nproblem in vector addition systems with states (VASS) and its extension with\npushdown stack (pushdown VASS). Up to now, the problem is known to be\n$\\mathcal{F}_k$-hard for VASS of dimension $3k+2$ (the complexity class\n$\\mathcal{F}_k$ corresponds to the $k$th level of the fast-growing hierarchy),\nand no essentially better bound is known for pushdown VASS. We provide a new\nconstruction that improves the lower bound for VASS: $\\mathcal{F}_k$-hardness\nin dimension $2k+3$. Furthermore, building on our new insights we show a new\nlower bound for pushdown VASS: $\\mathcal{F}_k$-hardness in dimension $\\frac k 2\n+ 4$. This dimension-parametric lower bound is strictly stronger than the upper\nbound for VASS, which suggests that the (still unknown) complexity of the\nreachability problem in pushdown VASS is higher than in plain VASS (where it is\nAckermann-complete).\n",
        "pdf_link": "http://arxiv.org/pdf/2310.09008v2"
    },
    {
        "title": "Contracting Tsetlin Machine with Absorbing Automata",
        "authors": [
            "Bimal Bhattarai",
            "Ole-Christoffer Granmo",
            "Lei Jiao",
            "Per-Arne Andersen",
            "Svein Anders Tunheim",
            "Rishad Shafik",
            "Alex Yakovlev"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we introduce a sparse Tsetlin Machine (TM) with absorbing\nTsetlin Automata (TA) states. In brief, the TA of each clause literal has both\nan absorbing Exclude- and an absorbing Include state, making the learning\nscheme absorbing instead of ergodic. When a TA reaches an absorbing state, it\nwill never leave that state again. If the absorbing state is an Exclude state,\nboth the automaton and the literal can be removed from further consideration.\nThe literal will as a result never participates in that clause. If the\nabsorbing state is an Include state, on the other hand, the literal is stored\nas a permanent part of the clause while the TA is discarded. A novel sparse\ndata structure supports these updates by means of three action lists: Absorbed\nInclude, Include, and Exclude. By updating these lists, the TM gets smaller and\nsmaller as the literals and their TA withdraw. In this manner, the computation\naccelerates during learning, leading to faster learning and less energy\nconsumption.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.11481v1"
    },
    {
        "title": "Reachability in Fixed VASS: Expressiveness and Lower Bounds",
        "authors": [
            "Andrei Draghici",
            "Christoph Haase",
            "Andrew Ryzhikov"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The recent years have seen remarkable progress in establishing the complexity\nof the reachability problem for vector addition systems with states (VASS),\nequivalently known as Petri nets. Existing work primarily considers the case in\nwhich both the VASS as well as the initial and target configurations are part\nof the input. In this paper, we investigate the reachability problem in the\nsetting where the VASS is fixed and only the initial configuration is variable.\nWe show that fixed VASS fully express arithmetic on initial segments of the\nnatural numbers. It follows that there is a very weak reduction from any fixed\nsuch number-theoretic predicate (e.g. primality or square-freeness) to\nreachability in fixed VASS where configurations are presented in unary. If\nconfigurations are given in binary, we show that there is a fixed VASS with\nfive counters whose reachability problem is PSPACE-hard.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.16740v1"
    },
    {
        "title": "Reachability in Continuous Pushdown VASS",
        "authors": [
            "A. R. Balasubramanian",
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Pushdown Vector Addition Systems with States (PVASS) consist of finitely many\ncontrol states, a pushdown stack, and a set of counters that can be incremented\nand decremented, but not tested for zero. Whether the reachability problem is\ndecidable for PVASS is a long-standing open problem.\n  We consider continuous PVASS, which are PVASS with a continuous semantics.\nThis means, the counter values are rational numbers and whenever a vector is\nadded to the current counter values, this vector is first scaled with an\narbitrarily chosen rational factor between zero and one. We show that\nreachability in continuous PVASS is NEXPTIME-complete. Our result is unusually\nrobust: Reachability can be decided in NEXPTIME even if all numbers are\nspecified in binary. On the other hand, NEXPTIME-hardness already holds for\ncoverability, in fixed dimension, for bounded stack, and even if all numbers\nare specified in unary.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.16798v2"
    },
    {
        "title": "Leveraging Large Language Models for Automated Proof Synthesis in Rust",
        "authors": [
            "Jianan Yao",
            "Ziqiao Zhou",
            "Weiteng Chen",
            "Weidong Cui"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Formal verification can provably guarantee the correctness of critical system\nsoftware, but the high proof burden has long hindered its wide adoption.\nRecently, Large Language Models (LLMs) have shown success in code analysis and\nsynthesis. In this paper, we present a combination of LLMs and static analysis\nto synthesize invariants, assertions, and other proof structures for a\nRust-based formal verification framework called Verus. In a few-shot setting,\nLLMs demonstrate impressive logical ability in generating postconditions and\nloop invariants, especially when analyzing short code snippets. However, LLMs\nlack the ability to retain and propagate context information, a strength of\ntraditional static analysis. Based on these observations, we developed a\nprototype based on OpenAI's GPT-4 model. Our prototype decomposes the\nverification task into multiple smaller ones, iteratively queries GPT-4, and\ncombines its output with lightweight static analysis. We evaluated the\nprototype with a developer in the automation loop on 20 vector-manipulating\nprograms. The results demonstrate that it significantly reduces human effort in\nwriting entry-level proof code.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.03739v2"
    },
    {
        "title": "Parikh's Theorem Made Symbolic",
        "authors": [
            "Matthew Hague",
            "Artur Jeż",
            "Anthony W. Lin"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Parikh's Theorem is a fundamental result in automata theory with numerous\napplications in computer science: software verification (e.g. infinite-state\nverification, string constraints, and theory of arrays), verification of\ncryptographic protocols (e.g. using Horn clauses modulo equational theories)\nand database querying (e.g. evaluating path-queries in graph databases).\nParikh's Theorem states that the letter-counting abstraction of a language\nrecognized by finite automata or context-free grammars is definable in\nPresburger Arithmetic. Unfortunately, real-world applications typically require\nlarge alphabets - which are well-known to be not amenable to explicit treatment\nof the alphabets.\n  Symbolic automata have proven in the last decade to be an effective\nalgorithmic framework for handling large finite or even infinite alphabets. A\nsymbolic automaton employs an effective boolean algebra, which offers a\nsymbolic representation of character sets and often lends itself to an\nexponentially more succinct representation of a language. Instead of\nletter-counting, Parikh's Theorem for symbolic automata amounts to counting the\nnumber of times different predicates are satisfied by an input sequence.\nUnfortunately, naively applying Parikh's Theorem from classical automata theory\nto symbolic automata yields existential Presburger formulas of exponential\nsize. We provide a new construction for Parikh's Theorem for symbolic automata\nand grammars, which avoids this exponential blowup: our algorithm computes an\nexistential formula in polynomial-time over (quantifier-free) Presburger and\nthe base theory. In fact, our algorithm extends to the model of parametric\nsymbolic grammars, which are one of the most expressive models of languages\nover infinite alphabets. We have implemented our algorithm and show it can be\nused to solve string constraints that are difficult to solve by existing\nsolvers.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.03901v2"
    },
    {
        "title": "The Complexity of Checking Non-Emptiness in Symbolic Tree Automata",
        "authors": [
            "Rodrigo Raya"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the satisfiability problem of symbolic tree automata and decompose\nit into the satisfiability problem of the existential first-order theory of the\ninput characters and the existential monadic second-order theory of the indices\nof the accepted words. We use our decomposition to obtain tight computational\ncomplexity bounds on the decision problem for this automata class and an\nextension that considers linear arithmetic constraints on the underlying\neffective Boolean algebra\n",
        "pdf_link": "http://arxiv.org/pdf/2311.05250v1"
    },
    {
        "title": "3vLTL: A Tool to Generate Automata for Three-valued LTL",
        "authors": [
            "Francesco Belardinelli",
            "Angelo Ferrando",
            "Vadim Malvone"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Multi-valued logics have a long tradition in the literature on system\nverification, including run-time verification. However, comparatively fewer\nmodel-checking tools have been developed for multi-valued specification\nlanguages. We present 3vLTL, a tool to generate Buchi automata from formulas in\nLinear-time Temporal Logic (LTL) interpreted on a three-valued semantics. Given\nan LTL formula, a set of atomic propositions as the alphabet for the automaton,\nand a truth value, our procedure generates a Buchi automaton that accepts all\nthe words that assign the chosen truth value to the LTL formula. Given the\nparticular type of the output of the tool, it can also be seamlessly processed\nby third-party libraries in a natural way. That is, the Buchi automaton can\nthen be used in the context of formal verification to check whether an LTL\nformula is true, false, or undefined on a given model.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.09787v1"
    },
    {
        "title": "Learning Deterministic Finite Automata from Confidence Oracles",
        "authors": [
            "Wilson Wu"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We discuss the problem of learning a deterministic finite automaton (DFA)\nfrom a confidence oracle. That is, we are given access to an oracle $Q$ with\nincomplete knowledge of some target language $L$ over an alphabet $\\Sigma$; the\noracle maps a string $x\\in\\Sigma^*$ to a score in the interval $[-1,1]$\nindicating its confidence that the string is in the language. The\ninterpretation is that the sign of the score signifies whether $x\\in L$, while\nthe magnitude $|Q(x)|$ represents the oracle's confidence. Our goal is to learn\na DFA representation of the oracle that preserves the information that it is\nconfident in. The learned DFA should closely match the oracle wherever it is\nhighly confident, but it need not do this when the oracle is less sure of\nitself.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.10963v1"
    },
    {
        "title": "Careful Synchronization of One-Cluster Automata",
        "authors": [
            "Jakub Ruszil"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper we investigate careful synchronization of one-cluster partial\nautomata. First we prove that in general case the shortest carefully\nsynchronizing word for such automata is of length $2^\\frac{n}{2} + 1$, where\n$n$ is the number of states of an automaton. Additionally we prove that\nchecking whether a given one-cluster partial automaton is carefully\nsynchronizing is NP-hard even in the case of binary alphabet.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.15020v1"
    },
    {
        "title": "Traversing automata with current state uncertainty under LTL$_f$\n  constraints",
        "authors": [
            "Andrew Ryzhikov",
            "Petra Wolf"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  In this paper, we consider a problem which we call LTL$_f$ model checking on\npaths: given a DFA $\\mathcal{A}$ and a formula $\\phi$ in LTL on finite traces,\ndoes there exist a word $w$ such that every path starting in a state of\n$\\mathcal{A}$ and labeled by $w$ satisfies $\\phi$? The original motivation for\nthis problem comes from the constrained parts orienting problem, introduced in\n[Petra Wolf, \"Synchronization Under Dynamic Constraints\", FSTTCS 2020], where\nthe input constraints restrict the order in which certain states are visited\nfor the first or the last time while reading a word $w$ which is also required\nto synchronize $\\mathcal{A}$. We identify very general conditions under which\nLTL$_f$ model checking on paths is solvable in polynomial space. For the\nparticular constraints in the parts orienting problem, we consider\nPSPACE-complete cases and one NP-complete case. The former provide very strong\nlower bound for LTL$_f$ model checking on paths. The latter is related to\n(classical) LTL$_f$ model checking for formulas with the until modality only\nand with no nesting of operators. We also consider LTL$_f$ model checking of\nthe power-set automaton of a given DFA, and get similar results for this\nsetting. For all our problems, we consider the case where the required word\nmust also be synchronizing, and prove that if the problem does not become\ntrivial, then this additional constraint does not change the complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.17849v1"
    },
    {
        "title": "Weighted Automata and Logics Meet Computational Complexity",
        "authors": [
            "Peter Kostolányi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Complexity classes such as $\\#\\mathbf{P}$, $\\oplus\\mathbf{P}$,\n$\\mathbf{GapP}$, $\\mathbf{OptP}$, $\\mathbf{NPMV}$, or the class of fuzzy\nlanguages realised by polynomial-time fuzzy nondeterministic Turing machines,\ncan all be described in terms of a class $\\mathbf{NP}[S]$ for a suitable\nsemiring $S$, defined via weighted Turing machines over $S$ similarly as\n$\\mathbf{NP}$ is defined via the classical nondeterministic Turing machines.\nOther complexity classes of decision problems can be lifted to the quantitative\nworld using the same recipe as well, and the resulting classes relate to the\noriginal ones in the same way as weighted automata or logics relate to their\nunweighted counterparts. The article surveys these too-little-known connexions\nbetween weighted automata theory and computational complexity theory implicit\nin the existing literature, suggests a systematic approach to the study of\nweighted complexity classes, and presents several new observations\nstrengthening the relation between both fields. In particular, it is proved\nthat a natural extension of the Boolean satisfiability problem to weighted\npropositional logic is complete for the class $\\mathbf{NP}[S]$ when $S$ is a\nfinitely generated semiring. Moreover, a class of semiring-valued functions\n$\\mathbf{FP}[S]$ is introduced for each semiring $S$ as a counterpart to the\nclass $\\mathbf{P}$, and the relations between $\\mathbf{FP}[S]$ and\n$\\mathbf{NP}[S]$ are considered.\n",
        "pdf_link": "http://arxiv.org/pdf/2312.10810v2"
    },
    {
        "title": "The Complexity of Simplifying $ω$-Automata through the Alternating\n  Cycle Decomposition",
        "authors": [
            "Antonio Casares",
            "Corto Mascle"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In 2021, Casares, Colcombet and Fijalkow introduced the Alternating Cycle\nDecomposition (ACD), a structure used to define optimal transformations of\nMuller into parity automata and to obtain theoretical results about the\npossibility of relabelling automata with different acceptance conditions. In\nthis work, we study the complexity of computing the ACD and its DAG-version,\nproving that this can be done in polynomial time for suitable representations\nof the acceptance condition of the Muller automaton. As corollaries, we obtain\nthat we can decide typeness of Muller automata in polynomial time, as well as\nthe parity index of the languages they recognise.\n  Furthermore, we show that we can minimise in polynomial time the number of\ncolours (resp. Rabin pairs) defining a Muller (resp. Rabin) acceptance\ncondition, but that these problems become NP-complete when taking into account\nthe structure of an automaton using such a condition.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.03811v3"
    },
    {
        "title": "Directed Regular and Context-Free Languages",
        "authors": [
            "Moses Ganardi",
            "Irmak Saglam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the problem of deciding whether a given language is directed. A\nlanguage $L$ is \\emph{directed} if every pair of words in $L$ have a common\n(scattered) superword in $L$. Deciding directedness is a fundamental problem in\nconnection with ideal decompositions of downward closed sets. Another\nmotivation is that deciding whether two \\emph{directed} context-free languages\nhave the same downward closures can be decided in polynomial time, whereas for\ngeneral context-free languages, this problem is known to be coNEXP-complete.\n  We show that the directedness problem for regular languages, given as NFAs,\nbelongs to $AC^1$, and thus polynomial time. Moreover, it is NL-complete for\nfixed alphabet sizes. Furthermore, we show that for context-free languages, the\ndirectedness problem is PSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.07106v2"
    },
    {
        "title": "Satisfiability of Context-free String Constraints with Subword-ordering\n  and Transducers",
        "authors": [
            "C Aiswarya",
            "Soumodev Mal",
            "Prakash Saivasan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the satisfiability of string constraints where context-free\nmembership constraints may be imposed on variables. Additionally a variable may\nbe constrained to be a subword of a word obtained by shuffling variables and\ntheir transductions. The satisfiability problem is known to be undecidable even\nwithout rational transductions. It is known to be NExptime-complete without\ntransductions, if the subword relations between variables do not have a cyclic\ndependency between them. We show that the satisfiability problem stays\ndecidable in this fragment even when rational transductions are added. It is\n2NExptime-complete with context-free membership, and NExptime-complete with\nonly regular membership. For the lower bound we prove a technical lemma that is\nof independent interest: The length of the shortest word in the intersection of\na pushdown automaton (of size $O(n)$) and $n$ finite-state automata (each of\nsize $O(n)$) can be double exponential in $n$.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.07996v1"
    },
    {
        "title": "Verification under TSO with an infinite Data Domain",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "Florian Furbach",
            "Shashwat Garg"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We examine verification of concurrent programs under the total store ordering\n(TSO) semantics used by the x86 architecture. In our model, threads manipulate\nvariables over infinite domains and they can check whether variables are\nrelated for a range of relations. We show that, in general, the control state\nreachability problem is undecidable. This result is derived through a reduction\nfrom the state reachability problem of lossy channel systems with data (which\nis known to be undecidable). In the light of this undecidability, we turn our\nattention to a more tractable variant of the reachability problem.\nSpecifically, we study context bounded runs, which provide an\nunder-approximation of the program behavior by limiting the possible\ninteractions between processes. A run consists of a number of contexts, with\neach context representing a sequence of steps where a only single designated\nthread is active. We prove that the control state reachability problem under\nbounded context switching is PSPACE complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.10423v1"
    },
    {
        "title": "Languages of Higher-Dimensional Timed Automata",
        "authors": [
            "Amazigh Amrane",
            "Hugo Bazille",
            "Emily Clement",
            "Uli Fahrenberg"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a new language semantics for real-time concurrency. Its\noperational models are higher-dimensional timed automata (HDTAs), a\ngeneralization of both higher-dimensional automata and timed automata. We\ndefine languages of HDTAs as sets of interval-timed pomsets with interfaces. As\nan application, we show that language inclusion of HDTAs is undecidable. On the\nother hand, using a region construction we can show that untimings of HDTA\nlanguages have enough regularity so that untimed language inclusion is\ndecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.17444v2"
    },
    {
        "title": "Axiomatizing NFAs Generated by Regular Grammars",
        "authors": [
            "Roberto Gorrieri"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A subclass of nondeterministic Finite Automata generated by means of regular\nGrammars (GFAs, for short) is introduced. A process algebra is proposed, whose\nsemantics maps a term to a GFA. We prove a representability theorem: for each\nGFA $N$, there exists a process algebraic term $p$ such that its semantics is a\nGFA isomorphic to $N$. Moreover, we provide a concise axiomatization of\nlanguage equivalence: two GFAs $N_1$ and $N_2$ recognize the same regular\nlanguage if and only if the associated terms $p_1$ and $p_2$, respectively, can\nbe equated by means of a set of axioms, comprising 7 axioms plus 2 conditional\naxioms, only.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.00502v2"
    },
    {
        "title": "The Freeness Problem for Automaton Semigroups",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We show that the freeness problems for automaton semigroups and for automaton\nmonoids are undecidable by giving a reduction from Post's Correspondence\nProblem. This construction seems to be quite versatile and we also immediately\nobtain that the problems of testing whether a given automaton semigroup\n(monoid) is (left) cancellative or whether it is equidivisible are undecidable.\nWe also obtain that it is undecidable whether a given map extends into a\nhomomorphism of automaton semigroups. Finally, we adapt our construction to\nshow that it is undecidable whether a given automaton generates a free monoid\nwhose basis is given by the states (but where we allow one state to act as the\nidentity). In the semigroup case, we show a weaker version of this statement.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.01372v1"
    },
    {
        "title": "Distributed Fair Assignment and Rebalancing for Mobility-on-Demand\n  Systems via an Auction-based Method",
        "authors": [
            "Kaier Liang",
            "Cristian-Ioan Vasile"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper, we consider fair assignment of complex requests for\nMobility-On-Demand systems. We model the transportation requests as temporal\nlogic formulas that must be satisfied by a fleet of vehicles. We require that\nthe assignment of requests to vehicles is performed in a distributed manner\nbased only on communication between vehicles while ensuring fair allocation.\nOur approach to the vehicle-request assignment problem is based on a\ndistributed auction scheme with no centralized bidding that leverages utility\nhistory correction of bids to improve fairness. Complementarily, we propose a\nrebalancing scheme that employs rerouting vehicles to more rewarding areas to\nincrease the potential future utility and ensure a fairer utility distribution.\nWe adopt the max-min and deviation of utility as the two criteria for fairness.\nWe demonstrate the methods in the mid-Manhattan map with a large number of\nrequests generated in different probability settings. We show that we increase\nthe fairness between vehicles based on the fairness criteria without\ndegenerating the servicing quality.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.04972v1"
    },
    {
        "title": "(Almost) Affine Higher-Order Tree Transducers",
        "authors": [
            "Lê Thành Dũng Tito Nguyên",
            "Gabriele Vanoni"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We investigate the tree-to-tree functions computed by\n\\enquote{affine$\\lambda$-transducers}: tree automata whose memory consists of\nan affine $\\lambda$-term instead of a finite state. They can be seen as\nvariations on Gallot, Lemay and Salvati's Linear High-Order Deterministic Tree\nTransducers. When the memory is almost purely affine (\\textit{\\`a la}\nKanazawa), we show that these machines can be translated to tree-walking\ntransducers (and with a purely affine memory, we get a reversible tree-walking\ntransducer). This leads to a proof of an inexpressivity conjecture of\n\\titocecilia on \\enquote{implicit automata} in an affine $\\lambda$-calculus.\nThe key technical tool in our proofs is the Interaction Abstract Machine (IAM),\nan operational avatar of the \\enquote{geometry of interaction} semantics of\nlinear logic. We work with ad-hoc specializations to (almost) affine\n$\\lambda$-terms of a tree-generating version of the IAM.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.05854v1"
    },
    {
        "title": "Random Deterministic Automata With One Added Transition",
        "authors": [
            "Arnaud Carayol",
            "Philippe Duchon",
            "Florent Koechlin",
            "Cyril Nicaud"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Every language recognized by a non-deterministic finite automaton can be\nrecognized by a deterministic automaton, at the cost of a potential increase of\nthe number of states, which in the worst case can go from $n$ states to $2^n$\nstates. In this article, we investigate this classical result in a\nprobabilistic setting where we take a deterministic automaton with $n$ states\nuniformly at random and add just one random transition. These automata are\nalmost deterministic in the sense that only one state has a non-deterministic\nchoice when reading an input letter. In our model, each state has a fixed\nprobability to be final. We prove that for any $d\\geq 1$, with non-negligible\nprobability the minimal (deterministic) automaton of the language recognized by\nsuch an automaton has more than $n^d$ states; as a byproduct, the expected size\nof its minimal automaton grows faster than any polynomial. Our result also\nholds when each state is final with some probability that depends on $n$, as\nlong as it is not too close to $0$ and $1$, at distance at least\n$\\Omega(\\frac1{\\sqrt{n}})$ to be precise, therefore allowing models with a\nsublinear number of final states in expectation.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.06591v3"
    },
    {
        "title": "Probabilistic automatic complexity of finite strings",
        "authors": [
            "Kenneth Gill"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce a new complexity measure for finite strings using probabilistic\nfinite-state automata (PFAs), in the same spirit as existing notions employing\nDFAs and NFAs, and explore its properties. The PFA complexity $A_P(x)$ is the\nleast number of states of a PFA for which $x$ is the most likely string of its\nlength to be accepted. The variant $A_{P,\\delta}(x)$ adds a real-valued\nparameter $\\delta$ specifying a required lower bound on the gap in acceptance\nprobabilities between $x$ and other strings. We prove $A_{P,\\delta}$ is\n$\\delta$-computable for all $\\delta$, relate $A_P$ to the DFA and NFA\ncomplexities, and obtain a complete classification of binary strings with\n$A_P=2$. Finally, we discuss several other variations on $A_P$ with a view to\nobtaining additional desirable properties.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.13376v4"
    },
    {
        "title": "Tree-Verifiable Graph Grammars",
        "authors": [
            "Mark Chimes",
            "Radu Iosif",
            "Florian Zuleger"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Hyperedge-Replacement grammars (HR) have been introduced by Courcelle in\norder to extend the notion of context-free sets from words and trees to graphs\nof bounded tree-width. While for words and trees the syntactic restrictions\nthat guarantee that the associated languages of words resp. trees are regular -\nand hence, MSO-definable - are known, the situation is far more complicated for\ngraphs. Here, Courcelle proposed the notion of regular graph grammars, a\nsyntactic restriction of HR grammars that guarantees the definability of the\nassociated languages of graphs in Counting Monadic Second Order Logic (CMSO).\nHowever, these grammars are not complete in the sense that not every\nCMSO-definable set of graphs of bounded tree-width can be generated by a\nregular graph grammar. In this paper, we introduce a new syntactic restriction\nof HR grammars, called tree-verifiable graph grammars, and a new notion of\nbounded tree-width, called embeddable bounded tree-width, where the later\nrestricts the trees of a tree-decomposition to be a subgraph of the analyzed\ngraph. The main property of tree-verifiable graph grammars is that their\nassociated languages are CMSO-definable and that the have bounded embeddable\ntree-width. We show further that they strictly generalize the regular graph\ngrammars of Courcelle. Finally, we establish a completeness result, showing\nthat every language of graphs that is CMSO-definable and of bounded embeddable\ntree-width can be generated by a tree-verifiable graph grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.17015v2"
    },
    {
        "title": "Active Learning of Mealy Machines with Timers",
        "authors": [
            "Véronique Bruyère",
            "Bharat Garhewal",
            "Guillermo A. Pérez",
            "Gaëtan Staquet",
            "Frits W. Vaandrager"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present the first algorithm for query learning of a class of Mealy\nmachines with timers in a black-box context. Our algorithm is an extension of\nthe L# algorithm of Vaandrager et al. to a timed setting. We rely on symbolic\nqueries which empower us to reason on untimed executions while learning.\nSimilarly to the algorithm for learning timed automata of Waga, these symbolic\nqueries can be implemented using finitely many concrete queries. Experiments\nwith a prototype implementation, written in Rust, show that our algorithm is\nable to efficiently learn realistic benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.02019v2"
    },
    {
        "title": "Enumeration for MSO-Queries on Compressed Trees",
        "authors": [
            "Markus Lohrey",
            "Markus L. Schmid"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a linear preprocessing and output-linear delay enumeration\nalgorithm for MSO-queries over trees that are compressed in the\nwell-established grammar-based framework. Time bounds are measured with respect\nto the size of the compressed representation of the tree. Our result extends\nprevious work on the enumeration of MSO-queries over uncompressed trees and on\nthe enumeration of document spanners over compressed text documents.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.03067v1"
    },
    {
        "title": "Logic and Languages of Higher-Dimensional Automata",
        "authors": [
            "Amazigh Amrane",
            "Hugo Bazille",
            "Uli Fahrenberg",
            "Marie Fortin"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this paper we study finite higher-dimensional automata (HDAs) from the\nlogical point of view. Languages of HDAs are sets of finite bounded-width\ninterval pomsets with interfaces (iiPoms<=k) closed under order extension. We\nprove that languages of HDAs are MSO-definable. For the converse, we show that\nthe order extensions of MSO-definable sets of iiPoms<=k are languages of HDAs.\nAs a consequence, unlike the case of all pomsets, order extension of\nMSO-definable sets of iiPoms<=k is also MSO-definable.\n",
        "pdf_link": "http://arxiv.org/pdf/2403.19526v1"
    },
    {
        "title": "Transformers as Transducers",
        "authors": [
            "Lena Strobl",
            "Dana Angluin",
            "David Chiang",
            "Jonathan Rawski",
            "Ashish Sabharwal"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the sequence-to-sequence mapping capacity of transformers by\nrelating them to finite transducers, and find that they can express\nsurprisingly large classes of transductions. We do so using variants of RASP, a\nprogramming language designed to help people \"think like transformers,\" as an\nintermediate representation. We extend the existing Boolean variant B-RASP to\nsequence-to-sequence functions and show that it computes exactly the\nfirst-order rational functions (such as string rotation). Then, we introduce\ntwo new extensions. B-RASP[pos] enables calculations on positions (such as\ncopying the first half of a string) and contains all first-order regular\nfunctions. S-RASP adds prefix sum, which enables additional arithmetic\noperations (such as squaring a string) and contains all first-order polyregular\nfunctions. Finally, we show that masked average-hard attention transformers can\nsimulate S-RASP.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.02040v3"
    },
    {
        "title": "A Uniform Framework for Language Inclusion Problems",
        "authors": [
            "Kyveli Doveri",
            "Pierre Ganty",
            "Chana Weil-Kennedy"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a uniform approach for solving language inclusion problems. Our\napproach relies on a least fixpoint characterization and a quasiorder to\ncompare words of the \"smaller\" language, reducing the inclusion check to a\nfinite number of membership queries in the \"larger\" language. We present our\napproach in detail on the case of inclusion of a context-free language given by\na grammar into a regular language. We then explore other inclusion problems and\ndiscuss how to apply our approach.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.09862v1"
    },
    {
        "title": "Context-Free Languages of String Diagrams",
        "authors": [
            "Matt Earnshaw",
            "Mario Román"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce context-free languages of morphisms in monoidal categories,\nextending recent work on the categorification of context-free languages, and\nregular languages of string diagrams. Context-free languages of string diagrams\ninclude classical context-free languages of words, trees, and hypergraphs, when\ninstantiated over appropriate monoidal categories. Using a contour-splicing\nadjunction, we prove a representation theorem for context-free languages of\nstring diagrams: every such language arises as the image under a monoidal\nfunctor of a regular language of string diagrams.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.10653v1"
    },
    {
        "title": "Computing Inductive Invariants of Regular Abstraction Frameworks",
        "authors": [
            "Philipp Czerner",
            "Javier Esparza",
            "Valentin Krasotin",
            "Christoph Welzel-Mohr"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Regular transition systems (RTS) are a popular formalism for modeling\ninfinite-state systems in general, and parameterised systems in particular. In\na CONCUR 22 paper, Esparza et al. introduce a novel approach to the\nverification of RTS, based on inductive invariants. The approach computes the\nintersection of all inductive invariants of a given RTS that can be expressed\nas CNF formulas with a bounded number of clauses, and uses it to construct an\nautomaton recognising an overapproximation of the reachable configurations. The\npaper shows that the problem of deciding if the language of this automaton\nintersects a given regular set of unsafe configurations is in\n$\\textsf{EXPSPACE}$ and $\\textsf{PSPACE}$-hard.\n  We introduce $\\textit{regular abstraction frameworks}$, a generalisation of\nthe approach of Esparza et al., very similar to the regular abstractions of\nHong and Lin. A framework consists of a regular language of\n$\\textit{constraints}$, and a transducer, called the $\\textit{interpretation}$,\nthat assigns to each constraint the set of configurations of the RTS satisfying\nit. Examples of regular abstraction frameworks include the formulas of Esparza\net al., octagons, bounded difference matrices, and views. We show that the\ngeneralisation of the decision problem above to regular abstraction frameworks\nremains in $\\textsf{EXPSPACE}$, and prove a matching (non-trivial)\n$\\textsf{EXPSPACE}$-hardness bound.\n  $\\textsf{EXPSPACE}$-hardness implies that, in the worst case, the automaton\nrecognising the overapproximation of the reachable configurations has a\ndouble-exponential number of states. We introduce a learning algorithm that\ncomputes this automaton in a lazy manner, stopping whenever the current\nhypothesis is already strong enough to prove safety. We report on an\nimplementation and show that our experimental results improve on those of\nEsparza et al.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.10752v2"
    },
    {
        "title": "Review of Automaton Learning Algorithms with Polynomial Complexity --\n  Completely Solved Examples",
        "authors": [
            "Farah Haneef"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Automaton learning is a domain in which the target system is inferred by the\nautomaton learning algorithm in the form of an automaton, by synthesizing a\nfinite number of inputs and their corresponding outputs. Automaton learning\nmakes use of a Minimally Adequate Teacher (MAT). The learner learns the target\nsystem by posing membership queries to the MAT. In this chapter, I have\nprovided completely solved examples of automaton learning algorithms. According\nto the best of my knowledge these are not available in any other source.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.11096v1"
    },
    {
        "title": "The Algebras for Automatic Relations",
        "authors": [
            "Rémi Morvan"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce \"synchronous algebras\", an algebraic structure tailored to\nrecognize automatic relations (aka. synchronous relations, or regular\nrelations). They are the equivalent of monoids for regular languages, however\nthey conceptually differ in two points: first, they are typed and second, they\nare equipped with a dependency relation expressing constraints between elements\nof different types.\n  The interest of the proposed definition is that it allows to lift, in an\neffective way, pseudovarieties of regular languages to that of synchronous\nrelations, and we show how algebraic characterizations of pseudovarieties of\nregular languages can be lifted to the pseudovarieties of synchronous relations\nthat they induce. A typical example of such a pseudovariety is the class of\n\"group relations\", defined as the relations recognized by finite-state\nsynchronous permutation automata.\n  In order to prove this result, we adapt two pillars of algebraic language to\nsynchronous algebras: (a) any relation admits a syntactic synchronous algebra\nrecognizing it, and moreover, the relation is synchronous if, and only if, its\nsyntactic algebra is finite and (b) classes of synchronous relations with\ndesirable closure properties (i.e. pseudovarieties) correspond to\npseudovarieties of synchronous algebras.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.15496v3"
    },
    {
        "title": "Edit Distance of Finite State Transducers",
        "authors": [
            "C. Aiswarya",
            "Amaldev Manuel",
            "Saina Sunny"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We lift metrics over words to metrics over word-to-word transductions, by\ndefining the distance between two transductions as the supremum of the\ndistances of their respective outputs over all inputs. This allows to compare\ntransducers beyond equivalence.\n  Two transducers are close (resp. $k$-close) with respect to a metric if their\ndistance is finite (resp. at most $k$). Over integer-valued metrics computing\nthe distance between transducers is equivalent to deciding the closeness and\n$k$-closeness problems. For common integer-valued edit distances such as,\nHamming, transposition, conjugacy and Levenshtein family of distances, we show\nthat the closeness and the $k$-closeness problems are decidable for functional\ntransducers. Hence, the distance with respect to these metrics is also\ncomputable.\n  Finally, we relate the notion of distance between functions to the notions of\ndiameter of a relation and index of a relation in another. We show that\ncomputing edit distance between functional transducers is equivalent to\ncomputing diameter of a rational relation and both are a specific instance of\nthe index problem of rational relations.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.16518v1"
    },
    {
        "title": "Regular Expressions with Backreferences and Lookaheads Capture NLOG",
        "authors": [
            "Yuya Uezato"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Backreferences and lookaheads are vital features to make classical regular\nexpressions (REGEX) practical. Although these features have been widely used,\nunderstanding of the unrestricted combination of them has been limited.\nPractically, most likely no implementation fully supports them. Theoretically,\nwhile some studies have addressed these features separately, few have dared to\ncombine them. In those few studies, it has been made clear that the\namalgamation of these features renders REGEX significantly expressive. However,\nno acceptable expressivity bound for REWBLk$\\unicode{x2014}$REGEX with\nbackreferences and lookaheads$\\unicode{x2014}$has been established.\n  We elucidate this by establishing that REWBLk coincides with NLOG, the class\nof languages accepted by log-space nondeterministic Turing machines (NTMs). In\ntranslating REWBLk to log-space NTMs, negative lookaheads are the most\nchallenging part since it essentially requires complementing log-space NTMs in\nnondeterministic log-space. To address this problem, we revisit\nImmerman$\\unicode{x2013}$Szelepcs\\'enyi theorem. In addition, we employ\nlog-space nested-oracles NTMs to naturally handle nested lookaheads of REWBLk.\nUtilizing such oracle machines, we also present the new result that the\nmembership problem of REWBLk is PSPACE-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.17492v1"
    },
    {
        "title": "Cornering Robots to Synchronize a DFA",
        "authors": [
            "Peter Bradshaw",
            "Alexander Clow",
            "Ladislav Stacho"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper considers the existence of short synchronizing words in\ndeterministic finite automata (DFAs). In particular, we define a general\nstrategy, which we call the \\emph{cornering strategy}, for generating short\nsynchronizing words in well-structured DFAs. We show that a DFA is\nsynchronizable if and only if this strategy can be applied.\n  Using the cornering strategy, we prove that all DFAs consisting of $n$ points\nin $\\mathbb{R}^d$ with bidirectional connected edge sets in which each edge\n$(\\mb x, \\mb y)$ is labeled $\\mb y - \\mb x$ are synchronizable. We also give\nsufficient conditions for such DFAs to have synchronizing words of length at\nmost $(n-1)^2$ and thereby satisfy \\v{C}ern\\'y's conjecture. Using similar\nideas, we generalise a result of Ananichev and Volkov\n\\cite{ananichev2004synchronizing} from monotonic automata to a wider class of\nDFAs admitting well-behaved partial orders. Finally, we consider how the\ncornering strategy can be applied to the problem of simultaneously\nsynchronizing a DFA $G$ to an initial state $u$ and a DFA $H$ to an initial\nstate $v$. We do not assume that DFAs $G$ and $H$ or states $u$ and $v$ are\nrelated beyond sharing the same edge labels.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.00826v1"
    },
    {
        "title": "A Direct Translation from LTL with Past to Deterministic Rabin Automata",
        "authors": [
            "Shaun Azzopardi",
            "David Lidell",
            "Nir Piterman"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a translation from linear temporal logic with past to\ndeterministic Rabin automata. The translation is direct in the sense that it\ndoes not rely on intermediate non-deterministic automata, and asymptotically\noptimal, resulting in Rabin automata of doubly exponential size. It is based on\ntwo main notions. One is that it is possible to encode the history contained in\nthe prefix of a word, as relevant for the formula under consideration, by\nperforming simple rewrites of the formula itself. As a consequence, a formula\ninvolving past operators can (through such rewrites, which involve alternating\nbetween weak and strong versions of past operators in the formula's syntax\ntree) be correctly evaluated at an arbitrary point in the future without\nrequiring backtracking through the word. The other is that this allows us to\ngeneralize to linear temporal logic with past the result that the language of a\npure-future formula can be decomposed into a Boolean combination of simpler\nlanguages, for which deterministic automata with simple acceptance conditions\nare easily constructed.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.01178v3"
    },
    {
        "title": "Scalable Computation of Inter-Core Bounds Through Exact Abstractions",
        "authors": [
            "Mohammed Aristide Foughali",
            "Marius Mikučionis",
            "Maryline Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Real-time systems (RTSs) are at the heart of numerous safety-critical\napplications. An RTS typically consists of a set of real-time tasks (the\nsoftware) that execute on a multicore shared-memory platform (the hardware)\nfollowing a scheduling policy. In an RTS, computing inter-core bounds, i.e.,\nbounds separating events produced by tasks on different cores, is crucial.\nWhile efficient techniques to over-approximate such bounds exist, little has\nbeen proposed to compute their exact values. Given an RTS with a set of cores C\nand a set of tasks T , under partitioned fixed-priority scheduling with limited\npreemption, a recent work by Foughali, Hladik and Zuepke (FHZ) models tasks\nwith affinity c (i.e., allocated to core c in C) as a Uppaal timed automata\n(TA) network Nc. For each core c in C, Nc integrates blocking (due to data\nsharing) using tight analytical formulae. Through compositional model checking,\nFHZ achieved a substantial gain in scalability for bounds local to a core.\nHowever, computing inter-core bounds for some events of interest E, produced by\na subset of tasks TE with different affinities CE, requires model checking the\nparallel composition of all TA networks Nc for each c in CE, which produces a\nlarge, often intractable, state space. In this paper, we present a new scalable\napproach based on exact abstractions to compute exact inter-core bounds in a\nschedulable RTS, under the assumption that tasks in TE have distinct\naffinities. We develop a novel algorithm, leveraging a new query that we\nimplement in Uppaal, that computes for each TA network Nc in NE an abstraction\nA(Nc) preserving the exact intervals within which events occur on c, therefore\ndrastically reducing the state space. The scalability of our approach is\ndemonstrated on the WATERS 2017 industrial challenge, for which we efficiently\ncompute various types of inter-core bounds where FHZ fails to scale.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.06387v2"
    },
    {
        "title": "Dynamic Programming for Symbolic Boolean Realizability and Synthesis",
        "authors": [
            "Yi Lin",
            "Lucas M. Tabajara",
            "Moshe Y. Vardi"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Inspired by recent progress in dynamic programming approaches for weighted\nmodel counting, we investigate a dynamic-programming approach in the context of\nboolean realizability and synthesis, which takes a conjunctive-normal-form\nboolean formula over input and output variables, and aims at synthesizing\nwitness functions for the output variables in terms of the inputs. We show how\ngraded project-join trees, obtained via tree decomposition, can be used to\ncompute a BDD representing the realizability set for the input formulas in a\nbottom-up order. We then show how the intermediate BDDs generated during\nrealizability checking phase can be applied to synthesizing the witness\nfunctions in a top-down manner. An experimental evaluation of a solver --\nDPSynth -- based on these ideas demonstrates that our approach for Boolean\nrealizabilty and synthesis has superior time and space performance over a\nheuristics-based approach using same symbolic representations. We discuss the\nadvantage on scalability of the new approach, and also investigate our findings\non the performance of the DP framework.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.07975v4"
    },
    {
        "title": "Propositional dynamic logic and asynchronous cascade decompositions for\n  regular trace languages",
        "authors": [
            "Bharat Adsul",
            "Paul Gastin",
            "Shantanu Kulkarni",
            "Pascal Weil"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We propose a local, past-oriented fragment of propositional dynamic logic to\nreason about concurrent scenarios modelled as Mazurkiewicz traces, and prove it\nto be expressively complete with respect to regular trace languages. Because of\nlocality, specifications in this logic are efficiently translated into\nasynchronous automata, in a way that reflects the structure of formulas. In\nparticular, we obtain a new proof of Zielonka's fundamental theorem and we\nprove that any regular trace language can be implemented by a cascade product\nof localized asynchronous automata, which essentially operate on a single\nprocess.\n  These results refine earlier results by Adsul et al. which involved a larger\nfragment of past propositional dynamic logic and used Mukund and Sohoni's\ngossip automaton. Our new results avoid using this automaton, or Zielonka's\ntimestamping mechanism and, in particular, they show how to implement a gossip\nautomaton as a cascade product.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.11308v1"
    },
    {
        "title": "Lindenmayer graph languages, first-order theories and expanders",
        "authors": [
            "Teodor Knapik"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Combinatorial generation of expander families and Lindenmayer-style\ndevelopment models are both parallel in nature. Both can be handled within\nproposed parallel graph grammar formalism. Their first-order properties can\nthen be checked by encompassing the generated graph language into an\nappropriate automatic structure.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.17629v1"
    },
    {
        "title": "DFAMiner: Mining minimal separating DFAs from labelled samples",
        "authors": [
            "Daniele Dell'Erba",
            "Yong Li",
            "Sven Schewe"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We propose DFAMiner, a passive learning tool for learning minimal separating\ndeterministic finite automata (DFA) from a set of labelled samples. Separating\nautomata are an interesting class of automata that occurs generally in regular\nmodel checking and has raised interest in foundational questions of parity game\nsolving. We first propose a simple and linear-time algorithm that incrementally\nconstructs a three-valued DFA (3DFA) from a set of labelled samples given in\nthe usual lexicographical order. This 3DFA has accepting and rejecting states\nas well as don't-care states, so that it can exactly recognise the labelled\nexamples. We then apply our tool to mining a minimal separating DFA for the\nlabelled samples by minimising the constructed automata via a reduction to\nsolving SAT problems. Empirical evaluation shows that our tool outperforms\ncurrent state-of-the-art tools significantly on standard benchmarks for\nlearning minimal separating DFAs from samples. Progress in the efficient\nconstruction of separating DFAs can also lead to finding the lower bound of\nparity game solving, where we show that DFAMiner can create optimal separating\nautomata for simple languages with up to 7 colours. Future improvements might\noffer inroads to better data structures.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.18871v1"
    },
    {
        "title": "A Subclass of Mu-Calculus with the Freeze Quantifier Equivalent to Buchi\n  Register Automata",
        "authors": [
            "Yoshiaki Takata",
            "Akira Onishi",
            "Ryoma Senda",
            "Hiroyuki Seki"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Register automaton (RA) is an extension of finite automaton for dealing with\ndata values in an infinite domain. In the previous work, we proposed\ndisjunctive mu$^\\downarrow$-calculus, which is a subclass of modal mu-calculus\nwith the freeze quantifier, and showed that it has the same expressive power as\nRA. However, disjunctive mu$^\\downarrow$-calculus is defined as a logic on\nfinite words, whereas temporal specifications in model checking are usually\ngiven in terms of infinite words. In this paper, we re-define the syntax and\nsemantics of disjunctive mu$^\\downarrow$-calculus to be suitable for infinite\nwords and prove that the obtained temporal logic has the same expressive power\nas Buchi RA.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.11351v1"
    },
    {
        "title": "PDFA Distillation via String Probability Queries",
        "authors": [
            "Robert Baumgartner",
            "Sicco Verwer"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Probabilistic deterministic finite automata (PDFA) are discrete event systems\nmodeling conditional probabilities over languages: Given an already seen\nsequence of tokens they return the probability of tokens of interest to appear\nnext. These types of models have gained interest in the domain of explainable\nmachine learning, where they are used as surrogate models for neural networks\ntrained as language models. In this work we present an algorithm to distill\nPDFA from neural networks. Our algorithm is a derivative of the L# algorithm\nand capable of learning PDFA from a new type of query, in which the algorithm\ninfers conditional probabilities from the probability of the queried string to\noccur. We show its effectiveness on a recent public dataset by distilling PDFA\nfrom a set of trained neural networks.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.18328v2"
    },
    {
        "title": "The single-use restriction for register automata and transducers over\n  infinite alphabets",
        "authors": [
            "Rafał Stefański"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This thesis studies the single-use restriction for register automata and\ntransducers over infinite alphabets. The restriction requires that a\nread-access to a register should have the side effect of destroying its\ncontents. This constraint results in robust classes of languages and\ntransductions. For automata models, we show that one-way register automata,\ntwo-way register automata, and orbit-finite monoids have the same expressive\npower. For transducer models, we show that single-use Mealy machines and\nsingle-use two-way transducers admit versions of the Krohn-Rhodes decomposition\ntheorem. Moreover, single-use Mealy machines are equivalent to an algebraic\nmodel called local algebraic semigroup transductions. Additionally, we show\nthat single-use two-way transducers are equivalent to single-use streaming\nstring transducers (SSTs) over infinite alphabets and to regular list functions\nwith atoms.\n  Compared with the previous work arXiv:1907.10504, this thesis offers a\ncoherent narrative on the single-use restriction. We introduce an abstract\nnotion of single-use functions and use them to define all the discussed\nsingle-use models. We also introduce and study the algebraic models of local\nsemigroup transduction and local rational semigroup transduction.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.18934v1"
    },
    {
        "title": "Minimising the Probabilistic Bisimilarity Distance",
        "authors": [
            "Stefan Kiefer",
            "Qiyi Tang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A labelled Markov decision process (MDP) is a labelled Markov chain with\nnondeterminism; i.e., together with a strategy a labelled MDP induces a\nlabelled Markov chain. The model is related to interval Markov chains.\nMotivated by applications to the verification of probabilistic noninterference\nin security, we study problems of minimising probabilistic bisimilarity\ndistances of labelled MDPs, in particular, whether there exist strategies such\nthat the probabilistic bisimilarity distance between the induced labelled\nMarkov chains is less than a given rational number, both for memoryless\nstrategies and general strategies. We show that the distance minimisation\nproblem is ExTh(R)-complete for memoryless strategies and undecidable for\ngeneral strategies. We also study the computational complexity of the\nqualitative problem about making the distance less than one. This problem is\nknown to be NP-complete for memoryless strategies. We show that it is\nEXPTIME-complete for general strategies.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.19830v1"
    },
    {
        "title": "The Finiteness Problem for Automaton Semigroups of Extended Bounded\n  Activity",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We extend the notion of activity for automaton semigroups and monoids\nintroduced by Bartholdi, Godin, Klimann and Picantin to a more general setting.\nTheir activity notion was already a generalization of Sidki's activity\nhierarchy for automaton groups. Using the concept of expandability introduced\nearlier by the current authors, we show that the language of $\\omega$-words\nwith infinite orbits is effectively a deterministic B\\\"uchi language for our\nextended activity. This generalizes a similar previous result on automaton\ngroups by Bondarenko and the third author. By a result of Francoeur and the\ncurrent authors, the description via a B\\\"uchi automaton immediately yields\nthat the finiteness problem for complete automaton semigroups and monoids of\nbounded activity is decidable. In fact, we obtain a stronger result where we\nmay consider sub-orbits under the action of a regular, suffix-closed language\nover the generators. This, in particular, also yields that it is decidable\nwhether a finitely generated subsemigroup (or -monoid) of a bounded complete\nautomaton semigroup is finite.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.20056v1"
    },
    {
        "title": "TheoremLlama: Transforming General-Purpose LLMs into Lean4 Experts",
        "authors": [
            "Ruida Wang",
            "Jipeng Zhang",
            "Yizhen Jia",
            "Rui Pan",
            "Shizhe Diao",
            "Renjie Pi",
            "Tong Zhang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Proving mathematical theorems using computer-verifiable formal languages like\nLean significantly impacts mathematical reasoning. One approach to formal\ntheorem proving involves generating complete proofs using Large Language Models\n(LLMs) based on Natural Language (NL) proofs. However, due to the scarcity of\naligned NL and Formal Language (FL) theorem-proving data most modern LLMs\nexhibit suboptimal performance.This scarcity results in a paucity of\nmethodologies for training LLMs and techniques to fully utilize their\ncapabilities in composing formal proofs. To address these challenges, this\npaper proposes TheoremLlama, an end-to-end framework that trains a\ngeneral-purpose LLM to be a Lean4 expert. TheoremLlama includes NL-FL dataset\ngeneration and bootstrapping method to obtain aligned dataset, curriculum\nlearning and block training techniques to train the model, and iterative proof\nwriting method to write Lean4 proofs that work together synergistically. Using\nthe dataset generation method in TheoremLlama, we provide Open Bootstrapped\nTheorems (OBT), an NL-FL aligned and bootstrapped dataset. Our novel NL-FL\nbootstrapping method, where NL proofs are integrated into Lean4 code for\ntraining datasets, leverages the NL reasoning ability of LLMs for formal\nreasoning. The TheoremLlama framework achieves cumulative accuracies of 36.48%\nand 33.61% on MiniF2F-Valid and Test datasets respectively, surpassing the\nGPT-4 baseline of 22.95% and 25.41%. Our code, model checkpoints, and the\ngenerated dataset is published in GitHub\n",
        "pdf_link": "http://arxiv.org/pdf/2407.03203v2"
    },
    {
        "title": "Simple grammar bisimilarity, with an application to session type\n  equivalence",
        "authors": [
            "Diogo Poças",
            "Vasco T. Vasconcelos"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We provide an algorithm for deciding simple grammar bisimilarity whose\ncomplexity is polynomial in the valuation of the grammar (maximum seminorm\namong production rules). Since the valuation is at most exponential in the size\nof the grammar, this gives rise to a single-exponential running time.\nPreviously only a doubly-exponential algorithm was known. As an application, we\nprovide a conversion from context-free session types to simple grammars whose\nvaluation is linear in the size of the type. In this way, we provide the first\npolynomial-time algorithm for deciding context-free session type equivalence.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.04063v1"
    },
    {
        "title": "Learning Weighted Finite Automata over the Max-Plus Semiring and its\n  Termination",
        "authors": [
            "Takamasa Okudono",
            "Masaki Waga",
            "Taro Sekiyama",
            "Ichiro Hasuo"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Active learning of finite automata has been vigorously pursued for the\npurposes of analysis and explanation of black-box systems. In this paper, we\nstudy an L*-style learning algorithm for weighted automata over the max-plus\nsemiring. The max-plus setting exposes a \"consistency\" issue in the previously\nstudied semiring-generic extension of L*: we show that it can fail to maintain\nconsistency of tables, and can thus make equivalence queries on obviously wrong\nhypothesis automata. We present a theoretical fix by a mathematically clean\nnotion of column-closedness. We also present a nontrivial and reasonably broad\nclass of weighted languages over the max-plus semiring in which our algorithm\nterminates.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.09775v1"
    },
    {
        "title": "Quasi-stratified Order Semantics of Concurrency",
        "authors": [
            "Maciej Koutny",
            "Lukasz Mikulski"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In the development of operational semantics of concurrent systems, a key\ndecision concerns the adoption of a suitable notion of execution model, which\nbasically amounts to choosing a class of partial orders according to which\nevents are arranged along the execution line. Typical kinds of such partial\norders are the total, stratified and interval orders. In this paper, we\nintroduce quasi-stratified orders - positioned in-between the stratified and\ninterval orders - which are tailored for transaction-like or hierarchical\nconcurrent executions.\n  Dealing directly with the vast number of executions of concurrent system is\nfar from being practical. It was realised long time ago that it can be much\nmore effective to consider behaviours at a more abstract level of behavioural\nspecifications (often based on intrinsic relationships between events such as\nthose represented by causal partial orders), each such specification -\ntypically, a relational structure - encompassing a (large) number of\nexecutions.\n  In this paper, we introduce and investigate suitable specifications for\nbehaviours represented by quasi-stratified orders. The proposed model of\nquasi-stratified relational structures is based on two relationships between\nevents - the 'before' and 'not later' relationships - which can be used to\nexpress and analyse causality, independence, and simultaneity between events.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.13406v1"
    },
    {
        "title": "Quasi-Isometric Reductions Between Infinite Strings",
        "authors": [
            "Karen Frilya Celine",
            "Ziyuan Gao",
            "Sanjay Jain",
            "Ryan Lou",
            "Frank Stephan",
            "Guohua Wu"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper studies the recursion-theoretic aspects of large-scale geometries\nof infinite strings, a subject initiated by Khoussainov and Takisaka (2017). We\ninvestigate several notions of quasi-isometric reductions between recursive\ninfinite strings and prove various results on the equivalence classes of such\nreductions. The main result is the construction of two infinite recursive\nstrings $\\alpha$ and $\\beta$ such that $\\alpha$ is strictly quasi-isometrically\nreducible to $\\beta$, but the reduction cannot be made recursive. This answers\nan open problem posed by Khoussainov and Takisaka.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.14105v1"
    },
    {
        "title": "Tight Bounds for the Number of Absent Scattered Factors",
        "authors": [
            "Duncan Adamson",
            "Pamela Fleischmann",
            "Annika Huch",
            "Max Wiedenhöft"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A scattered factor of a word $w$ is a word $u$ that can be obtained by\ndeleting arbitary letters from $w$ and keep the order of the remaining. Barker\net al. introduced the notion of $k$-universality, calling a word $k$-universal,\nif it contains all possible words of length $k$ over a given alphabet $\\Sigma$\nas a scattered factor. Kosche et al. introduced the notion of absent scattered\nfactors to categorise the words not being scattered factors of a given word.\n  In this paper, we investigate tight bounds on the possible number of absent\nscattered factors of a given length $k$ (also strictly longer than the shortest\nabsent scattered factors) among all words with the same universality extending\nthe results of Kosche et al. Specifically, given a length $k$ and universality\nindex $\\iota$, we characterize $\\iota$-universal words with both the maximal\nand minimal number of absent scattered factors of length $k$. For the lower\nbound, we provide the exact number in a closed form. For the upper bound, we\noffer efficient algorithms to compute the number based on the constructed\nwords. Moreover, by combining old results, we present an enumeration with\nconstant delay of the set of scattered factors of a fixed length in time\n$O(|\\Sigma||w|)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.18599v1"
    },
    {
        "title": "Hierarchical Clustering using Reversible Binary Cellular Automata for\n  High-Dimensional Data",
        "authors": [
            "Baby C. J.",
            "Kamalika Bhattacharjee"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This work proposes a hierarchical clustering algorithm for high-dimensional\ndatasets using the cyclic space of reversible finite cellular automata. In\ncellular automaton (CA) based clustering, if two objects belong to the same\ncycle, they are closely related and considered as part of the same cluster.\nHowever, if a high-dimensional dataset is clustered using the cycles of one CA,\nclosely related objects may belong to different cycles. This paper identifies\nthe relationship between objects in two different cycles based on the median of\nall elements in each cycle so that they can be grouped in the next stage.\nFurther, to minimize the number of intermediate clusters which in turn reduces\nthe computational cost, a rule selection strategy is taken to find the best\nrules based on information propagation and cycle structure. After encoding the\ndataset using frequency-based encoding such that the consecutive data elements\nmaintain a minimum hamming distance in encoded form, our proposed clustering\nalgorithm iterates over three stages to finally cluster the data elements into\nthe desired number of clusters given by user. This algorithm can be applied to\nvarious fields, including healthcare, sports, chemical research, agriculture,\netc. When verified over standard benchmark datasets with various performance\nmetrics, our algorithm is at par with the existing algorithms with quadratic\ntime complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.02250v1"
    },
    {
        "title": "LLMs as Probabilistic Minimally Adequate Teachers for DFA Learning",
        "authors": [
            "Lekai Chen",
            "Ashutosh Trivedi",
            "Alvaro Velasquez"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The emergence of intelligence in large language models (LLMs) has inspired\ninvestigations into their integration into automata learning. This paper\nintroduces the probabilistic Minimally Adequate Teacher (pMAT) formulation,\nwhich leverages a probabilistic oracle that could give persistent errors\nrandomly during answering the membership queries for deterministic finite\nautomata (DFA) learning. Given the tendency of LLMs to produce hallucinatory\ncontent, we have developed techniques to improve answer accuracy and ensure the\ncorrectness of the learned automata. We propose the $\\mathtt{Discrimination}$\nprompt as well as the $\\mathtt{Verification}$ prompt and explore their\nadvantages over common prompts. Additionally, we compare DFA learning\nperformance between the TTT algorithm and common active learning algorithms. To\naddress the exponential number of persistent errors, we implement a dynamic\nquery cache refinement algorithm that identifies and corrects conflicting\nqueries by combining the active and passive learning algorithms. The empirical\nresults demonstrate the robustness and efficiency of our approach, providing a\ntheoretical foundation for automata learning with LLMs in the loop.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.02999v1"
    },
    {
        "title": "Recomposition: A New Technique for Efficient Compositional Verification",
        "authors": [
            "Ian Dardik",
            "April Porter",
            "Eunsuk Kang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Compositional verification algorithms are well-studied in the context of\nmodel checking. Properly selecting components for verification is important for\nefficiency, yet has received comparatively less attention. In this paper, we\naddress this gap with a novel compositional verification framework that focuses\non component selection as an explicit, first-class concept. The framework\ndecomposes a system into components, which we then recompose into new\ncomponents for efficient verification. At the heart of our technique is the\nrecomposition map that determines how recomposition is performed; the component\nselection problem thus reduces to finding a good recomposition map. However,\nthe space of possible recomposition maps can be large. We therefore propose\nheuristics to find a small portfolio of recomposition maps, which we then run\nin parallel. We implemented our techniques in a model checker for the TLA+\nlanguage. In our experiments, we show that our tool achieves competitive\nperformance with TLC-a well-known model checker for TLA+-on a benchmark suite\nof distributed protocols.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.03488v2"
    },
    {
        "title": "Invariants for One-Counter Automata with Disequality Tests",
        "authors": [
            "Dmitry Chistikov",
            "Jérôme Leroux",
            "Henry Sinclair-Banks",
            "Nicolas Waldburger"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We study the reachability problem for one-counter automata in which\ntransitions can carry disequality tests. A disequality test is a guard that\nprohibits a specified counter value. This reachability problem has been known\nto be NP-hard and in PSPACE, and characterising its computational complexity\nhas been left as a challenging open question by Almagor, Cohen, P\\'erez,\nShirmohammadi, and Worrell (2020). We reduce the complexity gap, placing the\nproblem into the second level of the polynomial hierarchy, namely into the\nclass $\\mathsf{coNP}^{\\mathsf{NP}}$. In the presence of both equality and\ndisequality tests, our upper bound is at the third level,\n$\\mathsf{P}^{\\mathsf{NP}^{\\mathsf{NP}}}$.\n  To prove this result, we show that non-reachability can be witnessed by a\npair of invariants (forward and backward). These invariants are almost\ninductive. They aim to over-approximate only a \"core\" of the reachability set\ninstead of the entire set. The invariants are also leaky: it is possible to\nescape the set. We complement this with separate checks as the leaks can only\noccur in a controlled way.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.11908v1"
    },
    {
        "title": "Configuration Monitor Synthesis",
        "authors": [
            "Maximilian A. Köhl",
            "Clemens Dubslaff",
            "Holger Hermanns"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The observable behavior of a system usually carries useful information about\nits internal state, properties, and potential future behaviors. In this paper,\nwe introduce configuration monitoring to determine an unknown configuration of\na running system based on observations of its behavior. We develop a modular\nand generic pipeline to synthesize automata-theoretic configuration monitors\nfrom a featured transition system model of the configurable system to be\nmonitored. The pipeline further allows synthesis under partial observability\nand network-induced losses as well as predictive configuration monitors taking\nthe potential future behavior of a system into account. Beyond the novel\napplication of configuration monitoring, we show that our approach also\ngeneralizes and unifies existing work on runtime monitoring and fault\ndiagnosis, which aim at detecting the satisfaction or violation of properties\nand the occurrence of faults, respectively. We empirically demonstrate the\nefficacy of our approach with a case study on configuration monitors\nsynthesized from configurable systems community benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.17368v1"
    },
    {
        "title": "Completing the picture for the Skolem Problem on order-4 linear\n  recurrence sequences",
        "authors": [
            "Piotr Bacik"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  For almost a century, the decidability of the Skolem Problem - that is, the\nproblem of finding whether a given linear recurrence sequence (LRS) has a zero\nterm - has remained open. A breakthrough in the 1980s established that the\nSkolem Problem is indeed decidable for algebraic LRS of order at most 3, and\nreal algebraic LRS of order at most 4. However, for general algebraic LRS of\norder 4 the question of decidability has remained open. Our main contribution\nin this paper is to prove decidability for this last case, i.e. we show that\nthe Skolem Problem is decidable for all algebraic LRS of order at most 4.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.01221v2"
    },
    {
        "title": "Presheaf automata",
        "authors": [
            "Georg Struth",
            "Krzysztof Ziemiański"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce presheaf automata as a generalisation of different variants of\nhigher-dimensional automata and other automata-like formalisms, including Petri\nnets and vector addition systems. We develop the foundations of a language\ntheory for them based on notions of paths and track objects. We also define\nopen maps for presheaf automata, extending the standard notions of simulation\nand bisimulation for transition systems. Apart from these conceptual\ncontributions, we show that certain finite-type presheaf automata subsume all\nPetri nets, generalising a previous result by van Glabbeek, which applies to\nhigher-dimensional automata and safe Petri nets.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.04612v1"
    },
    {
        "title": "Proceedings 14th International Workshop on Non-Classical Models of\n  Automata and Applications (NCMA 2024)",
        "authors": [
            "Florin Manea",
            "Giovanni Pighizzini"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The Fourteenth International Workshop on Non-Classical Models of Automata and\nApplications (NCMA 2024) was held in G\\\"ottingen, Germany, on August 12 and 13,\n2024, at the historic Georg-Augustus-Universit\\\"at, organized by the\nTheoretical Computer Science research group of the respective university. The\nNCMA workshop series was established in 2009 as an annual event for researchers\nworking on non-classical and classical models of automata, grammars or related\ndevices. Such models are investigated both as theoretical models and as formal\nmodels for applications from various points of view. The goal of the NCMA\nworkshop series is to exchange and develop novel ideas in order to gain deeper\nand interdisciplinary coverage of this particular area that may foster new\ninsights and substantial progress.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06120v1"
    },
    {
        "title": "A GLR-like Parsing Algorithm for Three-Valued Interpretations of Boolean\n  Grammars with Strong Negation",
        "authors": [
            "Patrik Adrián",
            "György Vaszil"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Boolean grammars generalize context-free rewriting by extending the\npossibilities when dealing with different rules for the same nonterminal\nsymbol. By allowing not only disjunction (as in the case of usual context-free\ngrammars), but also conjunction and negation as possible connections between\ndifferent rules with the same left-hand side, they are able to simplify the\ndescription of context-free languages and characterize languages that are not\ncontext-free. The use of negation, however, leads to the possibility of\nintroducing rules that interplay in such a way which is problematic to handle\nin the classical, two-valued logical setting. Here we define a three valued\ninterpretation to deal with such contradictory grammars using a method\nintroduced originally in the context of logic programming, and present an\nalgorithm to determine the membership status of strings with respect to the\nresulting three valued languages.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06966v1"
    },
    {
        "title": "Complexity of Unary Exclusive Nondeterministic Finite Automata",
        "authors": [
            "Martin Kutrib",
            "Andreas Malcher",
            "Matthias Wendlandt"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Exclusive nondeterministic finite automata (XNFA) are nondeterministic finite\nautomata with a special acceptance condition. An input is accepted if there is\nexactly one accepting path in its computation tree. If there are none or more\nthan one accepting paths, the input is rejected. We study the descriptional\ncomplexity of XNFA accepting unary languages. While the state costs for mutual\nsimulations with DFA and NFA over general alphabets differ significantly from\nthe known types of finite automata, it turns out that the state costs for the\nsimulations in the unary case are in the order of magnitude of the general\ncase. In particular, the state costs for the simulation of an XNFA by a DFA or\nan NFA are $e^{\\theta(\\sqrt{n \\cdot ln{n}})}$. Conversely, converting an NFA to\nan equivalent XNFA may cost $e^{\\theta(\\sqrt{n \\cdot ln{n}})}$ states as well.\nAll bounds obtained are also tight in the order of magnitude. Finally, we\ninvestigate the computational complexity of different decision problems for\nunary XNFA and it is shown that the problems of emptiness, universality,\ninclusion, and equivalence are coNP-complete, whereas the general membership\nproblem is NL-complete.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06967v1"
    },
    {
        "title": "Winning Strategies for the Synchronization Game on Subclasses of Finite\n  Automata",
        "authors": [
            "Henning Fernau",
            "Carolina Haase",
            "Stefan Hoffmann",
            "Mikhail Volkov"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We exhibit a winning strategy for Synchronizer in the synchronization game on\nevery synchronizing automaton in whose transition monoid the regular D-classes\nform subsemigroups\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06971v1"
    },
    {
        "title": "Complexity Aspects of the Extension of Wagner's Hierarchy to\n  $k$-Partitions",
        "authors": [
            "Vladimir Podolskii",
            "Victor Selivanov"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  It is known that the Wadge reducibility of regular $\\omega$-languages is\nefficiently decidable (Krishnan et al., 1995), (Wilke, Yoo, 1995). In this\npaper we study analogous problem for regular k-partitions of\n$\\omega$-languages. In the series of previous papers (Selivanov, 2011), (Alaev,\nSelivanov, 2021), (Selivanov, 2012) there was a partial progress towards\nobtaining an efficient algorithm for deciding the Wadge reducibility in this\nsetting as well. In this paper we finalize this line of research providing a\nquadratic algorithm (in RAM model). For this we construct a quadratic algorithm\nto decide a preorder relation on iterated posets. Additionally, we discuss the\nsize of the representation of regular $\\omega$-languages and suggest a more\ncompact way to represent them. The algorithm we provide is efficient for the\nmore compact representation as well.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06977v1"
    },
    {
        "title": "Large Language Models and the Extended Church-Turing Thesis",
        "authors": [
            "Jiří Wiedermann",
            "Jan van Leeuwen"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The Extended Church-Turing Thesis (ECTT) posits that all effective\ninformation processing, including unbounded and non-uniform interactive\ncomputations, can be described in terms of interactive Turing machines with\nadvice. Does this assertion also apply to the abilities of contemporary large\nlanguage models (LLMs)? From a broader perspective, this question calls for an\ninvestigation of the computational power of LLMs by the classical means of\ncomputability and computational complexity theory, especially the theory of\nautomata. Along these lines, we establish a number of fundamental results.\nFirstly, we argue that any fixed (non-adaptive) LLM is computationally\nequivalent to a, possibly very large, deterministic finite-state transducer.\nThis characterizes the base level of LLMs. We extend this to a key result\nconcerning the simulation of space-bounded Turing machines by LLMs. Secondly,\nwe show that lineages of evolving LLMs are computationally equivalent to\ninteractive Turing machines with advice. The latter finding confirms the\nvalidity of the ECTT for lineages of LLMs. From a computability viewpoint, it\nalso suggests that lineages of LLMs possess super-Turing computational power.\nConsequently, in our computational model knowledge generation is in general a\nnon-algorithmic process realized by lineages of LLMs. Finally, we discuss the\nmerits of our findings in the broader context of several related disciplines\nand philosophies.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.06978v1"
    },
    {
        "title": "Formal verification of higher dimensional quantum protocols",
        "authors": [
            "Ittoop Vergheese Puthoor"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Formal methods have been a successful approach for modelling and verifying\nthe correctness of complex technologies like microprocessor chip design,\nbiological systems and others. This is the main motivation of developing\nquantum formal techniques which is to describe and analyse quantum information\nprocessing systems. Our previous work demonstrates the possibility of using a\nquantum process calculus called Communicating Quantum Processes (CQP) to model\nand describe higher dimensional quantum systems. By developing the theory to\ngeneralise the fundamental gates and Bell states, we have modelled quantum\nqudit protocols like teleportation and superdense coding in CQP. In this paper,\nwe demonstrate the use of CQP to analyse higher dimensional quantum protocols.\nThe main idea is to define two processes, one modelling the real protocol and\nthe other expressing a specification, and prove that they are behaviourally\nequivalent. This is a work-in-progress and we present our preliminary results\nin extending the theory of behavioural equivalence in CQP to verify higher\ndimensional quantum protocols using qudits.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.17980v1"
    },
    {
        "title": "Self-Replicating Mechanical Universal Turing Machine",
        "authors": [
            "Ralph P. Lano"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper presents the implementation of a self-replicating finite-state\nmachine (FSM) and a self-replicating Turing Machine (TM) using bio-inspired\nmechanisms. Building on previous work that introduced self-replicating\nstructures capable of sorting, copying, and reading information, this study\ndemonstrates the computational power of these mechanisms by explicitly\nconstructing a functioning FSM and TM. This study demonstrates the universality\nof the system by emulating the UTM(5,5) of Neary and Woods.\n",
        "pdf_link": "http://arxiv.org/pdf/2409.19037v1"
    },
    {
        "title": "Maximal Length Cellular Automata : A Survey",
        "authors": [
            "Sumit Adak",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This article surveys some theoretical aspects of Cellular Automata (CAs)\nresearch. In particular, we discuss on maximal length CA. An n-cell CA is a\nmaximal length CA, if all the configurations except one form a single cycle.\nThere is a bonding between maximal length CA and primitive polynomial. So,\nprimitive polynomials occupy a good amount of space in this survey. The main\ngoal of this survey is to provide a tutorial on maximal length CA theory to\nresearchers with classical and new results on maximality. We also give a\ncompact collection of known results with references to their proofs, and to\nsuggest some open problems. Additionally, some new theorems and corollaries are\nadded to bridge the gaps among several known results.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.05947v1"
    },
    {
        "title": "LR Parsing of Permutation Phrases",
        "authors": [
            "Jana Kostičová"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This paper presents an efficient method for LR parsing of permutation\nphrases. In practical cases, the proposed algorithm constructs an LR(0)\nautomaton that requires significantly fewer states to process a permutation\nphrase compared to the standard construction. For most real-world grammars, the\nnumber of states is typically reduced from $\\Omega(n!)$ to $O(2^{n})$,\nresulting in a much more compact parsing table. The state reduction increases\nwith longer permutation phrases and a higher number of permutation phrases\nwithin the right-hand side of a rule. We demonstrate the effectiveness of this\nmethod through its application to parsing a JSON document.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.06769v1"
    },
    {
        "title": "Motion Planning for Automata-based Objectives using Efficient\n  Gradient-based Methods",
        "authors": [
            "Anand Balakrishnan",
            "Merve Atasever",
            "Jyotirmoy V. Deshmukh"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In recent years, there has been increasing interest in using formal\nmethods-based techniques to safely achieve temporal tasks, such as timed\nsequence of goals, or patrolling objectives. Such tasks are often expressed in\nreal-time logics such as Signal Temporal Logic (STL), whereby, the logical\nspecification is encoded into an optimization problem. Such approaches usually\ninvolve optimizing over the quantitative semantics, or robustness degree, of\nthe logic over bounded horizons: the semantics can be encoded as mixed-integer\nlinear constraints or into smooth approximations of the robustness degree. A\nmajor limitation of this approach is that it faces scalability challenges with\nrespect to temporal complexity: for example, encoding long-term tasks requires\nstoring the entire history of the system. In this paper, we present a\nquantitative generalization of such tasks in the form of symbolic automata\nobjectives. Specifically, we show that symbolic automata can be expressed as\nmatrix operators that lend themselves to automatic differentiation, allowing\nfor the use of off-the-shelf gradient-based optimizers. We show how this helps\nsolve the need to store arbitrarily long system trajectories, while efficiently\nleveraging the task structure encoded in the automaton.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.11156v1"
    },
    {
        "title": "Completeness of FSM Test Suites Reconsidered",
        "authors": [
            "Frits Vaandrager",
            "Paul Fiterău-Broştean",
            "Ivo Melse"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  A fault domain that has been widely studied in black-box conformance testing\nis the class of finite state machines (FSMs) with at most $k$ extra states.\nNumerous methods for generating test suites have been proposed that guarantee\nfault coverage for this class. These test suites grow exponentially in $k$, so\none can only run them for small $k$. But the assumption that $k$ is small is\nnot realistic in practice. As a result, completeness for this fault domain has\nlimited practical significance. As an alternative, we propose (much larger)\nfault domains that capture the assumption that when bugs in an implementation\nintroduce extra states, these states can be reached via a few (at most $k$)\ntransitions from states reachable via a set $A$ of common scenarios.\nPreliminary evidence suggests these fault domains, which contain FSMs with an\nexponential number of extra states (in $k$), are of practical use for testing\nnetwork protocols. We present a sufficient condition for\n\\emph{$k$-$A$-completeness} of test suites with respect to these fault domains,\nphrased entirely in terms of properties of their testing tree. Our condition\nimplies $k$-$A$-completeness of two prominent test suite generation algorithms,\nthe Wp and HSI methods. Counterexamples show that three other approaches, the\nH, SPY and SPYH methods, do not always generate $k$-$A$-complete test suites.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.19405v1"
    },
    {
        "title": "Automata Size Reduction by Procedure Finding",
        "authors": [
            "Michal Šedý",
            "Lukáš Holík"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We introduce a novel paradigm for reducing the size of finite automata by\ncompressing repeating sub-graphs. These repeating sub-graphs can be viewed as\ninvocations of a single procedure. Instead of representing each invocation\nexplicitly, they can be replaced by a single procedure that uses a small\nruntime memory to remember the call context. We elaborate on the technical\ndetails of a basic implementation of this idea, where the memory used by the\nprocedures is a simple finite-state register. We propose methods for\nidentifying repetitive sub-graphs, collapsing them into procedures, and\nmeasuring the resulting reduction in automata size. Already, this basic\nimplementation of reduction by procedure finding yields practically relevant\nresults, particularly in the context of FPGA-accelerated pattern matching,\nwhere automata size is a primary bottleneck. We achieve up-to 70% size\nreduction on automata that had already been minimized using the most advanced\nexisting methods.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.20227v1"
    },
    {
        "title": "Synthesis of Timeline-Based Planning Strategies Avoiding Determinization",
        "authors": [
            "Renato Acampora",
            "Dario Della Monica",
            "Luca Geatti",
            "Nicola Gigante",
            "Angelo Montanari",
            "Pietro Sala"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Qualitative timeline-based planning models domains as sets of independent,\nbut interacting, components whose behaviors over time, the timelines, are\ngoverned by sets of qualitative temporal constraints (ordering relations),\ncalled synchronization rules. Its plan-existence problem has been shown to be\nPSPACE-complete; in particular, PSPACE-membership has been proved via reduction\nto the nonemptiness problem for nondeterministic finite automata. However,\nnondeterministic automata cannot be directly used to synthesize planning\nstrategies as a costly determinization step is needed. In this paper, we\nidentify a large fragment of qualitative timeline-based planning whose\nplan-existence problem can be directly mapped into the nonemptiness problem of\ndeterministic finite automata, which can then be exploited to synthesize\nstrategies. In addition, we identify a maximal subset of Allen's relations that\nfits into such a deterministic fragment.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.22757v1"
    },
    {
        "title": "Decidability Issues for Petri Nets -- a survey",
        "authors": [
            "Javier Esparza",
            "Mogens Nielsen"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We survey 25 years of research on decidability issues for Petri nets. We\ncollect results on the decidability of important properties, equivalence\nnotions, and temporal logics.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.01592v1"
    },
    {
        "title": "The Word Problem for $(ω- 1)$-Terms over $\\mathrm{DAb}$",
        "authors": [
            "Jorge Almeida",
            "Manfred Kufleitner",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We give a ranker-based description using finite-index congruences for the\nvariety $\\boldsymbol{\\mathrm{DAb}}$ of finite monoids whose regular\n$\\mathcal{D}$-classes form Abelian groups. This combinatorial description\nyields a normal form for general pseudowords over $\\boldsymbol{\\mathrm{DAb}}$.\nFor $(\\omega - 1)$-terms, this normal form is computable, which yields an\nalgorithm for the word problem for $(\\omega - 1)$-terms of\n$\\boldsymbol{\\mathrm{DAb}}$.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.08523v1"
    },
    {
        "title": "Proceedings Combined 31st International Workshop on Expressiveness in\n  Concurrency and 21st Workshop on Structural Operational Semantics",
        "authors": [
            "Georgiana Caltais",
            "Cinzia Di Giusto"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This volume contains the proceedings of EXPRESS/SOS 2024: the Combined 31st\nInternational Workshop on Expressiveness in Concurrency and the 21st Workshop\non Structural Operational Semantics, which was held in Calgary, Canada, as an\naffiliated workshop of CONFEST 2024. The EXPRESS/SOS workshop series aims at\nbringing together researchers interested in the formal semantics of systems and\nprogramming concepts, and in the expressiveness of computational models.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.13318v1"
    },
    {
        "title": "Complete Test Suites for Automata in Monoidal Closed Categories",
        "authors": [
            "Bálint Kocsis",
            "Jurriaan Rot"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Conformance testing of automata is about checking the equivalence of a known\nspecification and a black-box implementation. An important notion in\nconformance testing is that of a complete test suite, which guarantees that if\nan implementation satisfying certain conditions passes all tests, then it is\nequivalent to the specification.\n  We introduce a framework for proving completeness of test suites at the\ngeneral level of automata in monoidal closed categories. Moreover, we provide a\ngeneralization of a classical conformance testing technique, the W-method. We\ndemonstrate the applicability of our results by recovering the W-method for\ndeterministic finite automata, Moore machines, and Mealy machines, and by\nderiving new instances of complete test suites for weighted automata and\ndeterministic nominal automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.13412v1"
    },
    {
        "title": "Synchronisability in Mailbox Communication",
        "authors": [
            "Cinzia Di Giusto",
            "Laetitia Laversa",
            "Kirstin Peters"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We revisit the problem of synchronisability for communicating automata, i.e.,\nwhether the language of send messages for an asynchronous system is the same as\nthe language of send messages with a synchronous communication. The\nun/decidability of the problem depends on the specific asynchronous semantics\nconsidered as well as the topology (the communication flow) of the system.\nSynchronisability is known to be undecidable under the peer-to-peer semantics,\nwhile it is still an open problem for mailbox communication. The problem was\nshown to be decidable for ring topologies. In this paper, we show that when\ngeneralising to automata with accepting states, synchronisability is\nundecidable under the mailbox semantics, this result is obtained by resorting\nto the Post Correspondence problem. In an attempt to solve the specific problem\nwhere all states are accepting, we also show that synchronisability is\ndecidable for tree topologies (where, as well as for rings, peer-to-peer\ncoincides with mailbox semantics). We also discuss synchronisability for\nmultitrees in the mailbox setting.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.14580v1"
    },
    {
        "title": "Temporally Non-Uniform Cellular Automata (t-NUCA): Reversibility and\n  Cyclic behavior",
        "authors": [
            "Subrata Paul",
            "Sukanta Das"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this work, we propose a variant of non-uniform cellular automata, named as\nTemporally Non-Uniform Cellular Automata (t-NUCAs), which temporally use two\nrules, $f$ and $g$ in a sequence $\\mathcal{R}$. To observe reversibility in\nt-NUCAs, we study their injectivity and surjectivity properties. Unlike\nclassical CAs, some irreversible t-NUCAs show the behavior similar to\nreversible t-NUCAs. To study this behavior, we define restricted surjectivity\nof t-NUCA and introduce restricted reversibility which shows reversibility of\nt-NUCA for a set of initial configurations. By further investigating the\nremaining irreversible t-NUCAs, some t-NUCAs are found which have many-to-one\nmapping in their configuration space, but do not have non-reachable\n(Garden-of-Eden) configurations. We name these t-NUCAs as weakly reversible\nt-NUCAs. Under finite lattice size, a t-NUCA, like any classical CA, shows\ncyclic behavior. We explore this cyclic behavior and discuss its relation with\nrule sequence. Finally, we note down the possible longest cycle length of a\nt-NUCA, based on the lattice size and rule sequence.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.17421v1"
    },
    {
        "title": "Congruence-based Learning of Probabilistic Deterministic Finite Automata",
        "authors": [
            "Matías Carrasco",
            "Franz Mayr",
            "Sergio Yovine"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This work studies the question of learning probabilistic deterministic\nautomata from language models. For this purpose, it focuses on analyzing the\nrelations defined on algebraic structures over strings by equivalences and\nsimilarities on probability distributions. We introduce a congruence that\nextends the classical Myhill-Nerode congruence for formal languages. This new\ncongruence is the basis for defining regularity over language models. We\npresent an active learning algorithm that computes the quotient with respect to\nthis congruence whenever the language model is regular. The paper also defines\nthe notion of recognizability for language models and shows that it coincides\nwith regularity for congruences. For relations which are not congruences, it\nshows that this is not the case. Finally, it discusses the impact of this\nresult on learning in the context of language models.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.09760v1"
    },
    {
        "title": "The Black Ninjas and the Sniper: On Robustness of Population Protocols",
        "authors": [
            "Benno Lossin",
            "Philipp Czerner",
            "Javier Esparza",
            "Roland Guttenberg",
            "Tobias Prehn"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Population protocols are a model of distributed computation in which an\narbitrary number of indistinguishable finite-state agents interact in pairs to\ndecide some property of their initial configuration. We investigate the\nbehaviour of population protocols under adversarial faults that cause agents to\nsilently crash and no longer interact with other agents. As a starting point,\nwe consider the property ``the number of agents exceeds a given threshold\n$t$'', represented by the predicate $x \\geq t$, and show that the standard\nprotocol for $x \\geq t$ is very fragile: one single crash in a computation with\n$x:=2t-1$ agents can already cause the protocol to answer incorrectly that $x\n\\geq t$ does not hold. However, a slightly less known protocol is robust: for\nany number $t' \\geq t$ of agents, at least $t' - t+1$ crashes must occur for\nthe protocol to answer that the property does not hold.\n  We formally define robustness for arbitrary population protocols, and\ninvestigate the question whether every predicate computable by population\nprotocols has a robust protocol. Angluin et al. proved in 2007 that population\nprotocols decide exactly the Presburger predicates, which can be represented as\nBoolean combinations of threshold predicates of the form $\\sum_{i=1}^n a_i\n\\cdot x_i \\geq t$ for $a_1,...,a_n, t \\in \\mathbb{Z}$ and modulo prdicates of\nthe form $\\sum_{i=1}^n a_i \\cdot x_i \\bmod m \\geq t $ for $a_1, \\ldots, a_n, m,\nt \\in \\mathbb{N}$. We design robust protocols for all threshold and modulo\npredicates. We also show that, unfortunately, the techniques in the literature\nthat construct a protocol for a Boolean combination of predicates given\nprotocols for the conjuncts do not preserve robustness. So the question remains\nopen.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.11783v1"
    },
    {
        "title": "Reachability in Vector Addition System with States Parameterized by\n  Geometric Dimension",
        "authors": [
            "Yangluo Zheng"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  The geometric dimension of a Vector Addition System with States (VASS),\nemerged in Leroux and Schmitz (2019) and formalized by Fu, Yang, and Zheng\n(2024), quantifies the dimension of the vector space spanned by cycle effects\nin the system. This paper explores the VASS reachability problem through the\nlens of geometric dimension, revealing key differences from the traditional\ndimensional parameterization. Notably, we establish that the reachability\nproblem for both geometrically 1-dimensional and 2-dimensional VASS is\nPSPACE-complete, achieved by extending the pumping technique originally\nproposed by Czerwi\\'nski et al. (2019).\n",
        "pdf_link": "http://arxiv.org/pdf/2412.14608v1"
    },
    {
        "title": "The Tractability Border of Reachability in Simple Vector Addition\n  Systems with States",
        "authors": [
            "Dmitry Chistikov",
            "Wojciech Czerwiński",
            "Filip Mazowiecki",
            "Łukasz Orlikowski",
            "Henry Sinclair-Banks",
            "Karol Węgrzycki"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Vector Addition Systems with States (VASS), equivalent to Petri nets, are a\nwell-established model of concurrency. The central algorithmic challenge in\nVASS is the reachability problem: is there a run from a given starting state\nand counter values to a given target state and counter values? When the input\nis encoded in binary, reachability is computationally intractable: even in\ndimension one, it is NP-hard.\n  In this paper, we comprehensively characterise the tractability border of the\nproblem when the input is encoded in unary. For our main result, we prove that\nreachability is NP-hard in unary encoded 3-VASS, even when structure is heavily\nrestricted to be a simple linear path scheme. This improves upon a recent\nresult of Czerwi\\'nski and Orlikowski (2022), in both the number of counters\nand expressiveness of the considered model, as well as answers open questions\nof Englert, Lazi\\'c, and Totzke (2016) and Leroux (2021).\n  The underlying graph structure of a simple linear path scheme (SLPS) is just\na path with self-loops at each node. We also study the exceedingly weak model\nof computation that is SPLS with counter updates in {-1,0,+1}. Here, we show\nthat reachability is NP-hard when the dimension is bounded by O(\\alpha(k)),\nwhere \\alpha is the inverse Ackermann function and k bounds the size of the\nSLPS.\n  We complement our result by presenting a polynomial-time algorithm that\ndecides reachability in 2-SLPS when the initial and target configurations are\nspecified in binary. To achieve this, we show that reachability in such\ninstances is well-structured: all loops, except perhaps for a constant number,\nare taken either polynomially many times or almost maximally. This extends the\nmain result of Englert, Lazi\\'c, and Totzke (2016) who showed the problem is in\nNL when the initial and target configurations are specified in unary.\n",
        "pdf_link": "http://arxiv.org/pdf/2412.16612v1"
    },
    {
        "title": "Extended CTG Generalization and Dynamic Adjustment of Generalization\n  Strategies in IC3",
        "authors": [
            "Yuheng Su",
            "Qiusong Yang",
            "Yiwei Ci",
            "Ziyu Huang"
        ],
        "category": "cs.FL",
        "published_year": "2025",
        "summary": "  The IC3 algorithm is widely used in hardware formal verification, with\ngeneralization as a crucial step. Standard generalization expands a cube by\ndropping literals to include more unreachable states. The CTG approach enhances\nthis by blocking counterexamples to generalization (CTG) when dropping literals\nfails. In this paper, we extend the CTG method (EXCTG) to put more effort into\ngeneralization. If blocking the CTG fails, EXCTG attempts to block its\npredecessors, aiming for better generalization. While CTG and EXCTG offer\nbetter generalization results, they also come with increased computational\noverhead. Finding an appropriate balance between generalization quality and\ncomputational overhead is challenging with a static strategy. We propose\nDynAMic, a method that dynamically adjusts generalization strategies according\nto the difficulty of blocking states, thereby improving scalability without\ncompromising efficiency. A comprehensive evaluation demonstrates that EXCTG and\nDynAMic achieve significant scalability improvements, solving 8 and 25 more\ncases, respectively, compared to CTG generalization.\n",
        "pdf_link": "http://arxiv.org/pdf/2501.02480v1"
    },
    {
        "title": "Qualitative Concurrent Stochastic Games with Imperfect Information",
        "authors": [
            "Vincent Gripon",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We study a model of games that combines concurrency, imperfect information\nand stochastic aspects. Those are finite states games in which, at each round,\nthe two players choose, simultaneously and independently, an action. Then a\nsuccessor state is chosen accordingly to some fixed probability distribution\ndepending on the previous state and on the pair of actions chosen by the\nplayers. Imperfect information is modeled as follows: both players have an\nequivalence relation over states and, instead of observing the exact state,\nthey only know to which equivalence class it belongs. Therefore, if two partial\nplays are indistinguishable by some player, he should behave the same in both\nof them. We consider reachability (does the play eventually visit a final\nstate?) and B\\\"uchi objective (does the play visit infinitely often a final\nstate?). Our main contribution is to prove that the following problem is\ncomplete for 2-ExpTime: decide whether the first player has a strategy that\nensures her to almost-surely win against any possible strategy of her oponent.\nWe also characterise those strategies needed by the first player to\nalmost-surely win.\n",
        "pdf_link": "http://arxiv.org/pdf/0902.2108v3"
    },
    {
        "title": "Relation between the Usual Order and the Enumeration Orders of Elements\n  of r.e. Sets",
        "authors": [
            "Ali Akbar Safilian",
            "Farzad Didehvar"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In this paper, we have compared r.e. sets based on their enumeration orders\nwith Turing machines. Accordingly, we have defined novel concept uniformity for\nTuring machines and r.e. sets and have studied some relationships between\nuniformity and both one-reducibility and Turing reducibility. Furthermore, we\nhave defined type-2 uniformity concept and studied r.e. sets and Turing\nmachines based on this concept. In the end, we have introduced a new structure\ncalled Turing Output Binary Search Tree that helps us lighten some ideas.\n",
        "pdf_link": "http://arxiv.org/pdf/0904.3607v1"
    },
    {
        "title": "Self-Assembling Systems are Distributed Systems",
        "authors": [
            "Aaron Sterling"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  In 2004, Klavins et al. introduced the use of graph grammars to describe --\nand to program -- systems of self-assembly. We show that these graph grammars\ncan be embedded in a graph rewriting characterization of distributed systems\nthat was proposed by Degano and Montanari over twenty years ago. We apply this\nembedding to generalize Soloveichik and Winfree's local determinism criterion\n(for achieving a unique terminal assembly), from assembly systems of 4-sided\ntiles that embed in the plane, to arbitrary graph assembly systems. We present\na partial converse of the embedding result, by providing sufficient conditions\nunder which systems of distributed processors can be simulated by graph\nassembly systems topologically, in the plane, and in 3-space. We conclude by\ndefining a new complexity measure: \"surface cost\" (essentially the convex hull\nof the space inhabited by agents at the conclusion of a self-assembled\ncomputation). We show that, for growth-bounded graphs, executing a subroutine\nto find a Maximum Independent Set only increases the surface cost of a\nself-assembling computation by a constant factor. We obtain this complexity\nbound by using the simulation results to import the distributed computing\nnotions of \"local synchronizer\" and \"deterministic coin flipping\" into\nself-assembly.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.1072v2"
    },
    {
        "title": "On Measuring Non-Recursive Trade-Offs",
        "authors": [
            "Hermann Gruber",
            "Markus Holzer",
            "Martin Kutrib"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We investigate the phenomenon of non-recursive trade-offs between\ndescriptional systems in an abstract fashion. We aim at categorizing\nnon-recursive trade-offs by bounds on their growth rate, and show how to deduce\nsuch bounds in general. We also identify criteria which, in the spirit of\nabstract language theory, allow us to deduce non-recursive tradeoffs from\neffective closure properties of language families on the one hand, and\ndifferences in the decidability status of basic decision problems on the other.\nWe develop a qualitative classification of non-recursive trade-offs in order to\nobtain a better understanding of this very fundamental behaviour of\ndescriptional systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5063v1"
    },
    {
        "title": "Serializing the Parallelism in Parallel Communicating Pushdown Automata\n  Systems",
        "authors": [
            "M. Sakthi Balan"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We consider parallel communicating pushdown automata systems (PCPA) and\ndefine a property called known communication for it. We use this property to\nprove that the power of a variant of PCPA, called returning centralized\nparallel communicating pushdown automata (RCPCPA), is equivalent to that of\nmulti-head pushdown automata. The above result presents a new sub-class of\nreturning parallel communicating pushdown automata systems (RPCPA) called\nsimple-RPCPA and we show that it can be written as a finite intersection of\nmulti-head pushdown automata systems.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5083v1"
    },
    {
        "title": "On the Size Complexity of Non-Returning Context-Free PC Grammar Systems",
        "authors": [
            "Erzsébet Csuhaj-Varjú",
            "György Vaszil"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  Improving the previously known best bound, we show that any recursively\nenumerable language can be generated with a non-returning parallel\ncommunicating (PC) grammar system having six context-free components. We also\npresent a non-returning universal PC grammar system generating unary languages,\nthat is, a system where not only the number of components, but also the number\nof productions and the number of nonterminals are limited by certain constants,\nand these size parameters do not depend on the generated language.\n",
        "pdf_link": "http://arxiv.org/pdf/0907.5119v1"
    },
    {
        "title": "A Type System for a Stochastic CLS",
        "authors": [
            "Mariangiola Dezani-Ciancaglini",
            "Paola Giannini",
            "Angelo Troina"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  The Stochastic Calculus of Looping Sequences is suitable to describe the\nevolution of microbiological systems, taking into account the speed of the\ndescribed activities. We propose a type system for this calculus that models\nhow the presence of positive and negative catalysers can modify these speeds.\nWe claim that types are the right abstraction in order to represent the\ninteraction between elements without specifying exactly the element positions.\nOur claim is supported through an example modelling the lactose operon.\n",
        "pdf_link": "http://arxiv.org/pdf/0911.4985v1"
    },
    {
        "title": "Adaptive Scheduling of Data Paths using Uppaal Tiga",
        "authors": [
            "Israa AlAttili",
            "Fred Houben",
            "Georgeta Igna",
            "Steffen Michels",
            "Feng Zhu",
            "Frits Vaandrager"
        ],
        "category": "cs.FL",
        "published_year": "2009",
        "summary": "  We apply Uppaal Tiga to automatically compute adaptive scheduling strategies\nfor an industrial case study dealing with a state-of-the-art image processing\npipeline of a printer. As far as we know, this is the first application of\ntimed automata technology to an industrial scheduling problem with uncertainty\nin job arrivals.\n",
        "pdf_link": "http://arxiv.org/pdf/0912.1897v1"
    },
    {
        "title": "Complete Context Calculus Design and Implementation in GIPSY",
        "authors": [
            "Xin Tong",
            "Joey Paquet",
            "Serguei A. Mokhov"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  This paper presents the integration into the GIPSY of Lucx's context calculus\ndefined in Wan's PhD thesis. We start by defining different types of tag sets,\nthen we explain the concept of context, the types of context and the context\ncalculus operators. Finally, we present how context entities have been\nabstracted into Java classes and embedded into the GIPSY system.\n",
        "pdf_link": "http://arxiv.org/pdf/1002.4392v1"
    },
    {
        "title": "The Magic Number Problem for Subregular Language Families",
        "authors": [
            "Markus Holzer",
            "Sebastian Jakobi",
            "Martin Kutrib"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We investigate the magic number problem, that is, the question whether there\nexists a minimal n-state nondeterministic finite automaton (NFA) whose\nequivalent minimal deterministic finite automaton (DFA) has alpha states, for\nall n and alpha satisfying n less or equal to alpha less or equal to exp(2,n).\nA number alpha not satisfying this condition is called a magic number (for n).\nIt was shown in [11] that no magic numbers exist for general regular languages,\nwhile in [5] trivial and non-trivial magic numbers for unary regular languages\nwere identified. We obtain similar results for automata accepting subregular\nlanguages like, for example, combinational languages, star-free, prefix-,\nsuffix-, and infix-closed languages, and prefix-, suffix-, and infix-free\nlanguages, showing that there are only trivial magic numbers, when they exist.\nFor finite languages we obtain some partial results showing that certain\nnumbers are non-magic.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.1653v1"
    },
    {
        "title": "An Individual-based Probabilistic Model for Fish Stock Simulation",
        "authors": [
            "Federico Buti",
            "Flavio Corradini",
            "Emanuela Merelli",
            "Elio Paschini",
            "Pierluigi Penna",
            "Luca Tesei"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We define an individual-based probabilistic model of a sole (Solea solea)\nbehaviour. The individual model is given in terms of an Extended Probabilistic\nDiscrete Timed Automaton (EPDTA), a new formalism that is introduced in the\npaper and that is shown to be interpretable as a Markov decision process. A\ngiven EPDTA model can be probabilistically model-checked by giving a suitable\ntranslation into syntax accepted by existing model-checkers. In order to\nsimulate the dynamics of a given population of soles in different environmental\nscenarios, an agent-based simulation environment is defined in which each agent\nimplements the behaviour of the given EPDTA model. By varying the probabilities\nand the characteristic functions embedded in the EPDTA model it is possible to\nrepresent different scenarios and to tune the model itself by comparing the\nresults of the simulations with real data about the sole stock in the North\nAdriatic sea, available from the recent project SoleMon. The simulator is\npresented and made available for its adaptation to other species.\n",
        "pdf_link": "http://arxiv.org/pdf/1008.3303v1"
    },
    {
        "title": "Proceedings 12th International Workshop on Verification of\n  Infinite-State Systems",
        "authors": [
            "Yu-Fang Chen",
            "Ahmed Rezine"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  The aim of the INFINITY workshop is to provide a forum for researchers\ninterested in the development of formal methods and algorithmic techniques for\nthe analysis of systems with infinitely many states, and their application in\nautomated verification of complex software and hardware systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1010.6112v1"
    },
    {
        "title": "On Selective Unboundedness of VASS",
        "authors": [
            "Stéphane Demri"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  Numerous properties of vector addition systems with states amount to checking\nthe (un)boundedness of some selective feature (e.g., number of reversals, run\nlength). Some of these features can be checked in exponential space by using\nRackoff's proof or its variants, combined with Savitch's theorem. However, the\nquestion is still open for many others, e.g., reversal-boundedness. In the\npaper, we introduce the class of generalized unboundedness properties that can\nbe verified in exponential space by extending Rackoff's technique, sometimes in\nan unorthodox way. We obtain new optimal upper bounds, for example for\nplace-boundedness problem, reversal-boundedness detection (several variants\nexist), strong promptness detection problem and regularity detection. Our\nanalysis is sufficiently refined so as we also obtain a polynomial-space bound\nwhen the dimension is fixed.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0217v1"
    },
    {
        "title": "Non-Uniform Cellular Automata: classes, dynamics, and decidability",
        "authors": [
            "Alberto Dennunzio",
            "Enrico Formenti",
            "Julien Provillard"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  The dynamical behavior of non-uniform cellular automata is compared with the\none of classical cellular automata. Several differences and similarities are\npointed out by a series of examples. Decidability of basic properties like\nsurjectivity and injectivity is also established. The final part studies a\nstrong form of equicontinuity property specially suited for non-uniform\ncellular automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1107.5228v1"
    },
    {
        "title": "Decoupled execution of synchronous coordination models via behavioural\n  automata",
        "authors": [
            "José Proença",
            "Dave Clarke",
            "Erik de Vink",
            "Farhad Arbab"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  Synchronous coordination systems allow the exchange of data by logically\nindivisible actions involving all coordinated entities. This paper introduces\nbehavioural automata, a logically synchronous coordination model based on the\nReo coordination language, which focuses on relevant aspects for the concurrent\nevolution of these systems. We show how our automata model encodes the Reo and\nLinda coordination models and how it introduces an explicit predicate that\ncaptures the concurrent evolution, distinguishing local from global actions,\nand lifting the need of most synchronous models to involve all entities at each\ncoordination step, paving the way to more scalable implementations.\n",
        "pdf_link": "http://arxiv.org/pdf/1108.0232v1"
    },
    {
        "title": "Some Problems in Automata Theory Which Depend on the Models of Set\n  Theory",
        "authors": [
            "Olivier Finkel"
        ],
        "category": "cs.FL",
        "published_year": "2011",
        "summary": "  We prove that some fairly basic questions on automata reading infinite words\ndepend on the models of the axiomatic system ZFC. It is known that there are\nonly three possibilities for the cardinality of the complement of an\nomega-language $L(A)$ accepted by a B\\\"uchi 1-counter automaton $A$. We prove\nthe following surprising result: there exists a 1-counter B\\\"uchi automaton $A$\nsuch that the cardinality of the complement $L(A)^-$ of the omega-language\n$L(A)$ is not determined by ZFC: (1). There is a model $V_1$ of ZFC in which\n$L(A)^-$ is countable. (2). There is a model $V_2$ of ZFC in which $L(A)^-$ has\ncardinal $2^{\\aleph_0}$. (3). There is a model $V_3$ of ZFC in which $L(A)^-$\nhas cardinal $\\aleph_1$ with $\\aleph_0<\\aleph_1<2^{\\aleph_0}$. We prove a very\nsimilar result for the complement of an infinitary rational relation accepted\nby a 2-tape B\\\"uchi automaton $B$. As a corollary, this proves that the\nContinuum Hypothesis may be not satisfied for complements of 1-counter\nomega-languages and for complements of infinitary rational relations accepted\nby 2-tape B\\\"uchi automata. We infer from the proof of the above results that\nbasic decision problems about 1-counter omega-languages or infinitary rational\nrelations are actually located at the third level of the analytical hierarchy.\nIn particular, the problem to determine whether the complement of a 1-counter\nomega-language (respectively, infinitary rational relation) is countable is in\n$\\Sigma_3^1 \\setminus (\\Pi_2^1 \\cup \\Sigma_2^1)$. This is rather surprising if\ncompared to the fact that it is decidable whether an infinitary rational\nrelation is countable (respectively, uncountable).\n",
        "pdf_link": "http://arxiv.org/pdf/1108.2864v1"
    },
    {
        "title": "Deciding Word Problems of Semigroups using Finite State Automata",
        "authors": [
            "Max Neunhöffer",
            "Markus Pfeiffer",
            "Nik Ruskuc"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We explore a natural class of semigroups that have word problem decidable by\nfinite state automata. Among the main results are invariance of this property\nunder change of generators, invariance under basic algebraic constructions and\nalgebraic properties of these semigroups.\n",
        "pdf_link": "http://arxiv.org/pdf/1206.1714v4"
    },
    {
        "title": "On Generating *-Sound Nets with Substitution",
        "authors": [
            "Jacek Sroka",
            "Jan Hidders"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  We present a method for hierarchically generating sound workflow nets by\nsubstitution of nets with multiple inputs and outputs. We show that this method\nis correct and generalizes the class of nets generated by other hierarchical\napproaches. The method involves a new notion of soundness which is preserved by\nthe generalized type of substitution that is presented in this paper. We show\nthat this notion is better suited than *-soundness for use with the presented\ntype of generalized substitution, since {*}-soundness is not preserved by it.\nIt is moreover shown that it is in some sense the optimal notion of soundness\nfor the purpose of generating sound nets by the presented type of substitution.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2654v4"
    },
    {
        "title": "Approximating Weak Bisimilarity of Basic Parallel Processes",
        "authors": [
            "Piotr Hofman",
            "Patrick Totzke"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  This paper explores the well known approximation approach to decide weak\nbisimilarity of Basic Parallel Processes. We look into how different refinement\nfunctions can be used to prove weak bisimilarity decidable for certain\nsubclasses. We also show their limitations for the general case. In particular,\nwe show a lower bound of {\\omega} \\ast {\\omega} for the approximants which\nallow weak steps and a lower bound of {\\omega} + {\\omega} for the approximants\nthat allow sequences of actions. The former lower bound negatively answers the\nopen question of Jan\\v{c}ar and Hirshfeld.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2751v1"
    },
    {
        "title": "A Universal Semi-totalistic Cellular Automaton on Kite and Dart Penrose\n  Tilings",
        "authors": [
            "Katsunobu Imai",
            "Takahiro Hatsuda",
            "Victor Poupet",
            "Kota Sato"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this paper we investigate certain properties of semi-totalistic cellular\nautomata (CA) on the well known quasi-periodic kite and dart two dimensional\ntiling of the plane presented by Roger Penrose. We show that, despite the\nirregularity of the underlying grid, it is possible to devise a semi-totalistic\nCA capable of simulating any boolean circuit on this aperiodic tiling.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.2771v1"
    },
    {
        "title": "Is Wolfram and Cook's (2,5) Turing machine really universal?",
        "authors": [
            "Dominic J. D. Hughes"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  Wolfram [2, p. 707] and Cook [1, p. 3] claim to prove that a (2,5) Turing\nmachine (2 states, 5 symbols) is universal, via a universal cellular automaton\nknown as Rule 110. The first part of this paper points out a critical gap in\ntheir argument. The second part bridges the gap, thereby giving what appears to\nbe the first proof of universality.\n",
        "pdf_link": "http://arxiv.org/pdf/1208.6342v1"
    },
    {
        "title": "Symbolic Representation of Algorithmic Game Semantics",
        "authors": [
            "Aleksandar S. Dimovski"
        ],
        "category": "cs.FL",
        "published_year": "2012",
        "summary": "  In this paper we revisit the regular-language representation of game\nsemantics of second-order recursion free Idealized Algol with infinite data\ntypes. By using symbolic values instead of concrete ones we generalize the\nstandard notion of regular-language and automata representations to that of\ncorresponding symbolic representations. In this way terms with infinite data\ntypes, such as integers, can be expressed as finite symbolic-automata although\nthe standard automata interpretation is infinite. Moreover, significant\nreductions of the state space of game semantics models are obtained. This\nenables efficient verification of terms, which is illustrated with several\nexamples.\n",
        "pdf_link": "http://arxiv.org/pdf/1210.2454v1"
    },
    {
        "title": "Topological dynamics and recognition of languages",
        "authors": [
            "Benjamin Steinberg"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We define compact automata and show that every language has a unique minimal\ncompact automaton. We also define recognition of languages by compact left\nsemitopological monoids and construct the analogue of the syntactic monoid in\nthis context. For rational languages this reduces to the usual theory of finite\nautomata and finite monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1306.1468v1"
    },
    {
        "title": "A Small Universal Petri Net",
        "authors": [
            "Dmitry A. Zaitsev"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  A universal deterministic inhibitor Petri net with 14 places, 29 transitions\nand 138 arcs was constructed via simulation of Neary and Woods' weakly\nuniversal Turing machine with 2 states and 4 symbols; the total time complexity\nis exponential in the running time of their weak machine. To simulate the blank\nwords of the weakly universal Turing machine, a couple of dedicated transitions\ninsert their codes when reaching edges of the working zone. To complete a chain\nof a given Petri net encoding to be executed by the universal Petri net, a\ntranslation of a bi-tag system into a Turing machine was constructed. The\nconstructed Petri net is universal in the standard sense; a weaker form of\nuniversality for Petri nets was not introduced in this work.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.1274v1"
    },
    {
        "title": "Abelian networks I. Foundations and examples",
        "authors": [
            "Benjamin Bond",
            "Lionel Levine"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  In Deepak Dhar's model of abelian distributed processors, automata occupy the\nvertices of a graph and communicate via the edges. We show that two simple\naxioms ensure that the final output does not depend on the order in which the\nautomata process their inputs. A collection of automata obeying these axioms is\ncalled an \"abelian network\". We prove a least action principle for abelian\nnetworks. As an application, we show how abelian networks can solve certain\nlinear and nonlinear integer programs asynchronously.\n  In most previously studied abelian networks, the input alphabet of each\nautomaton consists of a single letter; in contrast, we propose two non-unary\nexamples of abelian networks: \"oil and water\" and \"abelian mobile agents\".\n",
        "pdf_link": "http://arxiv.org/pdf/1309.3445v3"
    },
    {
        "title": "Chemical concrete machine",
        "authors": [
            "Marius Buliga"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The chemical concrete machine is a graph rewriting system which uses only\nlocal moves (rewrites), seen as chemical reactions involving molecules which\nare graphs made up by 4 trivalent nodes. It is Turing complete, therefore it\nmight be used as a model of computation in algorithmic chemistry.\n",
        "pdf_link": "http://arxiv.org/pdf/1309.6914v1"
    },
    {
        "title": "Ehrenfeucht-Fraisse Games on Omega-Terms",
        "authors": [
            "Martin Huschenbett",
            "Manfred Kufleitner"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  Fragments of first-order logic over words can often be characterized in terms\nof finite monoids or finite semigroups. Usually these algebraic descriptions\nyield decidability of the question whether a given regular language is\ndefinable in a particular fragment. An effective algebraic characterization can\nbe obtained from identities of so-called omega-terms. In order to show that a\ngiven fragment satisfies some identity of omega-terms, one can use\nEhrenfeucht-Fraisse games on word instances of the omega-terms. The resulting\nproofs often require a significant amount of book-keeping with respect to the\nconstants involved. In this paper we introduce Ehrenfeucht-Fraisse games on\nomega-terms. To this end we assign a labeled linear order to every omega-term.\nOur main theorem shows that a given fragment satisfies some identity of\nomega-terms if and only if Duplicator has a winning strategy for the game on\nthe resulting linear orders. This allows to avoid the book-keeping. As an\napplication of our main result, we show that one can decide in exponential time\nwhether all aperiodic monoids satisfy some given identity of omega-terms,\nthereby improving a result of McCammond (Int. J. Algebra Comput., 2001).\n",
        "pdf_link": "http://arxiv.org/pdf/1310.3195v1"
    },
    {
        "title": "Weak Singular Hybrid Automata",
        "authors": [
            "Shankara Narayanan Krishna",
            "Umang Mathur",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The framework of Hybrid automata, introduced by Alur, Courcourbetis,\nHenzinger, and Ho, provides a formal modeling and analysis environment to\nanalyze the interaction between the discrete and the continuous parts of\ncyber-physical systems. Hybrid automata can be considered as generalizations of\nfinite state automata augmented with a finite set of real-valued variables\nwhose dynamics in each state is governed by a system of ordinary differential\nequations. Moreover, the discrete transitions of hybrid automata are guarded by\nconstraints over the values of these real-valued variables, and enable\ndiscontinuous jumps in the evolution of these variables. Singular hybrid\nautomata are a subclass of hybrid automata where dynamics is specified by\nstate-dependent constant vectors. Henzinger, Kopke, Puri, and Varaiya showed\nthat for even very restricted subclasses of singular hybrid automata, the\nfundamental verification questions, like reachability and schedulability, are\nundecidable. In this paper we present \\emph{weak singular hybrid automata}\n(WSHA), a previously unexplored subclass of singular hybrid automata, and show\nthe decidability (and the exact complexity) of various verification questions\nfor this class including reachability (NP-Complete) and LTL model-checking\n(PSPACE-Complete). We further show that extending WSHA with a single\nunrestricted clock or extending WSHA with unrestricted variable updates lead to\nundecidability of reachability problem.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.3826v3"
    },
    {
        "title": "Proceedings Second International Workshop on Trends in Tree Automata and\n  Tree Transducers",
        "authors": [
            "Sebastian Maneth"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  This volume contains the papers that were presented at the second\ninternational workshop on Trends in Tree Automata and Transducers (TTATT 2013)\nwhich took place on October 19th, 2013 in Hanoi/Vietnam. The workshop was\ncolocated with the verification conference ATVA. The first edition of the\nworkshop was colocated with RTA and took place in Nagoya/Japan. The interest of\nthe workshop lies at the intersection of programming languages, verification,\nand database theory, which are areas to which tree automata and transducers are\napplied recently.\n",
        "pdf_link": "http://arxiv.org/pdf/1311.5058v1"
    },
    {
        "title": "Periodic configurations of subshifts on groups",
        "authors": [
            "Francesca Fiorenzi"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the density of periodic configurations for shift spaces defined on\n(the Cayley graph of) a finitely generated group. We prove that in the case of\na full shift on a residually finite group and in that of a group shift space on\nan abelian group, the periodic configurations are dense. In the one-dimensional\ncase we prove the density for irreducible sofic shifts. In connection with this\nwe study the surjunctivity of cellular automata and local selfmappings. Some\nrelated decision problems for shift spaces of finite type are also\ninvestigated.\n",
        "pdf_link": "http://arxiv.org/pdf/1402.3448v1"
    },
    {
        "title": "Quantum finite automata: A modern introduction",
        "authors": [
            "A. C. Cem Say",
            "Abuzer Yakaryilmaz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present five examples where quantum finite automata (QFAs) outperform\ntheir classical counterparts. This may be useful as a relatively simple\ntechnique to introduce quantum computation concepts to computer scientists. We\nalso describe a modern QFA model involving superoperators that is able to\nsimulate all known QFA and classical finite automaton variants.\n",
        "pdf_link": "http://arxiv.org/pdf/1406.4048v1"
    },
    {
        "title": "Distributed Graph Automata and Verification of Distributed Algorithms",
        "authors": [
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Combining ideas from distributed algorithms and alternating automata, we\nintroduce a new class of finite graph automata that recognize precisely the\nlanguages of finite graphs definable in monadic second-order logic. By\nrestricting transitions to be nondeterministic or deterministic, we also obtain\ntwo strictly weaker variants of our automata for which the emptiness problem is\ndecidable. As an application, we suggest how suitable graph automata might be\nuseful in formal verification of distributed algorithms, using Floyd-Hoare\nlogic.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.3030v2"
    },
    {
        "title": "Maximally Permissive Controlled System Synthesis for Modal Logic",
        "authors": [
            "Allan van Hulst",
            "Michel Reniers",
            "Wan Fokkink"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We propose a new method for controlled system synthesis on non-deterministic\nautomata, which includes the synthesis for deadlock-freeness, as well as\ninvariant and reachability expressions. Our technique restricts the behavior of\na Kripke-structure with labeled transitions, representing the uncontrolled\nsystem, such that it adheres to a given requirement specification in an\nexpressive modal logic. while all non-invalidating behavior is retained. This\ninduces maximal permissiveness in the context of supervisory control. Research\npresented in this paper allows a system model to be constrained according to a\nbroad set of liveness, safety and fairness specifications of desired behavior,\nand embraces most concepts from Ramadge-Wonham supervisory control, including\ncontrollability and marker-state reachability. Synthesis is defined in this\npaper as a formal construction, which allowed a careful validation of its\ncorrectness using the Coq proof assistant.\n",
        "pdf_link": "http://arxiv.org/pdf/1408.3317v1"
    },
    {
        "title": "Weighted automata on infinite words in the context of Attacker-Defender\n  games",
        "authors": [
            "Vesa Halava",
            "Tero Harju",
            "Reino Niskanen",
            "Igor Potapov"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We consider infinite-state Attacker-Defender games with reachability\nobjectives. The results of the paper are twofold. Firstly we prove a new\nlanguage-theoretic result for weighted automata on infinite words and show its\nencoding into the framework of Attacker-Defender games. Secondly we use this\nnovel concept to prove undecidability for checking existence of a winning\nstrategy in several low-dimensional mathematical games including vector\nreachability games, word games and braid games.\n",
        "pdf_link": "http://arxiv.org/pdf/1411.4796v3"
    },
    {
        "title": "Reachability in Two-Dimensional Vector Addition Systems with States is\n  PSPACE-complete",
        "authors": [
            "Michael Blondin",
            "Alain Finkel",
            "Stefan Göller",
            "Christoph Haase",
            "Pierre McKenzie"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Determining the complexity of the reachability problem for vector addition\nsystems with states (VASS) is a long-standing open problem in computer science.\nLong known to be decidable, the problem to this day lacks any complexity upper\nbound whatsoever. In this paper, reachability for two-dimensional VASS is shown\nPSPACE-complete. This improves on a previously known doubly exponential time\nbound established by Howell, Rosier, Huynh and Yen in 1986. The coverability\nand boundedness problems are also noted to be PSPACE-complete. In addition,\nsome complexity results are given for the reachability problem in\ntwo-dimensional VASS and in integer VASS when numbers are encoded in unary.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.4259v1"
    },
    {
        "title": "New results on classical and quantum counter automata",
        "authors": [
            "Masaki Nakanishi",
            "Abuzer Yakaryılmaz",
            "Aida Gainutdinova"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We show that one-way quantum one-counter automaton with zero-error is more\npowerful than its probabilistic counterpart on promise problems. Then, we\nobtain a similar separation result between Las Vegas one-way probabilistic\none-counter automaton and one-way deterministic one-counter automaton.\n  We also obtain new results on classical counter automata regarding language\nrecognition. It was conjectured that one-way probabilistic one blind-counter\nautomata cannot recognize Kleene closure of equality language [A. Yakaryilmaz:\nSuperiority of one-way and realtime quantum machines. RAIRO - Theor. Inf. and\nApplic. 46(4): 615-641 (2012)]. We show that this conjecture is false, and also\nshow several separation results for blind/non-blind counter automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1412.6761v4"
    },
    {
        "title": "Graph Grammars, Insertion Lie Algebras, and Quantum Field Theory",
        "authors": [
            "Matilde Marcolli",
            "Alexander Port"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Graph grammars extend the theory of formal languages in order to model\ndistributed parallelism in theoretical computer science. We show here that to\ncertain classes of context-free and context-sensitive graph grammars one can\nassociate a Lie algebra, whose structure is reminiscent of the insertion Lie\nalgebras of quantum field theory. We also show that the Feynman graphs of\nquantum field theories are graph languages generated by a theory dependent\ngraph grammar.\n",
        "pdf_link": "http://arxiv.org/pdf/1502.07796v1"
    },
    {
        "title": "An Upper Bound on the Complexity of Recognizable Tree Languages",
        "authors": [
            "Olivier Finkel",
            "Dominique Lecomte",
            "Pierre Simonnet"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  The third author noticed in his 1992 PhD Thesis [Sim92] that every regular\ntree language of infinite trees is in a class $\\Game (D\\_n({\\bf\\Sigma}^0\\_2))$\nfor some natural number $n\\geq 1$, where $\\Game$ is the game quantifier. We\nfirst give a detailed exposition of this result. Next, using an embedding of\nthe Wadge hierarchy of non self-dual Borel subsets of the Cantor space\n$2^\\omega$ into the class ${\\bf\\Delta}^1\\_2$, and the notions of Wadge degree\nand Veblen function, we argue that this upper bound on the topological\ncomplexity of regular tree languages is much better than the usual\n${\\bf\\Delta}^1\\_2$.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.02840v2"
    },
    {
        "title": "On the decomposition of stochastic cellular automata",
        "authors": [
            "Witold Bołt",
            "Jan M. Baetens",
            "Bernard DeBaets"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  In this paper we present two interesting properties of stochastic cellular\nautomata that can be helpful in analyzing the dynamical behavior of such\nautomata. The first property allows for calculating cell-wise probability\ndistributions over the state set of a stochastic cellular automaton, i.e.\nimages that show the average state of each cell during the evolution of the\nstochastic cellular automaton. The second property shows that stochastic\ncellular automata are equivalent to so-called stochastic mixtures of\ndeterministic cellular automata. Based on this property, any stochastic\ncellular automaton can be decomposed into a set of deterministic cellular\nautomata, each of which contributes to the behavior of the stochastic cellular\nautomaton.\n",
        "pdf_link": "http://arxiv.org/pdf/1503.03318v2"
    },
    {
        "title": "Timed Orchestration for Component-based Systems",
        "authors": [
            "Chih-Hong Cheng",
            "Lacramioara Astefanoaei",
            "Harald Ruess",
            "Souha Ben Rayana",
            "Saddek Bensalem"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Individual machines in flexible production lines explicitly expose\ncapabilities at their interfaces by means of parametric skills. Given such a\nset of configurable machines, a line integrator is faced with the problem of\nfinding and tuning parameters for each machine such that the overall production\nline implements given safety and temporal requirements in an optimized and\nrobust fashion. We formalize this problem of configuring and orchestrating\nflexible production lines as a parameter synthesis problem for systems of\nparametric timed automata, where interactions are based on skills. Parameter\nsynthesis problems for interaction-level LTL properties are translated to\nparameter synthesis problems for state-based safety properties. For safety\nproperties, synthesis problems are solved by checking satisfiability of\n$\\exists\\forall$SMT constraints. For constraint generation, we provide a set of\ncomputationally cheap over-approximations of the set of reachable states,\ntogether with fence constructions as sufficient conditions for safety formulas.\nWe demonstrate the feasibility of our approach by solving typical machine\nconfiguration problems as encountered in industrial automation.\n",
        "pdf_link": "http://arxiv.org/pdf/1504.05513v3"
    },
    {
        "title": "Automata and Quantum Computing",
        "authors": [
            "Andris Ambainis",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Quantum computing is a new model of computation, based on quantum physics.\nQuantum computers can be exponentially faster than conventional computers for\nproblems such as factoring. Besides full-scale quantum computers, more\nrestricted models such as quantum versions of finite automata have been\nstudied. In this paper, we survey various models of quantum finite automata and\ntheir properties. We also provide some open questions and new directions for\nresearchers.\n  Keywords: quantum finite automata, probabilistic finite automata,\nnondeterminism, bounded error, unbounded error, state complexity, decidability\nand undecidability, computational complexity\n",
        "pdf_link": "http://arxiv.org/pdf/1507.01988v2"
    },
    {
        "title": "Translation-like Actions and Aperiodic Subshifts on Groups",
        "authors": [
            "Emmanuel Jeandel"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  It is well known that if $G$ admits a f.g. subgroup $H$ with a\nweaklyaperiodic SFT (resp. an undecidable domino problem), then $G$itself has a\nweakly aperiodic SFT (resp. an undecidable domino problem).We prove that we can\nreplace the property \"$H$ is a subgroup of $G$\"by \"$H$ acts translation-like on\n$G$\", provided $H$ is finitely presented.In particular:* If $G\\_1$ and $G\\_2$\nare f.g. infinite groups, then $G\\_1 \\times G\\_2$ has a weakly aperiodic SFT\n(and actually a undecidable domino problem). In particular the Grigorchuk group\nhas an undecidable domino problem. * Every infinite f.g. $p$-group admits a\nweakly aperiodic SFT.\n",
        "pdf_link": "http://arxiv.org/pdf/1508.06419v1"
    },
    {
        "title": "Cross-boundary Behavioural Reprogrammability Reveals Evidence of\n  Pervasive Universality",
        "authors": [
            "Jürgen Riedel",
            "Hector Zenil"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We exhaustively explore the reprogrammability capabilities and the intrinsic\nuniversality of the Cartesian product $P \\times C$ of the space $P$ of all\npossible computer programs of increasing size and the space $C$ of all possible\ncompilers of increasing length such that $p \\in P$ emulates $p^\\prime \\in P$\nwith $T|p^\\prime|=|p|$ under a coarse-graining transformation $T$. Our approach\nyields a novel perspective on the complexity, controllability, causality and\n(re)programmability discrete dynamical systems. We find evidence that the\ndensity of (qualitatively different) computer programs that can be reprogrammed\ngrows asymptotically as a function of program and compiler size. To illustrate\nthese findings we show a series of behavioural boundary crossing results,\nincluding emulations (for all initial conditions) of Wolfram class 2 Elementary\nCellular Automata (ECA) by Class 1 ECA, emulations of Classes 1, 2 and 3 ECA by\nClass 2 and 3 ECA, and of Classes 1, 2 and 3 by Class 3 ECA, along with results\nof even greater emulability for general CA (neighbourhood $r=3/2$), including\nClass 1 CA emulating Classes 2 and 3, and Classes 3 and 4 emulating all other\nclasses (1, 2, 3 and 4). The emulations occur with only a linear overhead and\ncan be considered computationally efficient. We also found that there is no\nhacking strategy to compress the search space based on compiler profiling in\nterms of e.g. similarity or complexity, suggesting that no strategy other than\nexhaustive search is viable. We also introduce emulation networks, derive a\ntopologically-based measure of complexity based upon out- and in-degree\nconnectivity, and establish bridges to fundamental ideas of complexity,\nuniversality, causality and dynamical systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.01671v15"
    },
    {
        "title": "Forkable Regular Expressions",
        "authors": [
            "Martin Sulzmann",
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We consider forkable regular expressions, which enrich regular expressions\nwith a fork operator, to establish a formal basis for static and dynamic\nanalysis of the communication behavior of concurrent programs. We define a\nnovel compositional semantics for forkable expressions, establish their\nfundamental properties, and define derivatives for them as a basis for the\ngeneration of automata, for matching, and for language containment tests.\nForkable expressions may give rise to non-regular languages, in general, but we\nidentify sufficient conditions on expressions that guarantee finiteness of the\nautomata construction via derivatives.\n",
        "pdf_link": "http://arxiv.org/pdf/1510.07293v2"
    },
    {
        "title": "Affine computation and affine automaton",
        "authors": [
            "Alejandro Díaz-Caro",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We introduce a quantum-like classical computational model, called affine\ncomputation, as a generalization of probabilistic computation. After giving the\nbasics of affine computation, we define affine finite automata (AfA) and\ncompare it with quantum and probabilistic finite automata (QFA and PFA,\nrespectively) with respect to three basic language recognition modes. We show\nthat, in the cases of bounded and unbounded error, AfAs are more powerful than\nQFAs and PFAs, and, in the case of nondeterministic computation, AfAs are more\npowerful than PFAs but equivalent to QFAs.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.04732v2"
    },
    {
        "title": "Symmetry Breaking Predicates for SAT-based DFA Identification",
        "authors": [
            "Vladimir Ulyantsev",
            "Ilya Zakirzyanov",
            "Anatoly Shalyto"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  It was shown before that the NP-hard problem of deterministic finite automata\n(DFA) identification can be effectively translated to Boolean satisfiability\n(SAT). Modern SAT-solvers can tackle hard DFA identification instances\nefficiently. We present a technique to reduce the problem search space by\nenforcing an enumeration of DFA states in depth-first search (DFS) or\nbreadth-first search (BFS) order. We propose symmetry breaking predicates,\nwhich can be added to Boolean formulae representing various DFA identification\nproblems. We show how to apply this technique to DFA identification from both\nnoiseless and noisy data. Also we propose a method to identify all automata of\nthe desired size. The proposed approach outperforms the current\nstate-of-the-art DFASAT method for DFA identification from noiseless data. A\nbig advantage of the proposed approach is that it allows to determine exactly\nthe existence or non-existence of a solution of the noisy DFA identification\nproblem unlike metaheuristic approaches such as genetic algorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05028v2"
    },
    {
        "title": "Language recognition power and succintness of affine automata",
        "authors": [
            "Marcos Villagra",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this work we study a non-linear generalization based on affine\ntransformations of probabilistic and quantum automata proposed recently by\nD\\'iaz-Caro and Yakary{\\i}lmaz \\cite{DCY16A} referred as affine automata.\nFirst, we present efficient simulations of probabilistic and quantum automata\nby means of affine automata which allows us to characterize the class of\nexclusive stochastic languages. Then, we initiate a study on the succintness of\naffine automata. In particular, we show that an infinite family of unary\nregular languages can be recognized by 2-state affine automata but the state\nnumbers of quantum and probabilistic automata cannot be bounded. Finally, we\npresent the characterization of all (regular) unary languages recognized by\ntwo-state affine automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.05432v2"
    },
    {
        "title": "Can one quantum bit separate any pair of words with zero-error?",
        "authors": [
            "Aleksandrs Belovs",
            "Juan Andres Montoya",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Determining the minimum number of states required by a finite automaton to\nseparate a given pair of different words is an important problem. In this\npaper, we consider this problem for quantum automata (QFAs). We show that\n2-state QFAs can separate any pair of words in nondeterministic acceptance mode\nand conjecture that they can separate any pair also with zero-error. Then, we\nfocus on (a more general problem) separating a pair of two disjoint finite set\nof words. We show that QFAs can separate them efficiently in nondeterministic\nacceptance mode, i.e. the number of states is two to the power of the size of\nthe small set. Additionally, we examine affine finite automata (AfAs) and show\nthat two states are enough to separate any pair with zero-error. Moreover, AfAs\ncan separate any pair of disjoint finite sets of words with one-sided bounded\nerror efficiently like QFAs in nondeterministic mode.\n",
        "pdf_link": "http://arxiv.org/pdf/1602.07967v1"
    },
    {
        "title": "Representing Extended Finite State Machines for SDL by A Novel Control\n  Model of Discrete Event Systems",
        "authors": [
            "Peng Wang",
            "Kai-Yuan Cai"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  This paper discusses EFSM for SDL and transforms EFSM into a novel control\nmodel of discrete event systems. We firstly propose a control model of discrete\nevent systems, where the event set is made up of several conflicting pairs and\ncontrol is implemented to select one event of the pair. Then we transform EFSM\nfor SDL to the control model to clarify the control mechanism functioning in\nSDL flow graphs. This work views the EFSM for SDL in the perspective of\nsupervisory control theory, and this contributes to the field of software\ncybernetics, which explores the theoretically justified interplay of software\nand the control.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.07585v1"
    },
    {
        "title": "Complexity Bounds of Constant-Space Quantum Computation",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We realize constant-space quantum computation by measure-many two-way quantum\nfinite automata and evaluate their language recognition power by analyzing\npatterns of their exotic behaviors and by exploring their structural\nproperties. In particular, we show that, when the automata halt \"in finite\nsteps\" along all computation paths, they must terminate in worst-case liner\ntime. In the bounded-error probability case, the acceptance of the automata\ndepends only on the computation paths that terminate within exponentially many\nsteps even if not all computation paths may terminate. We also present a\nclassical simulation of those automata on two-way multi-head probabilistic\nfinite automata with cut points. Moreover, we discuss how the recognition power\nof the automata varies as the automata's acceptance criteria change to error\nfree, one-sided error, bounded error, and unbounded error by comparing the\ncomplexity of their computational powers. We further note that, with the use of\narbitrary complex transition amplitudes, two-way unbounded-error quantum finite\nautomata and two-way bounded-error 2-head quantum finite automata can recognize\ncertain non-recursive languages, whereas two-way error-free quantum finite\nautomata recognize only recursive languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1606.08764v1"
    },
    {
        "title": "Nominal Cellular Automata",
        "authors": [
            "Tommaso Bolognesi",
            "Vincenzo Ciancia"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  The emerging field of Nominal Computation Theory is concerned with the theory\nof Nominal Sets and its applications to Computer Science. We investigate here\nthe impact of nominal sets on the definition of Cellular Automata and on their\ncomputational capabilities, with a special focus on the emergent behavioural\nproperties of this new model and their significance in the context of\ncomputation-oriented interpretations of physical phenomena. A preliminary\ninvestigation of the relations between Nominal Cellular Automata and Wolfram's\nElementary Cellular Automata is also carried out.\n",
        "pdf_link": "http://arxiv.org/pdf/1608.03320v1"
    },
    {
        "title": "Pro-aperiodic monoids via saturated models",
        "authors": [
            "Samuel J. v. Gool",
            "Benjamin Steinberg"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We apply Stone duality and model theory to study the structure theory of free\npro-aperiodic monoids. Stone duality implies that elements of the free\npro-aperiodic monoid may be viewed as elementary equivalence classes of\npseudofinite words. Model theory provides us with saturated words in each such\nclass, i.e., words in which all possible factorizations are realized. We give\nseveral applications of this new approach, including a solution to the word\nproblem for $\\omega$-terms that avoids using McCammond's normal forms, as well\nas new proofs and extensions of other structural results concerning free\npro-aperiodic monoids.\n",
        "pdf_link": "http://arxiv.org/pdf/1609.07736v2"
    },
    {
        "title": "Operational Calculus for Differentiable Programming",
        "authors": [
            "Žiga Sajovic",
            "Martin Vuk"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this work we present a theoretical model for differentiable programming.\nWe construct an algebraic language that encapsulates formal semantics of\ndifferentiable programs by way of Operational Calculus. The algebraic nature of\nOperational Calculus can alter the properties of the programs that are\nexpressed within the language and transform them into their solutions.\n  In our model programs are elements of programming spaces and viewed as maps\nfrom the virtual memory space to itself. Virtual memory space is an algebra of\nprograms, an algebraic data structure one can calculate with. We define the\noperator of differentiation ($\\partial$) on programming spaces and, using its\npowers, implement the general shift operator and the operator of program\ncomposition. We provide the formula for the expansion of a differentiable\nprogram into an infinite tensor series in terms of the powers of $\\partial$. We\nexpress the operator of program composition in terms of the generalized shift\noperator and $\\partial$, which implements a differentiable composition in the\nlanguage. Such operators serve as abstractions over the tensor series algebra,\nas main actors in our language.\n  We demonstrate our models usefulness in differentiable programming by using\nit to analyse iterators, deriving fractional iterations and their iterating\nvelocities, and explicitly solve the special case of ReduceSum.\n",
        "pdf_link": "http://arxiv.org/pdf/1610.07690v6"
    },
    {
        "title": "Exact Affine Counter Automata",
        "authors": [
            "Masaki Nakanishi",
            "Kamil Khadiev",
            "Krišjānis Prūsis",
            "Jevgēnijs Vihrovs",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce an affine generalization of counter automata, and analyze their\nability as well as affine finite automata. Our contributions are as follows. We\nshow that there is a language that can be recognized by exact realtime affine\ncounter automata but by neither 1-way deterministic pushdown automata nor\nrealtime deterministic k-counter automata. We also show that a certain promise\nproblem, which is conjectured not to be solved by two-way quantum finite\nautomata in polynomial time, can be solved by Las Vegas affine finite automata.\nLastly, we show that how a counter helps for affine finite automata by showing\nthat the language MANYTWINS, which is conjectured not to be recognized by\naffine, quantum or classical finite state models in polynomial time, can be\nrecognized by affine counter automata with one-sided bounded-error in realtime.\n",
        "pdf_link": "http://arxiv.org/pdf/1703.04281v3"
    },
    {
        "title": "Rewriting Context-free Families of String Diagrams",
        "authors": [
            "Vladimir Nikolaev Zamdzhiev"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  String diagrams provide a convenient graphical framework which may be used\nfor equational reasoning about morphisms of monoidal categories. However,\nunlike term rewriting, rewriting string diagrams results in shorter equational\nproofs, because the string diagrammatic representation allows us to formally\nestablish equalities modulo any rewrite steps which follow from the monoidal\nstructure.\n  Manipulating string diagrams by hand is a time-consuming and error-prone\nprocess, especially for large string diagrams. This can be ameliorated by using\nsoftware proof assistants, such as Quantomatic.\n  However, reasoning about concrete string diagrams may be limiting and in some\nscenarios it is necessary to reason about entire (infinite) families of string\ndiagrams. When doing so, we face the same problems as for manipulating concrete\nstring diagrams, but in addition, we risk making further mistakes if we are not\nprecise enough about the way we represent (infinite) families of string\ndiagrams.\n  The primary goal of this thesis is to design a mathematical framework for\nequational reasoning about infinite families of string diagrams which is\namenable to computer automation. We will be working with context-free families\nof string diagrams and we will represent them using context-free graph\ngrammars. We will model equations between infinite families of diagrams using\nrewrite rules between context-free grammars. Our framework represents\nequational reasoning about concrete string diagrams and context-free families\nof string diagrams using double-pushout rewriting on graphs and context-free\ngraph grammars respectively. We will prove that our representation is sound by\nshowing that it respects the concrete semantics of string diagrammatic\nreasoning and we will show that our framework is appropriate for software\nimplementation by proving important decidability properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.07520v1"
    },
    {
        "title": "Grammatical Inference as a Satisfiability Modulo Theories Problem",
        "authors": [
            "Rick Smetsers"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  The problem of learning a minimal consistent model from a set of labeled\nsequences of symbols is addressed from a satisfiability modulo theories\nperspective. We present two encodings for deterministic finite automata and\nextend one of these for Moore and Mealy machines. Our experimental results show\nthat these encodings improve upon the state-of-the-art, and are useful in\npractice for learning small models.\n",
        "pdf_link": "http://arxiv.org/pdf/1705.10639v1"
    },
    {
        "title": "A Computational Interpretation of Context-Free Expressions",
        "authors": [
            "Martin Sulzmann",
            "Peter Thiemann"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We phrase parsing with context-free expressions as a type inhabitation\nproblem where values are parse trees and types are context-free expressions. We\nfirst show how containment among context-free and regular expressions can be\nreduced to a reachability problem by using a canonical representation of\nstates. The proofs-as-programs principle yields a computational interpretation\nof the reachability problem in terms of a coercion that transforms the parse\ntree for a context-free expression into a parse tree for a regular expression.\nIt also yields a partial coercion from regular parse trees to context-free\nones. The partial coercion from the trivial language of all words to a\ncontext-free expression corresponds to a predictive parser for the expression.\n",
        "pdf_link": "http://arxiv.org/pdf/1708.07366v1"
    },
    {
        "title": "Verification of Asynchronous Systems with an Unspecified Component",
        "authors": [
            "Rosa Abbasi",
            "Fatemeh Ghassemi",
            "Ramtin Khosravi"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Component-based systems evolve as a new component is added or an existing one\nis replaced by a newer version. Hence, it is appealing to assure the new system\nstill preserves its safety properties. However, instead of inspecting the new\nsystem as a whole, which may result in a large state space, it is beneficial to\nreuse the verification results by inspecting the newly added component in\nisolation. To this aim, we study the problem of model checking component-based\nasynchronously communicating systems in the presence of an unspecified\ncomponent against safety properties. Our solution is based on assume-guarantee\nreasoning, adopted for asynchronous environments, which generates the weakest\nassumption. If the newly added component conforms to the assumption, then the\nwhole system still satisfies the property. To make the approach efficient and\nconvergent, we produce an overapproximated interface of the missing component\nand by its composition with the rest of the system components, we achieve an\noverapproximated specification of the system, from which we remove those traces\nof the system that violate the property and generate an assumption for the\nmissing component.\n  We have implemented our approach on two case studies. Furthermore, we\ncompared our results with the state of the art direct approach. Our resulting\nassumptions are smaller in size and achieved faster.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.03245v1"
    },
    {
        "title": "Neural Network Based Nonlinear Weighted Finite Automata",
        "authors": [
            "Tianyu Li",
            "Guillaume Rabusseau",
            "Doina Precup"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Weighted finite automata (WFA) can expressively model functions defined over\nstrings but are inherently linear models. Given the recent successes of\nnonlinear models in machine learning, it is natural to wonder whether\nex-tending WFA to the nonlinear setting would be beneficial. In this paper, we\npropose a novel model of neural network based nonlinearWFA model (NL-WFA) along\nwith a learning algorithm. Our learning algorithm is inspired by the spectral\nlearning algorithm for WFAand relies on a nonlinear decomposition of the\nso-called Hankel matrix, by means of an auto-encoder network. The expressive\npower of NL-WFA and the proposed learning algorithm are assessed on both\nsynthetic and real-world data, showing that NL-WFA can lead to smaller model\nsizes and infer complex grammatical structures from data.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.04380v2"
    },
    {
        "title": "Reachability Switching Games",
        "authors": [
            "John Fearnley",
            "Martin Gairing",
            "Matthias Mnich",
            "Rahul Savani"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We study the problem of deciding the winner of reachability switching games\nfor zero-, one-, and two-player variants. Switching games provide a\ndeterministic analogue of stochastic games. We show that the zero-player case\nis NL-hard, the one-player case is NP-complete, and that the two-player case is\nPSPACE-hard and in EXPTIME. For the zero-player case, we also show P-hardness\nfor a succinctly-represented model that maintains the upper bound of NP $\\cap$\ncoNP. For the one- and two-player cases, our results hold in both the natural,\nexplicit model and succinctly-represented model. Our results show that the\nswitching variant of a game is harder in complexity-theoretic terms than the\ncorresponding stochastic version.\n",
        "pdf_link": "http://arxiv.org/pdf/1709.08991v7"
    },
    {
        "title": "A bound for the shortest reset words for semisimple synchronizing\n  automata via the packing number",
        "authors": [
            "Emanuele Rodaro"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We show that if a semisimple synchronizing automaton with $n$ states has a\nminimal reachable non-unary subset of cardinality $r\\ge 2$, then there is a\nreset word of length at most $(n-1)D(2,r,n)$, where $D(2,r,n)$ is the\n$2$-packing number for families of $r$-subsets of $[1,n]$.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.00651v1"
    },
    {
        "title": "Recurrent Neural Networks as Weighted Language Recognizers",
        "authors": [
            "Yining Chen",
            "Sorcha Gilroy",
            "Andreas Maletti",
            "Jonathan May",
            "Kevin Knight"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We investigate the computational complexity of various problems for simple\nrecurrent neural networks (RNNs) as formal models for recognizing weighted\nlanguages. We focus on the single-layer, ReLU-activation, rational-weight RNNs\nwith softmax, which are commonly used in natural language processing\napplications. We show that most problems for such RNNs are undecidable,\nincluding consistency, equivalence, minimization, and the determination of the\nhighest-weighted string. However, for consistent RNNs the last problem becomes\ndecidable, although the solution length can surpass all computable bounds. If\nadditionally the string is limited to polynomial length, the problem becomes\nNP-complete and APX-hard. In summary, this shows that approximations and\nheuristic algorithms are necessary in practical applications of those RNNs.\n",
        "pdf_link": "http://arxiv.org/pdf/1711.05408v2"
    },
    {
        "title": "Characterisation of (Sub)sequential Rational Functions over a General\n  Class Monoids",
        "authors": [
            "Stefan Gerdjikov"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this technical report we describe a general class of monoids for which\n(sub)sequential rational can be characterised in terms of a congruence relation\nin the flavour of Myhill-Nerode relation. The class of monoids that we consider\ncan be described in terms of natural algebraic axioms, contains the free\nmonoids, groups, the tropical monoid, and is closed under Cartesian.\n",
        "pdf_link": "http://arxiv.org/pdf/1801.10063v1"
    },
    {
        "title": "A gauge-invariant reversible cellular automaton",
        "authors": [
            "Pablo Arrighi",
            "Giuseppe Di Molfetta",
            "Nathanaël Eon"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Gauge-invariance is a fundamental concept in physics---known to provide the\nmathematical justification for all four fundamental forces. In this paper, we\nprovide discrete counterparts to the main gauge theoretical concepts, directly\nin terms of Cellular Automata. More precisely, we describe a step-by-step\ngauging procedure to enforce local symmetries upon a given Cellular Automaton.\nWe apply it to a simple Reversible Cellular Automaton for concreteness. From a\nComputer Science perspective, discretized gauge theories may be applied to\nnumerical analysis, quantum simulation, fault-tolerant (quantum) computation.\nFrom a mathematical perspective, discreteness provides a simple yet rigorous\nroute straight to the core concepts.\n",
        "pdf_link": "http://arxiv.org/pdf/1802.07644v2"
    },
    {
        "title": "Von Neumann regularity, split epicness and elementary cellular automata",
        "authors": [
            "Ville Salo"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We show that a cellular automaton on a mixing subshift of finite type is a\nVon Neumann regular element in the semigroup of cellular automata if and only\nif it is split epic onto its image in the category of sofic shifts and block\nmaps. It follows from [S.-T\\\"orm\\\"a, 2015] that Von Neumann regularity is\ndecidable condition, and we decide it for all elementary CA.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.03913v3"
    },
    {
        "title": "Decidability of Timed Communicating Automata",
        "authors": [
            "Lorenzo Clemente"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We study the reachability problem for networks of timed communicating\nprocesses. Each process is a timed automaton communicating with other processes\nby exchanging messages over unbounded FIFO channels. Messages carry clocks\nwhich are checked at the time of transmission and reception with suitable\ntiming constraints. Each automaton can only access its set of local clocks and\nmessage clocks of sent/received messages. Time is dense and all clocks evolve\nat the same rate. Our main contribution is a complete characterisation of\ndecidable and undecidable communication topologies generalising and unifying\nprevious work. From a technical point of view, we use quantifier elimination\nand a reduction to counter automata with registers.\n",
        "pdf_link": "http://arxiv.org/pdf/1804.07815v1"
    },
    {
        "title": "Distributed Automata and Logic",
        "authors": [
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Distributed automata are finite-state machines that operate on finite\ndirected graphs. Acting as synchronous distributed algorithms, they use their\ninput graph as a network in which identical processors communicate for a\npossibly infinite number of synchronous rounds. For the local variant of those\nautomata, where the number of rounds is bounded by a constant, Hella et al.\n(2012, 2015) have established a logical characterization in terms of basic\nmodal logic. In this thesis, we provide similar logical characterizations for\ntwo more expressive classes of distributed automata.\n  The first class extends local automata with a global acceptance condition and\nthe ability to alternate between nondeterministic and parallel computations. We\nshow that it is equivalent to monadic second-order logic on graphs. By\nrestricting transitions to be nondeterministic or deterministic, we also obtain\ntwo strictly weaker variants for which the emptiness problem is decidable.\n  Our second class transfers the standard notion of asynchronous algorithm to\nthe setting of nonlocal distributed automata. The resulting machines are shown\nto be equivalent to a small fragment of least fixpoint logic, and more\nspecifically, to a restricted variant of the modal {\\mu}-calculus that allows\nleast fixpoints but forbids greatest fixpoints. Exploiting the connection with\nlogic, we additionally prove that the expressive power of those asynchronous\nautomata is independent of whether or not messages can be lost.\n",
        "pdf_link": "http://arxiv.org/pdf/1805.06238v1"
    },
    {
        "title": "A Trichotomy for Regular Trail Queries",
        "authors": [
            "Wim Martens",
            "Matthias Niewerth",
            "Tina Popp"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Regular path queries (RPQs) are an essential component of graph query\nlanguages. Such queries consider a regular expression r and a directed\nedge-labeled graph G and search for paths in G for which the sequence of labels\nis in the language of r. In order to avoid having to consider infinitely many\npaths, some database engines restrict such paths to be trails, that is, they\nonly consider paths without repeated edges. In this paper we consider the\nevaluation problem for RPQs under trail semantics, in the case where the\nexpression is fixed. We show that, in this setting, there exists a trichotomy.\nMore precisely, the complexity of RPQ evaluation divides the regular languages\ninto the finite languages, the class Ttract (for which the problem is\ntractable), and the rest. Interestingly, the tractable class in the trichotomy\nis larger than for the trichotomy for simple paths, discovered by Bagan,\nBonifati, and Groz [JCSS 2020]. In addition to this trichotomy result, we also\nstudy characterizations of the tractable class, its expressivity, the\nrecognition problem, closure properties, and show how the decision problem can\nbe extended to the enumeration problem, which is relevant to practice.\n",
        "pdf_link": "http://arxiv.org/pdf/1903.00226v5"
    },
    {
        "title": "Reactive Synthesis from Extended Bounded Response LTL Specifications",
        "authors": [
            "Alessandro Cimatti",
            "Luca Geatti",
            "Nicola Gigante",
            "Angelo Montanari",
            "Stefano Tonetta"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Reactive synthesis is a key technique for the design of\ncorrect-by-construction systems and has been thoroughly investigated in the\nlast decades. It consists in the synthesis of a controller that reacts to\nenvironment's inputs satisfying a given temporal logic specification. Common\napproaches are based on the explicit construction of automata and on their\ndeterminization, which limit their scalability.\n  In this paper, we introduce a new fragment of Linear Temporal Logic, called\nExtended Bounded Response LTL (\\LTLEBR), that allows one to combine bounded and\nuniversal unbounded temporal operators (thus covering a large set of practical\ncases), and we show that reactive synthesis from \\LTLEBR specifications can be\nreduced to solving a safety game over a deterministic symbolic automaton built\ndirectly from the specification. We prove the correctness of the proposed\napproach and we successfully evaluate it on various benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.05335v1"
    },
    {
        "title": "Automated Trajectory Synthesis for UAV Swarms Based on Resilient Data\n  Collection Objectives",
        "authors": [
            "A H M Jakaria",
            "Mohammad Ashiqur Rahman",
            "Matthew Anderson",
            "Steven Drager"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The use of Unmanned Aerial Vehicles (UAVs) for collecting data from remotely\nlocated sensor systems is emerging. The data can be time-sensitive and require\nto be transmitted to a data processing center. However, planning the trajectory\nof a collaborative UAV swarm depends on multi-fold constraints, such as data\ncollection requirements, UAV maneuvering capacity, and budget limitation. Since\na UAV may fail or be compromised, it is important to provide necessary\nresilience to such contingencies, thus ensuring data security. It is important\nto provide the UAVs with efficient spatio-temporal trajectories so that they\ncan efficiently cover necessary data sources. In this work, we present\nSynth4UAV, a formal approach for automated synthesis of efficient trajectories\nfor a UAV swarm by logically modeling the aerial space and data point topology,\nUAV moves, and associated constraints in terms of the turning and climbing\nangle, fuel usage, data collection point coverage, data freshness, and\nresiliency properties. We use efficient, logical formulas to encode and solve\nthe complex model. The solution to the model provides the routing and\nmaneuvering plan for each UAV, including the time to visit the points on the\npaths and corresponding fuel usage such that the necessary data points are\nvisited while satisfying the resiliency requirements. We evaluate the proposed\ntrajectory synthesizer, and the results show that the relationship among\ndifferent parameters follow the requirements while the tool scales well with\nthe problem size.\n",
        "pdf_link": "http://arxiv.org/pdf/2008.10782v1"
    },
    {
        "title": "Abelian networks II. Halting on all inputs",
        "authors": [
            "Benjamin Bond",
            "Lionel Levine"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Abelian networks are systems of communicating automata satisfying a local\ncommutativity condition. We show that a finite irreducible abelian network\nhalts on all inputs if and only if all eigenvalues of its production matrix lie\nin the open unit disk.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.0169v2"
    },
    {
        "title": "Abelian networks III. The critical group",
        "authors": [
            "Benjamin Bond",
            "Lionel Levine"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The critical group of an abelian network is a finite abelian group that\ngoverns the behavior of the network on large inputs. It generalizes the\nsandpile group of a graph. We show that the critical group of an irreducible\nabelian network acts freely and transitively on recurrent states of the\nnetwork. We exhibit the critical group as a quotient of a free abelian group by\na subgroup containing the image of the Laplacian, with equality in the case\nthat the network is rectangular. We generalize Dhar's burning algorithm to\nabelian networks, and estimate the running time of an abelian network on an\narbitrary input up to a constant additive error.\n",
        "pdf_link": "http://arxiv.org/pdf/1409.0170v2"
    },
    {
        "title": "Compositions of Functions and Permutations Specified by Minimal Reaction\n  Systems",
        "authors": [
            "Wen Chean Teh"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This paper studies mathematical properties of reaction systems that was\nintroduced by Enrenfeucht and Rozenberg as computational models inspired by\nbiochemical reaction in the living cells. In particular, we continue the study\non the generative power of functions specified by minimal reaction systems\nunder composition initiated by Salomaa. Allowing degenerate reaction systems,\nfunctions specified by minimal reaction systems over a quarternary alphabet\nthat are permutations generate the alternating group on the power set of the\nbackground set.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.01344v1"
    },
    {
        "title": "Controlling a Population",
        "authors": [
            "Nathalie Bertrand",
            "Miheer Dewaskar",
            "Blaise Genest",
            "Hugo Gimbert"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We introduce a new setting where a population of agents, each modelled by a\nfinite-state system, are controlled uniformly: the controller applies the same\naction to every agent. The framework is largely inspired by the control of a\nbiological system, namely a population of yeasts, where the controller may only\nchange the environment common to all cells. We study a synchronisation problem\nfor such populations: no matter how individual agents react to the actions of\nthe controller , the controller aims at driving all agents synchronously to a\ntarget state. The agents are naturally represented by a non-deterministic\nfinite state automaton (NFA), the same for every agent, and the whole system is\nencoded as a 2-player game. The first player (Controller) chooses actions, and\nthe second player (Agents) resolves non-determinism for each agent. The game\nwith m agents is called the m-population game. This gives rise to a\nparameterized control problem (where control refers to 2 player games), namely\nthe population control problem: can Controller control the m-population game\nfor all $m $\\in$ N$ whatever Agents does? In this paper, we prove that the\npopulation control problem is decidable, and it is a EXPTIME-complete problem.\nAs far as we know, this is one of the first results on parameterized control.\nOur algorithm, not based on cutoff techniques, produces winning strategies\nwhich are symbolic, that is, they do not need to count precisely how the\npopulation is spread between states. We also show that if there is no winning\nstrategy, then there is a population size M such that Controller wins the\nm-population game if and only if $m $\\le$ M$. Surprisingly, M can be doubly\nexponential in the number of states of the NFA, with tight upper and lower\nbounds.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.02058v1"
    },
    {
        "title": "The Power of Constraint Grammars Revisited",
        "authors": [
            "Anssi Yli-Jyrä"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Sequential Constraint Grammar (SCG) (Karlsson, 1990) and its extensions have\nlacked clear connections to formal language theory. The purpose of this article\nis to lay a foundation for these connections by simplifying the definition of\nstrings processed by the grammar and by showing that Nonmonotonic SCG is\nundecidable and that derivations similar to the Generative Phonology exist. The\ncurrent investigations propose resource bounds that restrict the generative\npower of SCG to a subset of context sensitive languages and present a strong\nfinite-state condition for grammars as wholes. We show that a grammar is\nequivalent to a finite-state transducer if it is implemented with a Turing\nmachine that runs in o(n log n) time. This condition opens new finite-state\nhypotheses and avenues for deeper analysis of SCG instances in the way inspired\nby Finite-State Phonology.\n",
        "pdf_link": "http://arxiv.org/pdf/1707.05115v1"
    },
    {
        "title": "Four-valued monitorability of $ω$-regular languages",
        "authors": [
            "Zhe Chen",
            "Yunyun Chen",
            "Robert M. Hierons",
            "Yifan Wu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Runtime Verification (RV) is a lightweight formal technique in which program\nor system execution is monitored and analyzed, to check whether certain\nproperties are satisfied or violated after a finite number of steps. The use of\nRV has led to interest in deciding whether a property is monitorable: whether\nit is always possible for the satisfaction or violation of the property to be\ndetermined after a finite future continuation. However, classical two-valued\nmonitorability suffers from two inherent limitations. First, a property can\nonly be evaluated as monitorable or non-monitorable; no information is\navailable regarding whether only one verdict (satisfaction or violation) can be\ndetected. Second, monitorability is defined at the language-level and does not\ntell us whether satisfaction or violation can be detected starting from the\ncurrent monitor state during system execution.\n  To address these limitations, this paper proposes a new notion of four-valued\nmonitorability for $\\omega$-languages and applies it at the state-level.\nFour-valued monitorability is more informative than two-valued monitorability\nas a property can be evaluated as a four-valued result, denoting that only\nsatisfaction, only violation, or both are active for a monitorable property. We\ncan also compute state-level weak monitorability, i.e., whether satisfaction or\nviolation can be detected starting from a given state in a monitor, which\nenables state-level optimizations of monitoring algorithms. Based on a new\nsix-valued semantics, we propose procedures for computing four-valued\nmonitorability of $\\omega$-regular languages, both at the language-level and at\nthe state-level. We have developed a new tool that implements the proposed\nprocedure for computing monitorability of LTL formulas.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.06737v2"
    },
    {
        "title": "Synthesis in Presence of Dynamic Links",
        "authors": [
            "Béatrice Bérard",
            "Benedikt Bollig",
            "Patricia Bouyer",
            "Matthias Függer",
            "Nathalie Sznajder"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The problem of distributed synthesis is to automatically generate a\ndistributed algorithm, given a target communication network and a specification\nof the algorithm's correct behavior.\n  Previous work has focused on static networks with an a priori fixed message\nsize. This approach has two shortcomings: Recent work in distributed computing\nis shifting towards dynamically changing communication networks rather than\nstatic ones, and an important class of distributed algorithms are so-called\nfull-information protocols, where nodes piggy-pack previously received messages\nonto current messages.\n  In this work, we consider the synthesis problem for a system of two nodes\ncommunicating in rounds over a dynamic link whose message size is not bounded.\nGiven a network model, i.e., a set of link directions, in each round of the\nexecution, the adversary choses a link from the network model, restricted only\nby the specification, and delivers messages according to the current link's\ndirections. Motivated by communication buses with direct acknowledge\nmechanisms, we further assume that nodes are aware of which messages have been\ndelivered.\n  We show that the synthesis problem is decidable for a network model if and\nonly if it does not contain the empty link that dismisses both nodes' messages.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.07545v2"
    },
    {
        "title": "How Good Is a Strategy in a Game With Nature?",
        "authors": [
            "Arnaud Carayol",
            "Olivier Serre"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We consider games with two antagonistic players --- \\'Elo\\\"ise (modelling a\nprogram) and Ab\\'elard (modelling a byzantine environment) --- and a third,\nunpredictable and uncontrollable player, that we call Nature. Motivated by the\nfact that the usual probabilistic semantics very quickly leads to\nundecidability when considering either infinite game graphs or\nimperfect-information, we propose two alternative semantics that leads to\ndecidability where the probabilistic one fails: one based on counting and one\nbased on topology.\n",
        "pdf_link": "http://arxiv.org/pdf/2002.09942v1"
    },
    {
        "title": "Profile Trees for Büchi Word Automata, with Application to\n  Determinization",
        "authors": [
            "Seth Fogarty",
            "Orna Kupferman",
            "Moshe Y. Vardi",
            "Thomas Wilke"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  The determinization of Buchi automata is a celebrated problem, with\napplications in synthesis, probabilistic verification, and multi-agent systems.\nSince the 1960s, there has been a steady progress of constructions: by\nMcNaughton, Safra, Piterman, Schewe, and others. Despite the proliferation of\nsolutions, they are all essentially ad-hoc constructions, with little theory\nbehind them other than proofs of correctness. Since Safra, all optimal\nconstructions employ trees as states of the deterministic automaton, and\ntransitions between states are defined operationally over these trees. The\noperational nature of these constructions complicates understanding,\nimplementing, and reasoning about them, and should be contrasted with\ncomplementation, where a solid theory in terms of automata run DAGs underlies\nmodern constructions.\n  In 2010, we described a profile-based approach to Buchi complementation,\nwhere a profile is simply the history of visits to accepting states. We\ndeveloped a structural theory of profiles and used it to describe a\ncomplementation construction that is deterministic in the limit. Here we extend\nthe theory of profiles to prove that every run DAG contains a profile tree with\nat most a finite number of infinite branches. We then show that this property\nprovides a theoretical grounding for a new determinization construction where\nmacrostates are doubly preordered sets of states. In contrast to extant\ndeterminization constructions, transitions in the new construction are\ndescribed declaratively rather than operationally.\n",
        "pdf_link": "http://arxiv.org/pdf/1307.4471v1"
    },
    {
        "title": "Potential of quantum finite automata with exact acceptance",
        "authors": [
            "Jozef Gruska",
            "Daowen Qiu",
            "Shenggen Zheng"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  The potential of the exact quantum information processing is an interesting,\nimportant and intriguing issue. For examples, it has been believed that quantum\ntools can provide significant, that is larger than polynomial, advantages in\nthe case of exact quantum computation only, or mainly, for problems with very\nspecial structures. We will show that this is not the case.\n  In this paper the potential of quantum finite automata producing outcomes not\nonly with a (high) probability, but with certainty (so called exactly) is\nexplored in the context of their uses for solving promise problems and with\nrespect to the size of automata. It is shown that for solving particular\nclasses $\\{A^n\\}_{n=1}^{\\infty}$ of promise problems, even those without some\nvery special structure, that succinctness of the exact quantum finite automata\nunder consideration, with respect to the number of (basis) states, can be very\nsmall (and constant) though it grows proportional to $n$ in the case\ndeterministic finite automata (DFAs) of the same power are used. This is here\ndemonstrated also for the case that the component languages of the promise\nproblems solvable by DFAs are non-regular. The method used can be applied in\nfinding more exact quantum finite automata or quantum algorithms for other\npromise problems.\n",
        "pdf_link": "http://arxiv.org/pdf/1404.1689v4"
    },
    {
        "title": "Automated Synthesis of Distributed Controllers",
        "authors": [
            "Anca Muscholl"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Synthesis is a particularly challenging problem for concurrent programs. At\nthe same time it is a very promising approach, since concurrent programs are\ndifficult to get right, or to analyze with traditional verification techniques.\nThis paper gives an introduction to distributed synthesis in the setting of\nMazurkiewicz traces, and its applications to decentralized runtime monitoring.\n1 Context Modern computing systems are increasingly distributed and\nheterogeneous. Software needs to be able to exploit these advances, providing\nmeans for applications to be more performant. Traditional concurrent\nprogramming paradigms, as in Java, are based on threads, shared-memory, and\nlocking mechanisms that guard access to common data. More recent paradigms like\nthe reactive programming model of Erlang [4] and Scala [35,36] replace shared\nmemory by asynchronous message passing, where sending a message is\nnon-blocking. In all these concurrent frameworks, writing reliable software is\na serious challenge. Programmers tend to think about code mostly in a\nsequential way, and it is hard to grasp all possible schedulings of events in a\nconcurrent execution. For similar reasons, verification and analysis of\nconcurrent programs is a difficult task. Testing, which is still the main\nmethod for error detection in software, has low coverage for concurrent\nprograms. The reason is that bugs in such programs are difficult to reproduce:\nthey may happen under very specific thread schedules and the likelihood of\ntaking such corner-case schedules is very low. Automated verification, such as\nmodel-checking and other traditional exploration techniques, can handle very\nlimited instances of concurrent programs, mostly because of the very large\nnumber of possible states and of possible interleavings of executions. Formal\nanalysis of programs requires as a prerequisite a clean mathematical model for\nprograms. Verification of sequential programs starts usually with an\nabstraction step -- reducing the value domains of variables to finite domains,\nviewing conditional branching as non-determinism, etc. Another major\nsimplification consists in disallowing recursion. This leads to a very robust\ncomputational model, namely finite-state automata and regular languages.\nRegular languages of words (and trees) are particularly well understood\nnotions. The deep connections between logic and automata revealed by the\nfoundational work of B\\\"uchi, Rabin, and others, are the main ingredients in\nautomata-based verification .\n",
        "pdf_link": "http://arxiv.org/pdf/1506.02369v1"
    },
    {
        "title": "On Delay and Regret Determinization of Max-Plus Automata",
        "authors": [
            "Emmanuel Filiot",
            "Ismaël Jecker",
            "Nathan Lhote",
            "Guillermo A. Pérez",
            "Jean-François Raskin"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Decidability of the determinization problem for weighted automata over the\nsemiring $(\\mathbb{Z} \\cup {-\\infty}, \\max, +)$, WA for short, is a\nlong-standing open question. We propose two ways of approaching it by\nconstraining the search space of deterministic WA: k-delay and r-regret. A WA N\nis k-delay determinizable if there exists a deterministic automaton D that\ndefines the same function as N and for all words {\\alpha} in the language of N,\nthe accepting run of D on {\\alpha} is always at most k-away from a maximal\naccepting run of N on {\\alpha}. That is, along all prefixes of the same length,\nthe absolute difference between the running sums of weights of the two runs is\nat most k. A WA N is r-regret determinizable if for all words {\\alpha} in its\nlanguage, its non-determinism can be resolved on the fly to construct a run of\nN such that the absolute difference between its value and the value assigned to\n{\\alpha} by N is at most r.\n  We show that a WA is determinizable if and only if it is k-delay\ndeterminizable for some k. Hence deciding the existence of some k is as\ndifficult as the general determinization problem. When k and r are given as\ninput, the k-delay and r-regret determinization problems are shown to be\nEXPtime-complete. We also show that determining whether a WA is r-regret\ndeterminizable for some r is in EXPtime.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.02903v2"
    },
    {
        "title": "A Load-Buffer Semantics for Total Store Ordering",
        "authors": [
            "Parosh Aziz Abdulla",
            "Mohamed Faouzi Atig",
            "Ahmed Bouajjani",
            "Tuan Phong Ngo"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We address the problem of verifying safety properties of concurrent programs\nrunning over the Total Store Order (TSO) memory model. Known decision\nprocedures for this model are based on complex encodings of store buffers as\nlossy channels. These procedures assume that the number of processes is fixed.\nHowever, it is important in general to prove the correctness of a\nsystem/algorithm in a parametric way with an arbitrarily large number of\nprocesses.\n  In this paper, we introduce an alternative (yet equivalent) semantics to the\nclassical one for the TSO semantics that is more amenable to efficient\nalgorithmic verification and for the extension to parametric verification. For\nthat, we adopt a dual view where load buffers are used instead of store\nbuffers. The flow of information is now from the memory to load buffers. We\nshow that this new semantics allows (1) to simplify drastically the safety\nanalysis under TSO, (2) to obtain a spectacular gain in efficiency and\nscalability compared to existing procedures, and (3) to extend easily the\ndecision procedure to the parametric case, which allows obtaining a new\ndecidability result, and more importantly, a verification algorithm that is\nmore general and more efficient in practice than the one for bounded instances.\n",
        "pdf_link": "http://arxiv.org/pdf/1701.08682v4"
    },
    {
        "title": "Featured Weighted Automata",
        "authors": [
            "Uli Fahrenberg",
            "Axel Legay"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  A featured transition system is a transition system in which the transitions\nare annotated with feature expressions: Boolean expressions on a finite number\nof given features. Depending on its feature expression, each individual\ntransition can be enabled when some features are present, and disabled for\nother sets of features. The behavior of a featured transition system hence\ndepends on a given set of features. There are algorithms for featured\ntransition systems which can check their properties for all sets of features at\nonce, for example for LTL or CTL properties.\n  Here we introduce a model of featured weighted automata which combines\nfeatured transition systems and (semiring-) weighted automata. We show that\nmethods and techniques from weighted automata extend to featured weighted\nautomata and devise algorithms to compute quantitative properties of featured\nweighted automata for all sets of features at once. We show applications to\nminimum reachability and to energy properties.\n",
        "pdf_link": "http://arxiv.org/pdf/1702.07484v2"
    },
    {
        "title": "The Emptiness Problem for Valence Automata over Graph Monoids",
        "authors": [
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  This work studies which storage mechanisms in automata permit decidability of\nthe emptiness problem. The question is formalized using valence automata, an\nabstract model of automata in which the storage mechanism is given by a monoid.\nFor each of a variety of storage mechanisms, one can choose a (typically\ninfinite) monoid $M$ such that valence automata over $M$ are equivalent to\n(one-way) automata with this type of storage. In fact, many important storage\nmechanisms can be realized by monoids defined by finite graphs, called graph\nmonoids. Examples include pushdown stacks, partially blind counters (which\nbehave like Petri net places), blind counters (which may attain negative\nvalues), and combinations thereof.\n  Hence, we study for which graph monoids the emptiness problem for valence\nautomata is decidable. A particular model realized by graph monoids is that of\nPetri nets with a pushdown stack. For these, decidability is a long-standing\nopen question and we do not answer it here.\n  However, if one excludes subgraphs corresponding to this model, a\ncharacterization can be achieved. Moreover, we provide a description of those\nstorage mechanisms for which decidability remains open. This leads to a model\nthat naturally generalizes both pushdown Petri nets and the priority\nmulticounter machines introduced by Reinhardt.\n  The cases that are proven decidable constitute a natural and apparently new\nextension of Petri nets with decidable reachability. It is finally shown that\nthis model can be combined with another such extension by Atig and Ganty: We\npresent a further decidability result that subsumes both of these Petri net\nextensions.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.07528v1"
    },
    {
        "title": "Approximate Reduction of Finite Automata for High-Speed Network\n  Intrusion Detection (Technical Report)",
        "authors": [
            "Milan Ceska",
            "Vojtech Havlena",
            "Lukas Holik",
            "Ondrej Lengal",
            "Tomas Vojnar"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  We consider the problem of approximate reduction of non-deterministic\nautomata that appear in hardware-accelerated network intrusion detection\nsystems (NIDSes). We define an error distance of a reduced automaton from the\noriginal one as the probability of packets being incorrectly classified by the\nreduced automaton (wrt the probabilistic distribution of packets in the network\ntraffic). We use this notion to design an approximate reduction procedure that\nachieves a great size reduction (much beyond the state-of-the-art\nlanguage-preserving techniques) with a controlled and small error. We have\nimplemented our approach and evaluated it on use cases from Snort, a popular\nNIDS. Our results provide experimental evidence that the method can be highly\nefficient in practice, allowing NIDSes to follow the rapid growth in the speed\nof networks.\n",
        "pdf_link": "http://arxiv.org/pdf/1710.08647v3"
    },
    {
        "title": "On Modelling the Avoidability of Patterns as CSP",
        "authors": [
            "Thorsten Ehlers",
            "Florin Manea",
            "Dirk Nowotka",
            "Kamellia Reshadi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Solving avoidability problems in the area of string combinatorics often\nrequires, in an initial step, the construction, via a computer program, of a\nvery long word that does not contain any word that matches a given pattern. It\nis well known that this is a computationally hard task. Despite being rather\nstraightforward that, ultimately, all such tasks can be formalized as\nconstraints satisfaction problems, no unified approach to solving them was\nproposed so far, and very diverse ad-hoc methods were used. We aim to fill this\ngap: we show how several relevant avoidability problems can be modelled, and\nconsequently solved, in an uniform way as constraint satisfaction problems,\nusing the framework of MiniZinc. The main advantage of this approach is that\none is now required only to formulate the avoidability problem in the MiniZinc\nlanguage, and then the actual search for a solution does not have to be\nimplemented ad-hoc, being instead carried out by a standard CSP-solver.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.00715v1"
    },
    {
        "title": "Learning with Partially Ordered Representations",
        "authors": [
            "Jane Chandlee",
            "Remi Eyraud",
            "Jeffrey Heinz",
            "Adam Jardine",
            "Jonathan Rawski"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper examines the characterization and learning of grammars defined\nwith enriched representational models. Model-theoretic approaches to formal\nlanguage theory traditionally assume that each position in a string belongs to\nexactly one unary relation. We consider unconventional string models where\npositions can have multiple, shared properties, which are arguably useful in\nmany applications. We show the structures given by these models are partially\nordered, and present a learning algorithm that exploits this ordering relation\nto effectively prune the hypothesis space. We prove this learning algorithm,\nwhich takes positive examples as input, finds the most general grammar which\ncovers the data.\n",
        "pdf_link": "http://arxiv.org/pdf/1906.07886v2"
    },
    {
        "title": "Tree Automata for Extracting Consensus from Partial Replicas of a\n  Structured Document",
        "authors": [
            "Maurice Tchoupé Tchendji",
            "Milliam Maxime Zekeng Ndadji"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In an asynchronous cooperative editing workflow of a structured document,\neach of the co-authors receives in the different phases of the editing process,\na copy of the document to insert its contribution. For confidentiality reasons,\nthis copy may be only a partial replica containing only parts of the (global)\ndocument which are of demonstrated interest for the considered co-author. Note\nthat some parts may be a demonstrated interest over a co-author; they will\ntherefore be accessible concurrently. When it's synchronization time (e.g. at\nthe end of an asynchronous editing phase of the process), we want to merge all\ncontributions of all authors in a single document. Due to the asynchronism of\nedition and to the potential existence of the document parts offering\nconcurrent access, conflicts may arise and make partial replicas unmergeable in\ntheir entirety: they are inconsistent, meaning that they contain conflictual\nparts. The purpose of this paper is to propose a merging approach said by\nconsensus of such partial replicas using tree automata. Specifically, from the\npartial replicas updates, we build a tree automaton that accepts exactly the\nconsensus documents. These documents are the maximum prefixes containing no\nconflict of partial replicas merged.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.00867v1"
    },
    {
        "title": "A String Diagrammatic Axiomatisation of Finite-State Automata",
        "authors": [
            "Robin Piedeleu",
            "Fabio Zanasi"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We develop a fully diagrammatic approach to the theory of finite-state\nautomata, based on reinterpreting their usual state-transition graphical\nrepresentation as a two-dimensional syntax of string diagrams. Moreover, we\nprovide an equational theory that completely axiomatises language equivalence\nin this new setting. This theory has two notable features. First, the Kleene\nstar is a derived concept, as it can be decomposed into more primitive\nalgebraic blocks. Second, the proposed axiomatisation is finitary -- a result\nwhich is provably impossible to obtain for the one-dimensional syntax of\nregular expressions.\n",
        "pdf_link": "http://arxiv.org/pdf/2009.14576v2"
    },
    {
        "title": "Compositional Reasoning for Shared-variable Concurrent Programs",
        "authors": [
            "Fuyuan Zhang",
            "Yongwang Zhao",
            "David Sanan",
            "Yang Liu",
            "Alwen Tiu",
            "Shang-Wei Lin",
            "Jun Sun"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Scalable and automatic formal verification for concurrent systems is always\ndemanding. In this paper, we propose a verification framework to support\nautomated compositional reasoning for concurrent programs with shared\nvariables. Our framework models concurrent programs as succinct automata and\nsupports the verification of multiple important properties. Safety verification\nand simulations of succinct automata are parallel compositional, and safety\nproperties of succinct automata are preserved under refinements. We generate\nsuccinct automata from infinite state concurrent programs in an automated\nmanner. Furthermore, we propose the first automated approach to checking\nrely-guarantee based simulations between infinite state concurrent programs. We\nhave prototyped our algorithms and applied our tool to the verification of\nmultiple refinements.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.00574v2"
    },
    {
        "title": "Some conjectures on codes",
        "authors": [
            "Clelia De Felice"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Variable-length codes are the bases of the free submonoids of a free monoid.\nThere are some important longstanding open questions about the structure of\nfinite maximal codes. In this paper we discuss this conjectures and their\nrelations with factorizations of cyclic groups.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.04580v1"
    },
    {
        "title": "Asynchronous Distributed Automata: A Characterization of the Modal\n  Mu-Fragment",
        "authors": [
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We establish the equivalence between a class of asynchronous distributed\nautomata and a small fragment of least fixpoint logic, when restricted to\nfinite directed graphs. More specifically, the logic we consider is (a variant\nof) the fragment of the modal $\\mu$-calculus that allows least fixpoints but\nforbids greatest fixpoints. The corresponding automaton model uses a network of\nidentical finite-state machines that communicate in an asynchronous manner and\nwhose state diagram must be acyclic except for self-loops. Exploiting the\nconnection with logic, we also prove that the expressive power of those\nmachines is independent of whether or not messages can be lost.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.08554v2"
    },
    {
        "title": "On the Complexity of the Word Problem for Automaton Semigroups and\n  Automaton Groups",
        "authors": [
            "Daniele D'Angeli",
            "Emanuele Rodaro",
            "Jan Philipp Wächter"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  In this paper, we study the word problem for automaton semigroups and\nautomaton groups from a complexity point of view. As an intermediate concept\nbetween automaton semigroups and automaton groups, we introduce\nautomaton-inverse semigroups, which are generated by partial, yet invertible\nautomata. We show that there is an automaton-inverse semigroup and, thus, an\nautomaton semigroup with a PSPACE-complete word problem. We also show that\nthere is an automaton group for which the word problem with a single rational\nconstraint is PSPACE-complete. Additionally, we provide simpler constructions\nfor the uniform word problems of these classes. For the uniform word problem\nfor automaton groups (without rational constraints), we show NL-hardness.\nFinally, we investigate a question asked by Cain about a better upper bound for\nthe length of a word on which two distinct elements of an automaton semigroup\nmust act differently.\n",
        "pdf_link": "http://arxiv.org/pdf/1611.09541v2"
    },
    {
        "title": "On Nonlinear Prices in Timed Automata",
        "authors": [
            "Devendra Bhave",
            "Shankara Narayanan Krishna",
            "Ashutosh Trivedi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Priced timed automata provide a natural model for quantitative analysis of\nreal-time systems and have been successfully applied in various scheduling and\nplanning problems. The optimal reachability problem for linearly-priced timed\nautomata is known to be PSPACE-complete. In this paper we investigate priced\ntimed automata with more general prices and show that in the most general\nsetting the optimal reachability problem is undecidable. We adapt and implement\nthe construction of Audemard, Cimatti, Kornilowicz, and Sebastiani for\nnon-linear priced timed automata using state-of-the-art theorem prover Z3 and\npresent some preliminary results.\n",
        "pdf_link": "http://arxiv.org/pdf/1612.04976v1"
    },
    {
        "title": "Learning Graph Weighted Models on Pictures",
        "authors": [
            "Philip Amortila",
            "Guillaume Rabusseau"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Graph Weighted Models (GWMs) have recently been proposed as a natural\ngeneralization of weighted automata over strings and trees to arbitrary\nfamilies of labeled graphs (and hypergraphs). A GWM generically associates a\nlabeled graph with a tensor network and computes a value by successive\ncontractions directed by its edges. In this paper, we consider the problem of\nlearning GWMs defined over the graph family of pictures (or 2-dimensional\nwords). As a proof of concept, we consider regression and classification tasks\nover the simple Bars & Stripes and Shifting Bits picture languages and provide\nan experimental study investigating whether these languages can be learned in\nthe form of a GWM from positive and negative examples using gradient-based\nmethods. Our results suggest that this is indeed possible and that\ninvestigating the use of gradient-based methods to learn picture series and\nfunctions computed by GWMs over other families of graphs could be a fruitful\ndirection.\n",
        "pdf_link": "http://arxiv.org/pdf/1806.08297v2"
    },
    {
        "title": "Planar digraphs for automatic complexity",
        "authors": [
            "Achilles A. Beros",
            "Bjørn Kjos-Hanssen",
            "Daylan Kaui Yogi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that the digraph of a nondeterministic finite automaton witnessing\nthe automatic complexity of a word can always be taken to be planar. In the\ncase of total transition functions studied by Shallit and Wang, planarity can\nfail.\n  Let $s_q(n)$ be the number of binary words $x$ of length $n$ having\nnondeterministic automatic complexity $A_N(x)=q$. We show that $s_q$ is\neventually constant for each $q$ and that the eventual constant value of $s_q$\nis computable.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.00812v1"
    },
    {
        "title": "The number of languages with maximum state complexity",
        "authors": [
            "Bjørn Kjos-Hanssen",
            "Lei Liu"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  C\\^{a}mpeanu and Ho (2004) determined the maximum finite state complexity of\nfinite languages, building on work of Champarnaud and Pin (1989). They stated\nthat it is very difficult to determine the number of maximum-complexity\nlanguages. Here we give a formula for this number. We also generalize their\nwork from languages to functions on finite sets.\n",
        "pdf_link": "http://arxiv.org/pdf/1902.00815v2"
    },
    {
        "title": "Preservation of normality by non-oblivious group selection",
        "authors": [
            "Olivier Carton",
            "Joseph Vandehey"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We give two different proofs of the fact that non-oblivious selection via\nregular group sets preserves normality. Non-oblivious here means that whether\nor not a symbol is selected can depend on the symbol itself. One proof relies\non the incompressibility of normal sequences, the other on the use of augmented\ndynamical systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1905.05801v1"
    },
    {
        "title": "On Verification of D-Detectability for Discrete Event Systems",
        "authors": [
            "Jiří Balun",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Detectability has been introduced as a generalization of state-estimation\nproperties of discrete event systems studied in the literature. It asks whether\nthe current and subsequent states of a system can be determined based on\nobservations. Since, in some applications, to exactly determine the current and\nsubsequent states may be too strict, a relaxed notion of D-detectability has\nbeen introduced, distinguishing only certain pairs of states rather than all\nstates. Four variants of D-detectability have been defined: strong (periodic)\nD-detectability and weak (periodic) D-detectability. Deciding weak (periodic)\nD-detectability is PSpace-complete, while deciding strong (periodic)\ndetectability or strong D-detectability is polynomial (and we show that it is\nactually NL-complete). However, to the best of our knowledge, it is an open\nproblem whether there exists a polynomial-time algorithm deciding strong\nperiodic D-detectability. We solve this problem by showing that deciding strong\nperiodic D-detectability is a PSpace-complete problem, and hence there is no\npolynomial-time algorithm unless PSpace = P. We further show that there is no\npolynomial-time algorithm deciding strong periodic D-detectability even for\nsystems with a single observable event, unless P = NP. Finally, we propose a\nclass of systems for which the problem is tractable.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.07312v2"
    },
    {
        "title": "On Opacity Verification for Discrete-Event Systems",
        "authors": [
            "Jiří Balun",
            "Tomáš Masopust"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Opacity is an information flow property characterizing whether a system\nreveals its secret to an intruder. Verification of opacity for discrete-event\nsystems modeled by automata is in general a hard problem. We discuss the\nquestion whether there are structural restrictions on the system models for\nwhich the opacity verification is tractable. We consider two kinds of automata\nmodels: (i) acyclic automata, and (ii) automata where all cycles are only in\nthe form of self-loops. In some sense, these models are the simplest models of\n(deadlock-free) systems. Although the expressivity of such systems is weaker\nthan the expressivity of linear temporal logic, we show that the opacity\nverification for these systems is still hard.\n",
        "pdf_link": "http://arxiv.org/pdf/1912.07314v1"
    },
    {
        "title": "Incremental Monoidal Grammars",
        "authors": [
            "Dan Shiebler",
            "Alexis Toumi",
            "Mehrnoosh Sadrzadeh"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work we define formal grammars in terms of free monoidal categories,\nalong with a functor from the category of formal grammars to the category of\nautomata. Generalising from the Booleans to arbitrary semirings, we extend our\nconstruction to weighted formal grammars and weighted automata. This allows us\nto link the categorical viewpoint on natural language to the standard machine\nlearning notion of probabilistic language model.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.02296v2"
    },
    {
        "title": "Streaming Transformations of Infinite Ordered-Data Words",
        "authors": [
            "Xiaokang Qiu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this paper, we define streaming register transducer (SRT), a one-way,\nletter-to-letter, transductional machine model for transformations of infinite\ndata words whose data domain forms a linear group. Comparing with existing data\nword transducers, SRT are able to perform two extra operations on the\nregisters: a linear-order-based comparison and an additive update. We consider\nthe transformations that can be defined by SRT and several subclasses of SRT.\nWe investigate the expressiveness of these languages and several decision\nproblems. Our main results include: 1) SRT are closed under union and\nintersection, and add-free SRT are also closed under composition; 2)\nSRT-definable transformations can be defined in monadic second-order (MSO)\nlogic, but are not comparable with first-order (FO) definable transformations;\n3) the functionality problem is decidable for add-free SRT, the reactivity\nproblem and inclusion problem are decidable for deterministic add-free SRT, but\nnone of these problems is decidable in general for SRT.\n",
        "pdf_link": "http://arxiv.org/pdf/2001.06952v1"
    },
    {
        "title": "Formal assessment of some properties of Context-Aware Systems",
        "authors": [
            "Fabio A. Schreiber",
            "Maria Elena Valcher"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Context-Aware systems are becoming useful components in autonomic and\nmonitoring applications and the assessment of their properties is an important\nstep towards reliable implementation, especially in safety-critical\napplications. In this paper, using an avalanche/landslide alert system as a\nrunning example, we propose a technique, based on Boolean Control Networks, to\nverify that the system dynamics has stable equilibrium states, corresponding to\nconstant inputs, and hence it does not exhibit oscillatory behaviors, and to\nestablish other useful properties in order to implement a precise and timely\nalarm system.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.00373v1"
    },
    {
        "title": "Structural Equivalences for Reversible Calculi of Communicating Systems\n  (Oral communication)",
        "authors": [
            "Clément Aubert",
            "Ioana Cristescu"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  The formalization of process algebras usually starts with a minimal core of\noperators and rules for its transition system, and then relax the system to\nimprove its usability and ease the proofs. In the calculus of communicating\nsystems (CCS), the structural congruence plays this role by making e.g.\nparallel composition commutative and associative: without it, the system would\nbe cumbersome to use and reason about, and it can be proven that this change is\ninnocuous in a precise technical sense. For the two reversible calculi\nextending CCS, the situation is less clear: CCS with Communication Keys (CCSK)\nwas first defined without any structural congruence, and then was endowed with\na fragment of CCS's congruence. Reversible CCS (RCCS) made the choice of\n\"backing in\" the structural equivalence, that became part of the \"minimal core\"\nof the system. In this short oral communication, we would like to re-consider\nthe status and role of the structural congruence in general, to question its\nrole in RCCS in particular, and to ask the more general question of the\nstructural equivalences legitimacy.\n",
        "pdf_link": "http://arxiv.org/pdf/2005.06818v1"
    },
    {
        "title": "Controlling a population",
        "authors": [
            "Nathalie Bertrand",
            "Miheer Dewaskar",
            "Blaise Genest",
            "Hugo Gimbert",
            "Adwait Amit Godbole"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We introduce a new setting where a population of agents, each modelled by a\nfinite-state system, are controlled uniformly: the controller applies the same\naction to every agent. The framework is largely inspired by the control of a\nbiological system, namely a population of yeasts, where the controller may only\nchange the environment common to all cells. We study a synchronisation problem\nfor such populations: no matter how individual agents react to the actions of\nthe controller, the controller aims at driving all agents synchronously to a\ntarget state. The agents are naturally represented by a non-deterministic\nfinite state automaton (NFA), the same for every agent, and the whole system is\nencoded as a 2-player game. The first player (Controller) chooses actions, and\nthe second player (Agents) resolves non-determinism for each agent. The game\nwith m agents is called the m -population game. This gives rise to a\nparameterized control problem (where control refers to 2 player games), namely\nthe population control problem: can Controller control the m-population game\nfor all m in N whatever Agents does?\n",
        "pdf_link": "http://arxiv.org/pdf/1807.00893v3"
    },
    {
        "title": "On the Complexity of Value Iteration",
        "authors": [
            "Nikhil Balaji",
            "Stefan Kiefer",
            "Petr Novotný",
            "Guillermo A. Pérez",
            "Mahsa Shirmohammadi"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Value iteration is a fundamental algorithm for solving Markov Decision\nProcesses (MDPs). It computes the maximal $n$-step payoff by iterating $n$\ntimes a recurrence equation which is naturally associated to the MDP. At the\nsame time, value iteration provides a policy for the MDP that is optimal on a\ngiven finite horizon $n$. In this paper, we settle the computational complexity\nof value iteration. We show that, given a horizon $n$ in binary and an MDP,\ncomputing an optimal policy is EXP-complete, thus resolving an open problem\nthat goes back to the seminal 1987 paper on the complexity of MDPs by\nPapadimitriou and Tsitsiklis. As a stepping stone, we show that it is\nEXP-complete to compute the $n$-fold iteration (with $n$ in binary) of a\nfunction given by a straight-line program over the integers with $\\max$ and $+$\nas operators.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.04920v3"
    },
    {
        "title": "Classically Time-Controlled Quantum Automata: Definition and Properties",
        "authors": [
            "Alejandro Díaz-Caro",
            "Marcos Villagra"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we introduce classically time-controlled quantum automata or\nCTQA, which is a reasonable modification of Moore-Crutchfield quantum finite\nautomata that uses time-dependent evolution and a \"scheduler\" defining how long\neach Hamiltonian will run. Surprisingly enough, time-dependent evolution\nprovides a significant change in the computational power of quantum automata\nwith respect to a discrete quantum model. Indeed, we show that if a scheduler\nis not computationally restricted, then a CTQA could even decide the Halting\nproblem. In order to unearth the computational capabilities of CTQAs we study\nthe case of a computationally restricted scheduler. In particular, we showed\nthat depending on the type of restriction imposed on the scheduler, a CTQA can\n(i) recognize non-regular languages with cut-point, even in the presence of\nKarp-Lipton advice, and (ii) recognize non-regular promise languages with\nbounded-error. Furthermore, we study the cutpoint-union of cutpoint languages\nby introducing a new model of Moore-Crutchfield quantum finite automata with a\nrotating tape head. CTQA presents itself as a new model of computation that\nprovides a different approach to a formal study of \"classical control, quantum\ndata\" schemes in quantum computing.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.05385v10"
    },
    {
        "title": "Universal trees grow inside separating automata: Quasi-polynomial lower\n  bounds for parity games",
        "authors": [
            "Wojciech Czerwiński",
            "Laure Daviaud",
            "Nathanaël Fijalkow",
            "Marcin Jurdziński",
            "Ranko Lazić",
            "Paweł Parys"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  Several distinct techniques have been proposed to design quasi-polynomial\nalgorithms for solving parity games since the breakthrough result of Calude,\nJain, Khoussainov, Li, and Stephan (2017): play summaries, progress measures\nand register games. We argue that all those techniques can be viewed as\ninstances of the separation approach to solving parity games, a key technical\ncomponent of which is constructing (explicitly or implicitly) an automaton that\nseparates languages of words encoding plays that are (decisively) won by either\nof the two players. Our main technical result is a quasi-polynomial lower bound\non the size of such separating automata that nearly matches the current best\nupper bounds. This forms a barrier that all existing approaches must overcome\nin the ongoing quest for a polynomial-time algorithm for solving parity games.\nThe key and fundamental concept that we introduce and study is a universal\nordered tree. The technical highlights are a quasi-polynomial lower bound on\nthe size of universal ordered trees and a proof that every separating safety\nautomaton has a universal tree hidden in its state space.\n",
        "pdf_link": "http://arxiv.org/pdf/1807.10546v2"
    },
    {
        "title": "The minimal probabilistic and quantum finite automata recognizing\n  uncountably many languages with fixed cutpoints",
        "authors": [
            "Aleksejs Naumovs",
            "Maksims Dimitrijevs",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  It is known that 2-state binary and 3-state unary probabilistic finite\nautomata and 2-state unary quantum finite automata recognize uncountably many\nlanguages with cutpoints. These results have been obtained by associating each\nrecognized language with a cutpoint and then by using the fact that there are\nuncountably many cutpoints. In this note, we prove the same results for fixed\ncutpoints: each recognized language is associated with an automaton (i.e.,\nalgorithm), and the proofs use the fact that there are uncountably many\nautomata. For each case, we present a new construction.\n",
        "pdf_link": "http://arxiv.org/pdf/1904.01381v4"
    },
    {
        "title": "Re-pairing brackets",
        "authors": [
            "Dmitry Chistikov",
            "Mikhail Vyalyi"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Consider the following one-player game. Take a well-formed sequence of\nopening and closing brackets. As a move, the player can pair any opening\nbracket with any closing bracket to its right, erasing them. The goal is to\nre-pair (erase) the entire sequence, and the complexity of a strategy is\nmeasured by its width: the maximum number of nonempty segments of symbols\n(separated by blank space) seen during the play.\n  For various initial sequences, we prove upper and lower bounds on the minimum\nwidth sufficient for re-pairing. (In particular, the sequence associated with\nthe complete binary tree of height $n$ admits a strategy of width\nsub-exponential in $\\log n$.) Our two key contributions are (1) lower bounds on\nthe width and (2) their application in automata theory: quasi-polynomial lower\nbounds on the translation from one-counter automata to Parikh-equivalent\nnondeterministic finite automata. The latter result answers a question by Atig\net al. (2016).\n",
        "pdf_link": "http://arxiv.org/pdf/1904.08402v1"
    },
    {
        "title": "Non-Abelian Gauge-Invariant Cellular Automata",
        "authors": [
            "Pablo Arrighi",
            "Giuseppe Di Molfetta",
            "Nathanaël Eon"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Gauge-invariance is a mathematical concept that has profound implications in\nPhysics---as it provides the justification of the fundamental interactions. It\nwas recently adapted to the Cellular Automaton (CA) framework, in a restricted\ncase. In this paper, this treatment is generalized to non-abelian\ngauge-invariance, including the notions of gauge-equivalent theories and\ngauge-invariants of configurations\n",
        "pdf_link": "http://arxiv.org/pdf/1908.01229v2"
    },
    {
        "title": "On the k-synchronizability of systems",
        "authors": [
            "Cinzia Di Giusto",
            "Cinzia Giusto",
            "Laetitia Laversa",
            "Etienne Lozes"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  In this paper, we work on the notion of k-synchronizability: a system is\nk-synchronizable if any of its executions, up to reordering causally\nindependent actions, can be divided into a succession of k-bounded interaction\nphases. We show two results (both for mailbox and peer-to-peer automata):\nfirst, the reachability problem is decidable for k-synchronizable systems;\nsecond, the membership problem (whether a given system is k-synchronizable) is\ndecidable as well. Our proofs fix several important issues in previous attempts\nto prove these two results for mailbox automata.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.01627v2"
    },
    {
        "title": "Fault Trees from Data: Efficient Learning with an Evolutionary Algorithm",
        "authors": [
            "Alexis Linard",
            "Doina Bucur",
            "Marielle Stoelinga"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Cyber-physical systems come with increasingly complex architectures and\nfailure modes, which complicates the task of obtaining accurate system\nreliability models. At the same time, with the emergence of the (industrial)\nInternet-of-Things, systems are more and more often being monitored via\nadvanced sensor systems. These sensors produce large amounts of data about the\ncomponents' failure behaviour, and can, therefore, be fruitfully exploited to\nlearn reliability models automatically. This paper presents an effective\nalgorithm for learning a prominent class of reliability models, namely fault\ntrees, from observational data. Our algorithm is evolutionary in nature; i.e.,\nis an iterative, population-based, randomized search method among fault-tree\nstructures that are increasingly more consistent with the observational data.\nWe have evaluated our method on a large number of case studies, both on\nsynthetic data, and industrial data. Our experiments show that our algorithm\noutperforms other methods and provides near-optimal results.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.06258v1"
    },
    {
        "title": "Towards a Coq-verified Chain of Esterel Semantics",
        "authors": [
            "Gérard Berry",
            "Lionel Rieg"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  This paper focuses on formally specifying and verifying the chain of formal\nsemantics of the Esterel synchronous programming language using the Coq proof\nassistant. In particular, in addition to the standard logical (LBS) semantics,\nconstructive semantics (CBS) and constructive state semantics (CSS), we\nintroduce a novel microstep semantics that gets rid of the Must/Can potential\nfunction pair of the constructive semantics and can be viewed as an abstract\nversion of Esterel's circuit semantics used by compilers to generate software\ncode and hardware designs. Excluding the loop construct from Esterel, the paper\nalso provides formal proofs in Coq of the equivalence between the CBS and CSS\nsemantics and of the refinement of the CSS by the microstep semantics.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.12582v4"
    },
    {
        "title": "Automata Learning: An Algebraic Approach",
        "authors": [
            "Henning Urbat",
            "Lutz Schröder"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We propose a generic categorical framework for learning unknown formal\nlanguages of various types (e.g. finite or infinite words, weighted and nominal\nlanguages). Our approach is parametric in a monad T that represents the given\ntype of languages and their recognizing algebraic structures. Using the concept\nof anautomata presentation of T-algebras, we demonstrate that the task of\nlearning a T-recognizable language can be reduced to learning an abstract form\nof algebraic automaton whose transitions are modeled by a functor. For the\nimportant case of adjoint automata, we devise a learning algorithm generalizing\nAngluin's L*. The algorithm is phrased in terms of categorically described\nextension steps; we provide for a termination and complexity analysis based on\na dedicated notion of finiteness. Our framework applies to structures like\nomega-regular languages that were not within the scope of existing categorical\naccounts of automata learning. In addition, it yields new learning algorithms\nfor several types of languages for which no such algorithms were previously\nknown at all, including sorted languages, nominal languages with name binding,\nand cost functions.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.00874v3"
    },
    {
        "title": "Controlling a random population",
        "authors": [
            "Thomas Colcombet",
            "Nathanaël Fijalkow",
            "Pierre Ohlmann"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Bertrand et al. introduced a model of parameterised systems, where each agent\nis represented by a finite state system, and studied the following control\nproblem: for any number of agents, does there exist a controller able to bring\nall agents to a target state? They showed that the problem is decidable and\nEXPTIME-complete in the adversarial setting, and posed as an open problem the\nstochastic setting, where the agent is represented by a Markov decision\nprocess. In this paper, we show that the stochastic control problem is\ndecidable. Our solution makes significant uses of well quasi orders, of the\nmax-flow min-cut theorem, and of the theory of regular cost functions. We\nintroduce an intermediate problem of independence interest called the\nsequential flow problem and study its complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.01195v5"
    },
    {
        "title": "The Complexity of Learning Linear Temporal Formulas from Examples",
        "authors": [
            "Nathanaël Fijalkow",
            "Guillaume Lagarde"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper we initiate the study of the computational complexity of\nlearning linear temporal logic (LTL) formulas from examples. We construct\napproximation algorithms for fragments of LTL and prove hardness results; in\nparticular we obtain tight bounds for approximation of the fragment containing\nonly the next operator and conjunctions, and prove NP-completeness results for\nmany fragments.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.00876v1"
    },
    {
        "title": "Regular Model Checking Approach to Knowledge Reasoning over\n  Parameterized Systems (technical report)",
        "authors": [
            "Daniel Stan",
            "Anthony Widjaja Lin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We present a general framework for modelling and verifying epistemic\nproperties over parameterized multi-agent systems that communicate by truthful\npublic announcements. In our framework, the number of agents or the amount of\ncertain resources are parameterized (i.e. not known a priori), and the\ncorresponding verification problem asks whether a given epistemic property is\ntrue regardless of the instantiation of the parameters. For example, in a muddy\nchildren puzzle, one could ask whether each child will eventually find out\nwhether (s)he is muddy, regardless of the number of children.\n  Our framework is regular model checking (RMC)-based, wherein synchronous\nfinite-state automata (equivalently, monadic second-order logic over words) are\nused to specify the systems. We propose an extension of public announcement\nlogic as specification language. Of special interests is the addition of the\nso-called iterated public announcement operators, which are crucial for\nreasoning about knowledge in parameterized systems. Although the operators make\nthe model checking problem undecidable, we show that this becomes decidable\nwhen an appropriate \"disappearance relation\" is given. Further, we show how\nAngluin's L*-algorithm for learning finite automata can be applied to find a\ndisappearance relation, which is guaranteed to terminate if it is regular. We\nhave implemented the algorithm and apply this to such examples as the Muddy\nChildren Puzzle, the Russian Card Problem, and Large Number Challenge.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.04361v3"
    },
    {
        "title": "Model Checking for Decision Making System of Long Endurance Unmanned\n  Surface Vehicle",
        "authors": [
            "Hanlin Niu",
            "Ze Ji",
            "Al Savvaris",
            "Antonios Tsourdos",
            "Joaquin Carrasco"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This work aims to develop a model checking method to verify the decision\nmaking system of Unmanned Surface Vehicle (USV) in a long range surveillance\nmission. The scenario in this work was captured from a long endurance USV\nsurveillance mission using C-Enduro, an USV manufactured by ASV Ltd. The\nC-Enduro USV may encounter multiple non-deterministic and concurrent problems\nincluding lost communication signals, collision risk and malfunction. The\nvehicle is designed to utilise multiple energy sources from solar panel, wind\nturbine and diesel generator. The energy state can be affected by the solar\nirradiance condition, wind condition, states of the diesel generator, sea\ncurrent condition and states of the USV. In this research, the states and the\ninteractive relations between environmental uncertainties, sensors, USV energy\nsystem, USV and Ground Control Station (GCS) decision making systems are\nabstracted and modelled successfully using Kripke models. The desirable\nproperties to be verified are expressed using temporal logic statement and\nfinally the safety properties and the long endurance properties are verified\nusing the model checker MCMAS, a model checker for multi-agent systems. The\nverification results are analyzed and show the feasibility of applying model\nchecking method to retrospect the desirable property of the USV decision making\nsystem. This method could assist researcher to identify potential design error\nof decision making system in advance.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.10604v2"
    },
    {
        "title": "Subcubic Certificates for CFL Reachability",
        "authors": [
            "Dmitry Chistikov",
            "Rupak Majumdar",
            "Philipp Schepper"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Many problems in interprocedural program analysis can be modeled as the\ncontext-free language (CFL) reachability problem on graphs and can be solved in\ncubic time. Despite years of efforts, there are no known truly sub-cubic\nalgorithms for this problem. We study the related certification task: given an\ninstance of CFL reachability, are there small and efficiently checkable\ncertificates for the existence and for the non-existence of a path? We show\nthat, in both scenarios, there exist succinct certificates ($O(n^2)$ in the\nsize of the problem) and these certificates can be checked in subcubic (matrix\nmultiplication) time. The certificates are based on grammar-based compression\nof paths (for positive instances) and on invariants represented as matrix\nconstraints (for negative instances). Thus, CFL reachability lies in\nnondeterministic and co-nondeterministic subcubic time.\n  A natural question is whether faster algorithms for CFL reachability will\nlead to faster algorithms for combinatorial problems such as Boolean\nsatisfiability (SAT). As a consequence of our certification results, we show\nthat there cannot be a fine-grained reduction from SAT to CFL reachability for\na conditional lower bound stronger than $n^\\omega$, unless the nondeterministic\nstrong exponential time hypothesis (NSETH) fails.\n  Our results extend to related subcubic equivalent problems: pushdown\nreachability and two-way nondeterministic pushdown automata (2NPDA) language\nrecognition. For example, we describe succinct certificates for pushdown\nnon-reachability (inductive invariants) and observe that they can be checked in\nmatrix multiplication time. We also extract a new hardest 2NPDA language,\ncapturing the \"hard core\" of all these problems.\n",
        "pdf_link": "http://arxiv.org/pdf/2102.13095v1"
    },
    {
        "title": "Synthesis from Weighted Specifications with Partial Domains over Finite\n  Words",
        "authors": [
            "Emmanuel Filiot",
            "Christof Löding",
            "Sarah Winter"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we investigate the synthesis problem of terminating reactive\nsystems from quantitative specifications. Such systems are modeled as finite\ntransducers whose executions are represented as finite words in $(I\\times\nO)^*$, where $I,O$ are finite sets of input and output symbols, respectively. A\nweighted specification $S$ assigns a rational value (or $-\\infty$) to words in\n$(I\\times O)^*$, and we consider three kinds of objectives for synthesis,\nnamely threshold objectives where the system's executions are required to be\nabove some given threshold, best-value and approximate objectives where the\nsystem is required to perform as best as it can by providing output symbols\nthat yield the best value and $\\varepsilon$-best value respectively w.r.t. $S$.\nWe establish a landscape of decidability results for these three objectives and\nweighted specifications with partial domain over finite words given by\ndeterministic weighted automata equipped with sum, discounted-sum and average\nmeasures. The resulting objectives are not regular in general and we develop an\ninfinite game framework to solve the corresponding synthesis problems, namely\nthe class of (weighted) critical prefix games.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.05550v1"
    },
    {
        "title": "On the Theory of Stochastic Automata",
        "authors": [
            "Merve Nur Cakir",
            "Mehwish Saleemi",
            "Karl-Heinz Zimmermann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The theory of discrete stochastic systems has been initiated by the work of\nShannon and von Neumann. While Shannon has considered memory-less communication\nchannels and their generalization by introducing states, von Neumann has\nstudied the synthesis of reliable systems from unreliable components. The\nfundamental work of Rabin and Scott about deterministic finite-state automata\nhas led to two generalizations. First, the generalization of transition\nfunctions to conditional distributions studied by Carlyle and Starke. This in\nturn has led to a generalization of time-discrete Markov chains in which the\nchains are governed by more than one transition probability matrix. Second, the\ngeneralization of regular sets by introducing stochastic automata as described\nby Rabin. Stochastic automata are well-investigated. This report provides a\nshort introduction to stochastic automata based on the valuable book of Claus.\nThis includes the basic topics of the theory of stochastic automata:\nequivalence, minimization, reduction, covering, observability, and determinism.\nThen stochastic versions of Mealy and Moore automata are studied and finally\nstochastic language acceptors are considered as a generalization of\nnondeterministic finite-state acceptors.\n",
        "pdf_link": "http://arxiv.org/pdf/2103.14423v1"
    },
    {
        "title": "Action Codes",
        "authors": [
            "Frits Vaandrager",
            "Thorsten Wißmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We provide a new perspective on the problem how high-level state machine\nmodels with abstract actions can be related to low-level models in which these\nactions are refined by sequences of concrete actions. We describe the\nconnection between high-level and low-level actions using \\emph{action codes},\na variation of the prefix codes known from coding theory. For each action code\n${\\mathcal{R}}$, we introduce a \\emph{contraction} operator\n$\\alpha_{\\mathcal{R}}$ that turns a low-level model $\\mathcal{M}$ into a\nhigh-level model, and a \\emph{refinement} operator $\\rho_{\\mathcal{R}}$ that\ntransforms a high-level model $\\mathcal{N}$ into a low-level model. We\nestablish a Galois connection $\\rho_{\\mathcal{R}}(\\mathcal{N}) \\sqsubseteq\n\\mathcal{M} \\Leftrightarrow \\mathcal{N} \\sqsubseteq\n\\alpha_{\\mathcal{R}}(\\mathcal{M})$, where $\\sqsubseteq$ is the well-known\nsimulation preorder. For conformance, we typically want to obtain an\noverapproximation of model $\\mathcal{M}$. To this end, we also introduce a\n\\emph{concretization} operator $\\gamma_{\\mathcal{R}}$, which behaves like the\nrefinement operator but adds arbitrary behavior at intermediate points, giving\nus a second Galois connection $\\alpha_{\\mathcal{R}}(\\mathcal{M}) \\sqsubseteq\n\\mathcal{N} \\Leftrightarrow \\mathcal{M} \\sqsubseteq\n\\gamma_{\\mathcal{R}}(\\mathcal{N})$. Action codes may be used to construct\nadaptors that translate between concrete and abstract actions during learning\nand testing of Mealy machines. If Mealy machine $\\mathcal{M}$ models a\nblack-box system then $\\alpha_{\\mathcal{R}}(\\mathcal{M})$ describes the\nbehavior that can be observed by a learner/tester that interacts with this\nsystem via an adaptor derived from code ${\\mathcal{R}}$. Whenever\n$\\alpha_{\\mathcal{R}}(\\mathcal{M})$ implements (or conforms to) $\\mathcal{N}$,\nwe may conclude that $\\mathcal{M}$ implements (or conforms to)\n$\\gamma_{{\\mathcal{R}}} (\\mathcal{N})$.\n",
        "pdf_link": "http://arxiv.org/pdf/2301.00199v2"
    },
    {
        "title": "Undecidable properties of self-affine sets and multi-tape automata",
        "authors": [
            "Timo Jolivet",
            "Jarkko Kari"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We study the decidability of the topological properties of some objects\ncoming from fractal geometry. We prove that having empty interior is\nundecidable for the sets defined by two-dimensional graph-directed iterated\nfunction systems. These results are obtained by studying a particular class of\nself-affine sets associated with multi-tape automata. We first establish the\nundecidability of some language-theoretical properties of such automata, which\nthen translate into undecidability results about their associated self-affine\nsets.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.0705v2"
    },
    {
        "title": "More ties than we thought",
        "authors": [
            "Dan Hirsch",
            "Ingemar Markström",
            "Meredith L Patterson",
            "Anders Sandberg",
            "Mikael Vejdemo-Johansson"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We extend the existing enumeration of neck tie-knots to include tie-knots\nwith a textured front, tied with the narrow end of a tie. These tie-knots have\ngained popularity in recent years, based on reconstructions of a costume detail\nfrom The Matrix Reloaded, and are explicitly ruled out in the enumeration by\nFink and Mao (2000).\n  We show that the relaxed tie-knot description language that comprehensively\ndescribes these extended tie-knot classes is context free. It has a regular\nsub-language that covers all the knots that originally inspired the work.\n  From the full language, we enumerate 266 682 distinct tie-knots that seem\ntie-able with a normal neck-tie. Out of these 266 682, we also enumerate 24 882\ntie-knots that belong to the regular sub-language.\n",
        "pdf_link": "http://arxiv.org/pdf/1401.8242v2"
    },
    {
        "title": "New Results on the Minimum Amount of Useful Space",
        "authors": [
            "Zuzana Bednárová",
            "Viliam Geffert",
            "Klaus Reinhardt",
            "Abuzer Yakaryilmaz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present several new results on minimal space requirements to recognize a\nnonregular language: (i) realtime nondeterministic Turing machines can\nrecognize a nonregular unary language within weak $\\log\\log n$ space, (ii)\n$\\log\\log n$ is a tight space lower bound for accepting general nonregular\nlanguages on weak realtime pushdown automata, (iii) there exist unary\nnonregular languages accepted by realtime alternating one-counter automata\nwithin weak $\\log n$ space, (iv) there exist nonregular languages accepted by\ntwo-way deterministic pushdown automata within strong $\\log\\log n$ space, and,\n(v) there exist unary nonregular languages accepted by two-way one-counter\nautomata using quantum and classical states with middle $\\log n$ space and\nbounded error.\n",
        "pdf_link": "http://arxiv.org/pdf/1405.2892v2"
    },
    {
        "title": "Alternating, private alternating, and quantum alternating realtime\n  automata",
        "authors": [
            "Gökalp Demirci",
            "Mika Hirvensalo",
            "Klaus Reinhardt",
            "A. C. Cem Say",
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  We present new results on realtime alternating, private alternating, and\nquantum alternating automaton models. Firstly, we show that the emptiness\nproblem for alternating one-counter automata on unary alphabets is undecidable.\nThen, we present two equivalent definitions of realtime private alternating\nfinite automata (PAFAs). We show that the emptiness problem is undecidable for\nPAFAs. Furthermore, PAFAs can recognize some nonregular unary languages,\nincluding the unary squares language, which seems to be difficult even for some\nclassical counter automata with two-way input. Regarding quantum finite\nautomata (QFAs), we show that the emptiness problem is undecidable both for\nuniversal QFAs on general alphabets, and for alternating QFAs with two\nalternations on unary alphabets. On the other hand, the same problem is\ndecidable for nondeterministic QFAs on general alphabets. We also show that the\nunary squares language is recognized by alternating QFAs with two alternations.\n",
        "pdf_link": "http://arxiv.org/pdf/1407.0334v5"
    },
    {
        "title": "Proving Safety with Trace Automata and Bounded Model Checking",
        "authors": [
            "Daniel Kroening",
            "Matt Lewis",
            "Georg Weissenbacher"
        ],
        "category": "cs.FL",
        "published_year": "2014",
        "summary": "  Loop under-approximation is a technique that enriches C programs with\nadditional branches that represent the effect of a (limited) range of loop\niterations. While this technique can speed up the detection of bugs\nsignificantly, it introduces redundant execution traces which may complicate\nthe verification of the program. This holds particularly true for verification\ntools based on Bounded Model Checking, which incorporate simplistic heuristics\nto determine whether all feasible iterations of a loop have been considered.\n  We present a technique that uses \\emph{trace automata} to eliminate redundant\nexecutions after performing loop acceleration. The method reduces the diameter\nof the program under analysis, which is in certain cases sufficient to allow a\nsafety proof using Bounded Model Checking. Our transformation is precise---it\ndoes not introduce false positives, nor does it mask any errors. We have\nimplemented the analysis as a source-to-source transformation, and present\nexperimental results showing the applicability of the technique.\n",
        "pdf_link": "http://arxiv.org/pdf/1410.5764v1"
    },
    {
        "title": "Generalized Eilenberg Theorem I: Local Varieties of Languages",
        "authors": [
            "Jiri Adamek",
            "Stefan Milius",
            "Robert Myers",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We investigate the duality between algebraic and coalgebraic recognition of\nlanguages to derive a generalization of the local version of Eilenberg's\ntheorem. This theorem states that the lattice of all boolean algebras of\nregular languages over an alphabet {\\Sigma} closed under derivatives is\nisomorphic to the lattice of all pseudovarieties of {\\Sigma}-generated monoids.\nBy applying our method to different categories, we obtain three related\nresults: one, due to Gehrke, Grigorieff and Pin, weakens boolean algebras to\ndistributive lattices, one weakens them to join-semilattices, and the last one\nconsiders vector spaces over the binary field.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.02834v1"
    },
    {
        "title": "Varieties of Languages in a Category",
        "authors": [
            "Jiri Adamek",
            "Stefan Milius",
            "Robert Myers",
            "Henning Urbat"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  Eilenberg's variety theorem, a centerpiece of algebraic automata theory,\nestablishes a bijective correspondence between varieties of languages and\npseudovarieties of monoids. In the present paper this result is generalized to\nan abstract pair of algebraic categories: we introduce varieties of languages\nin a category C, and prove that they correspond to pseudovarieties of monoids\nin a closed monoidal category D, provided that C and D are dual on the level of\nfinite objects. By suitable choices of these categories our result uniformly\ncovers Eilenberg's theorem and three variants due to Pin, Polak and Reutenauer,\nrespectively, and yields new Eilenberg-type correspondences.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.05180v1"
    },
    {
        "title": "Consensus Game Acceptors and Iterated Transductions",
        "authors": [
            "Dietmar Berwanger",
            "Marie van den Bogaard"
        ],
        "category": "cs.FL",
        "published_year": "2015",
        "summary": "  We study a game for recognising formal languages, in which two players with\nimperfect information need to coordinate on a common decision, given private\ninput words correlated by a finite graph. The players have a joint objective to\navoid an inadmissible decision, in spite of the uncertainty induced by the\ninput.\n  We show that the acceptor model based on consensus games characterises\ncontext-sensitive languages. Further, we describe the expressiveness of these\ngames in terms of iterated synchronous transductions and identify a subclass\nthat characterises context-free languages.\n",
        "pdf_link": "http://arxiv.org/pdf/1501.07131v3"
    },
    {
        "title": "An Automaton Learning Approach to Solving Safety Games over Infinite\n  Graphs",
        "authors": [
            "Daniel Neider",
            "Ufuk Topcu"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  We propose a method to construct finite-state reactive controllers for\nsystems whose interactions with their adversarial environment are modeled by\ninfinite-duration two-player games over (possibly) infinite graphs. The\nproposed method targets safety games with infinitely many states or with such a\nlarge number of states that it would be impractical---if not impossible---for\nconventional synthesis techniques that work on the entire state space. We\nresort to constructing finite-state controllers for such systems through an\nautomata learning approach, utilizing a symbolic representation of the\nunderlying game that is based on finite automata. Throughout the learning\nprocess, the learner maintains an approximation of the winning region\n(represented as a finite automaton) and refines it using different types of\ncounterexamples provided by the teacher until a satisfactory controller can be\nderived (if one exists). We present a symbolic representation of safety games\n(inspired by regular model checking), propose implementations of the learner\nand teacher, and evaluate their performance on examples motivated by robotic\nmotion planning in dynamic environments.\n",
        "pdf_link": "http://arxiv.org/pdf/1601.01660v1"
    },
    {
        "title": "A Software Package for Chemically Inspired Graph Transformation",
        "authors": [
            "Jakob L. Andersen",
            "Christoph Flamm",
            "Daniel Merkle",
            "Peter F. Stadler"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Chemical reaction networks can be automatically generated from graph grammar\ndescriptions, where rewrite rules model reaction patterns. Because a molecule\ngraph is connected and reactions in general involve multiple molecules, the\nrewriting must be performed on multisets of graphs. We present a general\nsoftware package for this type of graph rewriting system, which can be used for\nmodelling chemical systems. The package contains a C++ library with algorithms\nfor working with transformation rules in the Double Pushout formalism, e.g.,\ncomposition of rules and a domain specific language for programming graph\nlanguage generation. A Python interface makes these features easily accessible.\nThe package also has extensive procedures for automatically visualising not\nonly graphs and rewrite rules, but also Double Pushout diagrams and graph\nlanguages in form of directed hypergraphs. The software is available as an open\nsource package, and interactive examples can be found on the accompanying\nwebpage.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.02481v2"
    },
    {
        "title": "Automatic Theorem Proving in Walnut",
        "authors": [
            "Hamoon Mousavi"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Walnut is a software package that implements a mechanical decision procedure\nfor deciding certain combinatorial properties of some special words referred to\nas automatic words or automatic sequences. Walnut is written in Java and is\nopen source. It is licensed under GNU General Public License.\n",
        "pdf_link": "http://arxiv.org/pdf/1603.06017v2"
    },
    {
        "title": "On Restricted Nonnegative Matrix Factorization",
        "authors": [
            "Dmitry Chistikov",
            "Stefan Kiefer",
            "Ines Marušić",
            "Mahsa Shirmohammadi",
            "James Worrell"
        ],
        "category": "cs.FL",
        "published_year": "2016",
        "summary": "  Nonnegative matrix factorization (NMF) is the problem of decomposing a given\nnonnegative $n \\times m$ matrix $M$ into a product of a nonnegative $n \\times\nd$ matrix $W$ and a nonnegative $d \\times m$ matrix $H$. Restricted NMF\nrequires in addition that the column spaces of $M$ and $W$ coincide. Finding\nthe minimal inner dimension $d$ is known to be NP-hard, both for NMF and\nrestricted NMF. We show that restricted NMF is closely related to a question\nabout the nature of minimal probabilistic automata, posed by Paz in his seminal\n1971 textbook. We use this connection to answer Paz's question negatively, thus\nfalsifying a positive answer claimed in 1974. Furthermore, we investigate\nwhether a rational matrix $M$ always has a restricted NMF of minimal inner\ndimension whose factors $W$ and $H$ are also rational. We show that this holds\nfor matrices $M$ of rank at most $3$ and we exhibit a rank-$4$ matrix for which\n$W$ and $H$ require irrational entries.\n",
        "pdf_link": "http://arxiv.org/pdf/1605.07061v1"
    },
    {
        "title": "Sums of Palindromes: an Approach via Automata",
        "authors": [
            "Aayush Rajasekaran",
            "Jeffrey Shallit",
            "Tim Smith"
        ],
        "category": "cs.FL",
        "published_year": "2017",
        "summary": "  Recently, Cilleruelo, Luca, & Baxter proved, for all bases b >= 5, that every\nnatural number is the sum of at most 3 natural numbers whose base-b\nrepresentation is a palindrome. However, the cases b = 2, 3, 4 were left\nunresolved.\n  We prove, using a decision procedure based on automata, that every natural\nnumber is the sum of at most 4 natural numbers whose base-2 representation is a\npalindrome. Here the constant 4 is optimal. We obtain similar results for bases\n3 and 4, thus completely resolving the problem.\n  We consider some other variations on this problem, and prove similar results.\nWe argue that heavily case-based proofs are a good signal that a decision\nprocedure may help to automate the proof.\n",
        "pdf_link": "http://arxiv.org/pdf/1706.10206v3"
    },
    {
        "title": "Most Permissive Semantics of Boolean Networks",
        "authors": [
            "Thomas Chatain",
            "Stefan Haar",
            "Juraj Kol{č}ák",
            "Loïc Paulevé"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  As shown in (http://dx.doi.org/10.1101/2020.03.22.998377), the usual update\nmodes of Boolean networks (BNs), including synchronous and (generalized)\nasynchronous, fail to capture behaviors introduced by multivalued refinements.\nThus, update modes do not allow a correct abstract reasoning on dynamics of\nbiological systems, as they may lead to reject valid BN models.This technical\nreport lists the main definitions and properties of the most permissive\nsemantics of BNs introduced in http://dx.doi.org/10.1101/2020.03.22.998377.\nThis semantics meets with a correct abstraction of any multivalued refinements,\nwith any update mode. It subsumes all the usual updating modes, while enabling\nnew behaviors achievable by more concrete models. Moreover, it appears that\nclassical dynamical analyzes of reachability and attractors have a simpler\ncomputational complexity:- reachability can be assessed in a polynomial number\nof iterations. The computation of iterations is in NP in the very general case,\nand is linear when local functions are monotonic, or with some usual\nrepresentations of functions of BNs (binary decision diagrams, Petri nets,\nautomata networks, etc.). Thus, reachability is in P with locally-monotonic\nBNs, and P$^{\\text{NP}}$ otherwise (instead of being PSPACE-complete with\nupdate modes);- deciding wherever a configuration belongs to an attractor is in\ncoNP with locally-monotonic BNs, and coNP$^{\\text{coNP}}$ otherwise (instead of\nPSPACE-complete with update modes).Furthermore, we demonstrate that the\nsemantics completely captures any behavior achievable with any multilevel or\nODE refinement of the BN; and the semantics is minimal with respect to this\nmodel refinement criteria: to any most permissive trajectory, there exists a\nmultilevel refinement of the BN which can reproduce it.In brief, the most\npermissive semantics of BNs enables a correct abstract reasoning on dynamics of\nBNs, with a greater tractability than previously introduced update modes.\n",
        "pdf_link": "http://arxiv.org/pdf/1808.10240v2"
    },
    {
        "title": "Cobham's Theorem and Automaticity",
        "authors": [
            "Lucas Mol",
            "Narad Rampersad",
            "Jeffrey Shallit",
            "Manon Stipulanti"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We make certain bounds in Krebs' proof of Cobham's theorem explicit and\nobtain corresponding upper bounds on the length of a common prefix of an\naperiodic $a$-automatic sequence and an aperiodic $b$-automatic sequence, where\n$a$ and $b$ are multiplicatively independent. We also show that an automatic\nsequence cannot have arbitrarily large factors in common with a Sturmian\nsequence.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.00679v2"
    },
    {
        "title": "Parameter Synthesis Problems for one parametric clock Timed Automata",
        "authors": [
            "Liyun Dai",
            "Taolue Chen",
            "Zhiming Liu",
            "Bican Xia",
            "Naijun Zhan",
            "Kim G. Larsen"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  In this paper, we study the parameter synthesis problem for a class of\nparametric timed automata. The problem asks to construct the set of valuations\nof the parameters in the parametric timed automa- ton, referred to as the\nfeasible region, under which the resulting timed automaton satisfies certain\nproperties. We show that the parameter syn- thesis problem of parametric timed\nautomata with only one parametric clock (unlimited concretely constrained\nclock) and arbitrarily many pa- rameters is solvable when all the expressions\nare linear expressions. And it is moreover the synthesis problem is solvable\nwhen the form of con- straints are parameter polynomial inequality not just\nsimple constraint and parameter domain is nonnegative real number.\n",
        "pdf_link": "http://arxiv.org/pdf/1809.07177v1"
    },
    {
        "title": "Identifiers in Registers - Describing Network Algorithms with Logic",
        "authors": [
            "Benedikt Bollig",
            "Patricia Bouyer",
            "Fabian Reiter"
        ],
        "category": "cs.FL",
        "published_year": "2018",
        "summary": "  We propose a formal model of distributed computing based on register automata\nthat captures a broad class of synchronous network algorithms. The local memory\nof each process is represented by a finite-state controller and a fixed number\nof registers, each of which can store the unique identifier of some process in\nthe network. To underline the naturalness of our model, we show that it has the\nsame expressive power as a certain extension of first-order logic on graphs\nwhose nodes are equipped with a total order. Said extension lets us define new\nfunctions on the set of nodes by means of a so-called partial fixpoint\noperator. In spirit, our result bears close resemblance to a classical theorem\nof descriptive complexity theory that characterizes the complexity class PSPACE\nin terms of partial fixpoint logic (a proper superclass of the logic we\nconsider here).\n",
        "pdf_link": "http://arxiv.org/pdf/1811.08197v1"
    },
    {
        "title": "The Complexity of Unavoidable Word Patterns",
        "authors": [
            "Paul Sauer"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The avoidability, or unavoidability of patterns in words over finite\nalphabets has been studied extensively. A word (pattern) over a finite set is\nsaid to be unavoidable if, for all but finitely many words, there exists a\nmorphism mapping the pattern into every word. We present various\ncomplexity-related properties of unavoidable words. For words that are\nunavoidable, we provide an upper bound to the lengths of words that avoid them.\nA natural subsequent question is how many unavoidable words there are. We show\nthat the fraction of words that are unavoidable drops exponentially fast in the\nlength of the word. This allows us to calculate an upper bound on the number of\nunavoidable patterns for any given finite alphabet. Subsequently, we\ninvestigate computational aspects of unavoidable words. In particular, we\nexhibit concrete algorithms for determining whether a word is unavoidable. We\nalso prove results on the computational complexity of the problem of\ndetermining whether a given word is unavoidable.\n",
        "pdf_link": "http://arxiv.org/pdf/1901.07431v4"
    },
    {
        "title": "The Polynomial Complexity of Vector Addition Systems with States",
        "authors": [
            "Florian Zuleger"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  Vector addition systems are an important model in theoretical computer\nscience and have been used in a variety of areas. In this paper, we consider\nvector addition systems with states over a parameterized initial configuration.\nFor these systems, we are interested in the standard notion of computational\ncomplexity, i.e., we want to understand the length of the longest trace for a\nfixed vector addition system with states depending on the size of the initial\nconfiguration. We show that the asymptotic complexity of a given vector\naddition system with states is either $\\Theta(N^k)$ for some computable integer\n$k$, where $N$ is the size of the initial configuration, or at least\nexponential. We further show that $k$ can be computed in polynomial time in the\nsize of the considered vector addition system. Finally, we show that $1 \\le k\n\\le 2^n$, where $n$ is the dimension of the considered vector addition system.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.01076v3"
    },
    {
        "title": "Nonuniform Families of Polynomial-Size Quantum Finite Automata and\n  Quantum Logarithmic-Space Computation with Polynomial-Size Advice",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  The state complexity of a finite(-state) automaton intuitively measures the\nsize of the description of the automaton. Sakoda and Sipser [STOC 1972, pp.\n275--286] were concerned with nonuniform families of finite automata and they\ndiscussed the behaviors of the nonuniform complexity classes defined by such\nfamilies of finite automata having polynomial-size state complexity. In a\nsimilar fashion, we introduce nonuniform state complexity classes using\nnonuniform families of quantum finite automata empowered by the flexible use of\ngarbage tapes. We first present general inclusion and separation relationships\namong nonuniform state complexity classes of various one-way finite automata,\nincluding deterministic, nondeterministic, probabilistic, and quantum finite\nautomata having polynomially many inner states. For two-way quantum finite\nautomata equipped with flexible garbage tapes, we show a close relationship\nbetween the nonuniform state complexity of the family of such polynomial-size\nquantum finite automata and the parameterized complexity class induced by\nlogarithmic-space quantum computation assisted by polynomial-size advice. We\nfurther establish a direct connection between space-bounded quantum computation\nwith quantum advice and quantum finite automata whose transitions are dictated\nby superpositions of transition tables.\n",
        "pdf_link": "http://arxiv.org/pdf/1907.02916v4"
    },
    {
        "title": "Dependently Typed Knowledge Graphs",
        "authors": [
            "Zhangsheng Lai",
            "Aik Beng Ng",
            "Liang Ze Wong",
            "Simon See",
            "Shaowei Lin"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Reasoning over knowledge graphs is traditionally built upon a hierarchy of\nlanguages in the Semantic Web Stack. Starting from the Resource Description\nFramework (RDF) for knowledge graphs, more advanced constructs have been\nintroduced through various syntax extensions to add reasoning capabilities to\nknowledge graphs. In this paper, we show how standardized semantic web\ntechnologies (RDF and its query language SPARQL) can be reproduced in a unified\nmanner with dependent type theory. In addition to providing the basic\nfunctionalities of knowledge graphs, dependent types add expressiveness in\nencoding both entities and queries, explainability in answers to queries\nthrough witnesses, and compositionality and automation in the construction of\nwitnesses. Using the Coq proof assistant, we demonstrate how to build and query\ndependently typed knowledge graphs as a proof of concept for future works in\nthis direction.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.03785v1"
    },
    {
        "title": "Kontrol Edilebilir ptSTL Formulu Sentezi -- Synthesis of Controllable\n  ptSTL Formulas",
        "authors": [
            "Irmak Saglam",
            "Ebru Aydin Gol"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In this work, we develop an approach to anomaly detection and prevention\nproblem using Signal Temporal Logic (STL). This approach consists of two steps:\ndetection of the causes of the anomalities as STL formulas and prevention of\nthe satisfaction of the formula via controller synthesis. This work focuses on\nthe first step and proposes a formula template such that any controllable cause\ncan be represented in this template. An efficient algorithm to synthesize\nformulas in this template is presented. Finally, the results are shown on an\nexample.\n  -----\n  Bu bildiride anomali tespiti ve onlenmesi problemine, Sinyal Zamansal Mantigi\n(Signal Temporal Logic) tabanli iki asamali bir cozum sunulmaktadir. Ilk asama\nnedenlerin tespiti, ikinci asama ise bir kontrol stratejisi ile nedenlerin\nsistem uzerinde engellenmesidir. Iki asama birbirine bagimlidir. Bu bildiride,\nilk asama olan istenmeyen olaylarin nedenlerinin tespitinde kullanilan neden\nformulu sablonu gelistirilmektedir. Bildiride kullanilan sablon ile butun\nkontrol edilebilir formuller tanimlanabilmektedir. Bu sablon icin verimli bir\nformul sentezleme algoritmasi sunulmus, ve sonuclar ornek bir sistem uzerinde\ngosterilmistir.\n",
        "pdf_link": "http://arxiv.org/pdf/2003.09918v1"
    },
    {
        "title": "Gauge-invariance in cellular automata",
        "authors": [
            "Pablo Arrighi",
            "Giuseppe Di Molfetta",
            "Nathanaël Eon"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Gauge-invariance is a fundamental concept in Physics -- known to provide\nmathematical justification for the fundamental forces. In this paper, we\nprovide discrete counterparts to the main gauge theoretical concepts directly\nin terms of Cellular Automata. More precisely, the notions of gauge-invariance\nand gauge-equivalence in Cellular Automata are formalized. A step-by-step\ngauging procedure to enforce this symmetry upon a given Cellular Automaton is\ndeveloped, and three examples of gauge-invariant Cellular Automata are\nexamined.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.03656v2"
    },
    {
        "title": "Parameterized Verification of Systems with Global Synchronization and\n  Guards",
        "authors": [
            "Nouraldin Jaber",
            "Swen Jacobs",
            "Christopher Wagner",
            "Milind Kulkarni",
            "Roopsha Samanta"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Inspired by distributed applications that use consensus or other agreement\nprotocols for global coordination, we define a new computational model for\nparameterized systems that is based on a general global synchronization\nprimitive and allows for global transition guards. Our model generalizes many\nexisting models in the literature, including broadcast protocols and guarded\nprotocols. We show that reachability properties are decidable for systems\nwithout guards, and give sufficient conditions under which they remain\ndecidable in the presence of guards. Furthermore, we investigate cutoffs for\nreachability properties and provide sufficient conditions for small cutoffs in\na number of cases that are inspired by our target applications.\n",
        "pdf_link": "http://arxiv.org/pdf/2004.04896v3"
    },
    {
        "title": "A Quantum Finite Automata Approach to Modeling the Chemical Reactions",
        "authors": [
            "Amandeep Singh Bhatia",
            "Shenggen Zheng"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  In recent years, the modeling interest has increased significantly from the\nmolecular level to the atomic and quantum scale. The field of computational\nchemistry plays a significant role in designing computational models for the\noperation and simulation of systems ranging from atoms and molecules to\nindustrial-scale processes. It is influenced by a tremendous increase in\ncomputing power and the efficiency of algorithms. The representation of\nchemical reactions using classical automata theory in thermodynamic terms had a\ngreat influence on computer science. The study of chemical information\nprocessing with quantum computational models is a natural goal. In this paper,\nwe have modeled chemical reactions using two-way quantum finite automata, which\nare halted in linear time. Additionally, classical pushdown automata can be\ndesigned for such chemical reactions with multiple stacks. It has been proven\nthat computational versatility can be increased by combining chemical\naccept/reject signatures and quantum automata models.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.03976v1"
    },
    {
        "title": "RNA-2QCFA: Evolving Two-way Quantum Finite Automata with Classical\n  States for RNA Secondary Structures",
        "authors": [
            "Amandeep Singh Bhatia",
            "Shenggen Zheng"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Recently, the use of mathematical methods and computer science applications\nhave got significant response among biochemists and biologists to modeling the\nbiological systems. The computational and mathematical methods have enormous\npotential for modeling the deoxyribonucleic acid (DNA) and ribonucleic acid\n(RNA) structures. The modeling of DNA and RNA secondary structures using\nautomata theory had a significant impact in the fields of computer science. It\nis a natural goal to model the RNA secondary biomolecular structures using\nquantum computational models. Two-way quantum finite automata with classical\nstates are more dominant than two-way probabilistic finite automata in language\nrecognition. The main objective of this paper is on using two-way quantum\nfinite automata with classical states to simulate, model and analyze the\nribonucleic acid (RNA) sequences.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.06273v1"
    },
    {
        "title": "Verification and Parameter Synthesis for Real-Time Programs using\n  Refinement of Trace Abstraction",
        "authors": [
            "Franck Cassez",
            "Peter Gjøl Jensen",
            "Kim Guldstrand Larsen"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  We address the safety verification and synthesis problems for real-time\nsystems. We introduce real-time programs that are made of instructions that can\nperform assignments to discrete and real-valued variables. They are general\nenough to capture interesting classes of timed systems such as timed automata,\nstopwatch automata, time(d) Petri nets and hybrid automata.\n  We propose a semi-algorithm using refinement of trace abstractions to solve\nboth the reachability verification problem and the parameter synthesis problem\nfor real-time programs.\n  All of the algorithms proposed have been implemented and we have conducted a\nseries of experiments, comparing the performance of our new approach to\nstate-of-the-art tools in classical reachability, robustness analysis and\nparameter synthesis for timed systems. We show that our new method provides\nsolutions to problems which are unsolvable by the current state-of-the-art\ntools.\n",
        "pdf_link": "http://arxiv.org/pdf/2007.10539v1"
    },
    {
        "title": "Reinforcement Learning Based Temporal Logic Control with Maximum\n  Probabilistic Satisfaction",
        "authors": [
            "Mingyu Cai",
            "Shaoping Xiao",
            "Baoluo Li",
            "Zhiliang Li",
            "Zhen Kan"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  This paper presents a model-free reinforcement learning (RL) algorithm to\nsynthesize a control policy that maximizes the satisfaction probability of\nlinear temporal logic (LTL) specifications. Due to the consideration of\nenvironment and motion uncertainties, we model the robot motion as a\nprobabilistic labeled Markov decision process with unknown transition\nprobabilities and unknown probabilistic label functions. The LTL task\nspecification is converted to a limit deterministic generalized B\\\"uchi\nautomaton (LDGBA) with several accepting sets to maintain dense rewards during\nlearning. The novelty of applying LDGBA is to construct an embedded LDGBA\n(E-LDGBA) by designing a synchronous tracking-frontier function, which enables\nthe record of non-visited accepting sets without increasing dimensional and\ncomputational complexity. With appropriate dependent reward and discount\nfunctions, rigorous analysis shows that any method that optimizes the expected\ndiscount return of the RL-based approach is guaranteed to find the optimal\npolicy that maximizes the satisfaction probability of the LTL specifications. A\nmodel-free RL-based motion planning strategy is developed to generate the\noptimal policy in this paper. The effectiveness of the RL-based control\nsynthesis is demonstrated via simulation and experimental results.\n",
        "pdf_link": "http://arxiv.org/pdf/2010.06797v5"
    },
    {
        "title": "The complexity of bounded context switching with dynamic thread creation",
        "authors": [
            "Pascal Baumann",
            "Rupak Majumdar",
            "Ramanathan S. Thinniyam",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  Dynamic networks of concurrent pushdown systems (DCPS) are a theoretical\nmodel for multi-threaded recursive programs with shared global state and\ndynamical creation of threads. The (global) state reachability problem for DCPS\nis undecidable in general, but Atig et al. (2009) showed that it becomes\ndecidable, and is in 2EXPSPACE, when each thread is restricted to a fixed\nnumber of context switches. The best known lower bound for the problem is\nEXPSPACE-hard and this lower bound follows already when each thread is a\nfinite-state machine and runs atomically to completion (i.e., does not switch\ncontexts). In this paper, we close the gap by showing that state reachability\nis 2EXPSPACE-hard already with only one context switch. Interestingly, state\nreachability analysis is in EXPSPACE both for pushdown threads without context\nswitches as well as for finite-state threads with arbitrary context switches.\nThus, recursive threads together with a single context switch provide an\nexponential advantage.\n  Our proof techniques are of independent interest for 2EXPSPACE-hardness\nresults. We introduce transducer-defined Petri nets, a succinct representation\nfor Petri nets, and show coverability is 2EXPSPACE-hard for this model. To show\n2EXPSPACE-hardness, we present a modified version of Lipton's simulation of\ncounter machines by Petri nets, where the net programs can make explicit\nrecursive procedure calls up to a bounded depth.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.05825v1"
    },
    {
        "title": "Agafonov's Theorem for finite and infinite alphabets and probability\n  distributions different from equidistribution",
        "authors": [
            "Thomas Seiller",
            "Jakob Grue Simonsen"
        ],
        "category": "cs.FL",
        "published_year": "2020",
        "summary": "  An infinite sequence $\\alpha$ over an alphabet $\\Sigma$ is $\\mu$-distributed\nw.r.t. a probability map $\\mu$ if, for every finite string $w$, the limiting\nfrequency of $w$ in $\\alpha$ exists and equals $\\mu(w)$. %We raise the question\nof how to characterize the probability maps $\\mu$ for which\n$\\mu$-distributedness is preserved across finite-state selection, or\nequivalently, by selection by programs using constant space. We prove the\nfollowing result for any finite or countably infinite alphabet $\\Sigma$: every\nfinite-state selector over $\\Sigma$ selects a $\\mu$-distributed sequence from\nevery $\\mu$-distributed sequence \\emph{if and only if} $\\mu$ is induced by a\nBernoulli distribution on $\\Sigma$, that is a probability distribution on the\nalphabet extended to words by taking the product. The primary -- and remarkable\n-- consequence of our main result is a complete characterization of the set of\nprobability maps, on finite and infinite alphabets, for which finite-state\nselection preserves $\\mu$-distributedness. The main positive takeaway is that\n(the appropriate generalization of) Agafonov's Theorem holds for Bernoulli\ndistributions (rather than just equidistributions) on both finite and countably\ninfinite alphabets. As a further consequence, we obtain a result in the area of\nsymbolic dynamical systems: the shift-invariant measures $\\mu$ on\n$\\Sigma^{\\omega}$ such that any finite-state selector preserves the property of\ngenericity for $\\mu$, are exactly the positive Bernoulli measures.\n",
        "pdf_link": "http://arxiv.org/pdf/2011.08552v3"
    },
    {
        "title": "Positive first-order logic on words",
        "authors": [
            "Denis Kuperberg"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We study FO+, a fragment of first-order logic on finite words, where monadic\npredicates can only appear positively. We show that there is a FO-definable\nlanguage that is monotone in monadic predicates but not definable in FO+. This\nprovides a simple proof that Lyndon's preservation theorem fails on finite\nstructures. We additionally show that given a regular language, it is\nundecidable whether it is definable in FO+.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.01968v6"
    },
    {
        "title": "A Passive Online Technique for Learning Hybrid Automata from\n  Input/Output Traces",
        "authors": [
            "Iman Saberi",
            "Fathiyeh Faghih",
            "Farzad Sobhi Bavil"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Specification synthesis is the process of deriving a model from the\ninput-output traces of a system. It is used extensively in test design, reverse\nengineering, and system identification. One type of the resulting artifact of\nthis process for cyber-physical systems is hybrid automata. They are intuitive,\nprecise, tool independent, and at a high level of abstraction, and can model\nsystems with both discrete and continuous variables. In this paper, we propose\na new technique for synthesizing hybrid automaton from the input-output traces\nof a non-linear cyber-physical system. Similarity detection in non-linear\nbehaviors is the main challenge for extracting such models. We address this\nproblem by utilizing the Dynamic Time Warping technique. Our approach is\npassive, meaning that it does not need interaction with the system during\nautomata synthesis from the logged traces; and online, which means that each\ninput/output trace is used only once in the procedure. In other words, each new\ntrace can be used to improve the already synthesized automaton. We evaluated\nour algorithm in two industrial and simulated case studies. The accuracy of the\nderived automata show promising results.\n",
        "pdf_link": "http://arxiv.org/pdf/2101.07053v1"
    },
    {
        "title": "Free-Choice Nets With Home Clusters Are Lucent",
        "authors": [
            "Wil M. P. van der Aalst"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  A marked Petri net is lucent if there are no two different reachable markings\nenabling the same set of transitions, i.e., states are fully characterized by\nthe transitions they enable. Characterizing the class of systems that are\nlucent is a foundational and also challenging question. However, little\nresearch has been done on the topic. In this paper, it is shown that all\nfree-choice nets having a home cluster are lucent. These nets have a so-called\nhome marking such that it is always possible to reach this marking again. Such\na home marking can serve as a regeneration point or as an end-point. The result\nis highly relevant because in many applications, we want the system to be\nlucent and many well-behaved process models fall into the class identified in\nthis paper. Unlike previous work, we do not require the marked Petri net to be\nlive and strongly connected. Most of the analysis techniques for free-choice\nnets are tailored towards well-formed nets. The approach presented in this\npaper provides a novel perspective enabling new analysis techniques for\nfree-choice nets that do not need to be well-formed. Therefore, we can also\nmodel systems and processes that are terminating and/or have an initialization\nphase.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.03554v1"
    },
    {
        "title": "Reasoning about Emergence of Collective Memory",
        "authors": [
            "R. Ramanujam"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We offer a very simple model of how collective memory may form. Agents keep\nsignalling within neighbourhoods, and depending on how many support each\nsignal, some signals \"win\" in that neighbourhood. By agents interacting between\ndifferent neighbourhoods, 'influence' spreads and sometimes, a collective\nsignal emerges. We propose a logic in which we can reason about such emergence\nof memory and present preliminary technical results on the logic.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.11505v1"
    },
    {
        "title": "Decomposition of transition systems into sets of synchronizing state\n  machines",
        "authors": [
            "Viktor Teren",
            "Jordi Cortadella",
            "Tiziano Villa"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Transition systems (TS) and Petri nets (PN) are important models of\ncomputation ubiquitous in formal methods for modeling systems. An important\nproblem is how to extract from a given TS a PN whose reachability graph is\nequivalent (with a suitable notion of equivalence) to the original TS.\n  This paper addresses the decomposition of transition systems into\nsynchronizing state machines (SMs), which are a class of Petri nets where each\ntransition has one incoming and one outgoing arc and all markings have exactly\none token. This is an important case of the general problem of extracting a PN\nfrom a TS. The decomposition is based on the theory of regions, and it is shown\nthat a property of regions called excitation-closure is a sufficient condition\nto guarantee the equivalence between the original TS and a decomposition into\nSMs.\n  An efficient algorithm is provided which solves the problem by reducing its\ncritical steps to the maximal independent set problem (to compute a minimal set\nof irredundant SMs) or to satisfiability (to merge the SMs). We report\nexperimental results that show a good trade-off between quality of results vs.\ncomputation time.\n",
        "pdf_link": "http://arxiv.org/pdf/2106.13852v3"
    },
    {
        "title": "Computational Complexity of Synchronization under Sparse Regular\n  Constraints",
        "authors": [
            "Stefan Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The constrained synchronization problem (CSP) asks for a synchronizing word\nof a given input automaton contained in a regular set of constraints. It could\nbe viewed as a special case of synchronization of a discrete event system under\nsupervisory control. Here, we study the computational complexity of this\nproblem for the class of sparse regular constraint languages. We give a new\ncharacterization of sparse regular sets, which equal the bounded regular sets,\nand derive a full classification of the computational complexity of CSP for\nletter-bounded regular constraint languages, which properly contain the\nstrictly bounded regular languages. Then, we introduce strongly\nself-synchronizing codes and investigate CSP for bounded languages induced by\nthese codes. With our previous result, we deduce a full classification for\nthese languages as well. In both cases, depending on the constraint language,\nour problem becomes NP-complete or polynomial time solvable.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.00081v1"
    },
    {
        "title": "Finite Automata Intersection Non-Emptiness: Parameterized Complexity\n  Revisited",
        "authors": [
            "Henning Fernau",
            "Stefan Hoffmann",
            "Michael Wehar"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  The problem DFA-Intersection-Nonemptiness asks if a given number of\ndeterministic automata accept a common word. In general, this problem is\nPSPACE-complete. Here, we investigate this problem for the subclasses of\ncommutative automata and automata recognizing sparse languages. We show that in\nboth cases DFA-Intersection-Nonemptiness is complete for NP and for the\nparameterized class $W[1]$, where the number of input automata is the\nparameter, when the alphabet is fixed. Additionally, we establish the same\nresult for Tables Non-Empty Join, a problem that asks if the join of several\ntables (possibly containing null values) in a database is non-empty. Lastly, we\nshow that Bounded NFA-Intersection-Nonemptiness, parameterized by the length\nbound, is $\\mbox{co-}W[2]$-hard with a variable input alphabet and for\nnondeterministic automata recognizing finite strictly bounded languages,\nyielding a variant leaving the realm of $W[1]$.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.05244v1"
    },
    {
        "title": "Reducing Higher-order Recursion Scheme Equivalence to Coinductive\n  Higher-order Constrained Horn Clauses",
        "authors": [
            "Jerome Jochems"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Higher-order constrained Horn clauses (HoCHC) are a semantically-invariant\nsystem of higher-order logic modulo theories. With semi-decidable unsolvability\nover a semi-decidable background theory, HoCHC is suitable for safety\nverification. Less is known about its relation to larger classes of\nhigher-order verification problems. Motivated by program equivalence, we\nintroduce a coinductive version of HoCHC that enjoys a greatest model property.\nWe define an encoding of higher-order recursion schemes (HoRS) into HoCHC logic\nprograms. Correctness of this encoding reduces decidability of the open HoRS\nequivalence problem -- and, thus, the LambdaY-calculus B\\\"ohm tree equivalence\nproblem -- to semi-decidability of coinductive HoCHC over a complete and\ndecidable theory of trees.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.04632v1"
    },
    {
        "title": "Proceedings 12th International Symposium on Games, Automata, Logics, and\n  Formal Verification",
        "authors": [
            "Pierre Ganty",
            "Davide Bresolin"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This volume contains the proceedings of the 12th International Symposium on\nGames, Automata, Logic and Formal Verification (GandALF 2021). The aim of\nGandALF 2021 symposium is to bring together researchers from academia and\nindustry which are actively working in the fields of Games, Automata, Logics,\nand Formal Verification. The idea is to cover an ample spectrum of themes,\nranging from theory to applications, and stimulate cross-fertilization.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.07798v1"
    },
    {
        "title": "Abelian Repetition Threshold Revisited",
        "authors": [
            "Elena A. Petrova",
            "Arseny M. Shur"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  Abelian repetition threshold ART(k) is the number separating fractional\nAbelian powers which are avoidable and unavoidable over the k-letter alphabet.\nThe exact values of ART(k) are unknown; the lower bounds were proved in [A.V.\nSamsonov, A.M. Shur. On Abelian repetition threshold. RAIRO ITA, 2012] and\nconjectured to be tight. We present a method of study of Abelian power-free\nlanguages using random walks in prefix trees and some experimental results\nobtained by this method. On the base of these results, we conjecture that the\nlower bounds for ART(k) by Samsonov and Shur are not tight for all k except for\nk=5 and prove this conjecture for k=6,7,8,9,10. Namely, we show that ART(k) >\n(k-2)/(k-3) in all these cases.\n",
        "pdf_link": "http://arxiv.org/pdf/2109.09306v1"
    },
    {
        "title": "Symbolic Register Automata for Complex Event Recognition and Forecasting",
        "authors": [
            "Elias Alevizos",
            "Alexander Artikis",
            "Georgios Paliouras"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We propose an automaton model which is a combination of symbolic and register\nautomata, i.e., we enrich symbolic automata with memory. We call such automata\nSymbolic Register Automata (SRA). SRA extend the expressive power of symbolic\nautomata, by allowing Boolean formulas to be applied not only to the last\nelement read from the input string, but to multiple elements, stored in their\nregisters. SRA also extend register automata, by allowing arbitrary Boolean\nformulas, besides equality predicates. We study the closure properties of SRA\nunder union, intersection, concatenation, Kleene closure, complement and\ndeterminization and show that SRA, contrary to symbolic automata, are not in\ngeneral closed under complement and they are not determinizable. However, they\nare closed under these operations when a window operator, quintessential in\nComplex Event Recognition, is used. We show how SRA can be used in Complex\nEvent Recognition in order to detect patterns upon streams of events, using our\nframework that provides declarative and compositional semantics, and that\nallows for a systematic treatment of such automata. We also show how the\nbehavior of SRA, as they consume streams of events, can be given a\nprobabilistic description with the help of prediction suffix trees. This allows\nus to go one step beyond Complex Event Recognition to Complex Event\nForecasting, where, besides detecting complex patterns, we can also efficiently\nforecast their occurrence.\n",
        "pdf_link": "http://arxiv.org/pdf/2110.04032v1"
    },
    {
        "title": "Max-algebraic hybrid automata: Modelling and equivalences",
        "authors": [
            "A. Gupta",
            "B. De Schutter",
            "J. van der Woude",
            "T. van den Boom"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  This article introduces the novel framework of max-algebraic hybrid automata\nas a hybrid modelling language in the max-plus algebra. We show that the\nmodelling framework unifies and extends the switching max-plus linear systems\nframework and is analogous to the discrete hybrid automata framework in\nconventional algebra. In addition, we show that the framework serves as a\nbridge between automata-theoretic models in max-plus algebra and switching\nmax-plus linear systems. In doing so, we formalise the relationship between\nmax-plus automata and switching max-plus linear systems in a behavioural sense.\nThis also serves as another step towards importing tools for analysis and\noptimal control from conventional time-driven hybrid systems to discrete-event\nsystems in max-plus algebra.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.10318v1"
    },
    {
        "title": "Generating Tree Structures for Hyperbolic Tessellations",
        "authors": [
            "Dorota Celińska-Kopczyńska",
            "Eryk Kopczyński"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We show an efficient algorithm for generating geodesic regular tree\nstructures for periodic hyperbolic and Euclidean tessellations and\nexperimentally verify its performance on tessellations.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.12040v2"
    },
    {
        "title": "A Topological Approach for Computing Supremal Sublanguages for Some\n  Language Equations in Supervisory Control Theory",
        "authors": [
            "Liyong Lin",
            "Rong Su"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  In this paper, we shall present a topological approach for the computation of\nsome supremal sublanguages, often specified by language equations, which arise\nfrom the study of the supervisory control theory. The basic idea is to identify\nthe solutions of the language equations as open sets for some\n(semi)-topologies. Then, the supremal sublanguages naturally correspond to the\nsupremal open subsets, i.e., the interiors. This provides an elementary and\nuniform approach for computing various supremal sublanguages encountered in the\nsupervisory control theory and is closely related to a theory of approximation,\nknown as the rough set theory, in artificial intelligence.\n",
        "pdf_link": "http://arxiv.org/pdf/2111.13840v1"
    },
    {
        "title": "Positive First-order Logic on Words and Graphs",
        "authors": [
            "Denis Kuperberg"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We study FO+, a fragment of first-order logic on finite words, where monadic\npredicates can only appear positively. We show that there is an FO-definable\nlanguage that is monotone in monadic predicates but not definable in FO+. This\nprovides a simple proof that Lyndon's preservation theorem fails on finite\nstructures. We lift this example language to finite graphs, thereby providing a\nnew result of independent interest for FO-definable graph classes: negation\nmight be needed even when the class is closed under addition of edges. We\nfinally show that the problem of whether a given regular language of finite\nwords is definable in FO+ is undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2201.11619v5"
    },
    {
        "title": "Fast Symbolic Algorithms for Omega-Regular Games under Strong Transition\n  Fairness",
        "authors": [
            "Tamajit Banerjee",
            "Rupak Majumdar",
            "Kaushik Mallik",
            "Anne-Kathrin Schmuck",
            "Sadegh Soudjani"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider fixpoint algorithms for two-player games on graphs with\n$\\omega$-regular winning conditions, where the environment is constrained by a\nstrong transition fairness assumption. Strong transition fairness is a widely\noccurring special case of strong fairness, which requires that any execution is\nstrongly fair with respect to a specified set of live edges: whenever the\nsource vertex of a live edge is visited infinitely often along a play, the edge\nitself is traversed infinitely often along the play as well. We show that,\nsurprisingly, strong transition fairness retains the algorithmic\ncharacteristics of the fixpoint algorithms for $\\omega$-regular games -- the\nnew algorithms have the same alternation depth as the classical algorithms but\ninvoke a new type of predecessor operator. For Rabin games with $k$ pairs, the\ncomplexity of the new algorithm is $O(n^{k+2}k!)$ symbolic steps, which is\nindependent of the number of live edges in the strong transition fairness\nassumption. Further, we show that GR(1) specifications with strong transition\nfairness assumptions can be solved with a 3-nested fixpoint algorithm, same as\nthe usual algorithm. In contrast, strong fairness necessarily requires\nincreasing the alternation depth depending on the number of fairness\nassumptions. We get symbolic algorithms for (generalized) Rabin, parity and\nGR(1) objectives under strong transition fairness assumptions as well as a\ndirect symbolic algorithm for qualitative winning in stochastic\n$\\omega$-regular games that runs in $O(n^{k+2}k!)$ symbolic steps, improving\nthe state of the art. Finally, we have implemented a BDD-based synthesis engine\nbased on our algorithm. We show on a set of synthetic and real benchmarks that\nour algorithm is scalable, parallelizable, and outperforms previous algorithms\nby orders of magnitude.\n",
        "pdf_link": "http://arxiv.org/pdf/2202.07480v4"
    },
    {
        "title": "A Simpler Alternative: Minimizing Transition Systems Modulo Alternating\n  Simulation Equivalence",
        "authors": [
            "Gabriel de Albuquerque Gleizer",
            "Khushraj Nanik Madnani",
            "Manuel Mazo Jr"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This paper studies the reduction (abstraction) of finite-state transition\nsystems for control synthesis problems. We revisit the notion of alternating\nsimulation equivalence (ASE), a more relaxed condition than alternating\nbisimulations, to relate systems and their abstractions. As with alternating\nbisimulations, ASE preserves the property that the existence of a controller\nfor the abstraction is necessary and sufficient for a controller to exist for\nthe original system. Moreover, being a less stringent condition, ASE can reduce\nsystems further to produce smaller abstractions. We provide an algorithm that\nproduces minimal AS equivalent abstractions. The theoretical results are then\napplied to obtain (un)schedulability certificates of periodic event-triggered\ncontrol systems sharing a communication channel. A numerical example\nillustrates the results.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.01672v1"
    },
    {
        "title": "mwp-Analysis Improvement and Implementation: Realizing Implicit\n  Computational Complexity",
        "authors": [
            "Clément Aubert",
            "Thomas Rubiano",
            "Neea Rusch",
            "Thomas Seiller"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Implicit Computational Complexity (ICC) drives better understanding of\ncomplexity classes, but it also guides the development of resources-aware\nlanguages and static source code analyzers. Among the methods developed, the\nmwp-flow analysis certifies polynomial bounds on the size of the values\nmanipulated by an imperative program. This result is obtained by bounding the\ntransitions between states instead of focusing on states in isolation, as most\nstatic analyzers do, and is not concerned with termination or tight bounds on\nvalues. Those differences, along with its built-in compositionality, make the\nmwp-flow analysis a good target for determining how ICC-inspired techniques\ndiverge compared with more traditional static analysis methods. This paper's\ncontributions are threefold: we fine-tune the internal machinery of the\noriginal analysis to make it tractable in practice; we extend the analysis to\nfunction calls and leverage its machinery to compute the result of the analysis\nefficiently; and we implement the resulting analysis as a lightweight tool to\nautomatically perform data-size analysis of C programs. This documented effort\nprepares and enables the development of certified complexity analysis, by\ntransforming a costly analysis into a tractable program, that furthermore\ndecorrelates the problem of deciding if a bound exist with the problem of\ncomputing it.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.03943v1"
    },
    {
        "title": "Quantum Finite Automata and Quiver Algebras",
        "authors": [
            "George Jeffreys",
            "Siu-Cheong Lau"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We find an application in quantum finite automata for the ideas and results\nof [JL21] and [JL22]. We reformulate quantum finite automata with multiple-time\nmeasurements using the algebraic notion of near-ring. This gives a unified\nunderstanding towards quantum computing and deep learning. When the near-ring\ncomes from a quiver, we have a nice moduli space of computing machines with\nmetric that can be optimized by gradient descent.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.07597v2"
    },
    {
        "title": "Opportunistic Qualitative Planning in Stochastic Systems with\n  Preferences over Temporal Logic Objectives",
        "authors": [
            "Abhishek Ninad Kulkarni",
            "Jie Fu"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Preferences play a key role in determining what goals/constraints to satisfy\nwhen not all constraints can be satisfied simultaneously. In this work, we\nstudy preference-based planning in a stochastic system modeled as a Markov\ndecision process, subject to a possible incomplete preference over temporally\nextended goals. Our contributions are three folds: First, we introduce a\npreference language to specify preferences over temporally extended goals.\nSecond, we define a novel automata-theoretic model to represent the preorder\ninduced by given preference relation. The automata representation of\npreferences enables us to develop a preference-based planning algorithm for\nstochastic systems. Finally, we show how to synthesize opportunistic strategies\nthat achieves an outcome that improves upon the current satisfiable outcome,\nwith positive probability or with probability one, in a stochastic system. We\nillustrate our solution approaches using a robot motion planning example.\n",
        "pdf_link": "http://arxiv.org/pdf/2203.13803v1"
    },
    {
        "title": "Parameterized safety verification of round-based shared-memory systems",
        "authors": [
            "Nathalie Bertrand",
            "Nicolas Markey",
            "Ocan Sankur",
            "Nicolas Waldburger"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We consider the parameterized verification problem for distributed algorithms\nwhere the goal is to develop techniques to prove the correctness of a given\nalgorithm regardless of the number of participating processes. Motivated by an\nasynchronous binary consensus algorithm [J. Aspnes, Fast deterministic\nconsensus in a noisy environment. Journal of Algorithms, 2002], we consider\nround-based distributed algorithms communicating with shared memory. A\nparticular challenge in these systems is that 1) the number of processes is\nunbounded, and, more importantly, 2) there is a fresh set of registers at each\nround. A~verification algorithm thus needs to manage both sources of infinity.\nIn this setting, we prove that the safety verification problem, which consists\nin deciding whether all possible executions avoid a given error state, is\nPSPACE-complete. For~negative instances of the safety verification problem,\nwe~also provide exponential lower and upper bounds on the minimal number of\nprocesses needed for an error execution and on the minimal round on which the\nerror state can be covered.\n",
        "pdf_link": "http://arxiv.org/pdf/2204.11670v1"
    },
    {
        "title": "Alternating Good-for-MDP Automata",
        "authors": [
            "Ernst Moritz Hahn",
            "Mateo Perez",
            "Sven Schewe",
            "Fabio Somenzi",
            "Ashutosh Trivedi",
            "Dominik Wojtczak"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  When omega-regular objectives were first proposed in model-free reinforcement\nlearning (RL) for controlling MDPs, deterministic Rabin automata were used in\nan attempt to provide a direct translation from their transitions to scalar\nvalues. While these translations failed, it has turned out that it is possible\nto repair them by using good-for-MDPs (GFM) B\\\"uchi automata instead. These are\nnondeterministic B\\\"uchi automata with a restricted type of nondeterminism,\nalbeit not as restricted as in good-for-games automata. Indeed, deterministic\nRabin automata have a pretty straightforward translation to such GFM automata,\nwhich is bi-linear in the number of states and pairs. Interestingly, the same\ncannot be said for deterministic Streett automata: a translation to\nnondeterministic Rabin or B\\\"uchi automata comes at an exponential cost, even\nwithout requiring the target automaton to be good-for-MDPs. Do we have to pay\nmore than that to obtain a good-for-MDP automaton? The surprising answer is\nthat we have to pay significantly less when we instead expand the good-for-MDP\nproperty to alternating automata: like the nondeterministic GFM automata\nobtained from deterministic Rabin automata, the alternating good-for-MDP\nautomata we produce from deterministic Streett automata are bi-linear in the\nthe size of the deterministic automaton and its index, and can therefore be\nexponentially more succinct than minimal nondeterministic B\\\"uchi automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2205.03243v1"
    },
    {
        "title": "Towards Efficient Active Learning of PDFA",
        "authors": [
            "Franz Mayr",
            "Sergio Yovine",
            "Federico Pan",
            "Nicolas Basset",
            "Thao Dang"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We propose a new active learning algorithm for PDFA based on three main\naspects: a congruence over states which takes into account next-symbol\nprobability distributions, a quantization that copes with differences in\ndistributions, and an efficient tree-based data structure. Experiments showed\nsignificant performance gains with respect to reference implementations.\n",
        "pdf_link": "http://arxiv.org/pdf/2206.09004v1"
    },
    {
        "title": "Global Cellular Automata GCA -- A Massively Parallel Computing Model",
        "authors": [
            "Rolf Hoffmann"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The Global Cellular Automata (GCA) Model is a generalization of the Cellular\nAutomata (CA) Model. The GCA model consists of a collection of cells which\nchange their states depending on the states of their neighbors, like in the\nclassical CA model. In generalization of the CA model, the neighbors are no\nlonger fixed and local, they are variable and global. In the basic GCA model, a\ncell is structured into a data part and a pointer part. The pointer part\nconsists of several pointers that hold addresses to global neighbors. The data\nrule defines the new data state, and the pointer rule define the new pointer\nstates. The cell's state is synchronously or asynchronously updated using the\nnew data and new pointer states. Thereby the global neighbors can be changed\nfrom generation to generation. Similar to the CA model, only the own cell's\nstate is modified. Thereby write conflicts cannot occur, all cells can work in\nparallel which makes it a massively parallel model. The GCA model is related to\nthe CROW (concurrent read owners write) model, a specific PRAM (parallel random\naccess machine) model. Therefore many of the well-studied PRAM algorithms can\nbe transformed into GCA algorithms. Moreover, the GCA model allows to describe\na large number of data parallel applications in a suitable way. The GCA model\ncan easily be implemented in software, efficiently interpreted on standard\nparallel architectures, and synthesized / configured into special hardware\ntarget architectures. This article reviews the model, applications, and\nhardware architectures.\n",
        "pdf_link": "http://arxiv.org/pdf/2207.04885v1"
    },
    {
        "title": "Coarser Equivalences for Causal Concurrency",
        "authors": [
            "Azadeh Farzan",
            "Umang Mathur"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Trace theory is a principled framework for defining equivalence relations for\nconcurrent program runs based on a commutativity relation over the set of\natomic steps taken by individual program threads. Its simplicity, elegance, and\nalgorithmic efficiency makes it useful in many different contexts including\nprogram verification and testing. We study relaxations of trace equivalence\nwith the goal of maintaining its algorithmic advantages.\n  We first prove that the largest appropriate relaxation of trace equivalence,\nan equivalence relation that preserves the order of steps taken by each thread\nand what write operation each read operation observes, does not yield efficient\nalgorithms. We prove a linear space lower bound for the problem of checking, in\na streaming setting, if two arbitrary steps of a concurrent program run are\ncausally concurrent (i.e. they can be reordered in an equivalent run) or\ncausally ordered (i.e. they always appear in the same order in all equivalent\nruns). The same problem can be decided in constant space for trace equivalence.\nNext, we propose a new commutativity-based notion of equivalence called grain\nequivalence that is strictly more relaxed than trace equivalence, and yet\nyields a constant space algorithm for the same problem. This notion of\nequivalence uses commutativity of grains, which are sequences of atomic steps,\nin addition to the standard commutativity from trace theory. We study the two\ndistinct cases when the grains are contiguous subwords of the input program run\nand when they are not, formulate the precise definition of causal concurrency\nin each case, and show that they can be decided in constant space, despite\nbeing strict relaxations of the notion of causal concurrency based on trace\nequivalence.\n",
        "pdf_link": "http://arxiv.org/pdf/2208.12117v3"
    },
    {
        "title": "Proceedings of the 13th International Symposium on Games, Automata,\n  Logics and Formal Verification",
        "authors": [
            "Pierre Ganty",
            "Dario Della Monica"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  This volume contains the proceedings of the 13th International Symposium on\nGames, Automata, Logic and Formal Verification (GandALF 2022). The aim of\nGandALF 2022 symposium is to bring together researchers from academia and\nindustry which are actively working in the fields of Games, Automata, Logics,\nand Formal Verification. The idea is to cover an ample spectrum of themes,\nranging from theory to applications, and stimulate cross-fertilization.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.09333v1"
    },
    {
        "title": "On von Neumann regularity of cellular automata",
        "authors": [
            "Ville Salo"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We show that a cellular automaton on a one-dimensional two-sided mixing\nsubshift of finite type is a von Neumann regular element in the semigroup of\ncellular automata if and only if it is split epic onto its image in the\ncategory of sofic shifts and block maps. It follows from previous joint work of\nthe author and T\\\"orm\\\"a that von Neumann regularity is a decidable condition,\nand we decide it for all elementary CA, obtaining the optimal radii for weak\ngeneralized inverses. Two sufficient conditions for non-regularity are having a\nproper sofic image or having a point in the image with no preimage of the same\nperiod. We show that the non-regular ECA 9 and 28 cannot be proven non-regular\nusing these methods. We also show that a random cellular automaton is\nnon-regular with high probability.\n",
        "pdf_link": "http://arxiv.org/pdf/2209.13373v1"
    },
    {
        "title": "Stochastic Robustness Interval for Motion Planning with Signal Temporal\n  Logic",
        "authors": [
            "Roland B. Ilyes",
            "Qi Heng Ho",
            "Morteza Lahijanian"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  In this work, we present a novel robustness measure for continuous-time\nstochastic trajectories with respect to Signal Temporal Logic (STL)\nspecifications. We show the soundness of the measure and develop a monitor for\nreasoning about partial trajectories. Using this monitor, we introduce an STL\nsampling-based motion planning algorithm for robots under uncertainty. Given a\nminimum robustness requirement, this algorithm finds satisfying motion plans;\nalternatively, the algorithm also optimizes for the measure. We prove\nprobabilistic completeness and asymptotic optimality, and demonstrate the\neffectiveness of our approach on several case studies.\n",
        "pdf_link": "http://arxiv.org/pdf/2210.04813v2"
    },
    {
        "title": "Computable Bounds and Monte Carlo Estimates of the Expected Edit\n  Distance",
        "authors": [
            "Gianfranco Bilardi",
            "Michele Schimd"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  The edit distance is a metric of dissimilarity between strings, widely\napplied in computational biology, speech recognition, and machine learning. Let\n$e_k(n)$ denote the average edit distance between random, independent strings\nof $n$ characters from an alphabet of size $k$. For $k \\geq 2$, it is an open\nproblem how to efficiently compute the exact value of $\\alpha_{k}(n) =\ne_k(n)/n$ as well as of $\\alpha_{k} = \\lim_{n \\to \\infty} \\alpha_{k}(n)$, a\nlimit known to exist.\n  This paper shows that $\\alpha_k(n)-Q(n) \\leq \\alpha_k \\leq \\alpha_k(n)$, for\na specific $Q(n)=\\Theta(\\sqrt{\\log n / n})$, a result which implies that\n$\\alpha_k$ is computable. The exact computation of $\\alpha_k(n)$ is explored,\nleading to an algorithm running in time $T=\\mathcal{O}(n^2k\\min(3^n,k^n))$, a\ncomplexity that makes it of limited practical use.\n  An analysis of statistical estimates is proposed, based on McDiarmid's\ninequality, showing how $\\alpha_k(n)$ can be evaluated with good accuracy, high\nconfidence level, and reasonable computation time, for values of $n$ say up to\na quarter million. Correspondingly, 99.9\\% confidence intervals of width\napproximately $10^{-2}$ are obtained for $\\alpha_k$.\n  Combinatorial arguments on edit scripts are exploited to analytically\ncharacterize an efficiently computable lower bound $\\beta_k^*$ to $\\alpha_k$,\nsuch that $ \\lim_{k \\to \\infty} \\beta_k^*=1$. In general, $\\beta_k^* \\leq\n\\alpha_k \\leq 1-1/k$; for $k$ greater than a few dozens, computing $\\beta_k^*$\nis much faster than generating good statistical estimates with confidence\nintervals of width $1-1/k-\\beta_k^*$.\n  The techniques developed in the paper yield improvements on most previously\npublished numerical values as well as results for alphabet sizes and string\nlengths not reported before.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.07644v2"
    },
    {
        "title": "Automata Cascades: Expressivity and Sample Complexity",
        "authors": [
            "Alessandro Ronca",
            "Nadezda Alexandrovna Knorozova",
            "Giuseppe De Giacomo"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  Every automaton can be decomposed into a cascade of basic prime automata.\nThis is the Prime Decomposition Theorem by Krohn and Rhodes. Guided by this\ntheory, we propose automata cascades as a structured, modular, way to describe\nautomata as complex systems made of many components, each implementing a\nspecific functionality. Any automaton can serve as a component; using specific\ncomponents allows for a fine-grained control of the expressivity of the\nresulting class of automata; using prime automata as components implies\nspecific expressivity guarantees. Moreover, specifying automata as cascades\nallows for describing the sample complexity of automata in terms of their\ncomponents. We show that the sample complexity is linear in the number of\ncomponents and the maximum complexity of a single component, modulo logarithmic\nfactors. This opens to the possibility of learning automata representing large\ndynamical systems consisting of many parts interacting with each other. It is\nin sharp contrast with the established understanding of the sample complexity\nof automata, described in terms of the overall number of states and input\nletters, which implies that it is only possible to learn automata where the\nnumber of states is linear in the amount of data available. Instead our results\nshow that one can learn automata with a number of states that is exponential in\nthe amount of data available.\n",
        "pdf_link": "http://arxiv.org/pdf/2211.14028v3"
    },
    {
        "title": "Classical and quantum Merlin-Arthur automata",
        "authors": [
            "Abuzer Yakaryılmaz"
        ],
        "category": "cs.FL",
        "published_year": "2022",
        "summary": "  We introduce Merlin-Arthur (MA) automata where Merlin provides a certificate\nat the beginning of computation and it is scanned by Arthur before reading the\ninput. We define Merlin-Arthur deterministic, probabilistic, and quantum finite\nstate automata (resp., MA-DFAs, MA-PFAs, and MA-QFAs) and postselecting MA-PFAs\nand MA-QFAs (resp., MA-PostPFA and MA-PostQFA). We present several results\nusing different certificate lengths.\n  We show that MA-DFAs use constant length certificates, and they are\nequivalent to multi-entry DFAs. Thus, they recognize all and only regular\nlanguages, but they can be exponential and polynomial state efficient over\nbinary and unary languages, respectively. With sublinear length certificates,\nMA-PFAs can recognize several nonstochastic unary languages with cutpoint 1/2.\nWith linear length certificates, MA-PostPFAs can recognize these nonstochastic\nunary languages with bounded error. With arbitrarily long certificates,\nbounded-error MA-PostPFAs can verify every unary decidable language. With\nsublinear length certificates, bounded-error MA-PostQFAs can verify several\nnonstochastic unary languages. With linear length certificates, they can verify\nevery unary language and some NP-complete binary languages. With exponential\nlength certificates, they can verify every binary language.\n",
        "pdf_link": "http://arxiv.org/pdf/2212.13801v2"
    },
    {
        "title": "Symbolic Quantum Simulation with Quasimodo",
        "authors": [
            "Meghana Sistla",
            "Swarat Chaudhuri",
            "Thomas Reps"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The simulation of quantum circuits on classical computers is an important\nproblem in quantum computing. Such simulation requires representations of\ndistributions over very large sets of basis vectors, and recent work has used\nsymbolic data-structures such as Binary Decision Diagrams (BDDs) for this\npurpose. In this tool paper, we present Quasimodo, an extensible, open-source\nPython library for symbolic simulation of quantum circuits. Quasimodo is\nspecifically designed for easy extensibility to other backends. Quasimodo\nallows simulations of quantum circuits, checking properties of the outputs of\nquantum circuits, and debugging quantum circuits. It also allows the user to\nchoose from among several symbolic data-structures -- both unweighted and\nweighted BDDs, and a recent structure called Context-Free-Language Ordered\nBinary Decision Diagrams (CFLOBDDs) -- and can be easily extended to support\nother symbolic data-structures.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.04349v2"
    },
    {
        "title": "Asynchronous Multiparty Session Type Implementability is Decidable --\n  Lessons Learned from Message Sequence Charts",
        "authors": [
            "Felix Stutz"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Multiparty session types (MSTs) provide efficient means to specify and verify\nasynchronous message-passing systems. For a global type, which specifies all\ninteractions between roles in a system, the implementability problem asks\nwhether there are local specifications for all roles such that their\ncomposition is deadlock-free and generates precisely the specified executions.\nDecidability of the implementability problem is an open question. We answer it\npositively for global types with sender-driven choice, which allow a sender to\nsend to different receivers upon branching and a receiver to receive from\ndifferent senders. To achieve this, we generalise results from the domain of\nhigh-level message sequence charts (HMSCs). This connection also allows us to\ncomprehensively investigate how HMSC techniques can be adapted to the MST\nsetting. This comprises techniques to make the problem algorithmically more\ntractable as well as a variant of implementability that may open new design\nspace for MSTs. Inspired by potential performance benefits, we introduce a\ngeneralisation of the implementability problem that we, unfortunately, prove to\nbe undecidable.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.11272v3"
    },
    {
        "title": "The $\\mathsf{AC}^0$-Complexity Of Visibly Pushdown Languages",
        "authors": [
            "Stefan Göller",
            "Nathan Grosshans"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We study the question of which visibly pushdown languages (VPLs) are in the\ncomplexity class $\\mathsf{AC}^0$ and how to effectively decide this question.\nOur contribution is to introduce a particular subclass of one-turn VPLs, called\nintermediate VPLs, for which the raised question is entirely unclear: to the\nbest of our knowledge our research community is unaware of containment or\nnon-containment in $\\mathsf{AC}^0$ for any language in our newly introduced\nclass.\n  Our main result states that there is an algorithm that, given a visibly\npushdown automaton, correctly outputs either that its language is in\n$\\mathsf{AC}^0$, outputs some $m\\geq 2$ such that $L$ is\n$\\mathsf{ACC}^0(m)$-hard (implying that $L$ is not in $\\mathsf{AC}^0$), or\noutputs a finite disjoint union of intermediate VPLs that $L$ is constant-depth\nequivalent to. In the latter case one can moreover effectively compute\n$k,l\\in\\mathbb{N}_{>0}$ with $k\\not=l$ such that the concrete intermediate VPL\n$L(S\\rightarrow\\varepsilon\\mid a c^{k-1} S b_1\\mid ac^{l-1}Sb_2)$ is\nconstant-depth reducible to the language $L$. Due to their particular nature we\nconjecture that either all intermediate VPLs are in $\\mathsf{AC}^0$ or all are\nnot. As a corollary of our main result we obtain that in case the input\nlanguage is a visibly counter language our algorithm can effectively determine\nif it is in $\\mathsf{AC}^0$ -- hence our main result generalizes a result by\nKrebs et al. stating that it is decidable if a given visibly counter language\nis in $\\mathsf{AC}^0$ (when restricted to well-matched words).\n  For our proofs we revisit so-called Ext-algebras (introduced by Czarnetzki et\nal.), which are closely related to forest algebras (introduced by Boja\\'nczyk\nand Walukiewicz), and use Green's relations.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.13116v3"
    },
    {
        "title": "Speed Me up if You Can: Conditional Lower Bounds on Opacity Verification",
        "authors": [
            "Jiří Balun",
            "Tomáš Masopust",
            "Petr Osička"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Opacity is a property of privacy and security applications asking whether,\ngiven a system model, a passive intruder that makes online observations of\nsystem's behaviour can ascertain some \"secret\" information of the system.\nDeciding opacity is a PSpace-complete problem, and hence there are no\npolynomial-time algorithms to verify opacity under the assumption that PSpace\ndiffers from PTime. This assumption, however, gives rise to a question whether\nthe existing exponential-time algorithms are the best possible or whether there\nare faster, sub-exponential-time algorithms. We show that under the (Strong)\nExponential Time Hypothesis, there are no algorithms that would be\nsignificantly faster than the existing algorithms. As a by-product, we obtained\na new conditional lower bound on the time complexity of deciding universality\n(and therefore also inclusion and equivalence) for nondeterministic finite\nautomata.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.09920v1"
    },
    {
        "title": "On the Computational Power of Particle Methods",
        "authors": [
            "Johannes Pahlke",
            "Ivo F. Sbalzarini"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We investigate the computational power of particle methods, a\nwell-established class of algorithms with applications in scientific computing\nand computer simulation. The computational power of a compute model determines\nthe class of problems it can solve. Automata theory allows describing the\ncomputational power of abstract machines (automata) and the problems they can\nsolve. At the top of the Chomsky hierarchy of formal languages and grammars are\nTuring machines, which resemble the concept on which most modern computers are\nbuilt. Although particle methods can be interpreted as automata based on their\nformal definition, their computational power has so far not been studied. We\naddress this by analyzing Turing completeness of particle methods. In\nparticular, we prove two sets of restrictions under which a particle method is\nstill Turing powerful, and we show when it loses Turing powerfulness. This\ncontributes to understanding the theoretical foundations of particle methods\nand provides insight into the powerfulness of computer simulations.\n",
        "pdf_link": "http://arxiv.org/pdf/2304.10286v2"
    },
    {
        "title": "Model Checking Strategies from Synthesis Over Finite Traces",
        "authors": [
            "Suguman Bansal",
            "Yong Li",
            "Lucas Martinelli Tabajara",
            "Moshe Y. Vardi",
            "Andrew Wells"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The innovations in reactive synthesis from {\\em Linear Temporal Logics over\nfinite traces} (LTLf) will be amplified by the ability to verify the\ncorrectness of the strategies generated by LTLf synthesis tools. This motivates\nour work on {\\em LTLf model checking}. LTLf model checking, however, is not\nstraightforward. The strategies generated by LTLf synthesis may be represented\nusing {\\em terminating} transducers or {\\em non-terminating} transducers where\nexecutions are of finite-but-unbounded length or infinite length, respectively.\nFor synthesis, there is no evidence that one type of transducer is better than\nthe other since they both demonstrate the same complexity and similar\nalgorithms.\n  In this work, we show that for model checking, the two types of transducers\nare fundamentally different. Our central result is that LTLf model checking of\nnon-terminating transducers is \\emph{exponentially harder} than that of\nterminating transducers. We show that the problems are EXPSPACE-complete and\nPSPACE-complete, respectively. Hence, considering the feasibility of\nverification, LTLf synthesis tools should synthesize terminating transducers.\nThis is, to the best of our knowledge, the \\emph{first} evidence to use one\ntransducer over the other in LTLf synthesis.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.08319v3"
    },
    {
        "title": "Complete Multiparty Session Type Projection with Automata",
        "authors": [
            "Elaine Li",
            "Felix Stutz",
            "Thomas Wies",
            "Damien Zufferey"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Multiparty session types (MSTs) are a type-based approach to verifying\ncommunication protocols. Central to MSTs is a projection operator: a partial\nfunction that maps protocols represented as global types to\ncorrect-by-construction implementations for each participant, represented as a\ncommunicating state machine. Existing projection operators are syntactic in\nnature, and trade efficiency for completeness. We present the first projection\noperator that is sound, complete, and efficient. Our projection separates\nsynthesis from checking implementability. For synthesis, we use a simple\nautomata-theoretic construction; for checking implementability, we present\nsuccinct conditions that summarize insights into the property of\nimplementability. We use these conditions to show that MST implementability is\nin PSPACE. This improves upon a previous decision procedure that is in EXPSPACE\nand applies to a smaller class of MSTs. We demonstrate the effectiveness of our\napproach using a prototype implementation, which handles global types not\nsupported by previous work without sacrificing performance.\n",
        "pdf_link": "http://arxiv.org/pdf/2305.17079v3"
    },
    {
        "title": "Learning Broadcast Protocols",
        "authors": [
            "Dana Fisman",
            "Noa Izsak",
            "Swen Jacobs"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The problem of learning a computational model from examples has been\nreceiving growing attention. For the particularly challenging problem of\nlearning models of distributed systems, existing results are restricted to\nmodels with a fixed number of interacting processes. In this work we look for\nthe first time (to the best of our knowledge) at the problem of learning a\ndistributed system with an arbitrary number of processes, assuming only that\nthere exists a cutoff, i.e., a number of processes that is sufficient to\nproduce all observable behaviors. Specifically, we consider fine broadcast\nprotocols, these are broadcast protocols (BPs) with a finite cutoff and no\nhidden states. We provide a learning algorithm that can infer a correct BP from\na sample that is consistent with a fine BP, and a minimal equivalent BP if the\nsample is sufficiently complete. On the negative side we show that (a)\ncharacteristic sets of exponential size are unavoidable, (b) the consistency\nproblem for fine BPs is NP hard, and (c) that fine BPs are not polynomially\npredictable.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.14284v2"
    },
    {
        "title": "Checking Presence Reachability Properties on Parameterized Shared-Memory\n  Systems",
        "authors": [
            "Nicolas Waldburger"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  We consider the verification of distributed systems composed of an arbitrary\nnumber of asynchronous processes. Processes are identical finite-state machines\nthat communicate by reading from and writing to a shared memory. Beyond the\nstandard model with finitely many registers, we tackle round-based\nshared-memory systems with fresh registers at each round. In the latter model,\nboth the number of processes and the number of registers are unbounded, making\nverification particularly challenging. The properties studied are generic\npresence reachability objectives, which subsume classical questions such as\nsafety or synchronization by expressing the presence or absence of processes in\nsome states. In the more general round-based setting, we establish that the\nparameterized verification of presence reachability properties is\nPSPACE-complete. Moreover, for the roundless model with finitely many\nregisters, we prove that the complexity drops down to NP-complete and we\nprovide several natural restrictions that make the problem solvable in\npolynomial time.\n",
        "pdf_link": "http://arxiv.org/pdf/2306.17476v2"
    },
    {
        "title": "Opacity of Parametric Discrete Event Systems: Models, Decidability, and\n  Algorithms",
        "authors": [
            "Weilin Deng",
            "Daowen Qiu",
            "Jingkai Yang"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Finite automata (FAs) model is a popular tool to characterize discrete event\nsystems (DESs) due to its succinctness. However, for some complex systems, it\nis difficult to describe the necessary details by means of FAs model. In this\npaper, we consider a kind of extended finite automata (EFAs) in which each\ntransition carries a predicate over state and event parameters. We also\nconsider a type of simplified EFAs, called Event-Parameters EFAs (EP-EFAs),\nwhere the state parameters are removed. Based upon these two parametric models,\nwe investigate the problem of opacity analysis for parametric DESs. First of\nall, it is shown that EFAs model is more expressive than EP-EFAs model.\nSecondly, it is proved that the opacity properties for EFAs are undecidable in\ngeneral. Moreover, the decidable opacity properties for EP-EFAs are\ninvestigated. We present the verification algorithms for current-state opacity,\ninitial-state opacity and infinite-step opacity, and then discuss the\ncomplexity. This paper establishes a preliminary theory for the opacity of\nparametric DESs, which lays a foundation for the opacity analysis of complex\nsystems.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.03870v1"
    },
    {
        "title": "Learning Formal Specifications from Membership and Preference Queries",
        "authors": [
            "Ameesh Shah",
            "Marcell Vazquez-Chanlatte",
            "Sebastian Junges",
            "Sanjit A. Seshia"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Active learning is a well-studied approach to learning formal specifications,\nsuch as automata. In this work, we extend active specification learning by\nproposing a novel framework that strategically requests a combination of\nmembership labels and pair-wise preferences, a popular alternative to\nmembership labels. The combination of pair-wise preferences and membership\nlabels allows for a more flexible approach to active specification learning,\nwhich previously relied on membership labels only. We instantiate our framework\nin two different domains, demonstrating the generality of our approach. Our\nresults suggest that learning from both modalities allows us to robustly and\nconveniently identify specifications via membership and preferences.\n",
        "pdf_link": "http://arxiv.org/pdf/2307.10434v1"
    },
    {
        "title": "Data-Flow-Based Normalization Generation Algorithm of R1CS for\n  Zero-Knowledge Proof",
        "authors": [
            "Chenhao Shi",
            "Hao Chen",
            "Ruibang Liu",
            "Guoqiang Li"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The communities of blockchains and distributed ledgers have been stirred up\nby the introduction of zero-knowledge proofs (ZKPs). Originally designed to\nsolve privacy issues, ZKPs have now evolved into an effective remedy for\nscalability concerns and are applied in Zcash (internet money like Bitcoin). To\nenable ZKPs, Rank-1 Constraint Systems (R1CS) offer a verifier for bi-linear\nequations. To accurately and efficiently represent R1CS, several language tools\nlike Circom, Noir, and Snarky have been proposed to automate the compilation of\nadvanced programs into R1CS. However, due to the flexible nature of R1CS\nrepresentation, there can be significant differences in the compiled R1CS forms\ngenerated from circuit language programs with the same underlying semantics. To\naddress this issue, this paper uses a data-flow-based R1CS paradigm algorithm,\nwhich produces a standardized format for different R1CS instances with\nidentical semantics. By using the normalized R1CS format circuits, the\ncomplexity of circuits' verification can be reduced. In addition, this paper\npresents an R1CS normalization algorithm benchmark, and our experimental\nevaluation demonstrates the effectiveness and correctness of our methods.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.04274v2"
    },
    {
        "title": "Proceedings of the Fourteenth International Symposium on Games,\n  Automata, Logics, and Formal Verification",
        "authors": [
            "Antonis Achilleos",
            "Dario Della Monica"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  This volume contains the proceedings of the 14th International Symposium on\nGames, Automata, Logics, and Formal Verification (GandALF 2023). The aim of\nGandALF 2023 symposium is to bring together researchers from academia and\nindustry who are actively working in the fields of Games, Automata, Logics, and\nFormal Verification. The idea is to cover an ample spectrum of themes, ranging\nfrom theory to applications, and stimulate cross-fertilization.\n",
        "pdf_link": "http://arxiv.org/pdf/2309.17318v1"
    },
    {
        "title": "Bandwidth of Timed Automata: 3 Classes",
        "authors": [
            "Eugene Asarin",
            "Aldric Degorre",
            "Catalin Dima",
            "Bernardo Jacobo Inclan"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Timed languages contain sequences of discrete events (\"letters'') separated\nby real-valued delays, they can be recognized by timed automata, and represent\nbehaviors of various real-time systems. The notion of bandwidth of a timed\nlanguage defined in a previous paper characterizes the amount of information\nper time unit, encoded in words of the language observed with some precision\n{\\epsilon}.\n  In this paper, we identify three classes of timed automata according to the\nasymptotics of the bandwidth of their languages with respect to this precision\n{\\epsilon}: automata are either meager, with an O(1) bandwidth, normal, with a\n{\\Theta}(log (1/{\\epsilon})) bandwidth, or obese, with {\\Theta}(1/{\\epsilon})\nbandwidth. We define two structural criteria and prove that they partition\ntimed automata into these three classes of bandwidth, implying that there are\nno intermediate asymptotic classes. The classification problem of a timed\nautomaton is PSPACE-complete.\n  Both criteria are formulated using morphisms from paths of the timed\nautomaton to some finite monoids extending Puri's orbit graphs; the proofs are\nbased on Simon's factorization forest theorem.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.01941v1"
    },
    {
        "title": "Lemur: Integrating Large Language Models in Automated Program\n  Verification",
        "authors": [
            "Haoze Wu",
            "Clark Barrett",
            "Nina Narodytska"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The demonstrated code-understanding capability of LLMs raises the question of\nwhether they can be used for automated program verification, a task that\ndemands high-level abstract reasoning about program properties that is\nchallenging for verification tools. We propose a general methodology to combine\nthe power of LLMs and automated reasoners for automated program verification.\nWe formally describe this methodology as a set of transition rules and prove\nits soundness. We instantiate the calculus as a sound automated verification\nprocedure and demonstrate practical improvements on a set of synthetic and\ncompetition benchmarks.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.04870v5"
    },
    {
        "title": "Masked Hard-Attention Transformers Recognize Exactly the Star-Free\n  Languages",
        "authors": [
            "Andy Yang",
            "David Chiang",
            "Dana Angluin"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The expressive power of transformers over inputs of unbounded size can be\nstudied through their ability to recognize classes of formal languages. In this\npaper, we establish exact characterizations of transformers with hard attention\n(in which all attention is focused on exactly one position) and attention\nmasking (in which each position only attends to positions on one side). With\nstrict masking (each position cannot attend to itself) and without position\nembeddings, these transformers are expressively equivalent to linear temporal\nlogic (LTL), which defines exactly the star-free languages. A key technique is\nthe use of Boolean RASP as a convenient intermediate language between\ntransformers and LTL. We then take numerous results known for LTL and apply\nthem to transformers, showing how position embeddings, strict masking, and\ndepth all increase expressive power.\n",
        "pdf_link": "http://arxiv.org/pdf/2310.13897v4"
    },
    {
        "title": "Co-Buchi Barrier Certificates for Discrete-time Dynamical Systems",
        "authors": [
            "Vishnu Murali",
            "Ashutosh Trivedi",
            "Majid Zamani"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Barrier certificates provide functional overapproximations for the reachable\nset of dynamical systems and provide inductive guarantees on the safe evolution\nof the system. Formally a barrier certificate is a real-valued function over\nthe state set that is required to be non-positive for the initial states,\npositive over the set of unsafe states and nonincreasing along the state\ntransitions. These conditions together provide an inductive argument that the\nsystem will not reach an unsafe state even once as the barrier certificate\nremains non-positive for all reachable states. In the automata-theoretic\napproach to verification, a key query is to determine whether the system visits\na given predicate over the states finitely often, typically resulting from the\ncomplement of the traditional Buchi acceptance condition. This paper proposes a\nbarrier certificate approach to answer such queries by developing a notion of\nco-Buchi barrier certificates (CBBCs) that generalize classic barrier\ncertificates to ensure that the traces of a system visit a given predicate a\nfixed number of times. Our notion of CBBC is inspired from bounded synthesis\nparadigm to LTL realizability, where the LTL specifications are converted to\nsafety automata via universal co-Buchi automata with a bound on final state\nvisitations provided as a hyperparameter. Our application of CBBCs in\nverification is analogous in nature: we fix a bound and search for a suitable\nbarrier certificate, increasing the bound if no suitable function can be found.\nWe then use these CBBCs to verify our system against properties specified by\nco-Buchi automata and demonstrate their effectiveness via some case studies. We\nalso show that the present approach strictly generalizes performant barrier\ncertificate based approaches that rely on cutting the paths of the automata\nthat start from an initial state and reach some accepting states.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.07695v1"
    },
    {
        "title": "Unambiguity and Fewness for Nonuniform Families of Polynomial-Size\n  Nondeterministic Finite Automata",
        "authors": [
            "Tomoyuki Yamakami"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Nonuniform families of polynomial-size finite automata, which are series of\nindexed finite automata having polynomially many inner states, are used in the\npast literature to solve nonuniform families of promise decision problems.\nAmong such nonuniform families of finite automata, we focus our attention, in\nparticular, on the variants of nondeterministic finite automata, which have at\nmost \"one\" (unambiguous), \"polynomially many\" (few) accepting computation\npaths, or unambiguous/few computation paths leading to each fixed\nconfiguration. When such machines are limited to make only one-way head moves,\nwe can prove with no unproven hardness assumptions that some of these variants\nare different in computational power from each other. As for two-way machines\nrestricted to instances of polynomially-bounded length, families of two-way\npolynomial-size nondeterministic finite automata are equivalent in power to\nfamilies of polynomial-size unambiguous finite automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2311.09979v1"
    },
    {
        "title": "On the rank of the communication matrix for deterministic two-way finite\n  automata",
        "authors": [
            "Semyon Petrov",
            "Fedor Petrov",
            "Alexander Okhotin"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  The communication matrix for two-way deterministic finite automata (2DFA)\nwith $n$ states is defined for an automaton over a full alphabet of all\n$(2n+1)^n$ possible symbols: its rows and columns are indexed by strings, and\nthe entry $(u, v)$ is $1$ if $uv$ is accepted by the automaton, and $0$\notherwise. With duplicate rows and columns removed, this is a square matrix of\norder $n(n^n-(n-1)^n)+1$, and its rank is known to be a lower bound on the\nnumber of states necessary to transform an $n$-state 2DFA to a one-way\nunambiguous finite automaton (UFA). This paper determines this rank, showing\nthat it is exactly $f(n)=\\sum_{k=1}^n \\binom{n}{k-1} \\binom{n}{k}\n\\binom{2k-2}{k-1} =(1+o(1)) \\frac{3\\sqrt{3}}{8\\pi n} 9^n$, and this function\nbecomes the new lower bound on the state complexity of the 2DFA to UFA\ntransformation, thus improving a recent lower bound by S. Petrov and Okhotin\n(``On the transformation of two-way deterministic finite automata to\nunambiguous finite automata'', Inf. Comput., 2023). The key element of the\nproof is determining the rank of a $k! \\times k!$ submatrix, with its rows and\ncolumns indexed by permutations, where the entry $(\\pi, \\sigma)$ is $1$ if\n$\\sigma \\circ \\pi$ is a cycle of length $k$, and 0 otherwise; using the methods\nof group representation theory it is shown that its rank is exactly\n$\\binom{2k-2}{k-1}$, and this implies the above formula for $f(n)$.\n",
        "pdf_link": "http://arxiv.org/pdf/2312.05909v1"
    },
    {
        "title": "On Some Complexity Results for Even Linear Languages",
        "authors": [
            "Liliana Cojocaru"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We deal with a normal form for context-free grammars, called Dyck normal\nform. This normal form is a syntactical restriction of the Chomsky normal form,\nin which the two nonterminals occurring on the right-hand side of a rule are\npaired nonterminals. This pairwise property, along with several other terminal\nrewriting conditions, makes it possible to define a homomorphism from Dyck\nwords to words generated by a grammar in Dyck normal form. We prove that for\neach context-free language L, there exist an integer K and a homomorphism phi\nsuch that L=phi(D'_K), where D'_K is a subset of D_K and D_K is the one-sided\nDyck language over K letters. As an application we give an alternative proof of\nthe inclusion of the class of even linear languages in AC1.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.14303v1"
    },
    {
        "title": "Positional $ω$-regular languages",
        "authors": [
            "Antonio Casares",
            "Pierre Ohlmann"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In the context of two-player games over graphs, a language $L$ is called\npositional if, in all games using $L$ as winning objective, the protagonist can\nplay optimally using positional strategies, that is, strategies that do not\ndepend on the history of the play. In this work, we describe the class of\nparity automata recognising positional languages, providing a complete\ncharacterisation of positionality for $\\omega$-regular languages. As\ncorollaries, we establish decidability of positionality in polynomial time,\nfinite-to-infinite and 1-to-2-players lifts, and show the closure under union\nof prefix-independent positional objectives, answering a conjecture by\nKopczy\\'nski in the $\\omega$-regular case.\n",
        "pdf_link": "http://arxiv.org/pdf/2401.15384v3"
    },
    {
        "title": "On Algorithms verifying Initial-and-Final-State Opacity: Complexity,\n  Special Cases, and Comparison",
        "authors": [
            "Tomáš Masopust",
            "Petr Osička"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Opacity is a general framework modeling security properties of systems\ninteracting with a passive attacker. Initial-and-final-state opacity (IFO)\ngeneralizes the classical notions of opacity, such as current-state opacity and\ninitial-state opacity. In IFO, the secret is whether the system evolved from a\ngiven initial state to a given final state or not. There are two algorithms for\nIFO verification. One arises from a trellis-based state estimator, which builds\na semigroup of binary relations generated by the events of the automaton, and\nthe other is based on the reduction to language inclusion. The time complexity\nof both algorithms is bounded by a super-exponential function, and it is a\nchallenging open problem to find a faster algorithm or to show that no faster\nalgorithm exists. We discuss the lower-bound time complexity for both general\nand special cases, and use extensive benchmarks to compare the existing\nalgorithms.\n",
        "pdf_link": "http://arxiv.org/pdf/2402.17000v2"
    },
    {
        "title": "Supervisory Control Theory with Event Forcing",
        "authors": [
            "Michel Reniers",
            "Kai Cai"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In the Ramadge-Wonham supervisory control theory the only interaction\nmechanism between supervisor and plant is that the supervisor may\nenable/disable events from the plant and the plant makes a final decision about\nwhich of the enabled events is actually taking place. In this paper, the\ninteraction between supervisor and plant is enriched by allowing the supervisor\nto force specific events (called forcible events) that are allowed to preempt\nuncontrollable events. A notion of forcible-controllability is defined that\ncaptures the interplay between controllability of a supervisor w.r.t. the\nuncontrollable events provided by a plant in the setting with event forcing.\nExistence of a maximally permissive, forcibly-controllable, nonblocking\nsupervisor is shown and an algorithm is provided that computes such a\nsupervisor. The approach is illustrated by two small case studies.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.08469v1"
    },
    {
        "title": "Flow-Based Synthesis of Reactive Tests for Discrete Decision-Making\n  Systems with Temporal Logic Specifications",
        "authors": [
            "Josefine B. Graebener",
            "Apurva S. Badithela",
            "Denizalp Goktas",
            "Wyatt Ubellacker",
            "Eric V. Mazumdar",
            "Aaron D. Ames",
            "Richard M. Murray"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Designing tests to evaluate if a given autonomous system satisfies complex\nspecifications is challenging due to the complexity of these systems. This work\nproposes a flow-based approach for reactive test synthesis from temporal logic\nspecifications, enabling the synthesis of test environments consisting of\nstatic and reactive obstacles and dynamic test agents. The temporal logic\nspecifications describe desired test behavior, including system requirements as\nwell as a test objective that is not revealed to the system. The synthesized\ntest strategy places restrictions on system actions in reaction to the system\nstate. The tests are minimally restrictive and accomplish the test objective\nwhile ensuring realizability of the system's objective without aiding it\n(semi-cooperative setting). Automata theory and flow networks are leveraged to\nformulate a mixed-integer linear program (MILP) to synthesize the test\nstrategy. For a dynamic test agent, the agent strategy is synthesized for a\nGR(1) specification constructed from the solution of the MILP. If the\nspecification is unrealizable by the dynamics of the test agent, a\ncounterexample-guided approach is used to resolve the MILP until a strategy is\nfound. This flow-based, reactive test synthesis is conducted offline and is\nagnostic to the system controller. Finally, the resulting test strategy is\ndemonstrated in simulation and experimentally on a pair of quadrupedal robots\nfor a variety of specifications.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.09888v1"
    },
    {
        "title": "Opacity complexity of automatic sequences. The general case",
        "authors": [
            "J. -P. Allouche",
            "J. -Y. Yao"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In this work we introduce a new notion called opacity complexity to measure\nthe complexity of automatic sequences. We study basic properties of this\nnotion, and exhibit an algorithm to compute it. As applications, we compute the\nopacity complexity of some well-known automatic sequences, including in\nparticular constant sequences, purely periodic sequences, the Thue-Morse\nsequence, the period-doubling sequence, the Golay-Shapiro(-Rudin) sequence, the\npaperfolding sequence, the Baum-Sweet sequence, the Tower of Hanoi sequence,\nand so on.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.13601v1"
    },
    {
        "title": "On the topology of concurrent systems",
        "authors": [
            "Catarina Faustino",
            "Thomas Kahl",
            "Rodrigo Lopes"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Higher-dimensional automata, i.e., pointed labeled precubical sets, are a\npowerful combinatorial-topological model for concurrent systems. In this paper,\nwe show that for every (nonempty) connected polyhedron there exists a\nshared-variable system such that the higher-dimensional automaton modeling the\nstate space of the system has the homotopy type of the polyhedron.\n",
        "pdf_link": "http://arxiv.org/pdf/2404.16492v1"
    },
    {
        "title": "Time complexity for deterministic string machines",
        "authors": [
            "Ali Cataltepe",
            "Vanessa Kosoy"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Algorithms which learn environments represented by automata in the past have\nhad complexity scaling with the number of states in the automaton, which can be\nexponentially large even for automata recognizing regular expressions with a\nsmall description length. We thus formalize a compositional language that can\nconstruct automata as transformations between certain types of category,\nrepresentable as string diagrams, which better reflects the description\ncomplexity of various automata. We define complexity constraints on this\nframework by having them operate on categories enriched over filtered sets, and\nusing these constraints, we prove elementary results on the runtime and\nexpressivity of a subset of these transformations which operate\ndeterministically on finite state spaces. These string diagrams, or \"string\nmachines,\" are themselves morphisms in a category, so it is possible for string\nmachines to create other string machines in runtime to model computations which\ntake more than constant memory. We prove sufficient conditions for polynomial\nruntime guarantees on these, which can help develop complexity constraints on\nstring machines which also encapsulate runtime complexity.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.06043v1"
    },
    {
        "title": "Constructing a BPE Tokenization DFA",
        "authors": [
            "Martin Berglund",
            "Willeke Martens",
            "Brink van der Merwe"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Many natural language processing systems operate over tokenizations of text\nto address the open-vocabulary problem. In this paper, we give and analyze an\nalgorithm for the efficient construction of deterministic finite automata\ndesigned to operate directly on tokenizations produced by the popular byte pair\nencoding technique. This makes it possible to apply many existing techniques\nand algorithms to the tokenized case, such as pattern matching, equivalence\nchecking of tokenization dictionaries, and composing tokenized languages in\nvarious ways.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.07671v1"
    },
    {
        "title": "Slice closures of indexed languages and word equations with counting\n  constraints",
        "authors": [
            "Laura Ciobanu",
            "Georg Zetzsche"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Indexed languages are a classical notion in formal language theory. As the\nlanguage equivalent of second-order pushdown automata, they have received\nconsiderable attention in higher-order model checking. Unfortunately, counting\nproperties are notoriously difficult to decide for indexed languages: So far,\nall results about non-regular counting properties show undecidability.\n  In this paper, we initiate the study of slice closures of (Parikh images of)\nindexed languages. A slice is a set of vectors of natural numbers such that\nmembership of $u,u+v,u+w$ implies membership of $u+v+w$. Our main result is\nthat given an indexed language $L$, one can compute a semilinear representation\nof the smallest slice containing $L$'s Parikh image.\n  We present two applications. First, one can compute the set of all affine\nrelations satisfied by the Parikh image of an indexed language. In particular,\nthis answers affirmatively a question by Kobayashi: Is it decidable whether in\na given indexed language, every word has the same number of $a$'s as $b$'s.\n  As a second application, we show decidability of (systems of) word equations\nwith rational constraints and a class of counting constraints: These allow us\nto look for solutions where a counting function (defined by an automaton) is\nnot zero. For example, one can decide whether a word equation with rational\nconstraints has a solution where the number of occurrences of $a$ differs\nbetween variables $X$ and $Y$.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.07911v1"
    },
    {
        "title": "$O_2$ is a multiple context-free grammar: an implementation-,\n  formalisation-friendly proof",
        "authors": [
            "Marco B. Caminati"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Classifying formal languages according to the expressiveness of grammars able\nto generate them is a fundamental problem in computational linguistics and,\ntherefore, in the theory of computation. Furthermore, such kind of analysis can\ngive insight into the classification of abstract algebraic structure such as\ngroups, for example through the correspondence given by the word problem. While\nmany such classification problems remain open, others have been settled.\nRecently, it was proved that $n$-balanced languages (i.e., whose strings\ncontain the same occurrences of letters $a_i$ and $A_i$ with $1\\leq i \\leq n$)\ncan be generated by multiple context-free grammars (MCFGs), which are one of\nthe several slight extensions of context free grammars added to the classical\nChomsky hierarchy to make the mentioned classification more precise. This paper\nanalyses the existing proofs from the computational and the proof-theoretical\npoint of views, systematically studying whether each proof can lead to a\nverified (i.e., checked by a proof assistant) algorithm parsing balanced\nlanguages via MCFGs. We conclude that none of the existing proofs is\nrealistically suitable against this practical goal, and proceed to provide a\nradically new, elementary, extremely short proof for the crucial case $n \\leq\n2$. A comparative analysis with respect to the existing proofs is finally\nperformed to justify why the proposed proof is a substantial step towards\nconcretely obtaining a verified parsing algorithm for $O_2$.\n",
        "pdf_link": "http://arxiv.org/pdf/2405.09396v1"
    },
    {
        "title": "Analyzing constrained LLM through PDFA-learning",
        "authors": [
            "Matías Carrasco",
            "Franz Mayr",
            "Sergio Yovine",
            "Johny Kidd",
            "Martín Iturbide",
            "Juan Pedro da Silva",
            "Alejo Garat"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We define a congruence that copes with null next-symbol probabilities that\narise when the output of a language model is constrained by some means during\ntext generation. We develop an algorithm for efficiently learning the quotient\nwith respect to this congruence and evaluate it on case studies for analyzing\nstatistical properties of LLM.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.08269v2"
    },
    {
        "title": "Querying Labeled Time Series Data with Scenario Programs",
        "authors": [
            "Devan Shanker"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  In order to ensure autonomous vehicles are safe for on-road deployment,\nsimulation-based testing has become an integral complement to on-road testing.\nThe rise in simulation testing and validation reflects a growing need to verify\nthat AV behavior is consistent with desired outcomes even in edge case\nscenarios $-$ which may seldom or never appear in on-road testing data. This\nraises a critical question: to what extent are AV failures in simulation\nconsistent with data collected from real-world testing? As a result of the gap\nbetween simulated and real sensor data (sim-to-real gap), failures in\nsimulation can either be spurious (simulation- or simulator-specific issues) or\nrelevant (safety-critical AV system issues). One possible method for validating\nif simulated time series failures are consistent with real world time series\nsensor data could involve retrieving instances of the failure scenario from a\nreal-world time series dataset, in order to understand AV performance in these\nscenarios. Adopting this strategy, we propose a formal definition of what\nconstitutes a match between a real-world labeled time series data item and a\nsimulated scenario written from a fragment of the Scenic probabilistic\nprogramming language for simulation generation. With this definition of a\nmatch, we develop a querying algorithm that identifies the subset of a labeled\ntime series dataset matching a given scenario. To allow this approach to be\nused to verify the safety of other cyber-physical systems (CPS), we present a\ndefinition and algorithm for matching scalable beyond the autonomous vehicles\ndomain. Experiments demonstrate the precision and scalability of the algorithm\nfor a set of challenging and uncommon time series scenarios identified from the\nnuScenes autonomous driving dataset. We include a full system implementation of\nthe querying algorithm freely available for use across a wide range of CPS.\n",
        "pdf_link": "http://arxiv.org/pdf/2406.17627v1"
    },
    {
        "title": "Complex Event Recognition with Symbolic Register Transducers: Extended\n  Technical Report",
        "authors": [
            "Elias Alevizos",
            "Alexander Artikis",
            "Georgios Paliouras"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We present a system for Complex Event Recognition (CER) based on automata.\nWhile multiple such systems have been described in the literature, they\ntypically suffer from a lack of clear and denotational semantics, a limitation\nwhich often leads to confusion with respect to their expressive power. In order\nto address this issue, our system is based on an automaton model which is a\ncombination of symbolic and register automata. We extend previous work on these\ntypes of automata, in order to construct a formalism with clear semantics and a\ncorresponding automaton model whose properties can be formally investigated. We\ncall such automata Symbolic Register Transducers (SRT). We show that SRT are\nclosed under various operators, but are not in general closed under complement\nand they are not determinizable. However, they are closed under these\noperations when a window operator, quintessential in Complex Event Recognition,\nis used. We show how SRT can be used in CER in order to detect patterns upon\nstreams of events, using our framework that provides declarative and\ncompositional semantics, and that allows for a systematic treatment of such\nautomata. For SRT to work in pattern detection, we allow them to mark events\nfrom the input stream as belonging to a complex event or not, hence the name\n\"transducers\". We also present an implementation of SRT which can perform CER.\nWe compare our SRT-based CER engine against other state-of-the-art CER systems\nand show that it is both more expressive and more efficient.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.02884v1"
    },
    {
        "title": "Finite-State Automaton To/From Regular Expression Visualization",
        "authors": [
            "Marco T. Morazán",
            "Tijana Minić"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Most Formal Languages and Automata Theory courses explore the duality between\ncomputation models to recognize words in a language and computation models to\ngenerate words in a language. For students unaccustomed to formal statements,\nthese transformations are rarely intuitive. To assist students with such\ntransformations, visualization tools can play a pivotal role. This article\npresents visualization tools developed for FSM -- a domain-specific language\nfor the Automata Theory classroom -- to transform a finite state automaton to a\nregular expression and vice versa. Using these tools, the user may provide an\narbitrary finite-state machine or an arbitrary regular expression and step\nforward and step backwards through a transformation. At each step, the\nvisualization describes the step taken. The tools are outlined, their\nimplementation is described, and they are compared with related work. In\naddition, empirical data collected from a control group is presented. The\nempirical data suggests that the tools are well-received, effective, and\nlearning how to use them has a low extraneous cognitive load.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.08088v1"
    },
    {
        "title": "The $μ\\mathcal{G}$ Language for Programming Graph Neural Networks",
        "authors": [
            "Matteo Belenchia",
            "Flavio Corradini",
            "Michela Quadrini",
            "Michele Loreti"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Graph neural networks form a class of deep learning architectures\nspecifically designed to work with graph-structured data. As such, they share\nthe inherent limitations and problems of deep learning, especially regarding\nthe issues of explainability and trustworthiness. We propose $\\mu\\mathcal{G}$,\nan original domain-specific language for the specification of graph neural\nnetworks that aims to overcome these issues. The language's syntax is\nintroduced, and its meaning is rigorously defined by a denotational semantics.\nAn equivalent characterization in the form of an operational semantics is also\nprovided and, together with a type system, is used to prove the type soundness\nof $\\mu\\mathcal{G}$. We show how $\\mu\\mathcal{G}$ programs can be represented\nin a more user-friendly graphical visualization, and provide examples of its\ngenerality by showing how it can be used to define some of the most popular\ngraph neural network models, or to develop any custom graph processing\napplication.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.09441v4"
    },
    {
        "title": "Detecting and explaining (in)equivalence of context-free grammars",
        "authors": [
            "Marko Schmellenkamp",
            "Thomas Zeume",
            "Sven Argo",
            "Sandra Kiefer",
            "Cedric Siems",
            "Fynn Stebel"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We propose a scalable framework for deciding, proving, and explaining\n(in)equivalence of context-free grammars. We present an implementation of the\nframework and evaluate it on large data sets collected within educational\nsupport systems. Even though the equivalence problem for context-free languages\nis undecidable in general, the framework is able to handle a large portion of\nthese datasets. It introduces and combines techniques from several areas, such\nas an abstract grammar transformation language to identify equivalent grammars\nas well as sufficiently similar inequivalent grammars, theory-based comparison\nalgorithms for a large class of context-free languages, and a\ngraph-theory-inspired grammar canonization that allows to efficiently identify\nisomorphic grammars.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.18220v1"
    },
    {
        "title": "Hyper parametric timed CTL",
        "authors": [
            "Masaki Waga",
            "Étienne André"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Hyperproperties enable simultaneous reasoning about multiple execution traces\nof a system and are useful to reason about non-interference, opacity,\nrobustness, fairness, observational determinism, etc. We introduce hyper\nparametric timed computation tree logic (HyperPTCTL), extending hyperlogics\nwith timing reasoning and, notably, parameters to express unknown values. We\nmainly consider its nest-free fragment, where temporal operators cannot be\nnested. However, we allow extensions that enable counting actions and comparing\nthe duration since the most recent occurrence of specific actions. We show that\nour nest-free fragment with this extension is sufficiently expressive to encode\nproperties, e.g., opacity, (un)fairness, or robust observational\n(non-)determinism. We propose semi-algorithms for model checking and synthesis\nof parametric timed automata (an extension of timed automata with timing\nparameters) against this nest-free fragment with the extension via reduction to\nPTCTL model checking and synthesis. While the general model checking (and thus\nsynthesis) problem is undecidable, we show that a large part of our extended\n(yet nest-free) fragment is decidable, provided the parameters only appear in\nthe property, not in the model. We also exhibit additional decidable fragments\nwhere parameters within the model are allowed. We implemented our\nsemi-algorithms on top of the IMITATOR model checker, and performed\nexperiments. Our implementation supports most of the nest-free fragments\n(beyond the decidable classes). The experimental results highlight our method's\npractical relevance.\n",
        "pdf_link": "http://arxiv.org/pdf/2407.21321v1"
    },
    {
        "title": "Runtime Verification via Rational Monitor with Imperfect Information",
        "authors": [
            "Angelo Ferrando",
            "Vadim Malvone"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Trusting software systems, particularly autonomous ones, is challenging. To\naddress this, formal verification techniques can ensure these systems behave as\nexpected. Runtime Verification (RV) is a leading, lightweight method for\nverifying system behaviour during execution. However, traditional RV assumes\nperfect information, meaning the monitoring component perceives everything\naccurately. This assumption often fails, especially with autonomous systems\noperating in real-world environments where sensors might be faulty.\nAdditionally, traditional RV considers the monitor to be passive, lacking the\ncapability to interpret the system's information and thus unable to address\nincomplete data. In this work, we extend standard RV of Linear Temporal Logic\nproperties to accommodate scenarios where the monitor has imperfect information\nand behaves rationally. We outline the necessary engineering steps to update\nthe verification pipeline and demonstrate our implementation in a case study\ninvolving robotic systems.\n",
        "pdf_link": "http://arxiv.org/pdf/2408.11627v1"
    },
    {
        "title": "A complete formalization of Fermat's Last Theorem for regular primes in\n  Lean",
        "authors": [
            "Riccardo Brasca",
            "Christopher Birkbeck",
            "Eric Rodriguez Boidi",
            "Alex Best",
            "Ruben van De Velde",
            "Andrew Yang"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  We formalize a complete proof of the regular case of Fermat's Last Theorem in\nthe Lean4 theorem prover. Our formalization includes a proof of Kummer's lemma,\nthat is the main obstruction to Fermat's Last Theorem for regular primes.\nRather than following the modern proof of Kummer's lemma via class field\ntheory, we prove it by using Hilbert's Theorems 90-94 in a way that is more\namenable to formalization.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.01466v2"
    },
    {
        "title": "Opacity Enforcement by Edit Functions Under Incomparable Observations",
        "authors": [
            "Wei Duan",
            "Ruotian Liu",
            "Maria Pia Fanti",
            "Christoforos N. Hadjicostis",
            "Zhiwu Li"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  As an information-flow privacy property, opacity characterizes whether a\nmalicious external observer (referred to as an intruder) is able to infer the\nsecret behavior of a system. This paper addresses the problem of opacity\nenforcement using edit functions in discrete event systems modeled by partially\nobserved deterministic finite automata. A defender uses the edit function as an\ninterface at the output of a system to manipulate actual observations through\ninsertion, substitution, and deletion operations so that the intruder will be\nprevented from inferring the secret behavior of the system. Unlike existing\nwork which usually assumes that the observation capabilities of the intruder\nand the defender are identical, we consider a more general setting where they\nmay observe incomparable subsets of events generated by the system.To\ncharacterize whether the defender has the ability to enforce opacity of the\nsystem under this setting, the notion of \\emph{$ic$-enforceability} is\nintroduced. Then, the opacity enforcement problem is transformed to a\ntwo-player game, with imperfect information between the system and the\ndefender, which can be used to determine a feasible decision-making strategy\nfor the defender. Within the game scheme, an edit mechanism is constructed to\nenumerate all feasible edit actions following system behavior. We further show\nthat an $ic$-enforcing edit function (if one exists) can be synthesized from\nthe edit mechanism to enforce opacity.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.08471v1"
    },
    {
        "title": "Proceedings Fifteenth International Symposium on Games, Automata,\n  Logics, and Formal Verification",
        "authors": [
            "Antonis Achilleos",
            "Adrian Francalanza"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  This volume contains the proceedings of GandALF 2024, the Fifteenth\nInternational Symposium on Games, Automata, Logics, and Formal Verification.\nGandALF 2024 took place on 19-21 June 2024, in Reykjavik, Iceland. The aim of\nGandALF 2024 is to bring together researchers from academia and industry who\nare actively working in the fields of Games, Automata, Logics, and Formal\nVerification. The idea is to cover an ample spectrum of themes, ranging from\ntheory to applications, and stimulate cross-fertilization.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.21884v1"
    },
    {
        "title": "Tracer: A Tool for Race Detection in Software Defined Network Models",
        "authors": [
            "Georgiana Caltais",
            "Mahboobeh Zangiabady",
            "Ervin Zvirbulis"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Software Defined Networking (SDN) has become a new paradigm in computer\nnetworking, introducing a decoupled architecture that separates the network\ninto the data plane and the control plane. The control plane acts as the\ncentralized brain, managing configuration updates and network management tasks,\nwhile the data plane handles traffic based on the configurations provided by\nthe control plane. Given its asynchronous distributed nature, SDN can\nexperience data races due to message passing between the control and data\nplanes. This paper presents Tracer, a tool designed to automatically detect and\nexplain the occurrence of data races in DyNetKAT SDN models. DyNetKAT is a\nformal framework for modeling and analyzing SDN behaviors, with robust\noperational semantics and a complete axiomatization implemented in Maude. Built\non NetKAT, a language leveraging Kleene Algebra with Tests to express data\nplane forwarding behavior, DyNetKAT extends these capabilities by adding\nprimitives for communication between the control and data planes. Tracer\nexploits the DyNetKAT axiomatization and enables race detection in SDNs based\non Lamport vector clocks. Tracer is a publicly available tool.\n",
        "pdf_link": "http://arxiv.org/pdf/2410.23763v1"
    },
    {
        "title": "Topoi of automata I: Four topoi of automata and regular languages",
        "authors": [
            "Ryuya Hora"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Both topos theory and automata theory are known for their multi-faceted\nnature and relationship with topology, algebra, logic, and category theory.\nThis paper aims to clarify the topos-theoretic aspects of automata theory,\nparticularly demonstrating through two main theorems how regular (and\nnon-regular) languages arise in topos-theoretic calculation. First, it is shown\nthat the four different notions of automata form four types of Grothendieck\ntopoi, illustrating how the technical details of automata theory are described\nby topos theory. Second, we observe that the four characterizations of regular\nlanguages (DFA, Myhill-Nerode theorem, finite monoids, profinite words) provide\nMorita-equivalent definitions of a single Boolean-ringed topos, situating this\nwithin the context of Olivia Caramello's 'Toposes as Bridges.'\n  This paper also serves as a preparation for follow-up papers, which deal with\nthe relationship between hyperconnected geometric morphisms and\nalgebraic/geometric aspects of formal language theory.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.06358v2"
    },
    {
        "title": "The Equivalence Problem of E-Pattern Languages with Length Constraints\n  is Undecidable",
        "authors": [
            "Dirk Nowotka",
            "Max Wiedenhöft"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Patterns are words with terminals and variables. The language of a pattern is\nthe set of words obtained by uniformly substituting all variables with words\nthat contain only terminals. Length constraints restrict valid substitutions of\nvariables by associating the variables of a pattern with a system (or\ndisjunction of systems) of linear diophantine inequalities. Pattern languages\nwith length constraints contain only words in which all variables are\nsubstituted to words with lengths that fulfill such a given set of length\nconstraints. We consider membership, inclusion, and equivalence problems for\nerasing and non-erasing pattern languages with length constraints. Our main\nresult shows that the erasing equivalence problem, one of the most prominent\nopen problems in the realm of patterns-becomes undecidable if length\nconstraints are allowed in addition to variable equality. Additionally, it is\nshown that the terminal-free inclusion problem-another prominent open problem\nin the realm of patterns-is also undecidable in this setting. It is also shown\nthat considering regular constraints, i.e., associating variables also with\nregular languages as additional restrictions together with length constraints\nfor valid substitutions, results in undecidability of the non-erasing\nequivalence problem. This sets a first upper bound on constraints to obtain\nundecidability in this case, as this problem is trivially decidable in the case\nof no constraints and as it has unknown decidability if only regular- or only\nlength-constraints are considered.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.06904v1"
    },
    {
        "title": "The Equivalence Problem of E-Pattern Languages with Regular Constraints\n  is Undecidable",
        "authors": [
            "Dirk Nowotka",
            "Max Wiedenhöft"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Patterns are words with terminals and variables. The language of a pattern is\nthe set of words obtained by uniformly substituting all variables with words\nthat contain only terminals. Regular constraints restrict valid substitutions\nof variables by associating with each variable a regular language representable\nby, e.g., finite automata. Pattern languages with regular constraints contain\nonly words in which each variable is substituted according to a set of regular\nconstraints. We consider the membership, inclusion, and equivalence problems\nfor erasing and non-erasing pattern languages with regular constraints. Our\nmain result shows that the erasing equivalence problem, one of the most\nprominent open problems in the realm of patterns, becomes undecidable if\nregular constraints are allowed in addition to variable equality.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.07275v1"
    },
    {
        "title": "Learning Quantitative Automata Modulo Theories",
        "authors": [
            "Eric Hsiung",
            "Swarat Chaudhuri",
            "Joydeep Biswas"
        ],
        "category": "cs.FL",
        "published_year": "2024",
        "summary": "  Quantitative automata are useful representations for numerous applications,\nincluding modeling probability distributions over sequences to Markov chains\nand reward machines. Actively learning such automata typically occurs using\nexplicitly gathered input-output examples under adaptations of the L-star\nalgorithm. However, obtaining explicit input-output pairs can be expensive, and\nthere exist scenarios, including preference-based learning or learning from\nrankings, where providing constraints is a less exerting and a more natural way\nto concisely describe desired properties. Consequently, we propose the problem\nof learning deterministic quantitative automata from sets of constraints over\nthe valuations of input sequences. We present QUINTIC, an active learning\nalgorithm, wherein the learner infers a valid automaton through deductive\nreasoning, by applying a theory to a set of currently available constraints and\nan assumed preference model and quantitative automaton class. QUINTIC performs\na complete search over the space of automata, and is guaranteed to be minimal\nand correctly terminate. Our evaluations utilize theory of rationals in order\nto learn summation, discounted summation, product, and classification\nquantitative automata, and indicate QUINTIC is effective at learning these\ntypes of automata.\n",
        "pdf_link": "http://arxiv.org/pdf/2411.10601v1"
    },
    {
        "title": "Computability of the entropy of one-tape Turing Machines",
        "authors": [
            "Emmanuel Jeandel"
        ],
        "category": "cs.FL",
        "published_year": "2013",
        "summary": "  We prove that the maximum speed and the entropy of a one-tape Turing machine\nare computable, in the sense that we can approximate them to any given\nprecision $\\epsilon$. This is contrary to popular belief, as all dynamical\nproperties are usually undecidable for Turing machines. The result is quite\nspecific to one-tape Turing machines, as it is not true anymore for two-tape\nTuring machines by the results of Blondel et al., and uses the approach of\ncrossing sequences introduced by Hennie.\n",
        "pdf_link": "http://arxiv.org/pdf/1302.1170v1"
    },
    {
        "title": "Structural Commutation Relations for Stochastic Labelled Graph Grammar\n  Rule Operators",
        "authors": [
            "Eric Mjolsness"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show how to calculate the operator algebra and the operator Lie algebra of\na stochastic labelled-graph grammar. More specifically, we carry out a generic\ncalculation of the product (and therefore the commutator) of time-evolution\noperators for any two labelled-graph grammar rewrite rules, where the operator\ncorresponding to each rule is defined in terms of elementary two-state\ncreation/annihilation operators. The resulting graph grammar algebra has the\nfollowing properties: (1) The product and commutator of two such operators is a\nsum of such operators with integer coefficients. Thus, the algebra and the Lie\nalgebra occurs entirely at the structural (or graph-combinatorial) level of\ngraph grammar rules, lifted from the level of elementary creation/annihilation\noperators (an improvement over [1], Propositions 1 and 2). (2) The product of\nthe off-diagonal (state-changing) parts of two such graph rule operators is a\nsum of off-diagonal graph rule operators with non-negative integer\ncoefficients. (3) These results apply whether the semantics of a graph grammar\nrule leaves behind hanging edges (Theorem 1), or removes hanging edges (Theorem\n2). (4) The algebra is constructive in terms of elementary two-state\ncreation/annihilation operators (Corollaries 3 and 8). These results are useful\nbecause dynamical transformations of labelled graphs comprise a general\nmodeling framework, and algebraic commutators of time-evolution operators have\nmany analytic uses including designing simulation algorithms and estimating\ntheir errors.\n",
        "pdf_link": "http://arxiv.org/pdf/1909.04118v1"
    },
    {
        "title": "Multi-Agent Safety Verification using Symmetry Transformations",
        "authors": [
            "Hussein Sibai",
            "Navid Mokhlesi",
            "Chuchu Fan",
            "Sayan Mitra"
        ],
        "category": "cs.FL",
        "published_year": "2019",
        "summary": "  We show that symmetry transformations and caching can enable scalable, and\npossibly unbounded, verification of multi-agent systems. Symmetry\ntransformations map solutions and to other solutions. We show that this\nproperty can be used to transform cached reachsets to compute new reachsets,\nfor hybrid and multi-agent models. We develop a notion of virtual system which\ndefine symmetry transformations for a broad class of agent models that visit\nwaypoint sequences. Using this notion of virtual system, we present a prototype\ntool CacheReach that builds a cache of reachtubes for this system, in a way\nthat is agnostic of the representation of the reachsets and the reachability\nanalysis subroutine used. Our experimental evaluation of CacheReach shows up to\n66% savings in safety verification computation time on multi-agent systems with\n3-dimensional linear and 4-dimensional nonlinear fixed-wing aircraft models\nfollowing sequences of waypoints. These savings and our theoretical results\nillustrate the potential benefits of using symmetry-based caching in the safety\nverification of multi-agent systems.\n",
        "pdf_link": "http://arxiv.org/pdf/1911.00608v1"
    },
    {
        "title": "A Transaction Represented with Weighted Finite-State Transducers",
        "authors": [
            "J. Nathaniel Holmes",
            "Homayoon Beigi"
        ],
        "category": "cs.FL",
        "published_year": "2023",
        "summary": "  Not all contracts are good, but all good contracts can be expressed as a\nfinite-state transition system (\"State-Transition Contracts\"). Contracts that\ncan be represented as State-Transition Contracts discretize fat-tailed risk to\nforeseeable, managed risk, define the boundary of relevant events governed by\nthe relationship, and eliminate the potential of inconsistent contractual\nprovisions. Additionally, State-Transition Contracts reap the substantial\nbenefit of being able to be analyzed under the rules governing the science of\nthe theory of computation. Simple State-Transition Contracts can be represented\nas discrete finite automata; more complicated State-Transition Contracts, such\nas those that have downstream effects on other agreements or complicated\npathways of performance, benefit from representation as weighted finite-state\ntransducers, with weights assigned as costs, penalties, or probabilities of\ntransitions. This research paper (the \"Research\" or \"Paper\") presents a complex\nlegal transaction represented as weighted finite-state transducers.\nFurthermore, we show that the mathematics/algorithms permitted by the algebraic\nstructure of weighted finite-state transducers provides actionable, legal\ninsight into the transaction.\n",
        "pdf_link": "http://arxiv.org/pdf/2302.00200v1"
    },
    {
        "title": "Enumerating Finitary Processes",
        "authors": [
            "B. D. Johnson",
            "J. P. Crutchfield",
            "C. J. Ellison",
            "C. S. McTague"
        ],
        "category": "cs.FL",
        "published_year": "2010",
        "summary": "  We show how to efficiently enumerate a class of finite-memory stochastic\nprocesses using the causal representation of epsilon-machines. We characterize\nepsilon-machines in the language of automata theory and adapt a recent\nalgorithm for generating accessible deterministic finite automata, pruning this\nover-large class down to that of epsilon-machines. As an application, we\nexactly enumerate topological epsilon-machines up to eight states and\nsix-letter alphabets.\n",
        "pdf_link": "http://arxiv.org/pdf/1011.0036v3"
    },
    {
        "title": "Decentralized Observation of Discrete-Event Systems: At Least One Can\n  Tell",
        "authors": [
            "Stavros Tripakis",
            "Karen Rudie"
        ],
        "category": "cs.FL",
        "published_year": "2021",
        "summary": "  We introduce a new decentralized observation condition which we call \"at\nleast one can tell\" (OCT) and which attempts to capture the idea that for any\npossible behavior that a system can generate, at least one decentralized\nobservation agent can tell whether that behavior was \"good\" or \"bad\", for given\nformal specifications of \"good\" and \"bad\". We provide several equivalent\nformulations of the OCT condition, and we relate it to (and show that it is\ndifferent from) previously introduced joint observability. In fact, contrary to\njoint observability which is undecidable, we show that the OCT condition is\ndecidable. We also show that when the condition holds, finite-state\ndecentralized observers exist.\n",
        "pdf_link": "http://arxiv.org/pdf/2108.04523v1"
    }
]